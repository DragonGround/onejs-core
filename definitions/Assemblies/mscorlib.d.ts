
declare namespace CS {
    const __keep_incompatibility: unique symbol;
    
    interface $Ref<T> {
        value: T
    }
    namespace System {
        interface Array$1<T> extends System.Array {
            get_Item(index: number):T;
            
            set_Item(index: number, value: T):void;
        }
    }
    type $Task<T> = System.Threading.Tasks.Task$1<T>
    namespace System {
        class Object
        {
            protected [__keep_incompatibility]: never;
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
            public GetHashCode () : number
            public GetType () : System.Type
            public ToString () : string
            public static ReferenceEquals ($objA: any, $objB: any) : boolean
            public constructor ()
        }
        class MarshalByRefObject extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public CreateObjRef ($requestedType: System.Type) : System.Runtime.Remoting.ObjRef
            public GetLifetimeService () : any
            public InitializeLifetimeService () : any
        }
        interface IDisposable
        {
        }
        class String extends System.Object implements System.ICloneable, System.IComparable, System.IComparable$1<string>, System.IConvertible, System.Collections.Generic.IEnumerable$1<number>, System.Collections.IEnumerable, System.IEquatable$1<string>
        {
            protected [__keep_incompatibility]: never;
            public static Empty : string
            public get Length(): number;
            public get Chars(): number;
            public static Compare ($strA: string, $strB: string) : number
            public static Compare ($strA: string, $strB: string, $ignoreCase: boolean) : number
            public static Compare ($strA: string, $strB: string, $comparisonType: System.StringComparison) : number
            public static Compare ($strA: string, $strB: string, $culture: System.Globalization.CultureInfo, $options: System.Globalization.CompareOptions) : number
            public static Compare ($strA: string, $strB: string, $ignoreCase: boolean, $culture: System.Globalization.CultureInfo) : number
            public static Compare ($strA: string, $indexA: number, $strB: string, $indexB: number, $length: number) : number
            public static Compare ($strA: string, $indexA: number, $strB: string, $indexB: number, $length: number, $ignoreCase: boolean) : number
            public static Compare ($strA: string, $indexA: number, $strB: string, $indexB: number, $length: number, $ignoreCase: boolean, $culture: System.Globalization.CultureInfo) : number
            public static Compare ($strA: string, $indexA: number, $strB: string, $indexB: number, $length: number, $culture: System.Globalization.CultureInfo, $options: System.Globalization.CompareOptions) : number
            public static Compare ($strA: string, $indexA: number, $strB: string, $indexB: number, $length: number, $comparisonType: System.StringComparison) : number
            public static CompareOrdinal ($strA: string, $strB: string) : number
            public static CompareOrdinal ($strA: string, $indexA: number, $strB: string, $indexB: number, $length: number) : number
            public CompareTo ($value: any) : number
            public CompareTo ($strB: string) : number
            public EndsWith ($value: string) : boolean
            public EndsWith ($value: string, $comparisonType: System.StringComparison) : boolean
            public EndsWith ($value: string, $ignoreCase: boolean, $culture: System.Globalization.CultureInfo) : boolean
            public EndsWith ($value: number) : boolean
            public Equals ($obj: any) : boolean
            public Equals ($value: string) : boolean
            public Equals ($value: string, $comparisonType: System.StringComparison) : boolean
            public static Equals ($a: string, $b: string) : boolean
            public static Equals ($a: string, $b: string, $comparisonType: System.StringComparison) : boolean
            public static op_Equality ($a: string, $b: string) : boolean
            public static op_Inequality ($a: string, $b: string) : boolean
            public GetHashCode () : number
            public GetHashCode ($comparisonType: System.StringComparison) : number
            public StartsWith ($value: string) : boolean
            public StartsWith ($value: string, $comparisonType: System.StringComparison) : boolean
            public StartsWith ($value: string, $ignoreCase: boolean, $culture: System.Globalization.CultureInfo) : boolean
            public StartsWith ($value: number) : boolean
            public Clone () : any
            public static Copy ($str: string) : string
            public CopyTo ($sourceIndex: number, $destination: System.Array$1<number>, $destinationIndex: number, $count: number) : void
            public ToCharArray () : System.Array$1<number>
            public ToCharArray ($startIndex: number, $length: number) : System.Array$1<number>
            public static IsNullOrEmpty ($value: string) : boolean
            public static IsNullOrWhiteSpace ($value: string) : boolean
            public ToString () : string
            public ToString ($provider: System.IFormatProvider) : string
            public GetEnumerator () : System.CharEnumerator
            public GetTypeCode () : System.TypeCode
            public IsNormalized () : boolean
            public IsNormalized ($normalizationForm: System.Text.NormalizationForm) : boolean
            public Normalize () : string
            public Normalize ($normalizationForm: System.Text.NormalizationForm) : string
            public static Concat ($arg0: any) : string
            public static Concat ($arg0: any, $arg1: any) : string
            public static Concat ($arg0: any, $arg1: any, $arg2: any) : string
            public static Concat (...args: any[]) : string
            public static Concat ($values: System.Collections.Generic.IEnumerable$1<string>) : string
            public static Concat ($str0: string, $str1: string) : string
            public static Concat ($str0: string, $str1: string, $str2: string) : string
            public static Concat ($str0: string, $str1: string, $str2: string, $str3: string) : string
            public static Concat (...values: string[]) : string
            public static Format ($format: string, $arg0: any) : string
            public static Format ($format: string, $arg0: any, $arg1: any) : string
            public static Format ($format: string, $arg0: any, $arg1: any, $arg2: any) : string
            public static Format ($format: string, ...args: any[]) : string
            public static Format ($provider: System.IFormatProvider, $format: string, $arg0: any) : string
            public static Format ($provider: System.IFormatProvider, $format: string, $arg0: any, $arg1: any) : string
            public static Format ($provider: System.IFormatProvider, $format: string, $arg0: any, $arg1: any, $arg2: any) : string
            public static Format ($provider: System.IFormatProvider, $format: string, ...args: any[]) : string
            public Insert ($startIndex: number, $value: string) : string
            public static Join ($separator: number, ...value: string[]) : string
            public static Join ($separator: number, ...values: any[]) : string
            public static Join ($separator: number, $value: System.Array$1<string>, $startIndex: number, $count: number) : string
            public static Join ($separator: string, ...value: string[]) : string
            public static Join ($separator: string, ...values: any[]) : string
            public static Join ($separator: string, $values: System.Collections.Generic.IEnumerable$1<string>) : string
            public static Join ($separator: string, $value: System.Array$1<string>, $startIndex: number, $count: number) : string
            public PadLeft ($totalWidth: number) : string
            public PadLeft ($totalWidth: number, $paddingChar: number) : string
            public PadRight ($totalWidth: number) : string
            public PadRight ($totalWidth: number, $paddingChar: number) : string
            public Remove ($startIndex: number, $count: number) : string
            public Remove ($startIndex: number) : string
            public Replace ($oldValue: string, $newValue: string, $ignoreCase: boolean, $culture: System.Globalization.CultureInfo) : string
            public Replace ($oldValue: string, $newValue: string, $comparisonType: System.StringComparison) : string
            public Replace ($oldChar: number, $newChar: number) : string
            public Replace ($oldValue: string, $newValue: string) : string
            public Split ($separator: number, $options?: System.StringSplitOptions) : System.Array$1<string>
            public Split ($separator: number, $count: number, $options?: System.StringSplitOptions) : System.Array$1<string>
            public Split (...separator: number[]) : System.Array$1<string>
            public Split ($separator: System.Array$1<number>, $count: number) : System.Array$1<string>
            public Split ($separator: System.Array$1<number>, $options: System.StringSplitOptions) : System.Array$1<string>
            public Split ($separator: System.Array$1<number>, $count: number, $options: System.StringSplitOptions) : System.Array$1<string>
            public Split ($separator: string, $options?: System.StringSplitOptions) : System.Array$1<string>
            public Split ($separator: string, $count: number, $options?: System.StringSplitOptions) : System.Array$1<string>
            public Split ($separator: System.Array$1<string>, $options: System.StringSplitOptions) : System.Array$1<string>
            public Split ($separator: System.Array$1<string>, $count: number, $options: System.StringSplitOptions) : System.Array$1<string>
            public Substring ($startIndex: number) : string
            public Substring ($startIndex: number, $length: number) : string
            public ToLower () : string
            public ToLower ($culture: System.Globalization.CultureInfo) : string
            public ToLowerInvariant () : string
            public ToUpper () : string
            public ToUpper ($culture: System.Globalization.CultureInfo) : string
            public ToUpperInvariant () : string
            public Trim () : string
            public Trim ($trimChar: number) : string
            public Trim (...trimChars: number[]) : string
            public TrimStart () : string
            public TrimStart ($trimChar: number) : string
            public TrimStart (...trimChars: number[]) : string
            public TrimEnd () : string
            public TrimEnd ($trimChar: number) : string
            public TrimEnd (...trimChars: number[]) : string
            public Contains ($value: string) : boolean
            public Contains ($value: string, $comparisonType: System.StringComparison) : boolean
            public Contains ($value: number) : boolean
            public Contains ($value: number, $comparisonType: System.StringComparison) : boolean
            public IndexOf ($value: number) : number
            public IndexOf ($value: number, $startIndex: number) : number
            public IndexOf ($value: number, $comparisonType: System.StringComparison) : number
            public IndexOf ($value: number, $startIndex: number, $count: number) : number
            public IndexOfAny ($anyOf: System.Array$1<number>) : number
            public IndexOfAny ($anyOf: System.Array$1<number>, $startIndex: number) : number
            public IndexOfAny ($anyOf: System.Array$1<number>, $startIndex: number, $count: number) : number
            public IndexOf ($value: string) : number
            public IndexOf ($value: string, $startIndex: number) : number
            public IndexOf ($value: string, $startIndex: number, $count: number) : number
            public IndexOf ($value: string, $comparisonType: System.StringComparison) : number
            public IndexOf ($value: string, $startIndex: number, $comparisonType: System.StringComparison) : number
            public IndexOf ($value: string, $startIndex: number, $count: number, $comparisonType: System.StringComparison) : number
            public LastIndexOf ($value: number) : number
            public LastIndexOf ($value: number, $startIndex: number) : number
            public LastIndexOf ($value: number, $startIndex: number, $count: number) : number
            public LastIndexOfAny ($anyOf: System.Array$1<number>) : number
            public LastIndexOfAny ($anyOf: System.Array$1<number>, $startIndex: number) : number
            public LastIndexOfAny ($anyOf: System.Array$1<number>, $startIndex: number, $count: number) : number
            public LastIndexOf ($value: string) : number
            public LastIndexOf ($value: string, $startIndex: number) : number
            public LastIndexOf ($value: string, $startIndex: number, $count: number) : number
            public LastIndexOf ($value: string, $comparisonType: System.StringComparison) : number
            public LastIndexOf ($value: string, $startIndex: number, $comparisonType: System.StringComparison) : number
            public LastIndexOf ($value: string, $startIndex: number, $count: number, $comparisonType: System.StringComparison) : number
            public static Concat ($arg0: any, $arg1: any, $arg2: any, $arg3: any) : string
            public get_Chars ($index: number) : number
            public static Intern ($str: string) : string
            public static IsInterned ($str: string) : string
            public constructor ($value: System.Array$1<number>)
            public constructor ($value: System.Array$1<number>, $startIndex: number, $length: number)
            public constructor ($c: number, $count: number)
            public CompareTo ($obj: any) : number
            public ToBoolean ($provider: System.IFormatProvider) : boolean
            public ToChar ($provider: System.IFormatProvider) : number
            public ToSByte ($provider: System.IFormatProvider) : number
            public ToByte ($provider: System.IFormatProvider) : number
            public ToInt16 ($provider: System.IFormatProvider) : number
            public ToUInt16 ($provider: System.IFormatProvider) : number
            public ToInt32 ($provider: System.IFormatProvider) : number
            public ToUInt32 ($provider: System.IFormatProvider) : number
            public ToInt64 ($provider: System.IFormatProvider) : bigint
            public ToUInt64 ($provider: System.IFormatProvider) : bigint
            public ToSingle ($provider: System.IFormatProvider) : number
            public ToDouble ($provider: System.IFormatProvider) : number
            public ToDecimal ($provider: System.IFormatProvider) : System.Decimal
            public ToDateTime ($provider: System.IFormatProvider) : System.DateTime
            public ToType ($conversionType: System.Type, $provider: System.IFormatProvider) : any
            public GetEnumerator () : System.Collections.IEnumerator
            public static Equals ($objA: any, $objB: any) : boolean
            public constructor ()
        }
        interface String {
            AsMemory () : System.ReadOnlyMemory$1<number>;
            AsMemory ($start: number) : System.ReadOnlyMemory$1<number>;
            AsMemory ($startIndex: System.Index) : System.ReadOnlyMemory$1<number>;
            AsMemory ($start: number, $length: number) : System.ReadOnlyMemory$1<number>;
            AsMemory ($range: System.Range) : System.ReadOnlyMemory$1<number>;
        }
        interface ICloneable
        {
        }
        interface IComparable
        {
            CompareTo ($obj: any) : number
        }
        interface IComparable$1<T>
        {
            CompareTo ($other: T) : number
        }
        interface IConvertible
        {
            GetTypeCode () : System.TypeCode
            ToBoolean ($provider: System.IFormatProvider) : boolean
            ToChar ($provider: System.IFormatProvider) : number
            ToSByte ($provider: System.IFormatProvider) : number
            ToByte ($provider: System.IFormatProvider) : number
            ToInt16 ($provider: System.IFormatProvider) : number
            ToUInt16 ($provider: System.IFormatProvider) : number
            ToInt32 ($provider: System.IFormatProvider) : number
            ToUInt32 ($provider: System.IFormatProvider) : number
            ToInt64 ($provider: System.IFormatProvider) : bigint
            ToUInt64 ($provider: System.IFormatProvider) : bigint
            ToSingle ($provider: System.IFormatProvider) : number
            ToDouble ($provider: System.IFormatProvider) : number
            ToDecimal ($provider: System.IFormatProvider) : System.Decimal
            ToDateTime ($provider: System.IFormatProvider) : System.DateTime
            ToString ($provider: System.IFormatProvider) : string
            ToType ($conversionType: System.Type, $provider: System.IFormatProvider) : any
        }
        class ValueType extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class Char extends System.ValueType implements System.IComparable, System.IComparable$1<number>, System.IConvertible, System.IEquatable$1<number>
        {
            protected [__keep_incompatibility]: never;
            public static MaxValue : number
            public static MinValue : number
            public Equals ($obj: any) : boolean
            public Equals ($obj: number) : boolean
            public CompareTo ($value: any) : number
            public CompareTo ($value: number) : number
            public ToString () : string
            public ToString ($provider: System.IFormatProvider) : string
            public static ToString ($c: number) : string
            public static Parse ($s: string) : number
            public static TryParse ($s: string, $result: $Ref<number>) : boolean
            public static IsDigit ($c: number) : boolean
            public static IsLetter ($c: number) : boolean
            public static IsWhiteSpace ($c: number) : boolean
            public static IsUpper ($c: number) : boolean
            public static IsLower ($c: number) : boolean
            public static IsPunctuation ($c: number) : boolean
            public static IsLetterOrDigit ($c: number) : boolean
            public static ToUpper ($c: number, $culture: System.Globalization.CultureInfo) : number
            public static ToUpper ($c: number) : number
            public static ToUpperInvariant ($c: number) : number
            public static ToLower ($c: number, $culture: System.Globalization.CultureInfo) : number
            public static ToLower ($c: number) : number
            public static ToLowerInvariant ($c: number) : number
            public GetTypeCode () : System.TypeCode
            public static IsControl ($c: number) : boolean
            public static IsControl ($s: string, $index: number) : boolean
            public static IsDigit ($s: string, $index: number) : boolean
            public static IsLetter ($s: string, $index: number) : boolean
            public static IsLetterOrDigit ($s: string, $index: number) : boolean
            public static IsLower ($s: string, $index: number) : boolean
            public static IsNumber ($c: number) : boolean
            public static IsNumber ($s: string, $index: number) : boolean
            public static IsPunctuation ($s: string, $index: number) : boolean
            public static IsSeparator ($c: number) : boolean
            public static IsSeparator ($s: string, $index: number) : boolean
            public static IsSurrogate ($c: number) : boolean
            public static IsSurrogate ($s: string, $index: number) : boolean
            public static IsSymbol ($c: number) : boolean
            public static IsSymbol ($s: string, $index: number) : boolean
            public static IsUpper ($s: string, $index: number) : boolean
            public static IsWhiteSpace ($s: string, $index: number) : boolean
            public static GetUnicodeCategory ($c: number) : System.Globalization.UnicodeCategory
            public static GetUnicodeCategory ($s: string, $index: number) : System.Globalization.UnicodeCategory
            public static GetNumericValue ($c: number) : number
            public static GetNumericValue ($s: string, $index: number) : number
            public static IsHighSurrogate ($c: number) : boolean
            public static IsHighSurrogate ($s: string, $index: number) : boolean
            public static IsLowSurrogate ($c: number) : boolean
            public static IsLowSurrogate ($s: string, $index: number) : boolean
            public static IsSurrogatePair ($s: string, $index: number) : boolean
            public static IsSurrogatePair ($highSurrogate: number, $lowSurrogate: number) : boolean
            public static ConvertFromUtf32 ($utf32: number) : string
            public static ConvertToUtf32 ($highSurrogate: number, $lowSurrogate: number) : number
            public static ConvertToUtf32 ($s: string, $index: number) : number
            public CompareTo ($obj: any) : number
            public ToBoolean ($provider: System.IFormatProvider) : boolean
            public ToChar ($provider: System.IFormatProvider) : number
            public ToSByte ($provider: System.IFormatProvider) : number
            public ToByte ($provider: System.IFormatProvider) : number
            public ToInt16 ($provider: System.IFormatProvider) : number
            public ToUInt16 ($provider: System.IFormatProvider) : number
            public ToInt32 ($provider: System.IFormatProvider) : number
            public ToUInt32 ($provider: System.IFormatProvider) : number
            public ToInt64 ($provider: System.IFormatProvider) : bigint
            public ToUInt64 ($provider: System.IFormatProvider) : bigint
            public ToSingle ($provider: System.IFormatProvider) : number
            public ToDouble ($provider: System.IFormatProvider) : number
            public ToDecimal ($provider: System.IFormatProvider) : System.Decimal
            public ToDateTime ($provider: System.IFormatProvider) : System.DateTime
            public ToType ($conversionType: System.Type, $provider: System.IFormatProvider) : any
            public static Equals ($objA: any, $objB: any) : boolean
        }
        interface IEquatable$1<T>
        {
            Equals ($other: T) : boolean
        }
        class Void extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class Enum extends System.ValueType implements System.IFormattable, System.IComparable, System.IConvertible
        {
            protected [__keep_incompatibility]: never;
            public static Parse ($enumType: System.Type, $value: string) : any
            public static Parse ($enumType: System.Type, $value: string, $ignoreCase: boolean) : any
            public static GetUnderlyingType ($enumType: System.Type) : System.Type
            public static GetValues ($enumType: System.Type) : System.Array
            public static GetName ($enumType: System.Type, $value: any) : string
            public static GetNames ($enumType: System.Type) : System.Array$1<string>
            public static ToObject ($enumType: System.Type, $value: any) : any
            public static IsDefined ($enumType: System.Type, $value: any) : boolean
            public static Format ($enumType: System.Type, $value: any, $format: string) : string
            public ToString () : string
            public CompareTo ($target: any) : number
            public ToString ($format: string) : string
            public HasFlag ($flag: System.Enum) : boolean
            public GetTypeCode () : System.TypeCode
            public static ToObject ($enumType: System.Type, $value: number) : any
            public static ToObject ($enumType: System.Type, $value: bigint) : any
            public static TryParse ($enumType: System.Type, $value: string, $ignoreCase: boolean, $result: $Ref<any>) : boolean
            public static TryParse ($enumType: System.Type, $value: string, $result: $Ref<any>) : boolean
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            public CompareTo ($obj: any) : number
            public ToBoolean ($provider: System.IFormatProvider) : boolean
            public ToChar ($provider: System.IFormatProvider) : number
            public ToSByte ($provider: System.IFormatProvider) : number
            public ToByte ($provider: System.IFormatProvider) : number
            public ToInt16 ($provider: System.IFormatProvider) : number
            public ToUInt16 ($provider: System.IFormatProvider) : number
            public ToInt32 ($provider: System.IFormatProvider) : number
            public ToUInt32 ($provider: System.IFormatProvider) : number
            public ToInt64 ($provider: System.IFormatProvider) : bigint
            public ToUInt64 ($provider: System.IFormatProvider) : bigint
            public ToSingle ($provider: System.IFormatProvider) : number
            public ToDouble ($provider: System.IFormatProvider) : number
            public ToDecimal ($provider: System.IFormatProvider) : System.Decimal
            public ToDateTime ($provider: System.IFormatProvider) : System.DateTime
            public ToString ($provider: System.IFormatProvider) : string
            public ToType ($conversionType: System.Type, $provider: System.IFormatProvider) : any
        }
        interface IFormattable
        {
            ToString ($format: string, $formatProvider: System.IFormatProvider) : string
        }
        class Int32 extends System.ValueType implements System.IFormattable, System.ISpanFormattable, System.IComparable, System.IComparable$1<number>, System.IConvertible, System.IEquatable$1<number>
        {
            protected [__keep_incompatibility]: never;
            public static MaxValue : number
            public static MinValue : number
            public CompareTo ($value: any) : number
            public CompareTo ($value: number) : number
            public Equals ($obj: any) : boolean
            public Equals ($obj: number) : boolean
            public ToString () : string
            public ToString ($format: string) : string
            public ToString ($provider: System.IFormatProvider) : string
            public ToString ($format: string, $provider: System.IFormatProvider) : string
            public static Parse ($s: string) : number
            public static Parse ($s: string, $style: System.Globalization.NumberStyles) : number
            public static Parse ($s: string, $provider: System.IFormatProvider) : number
            public static Parse ($s: string, $style: System.Globalization.NumberStyles, $provider: System.IFormatProvider) : number
            public static TryParse ($s: string, $result: $Ref<number>) : boolean
            public static TryParse ($s: string, $style: System.Globalization.NumberStyles, $provider: System.IFormatProvider, $result: $Ref<number>) : boolean
            public GetTypeCode () : System.TypeCode
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            public CompareTo ($obj: any) : number
            public ToBoolean ($provider: System.IFormatProvider) : boolean
            public ToChar ($provider: System.IFormatProvider) : number
            public ToSByte ($provider: System.IFormatProvider) : number
            public ToByte ($provider: System.IFormatProvider) : number
            public ToInt16 ($provider: System.IFormatProvider) : number
            public ToUInt16 ($provider: System.IFormatProvider) : number
            public ToInt32 ($provider: System.IFormatProvider) : number
            public ToUInt32 ($provider: System.IFormatProvider) : number
            public ToInt64 ($provider: System.IFormatProvider) : bigint
            public ToUInt64 ($provider: System.IFormatProvider) : bigint
            public ToSingle ($provider: System.IFormatProvider) : number
            public ToDouble ($provider: System.IFormatProvider) : number
            public ToDecimal ($provider: System.IFormatProvider) : System.Decimal
            public ToDateTime ($provider: System.IFormatProvider) : System.DateTime
            public ToType ($conversionType: System.Type, $provider: System.IFormatProvider) : any
            public static Equals ($objA: any, $objB: any) : boolean
        }
        interface ISpanFormattable
        {
        }
        class Boolean extends System.ValueType implements System.IComparable, System.IComparable$1<boolean>, System.IConvertible, System.IEquatable$1<boolean>
        {
            protected [__keep_incompatibility]: never;
            public static TrueString : string
            public static FalseString : string
            public ToString () : string
            public ToString ($provider: System.IFormatProvider) : string
            public Equals ($obj: any) : boolean
            public Equals ($obj: boolean) : boolean
            public CompareTo ($obj: any) : number
            public CompareTo ($value: boolean) : number
            public static Parse ($value: string) : boolean
            public static TryParse ($value: string, $result: $Ref<boolean>) : boolean
            public GetTypeCode () : System.TypeCode
            public ToBoolean ($provider: System.IFormatProvider) : boolean
            public ToChar ($provider: System.IFormatProvider) : number
            public ToSByte ($provider: System.IFormatProvider) : number
            public ToByte ($provider: System.IFormatProvider) : number
            public ToInt16 ($provider: System.IFormatProvider) : number
            public ToUInt16 ($provider: System.IFormatProvider) : number
            public ToInt32 ($provider: System.IFormatProvider) : number
            public ToUInt32 ($provider: System.IFormatProvider) : number
            public ToInt64 ($provider: System.IFormatProvider) : bigint
            public ToUInt64 ($provider: System.IFormatProvider) : bigint
            public ToSingle ($provider: System.IFormatProvider) : number
            public ToDouble ($provider: System.IFormatProvider) : number
            public ToDecimal ($provider: System.IFormatProvider) : System.Decimal
            public ToDateTime ($provider: System.IFormatProvider) : System.DateTime
            public ToType ($conversionType: System.Type, $provider: System.IFormatProvider) : any
            public static Equals ($objA: any, $objB: any) : boolean
        }
        class Array extends System.Object implements System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.ICloneable, System.Collections.ICollection, System.Collections.IEnumerable, System.Collections.IList
        {
            protected [__keep_incompatibility]: never;
            public get LongLength(): bigint;
            public get IsFixedSize(): boolean;
            public get IsReadOnly(): boolean;
            public get IsSynchronized(): boolean;
            public get SyncRoot(): any;
            public get Length(): number;
            public get Rank(): number;
            public get Count(): number;
            public static CreateInstance ($elementType: System.Type, ...lengths: bigint[]) : System.Array
            public CopyTo ($array: System.Array, $index: number) : void
            public Clone () : any
            public static BinarySearch ($array: System.Array, $value: any) : number
            public static Copy ($sourceArray: System.Array, $destinationArray: System.Array, $length: bigint) : void
            public static Copy ($sourceArray: System.Array, $sourceIndex: bigint, $destinationArray: System.Array, $destinationIndex: bigint, $length: bigint) : void
            public CopyTo ($array: System.Array, $index: bigint) : void
            public GetLongLength ($dimension: number) : bigint
            public GetValue ($index: bigint) : any
            public GetValue ($index1: bigint, $index2: bigint) : any
            public GetValue ($index1: bigint, $index2: bigint, $index3: bigint) : any
            public GetValue (...indices: bigint[]) : any
            public static BinarySearch ($array: System.Array, $index: number, $length: number, $value: any) : number
            public static BinarySearch ($array: System.Array, $value: any, $comparer: System.Collections.IComparer) : number
            public static BinarySearch ($array: System.Array, $index: number, $length: number, $value: any, $comparer: System.Collections.IComparer) : number
            public static IndexOf ($array: System.Array, $value: any) : number
            public static IndexOf ($array: System.Array, $value: any, $startIndex: number) : number
            public static IndexOf ($array: System.Array, $value: any, $startIndex: number, $count: number) : number
            public static LastIndexOf ($array: System.Array, $value: any) : number
            public static LastIndexOf ($array: System.Array, $value: any, $startIndex: number) : number
            public static LastIndexOf ($array: System.Array, $value: any, $startIndex: number, $count: number) : number
            public static Reverse ($array: System.Array) : void
            public static Reverse ($array: System.Array, $index: number, $length: number) : void
            public SetValue ($value: any, $index: bigint) : void
            public SetValue ($value: any, $index1: bigint, $index2: bigint) : void
            public SetValue ($value: any, $index1: bigint, $index2: bigint, $index3: bigint) : void
            public SetValue ($value: any, ...indices: bigint[]) : void
            public static Sort ($array: System.Array) : void
            public static Sort ($array: System.Array, $index: number, $length: number) : void
            public static Sort ($array: System.Array, $comparer: System.Collections.IComparer) : void
            public static Sort ($array: System.Array, $index: number, $length: number, $comparer: System.Collections.IComparer) : void
            public static Sort ($keys: System.Array, $items: System.Array) : void
            public static Sort ($keys: System.Array, $items: System.Array, $comparer: System.Collections.IComparer) : void
            public static Sort ($keys: System.Array, $items: System.Array, $index: number, $length: number) : void
            public static Sort ($keys: System.Array, $items: System.Array, $index: number, $length: number, $comparer: System.Collections.IComparer) : void
            public GetEnumerator () : System.Collections.IEnumerator
            public GetLength ($dimension: number) : number
            public GetLowerBound ($dimension: number) : number
            public GetValue (...indices: number[]) : any
            public SetValue ($value: any, ...indices: number[]) : void
            public GetUpperBound ($dimension: number) : number
            public GetValue ($index: number) : any
            public GetValue ($index1: number, $index2: number) : any
            public GetValue ($index1: number, $index2: number, $index3: number) : any
            public SetValue ($value: any, $index: number) : void
            public SetValue ($value: any, $index1: number, $index2: number) : void
            public SetValue ($value: any, $index1: number, $index2: number, $index3: number) : void
            public static CreateInstance ($elementType: System.Type, $length: number) : System.Array
            public static CreateInstance ($elementType: System.Type, $length1: number, $length2: number) : System.Array
            public static CreateInstance ($elementType: System.Type, $length1: number, $length2: number, $length3: number) : System.Array
            public static CreateInstance ($elementType: System.Type, ...lengths: number[]) : System.Array
            public static CreateInstance ($elementType: System.Type, $lengths: System.Array$1<number>, $lowerBounds: System.Array$1<number>) : System.Array
            public static Clear ($array: System.Array, $index: number, $length: number) : void
            public static Copy ($sourceArray: System.Array, $destinationArray: System.Array, $length: number) : void
            public static Copy ($sourceArray: System.Array, $sourceIndex: number, $destinationArray: System.Array, $destinationIndex: number, $length: number) : void
            public static ConstrainedCopy ($sourceArray: System.Array, $sourceIndex: number, $destinationArray: System.Array, $destinationIndex: number, $length: number) : void
            public Initialize () : void
            public CompareTo ($other: any, $comparer: System.Collections.IComparer) : number
            public Equals ($other: any, $comparer: System.Collections.IEqualityComparer) : boolean
            public GetHashCode ($comparer: System.Collections.IEqualityComparer) : number
            public get_Item ($index: number) : any
            public set_Item ($index: number, $value: any) : void
            public Add ($value: any) : number
            public Contains ($value: any) : boolean
            public Clear () : void
            public IndexOf ($value: any) : number
            public Insert ($index: number, $value: any) : void
            public Remove ($value: any) : void
            public RemoveAt ($index: number) : void
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
            public GetHashCode () : number
        }
        class IntPtr extends System.ValueType implements System.Runtime.Serialization.ISerializable, System.IEquatable$1<System.IntPtr>
        {
            protected [__keep_incompatibility]: never;
            public static Zero : System.IntPtr
            public static get Size(): number;
            public ToInt32 () : number
            public ToInt64 () : bigint
            public ToString () : string
            public ToString ($format: string) : string
            public static op_Equality ($value1: System.IntPtr, $value2: System.IntPtr) : boolean
            public static op_Inequality ($value1: System.IntPtr, $value2: System.IntPtr) : boolean
            public static op_Explicit ($value: number) : System.IntPtr
            public static op_Explicit ($value: bigint) : System.IntPtr
            public static op_Explicit ($value: System.IntPtr) : number
            public static op_Explicit ($value: System.IntPtr) : bigint
            public static Add ($pointer: System.IntPtr, $offset: number) : System.IntPtr
            public static Subtract ($pointer: System.IntPtr, $offset: number) : System.IntPtr
            public static op_Addition ($pointer: System.IntPtr, $offset: number) : System.IntPtr
            public static op_Subtraction ($pointer: System.IntPtr, $offset: number) : System.IntPtr
            public constructor ($value: number)
            public constructor ($value: bigint)
            public constructor ()
        }
        enum StringComparison
        { CurrentCulture = 0, CurrentCultureIgnoreCase = 1, InvariantCulture = 2, InvariantCultureIgnoreCase = 3, Ordinal = 4, OrdinalIgnoreCase = 5 }
        interface IFormatProvider
        {
            GetFormat ($formatType: System.Type) : any
        }
        class Delegate extends System.Object implements System.Runtime.Serialization.ISerializable, System.ICloneable
        {
            protected [__keep_incompatibility]: never;
            public get Method(): System.Reflection.MethodInfo;
            public get Target(): any;
            public static CreateDelegate ($type: System.Type, $firstArgument: any, $method: System.Reflection.MethodInfo, $throwOnBindFailure: boolean) : Function
            public static CreateDelegate ($type: System.Type, $firstArgument: any, $method: System.Reflection.MethodInfo) : Function
            public static CreateDelegate ($type: System.Type, $method: System.Reflection.MethodInfo, $throwOnBindFailure: boolean) : Function
            public static CreateDelegate ($type: System.Type, $method: System.Reflection.MethodInfo) : Function
            public static CreateDelegate ($type: System.Type, $target: any, $method: string) : Function
            public static CreateDelegate ($type: System.Type, $target: System.Type, $method: string, $ignoreCase: boolean, $throwOnBindFailure: boolean) : Function
            public static CreateDelegate ($type: System.Type, $target: System.Type, $method: string) : Function
            public static CreateDelegate ($type: System.Type, $target: System.Type, $method: string, $ignoreCase: boolean) : Function
            public static CreateDelegate ($type: System.Type, $target: any, $method: string, $ignoreCase: boolean, $throwOnBindFailure: boolean) : Function
            public static CreateDelegate ($type: System.Type, $target: any, $method: string, $ignoreCase: boolean) : Function
            public DynamicInvoke (...args: any[]) : any
            public Clone () : any
            public GetObjectData ($info: System.Runtime.Serialization.SerializationInfo, $context: System.Runtime.Serialization.StreamingContext) : void
            public GetInvocationList () : System.Array$1<Function>
            public static Combine ($a: Function, $b: Function) : Function
            public static Combine (...delegates: Function[]) : Function
            public static Remove ($source: Function, $value: Function) : Function
            public static RemoveAll ($source: Function, $value: Function) : Function
            public static op_Equality ($d1: Function, $d2: Function) : boolean
            public static op_Inequality ($d1: Function, $d2: Function) : boolean
        }
        interface Delegate {
            GetMethodInfo () : System.Reflection.MethodInfo;
        }
        interface MulticastDelegate
        { 
        (...args:any[]) : any; 
        Invoke?: (...args:any[]) => any;
        }
        var MulticastDelegate: { new (func: (...args:any[]) => any): MulticastDelegate; }
        class Span$1<T> extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get Length(): number;
            public get IsEmpty(): boolean;
            public get_Item ($index: number) : $Ref<T>
            public GetPinnableReference () : $Ref<T>
            public Clear () : void
            public Fill ($value: T) : void
            public ToArray () : System.Array$1<T>
            public constructor ($array: System.Array$1<T>)
            public constructor ($array: System.Array$1<T>, $start: number, $length: number)
            public constructor ()
        }
        class ReadOnlySpan$1<T> extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get Length(): number;
            public get IsEmpty(): boolean;
            public get_Item ($index: number) : $Ref<T>
            public GetPinnableReference () : $Ref<T>
            public ToArray () : System.Array$1<T>
            public constructor ($array: System.Array$1<T>)
            public constructor ($array: System.Array$1<T>, $start: number, $length: number)
            public constructor ()
        }
        class CharEnumerator extends System.Object implements System.ICloneable, System.Collections.Generic.IEnumerator$1<number>, System.IDisposable, System.Collections.IEnumerator
        {
            protected [__keep_incompatibility]: never;
            public get Current(): number;
            public Clone () : any
            public MoveNext () : boolean
            public Dispose () : void
            public Reset () : void
        }
        enum TypeCode
        { Empty = 0, Object = 1, DBNull = 2, Boolean = 3, Char = 4, SByte = 5, Byte = 6, Int16 = 7, UInt16 = 8, Int32 = 9, UInt32 = 10, Int64 = 11, UInt64 = 12, Single = 13, Double = 14, Decimal = 15, DateTime = 16, String = 18 }
        enum StringSplitOptions
        { None = 0, RemoveEmptyEntries = 1 }
        class TimeZoneInfo extends System.Object implements System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable, System.IEquatable$1<System.TimeZoneInfo>
        {
            protected [__keep_incompatibility]: never;
            public get Id(): string;
            public get DisplayName(): string;
            public get StandardName(): string;
            public get DaylightName(): string;
            public get BaseUtcOffset(): System.TimeSpan;
            public get SupportsDaylightSavingTime(): boolean;
            public static get Local(): System.TimeZoneInfo;
            public static get Utc(): System.TimeZoneInfo;
            public GetAdjustmentRules () : System.Array$1<System.TimeZoneInfo.AdjustmentRule>
            public static FindSystemTimeZoneById ($id: string) : System.TimeZoneInfo
            public GetAmbiguousTimeOffsets ($dateTimeOffset: System.DateTimeOffset) : System.Array$1<System.TimeSpan>
            public GetAmbiguousTimeOffsets ($dateTime: System.DateTime) : System.Array$1<System.TimeSpan>
            public GetUtcOffset ($dateTimeOffset: System.DateTimeOffset) : System.TimeSpan
            public GetUtcOffset ($dateTime: System.DateTime) : System.TimeSpan
            public IsAmbiguousTime ($dateTimeOffset: System.DateTimeOffset) : boolean
            public IsAmbiguousTime ($dateTime: System.DateTime) : boolean
            public IsDaylightSavingTime ($dateTimeOffset: System.DateTimeOffset) : boolean
            public IsDaylightSavingTime ($dateTime: System.DateTime) : boolean
            public IsInvalidTime ($dateTime: System.DateTime) : boolean
            public static ClearCachedData () : void
            public static ConvertTimeBySystemTimeZoneId ($dateTimeOffset: System.DateTimeOffset, $destinationTimeZoneId: string) : System.DateTimeOffset
            public static ConvertTimeBySystemTimeZoneId ($dateTime: System.DateTime, $destinationTimeZoneId: string) : System.DateTime
            public static ConvertTimeBySystemTimeZoneId ($dateTime: System.DateTime, $sourceTimeZoneId: string, $destinationTimeZoneId: string) : System.DateTime
            public static ConvertTime ($dateTimeOffset: System.DateTimeOffset, $destinationTimeZone: System.TimeZoneInfo) : System.DateTimeOffset
            public static ConvertTime ($dateTime: System.DateTime, $destinationTimeZone: System.TimeZoneInfo) : System.DateTime
            public static ConvertTime ($dateTime: System.DateTime, $sourceTimeZone: System.TimeZoneInfo, $destinationTimeZone: System.TimeZoneInfo) : System.DateTime
            public static ConvertTimeFromUtc ($dateTime: System.DateTime, $destinationTimeZone: System.TimeZoneInfo) : System.DateTime
            public static ConvertTimeToUtc ($dateTime: System.DateTime) : System.DateTime
            public static ConvertTimeToUtc ($dateTime: System.DateTime, $sourceTimeZone: System.TimeZoneInfo) : System.DateTime
            public Equals ($other: System.TimeZoneInfo) : boolean
            public Equals ($obj: any) : boolean
            public static FromSerializedString ($source: string) : System.TimeZoneInfo
            public static GetSystemTimeZones () : System.Collections.ObjectModel.ReadOnlyCollection$1<System.TimeZoneInfo>
            public HasSameRules ($other: System.TimeZoneInfo) : boolean
            public ToSerializedString () : string
            public static CreateCustomTimeZone ($id: string, $baseUtcOffset: System.TimeSpan, $displayName: string, $standardDisplayName: string) : System.TimeZoneInfo
            public static CreateCustomTimeZone ($id: string, $baseUtcOffset: System.TimeSpan, $displayName: string, $standardDisplayName: string, $daylightDisplayName: string, $adjustmentRules: System.Array$1<System.TimeZoneInfo.AdjustmentRule>) : System.TimeZoneInfo
            public static CreateCustomTimeZone ($id: string, $baseUtcOffset: System.TimeSpan, $displayName: string, $standardDisplayName: string, $daylightDisplayName: string, $adjustmentRules: System.Array$1<System.TimeZoneInfo.AdjustmentRule>, $disableDaylightSavingTime: boolean) : System.TimeZoneInfo
            public OnDeserialization ($sender: any) : void
            public static Equals ($objA: any, $objB: any) : boolean
        }
        class TimeSpan extends System.ValueType implements System.IFormattable, System.ISpanFormattable, System.IComparable, System.IComparable$1<System.TimeSpan>, System.IEquatable$1<System.TimeSpan>
        {
            protected [__keep_incompatibility]: never;
            public static TicksPerMillisecond : bigint
            public static TicksPerSecond : bigint
            public static TicksPerMinute : bigint
            public static TicksPerHour : bigint
            public static TicksPerDay : bigint
            public static Zero : System.TimeSpan
            public static MaxValue : System.TimeSpan
            public static MinValue : System.TimeSpan
            public get Ticks(): bigint;
            public get Days(): number;
            public get Hours(): number;
            public get Milliseconds(): number;
            public get Minutes(): number;
            public get Seconds(): number;
            public get TotalDays(): number;
            public get TotalHours(): number;
            public get TotalMilliseconds(): number;
            public get TotalMinutes(): number;
            public get TotalSeconds(): number;
            public Add ($ts: System.TimeSpan) : System.TimeSpan
            public static Compare ($t1: System.TimeSpan, $t2: System.TimeSpan) : number
            public CompareTo ($value: any) : number
            public CompareTo ($value: System.TimeSpan) : number
            public static FromDays ($value: number) : System.TimeSpan
            public Duration () : System.TimeSpan
            public Equals ($value: any) : boolean
            public Equals ($obj: System.TimeSpan) : boolean
            public static Equals ($t1: System.TimeSpan, $t2: System.TimeSpan) : boolean
            public static FromHours ($value: number) : System.TimeSpan
            public static FromMilliseconds ($value: number) : System.TimeSpan
            public static FromMinutes ($value: number) : System.TimeSpan
            public Negate () : System.TimeSpan
            public static FromSeconds ($value: number) : System.TimeSpan
            public Subtract ($ts: System.TimeSpan) : System.TimeSpan
            public Multiply ($factor: number) : System.TimeSpan
            public Divide ($divisor: number) : System.TimeSpan
            public Divide ($ts: System.TimeSpan) : number
            public static FromTicks ($value: bigint) : System.TimeSpan
            public static Parse ($s: string) : System.TimeSpan
            public static Parse ($input: string, $formatProvider: System.IFormatProvider) : System.TimeSpan
            public static ParseExact ($input: string, $format: string, $formatProvider: System.IFormatProvider) : System.TimeSpan
            public static ParseExact ($input: string, $formats: System.Array$1<string>, $formatProvider: System.IFormatProvider) : System.TimeSpan
            public static ParseExact ($input: string, $format: string, $formatProvider: System.IFormatProvider, $styles: System.Globalization.TimeSpanStyles) : System.TimeSpan
            public static ParseExact ($input: string, $formats: System.Array$1<string>, $formatProvider: System.IFormatProvider, $styles: System.Globalization.TimeSpanStyles) : System.TimeSpan
            public static TryParse ($s: string, $result: $Ref<System.TimeSpan>) : boolean
            public static TryParse ($input: string, $formatProvider: System.IFormatProvider, $result: $Ref<System.TimeSpan>) : boolean
            public static TryParseExact ($input: string, $format: string, $formatProvider: System.IFormatProvider, $result: $Ref<System.TimeSpan>) : boolean
            public static TryParseExact ($input: string, $formats: System.Array$1<string>, $formatProvider: System.IFormatProvider, $result: $Ref<System.TimeSpan>) : boolean
            public static TryParseExact ($input: string, $format: string, $formatProvider: System.IFormatProvider, $styles: System.Globalization.TimeSpanStyles, $result: $Ref<System.TimeSpan>) : boolean
            public static TryParseExact ($input: string, $formats: System.Array$1<string>, $formatProvider: System.IFormatProvider, $styles: System.Globalization.TimeSpanStyles, $result: $Ref<System.TimeSpan>) : boolean
            public ToString () : string
            public ToString ($format: string) : string
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            public static op_UnaryNegation ($t: System.TimeSpan) : System.TimeSpan
            public static op_Subtraction ($t1: System.TimeSpan, $t2: System.TimeSpan) : System.TimeSpan
            public static op_UnaryPlus ($t: System.TimeSpan) : System.TimeSpan
            public static op_Addition ($t1: System.TimeSpan, $t2: System.TimeSpan) : System.TimeSpan
            public static op_Multiply ($timeSpan: System.TimeSpan, $factor: number) : System.TimeSpan
            public static op_Multiply ($factor: number, $timeSpan: System.TimeSpan) : System.TimeSpan
            public static op_Division ($timeSpan: System.TimeSpan, $divisor: number) : System.TimeSpan
            public static op_Division ($t1: System.TimeSpan, $t2: System.TimeSpan) : number
            public static op_Equality ($t1: System.TimeSpan, $t2: System.TimeSpan) : boolean
            public static op_Inequality ($t1: System.TimeSpan, $t2: System.TimeSpan) : boolean
            public static op_LessThan ($t1: System.TimeSpan, $t2: System.TimeSpan) : boolean
            public static op_LessThanOrEqual ($t1: System.TimeSpan, $t2: System.TimeSpan) : boolean
            public static op_GreaterThan ($t1: System.TimeSpan, $t2: System.TimeSpan) : boolean
            public static op_GreaterThanOrEqual ($t1: System.TimeSpan, $t2: System.TimeSpan) : boolean
            public constructor ($ticks: bigint)
            public constructor ($hours: number, $minutes: number, $seconds: number)
            public constructor ($days: number, $hours: number, $minutes: number, $seconds: number)
            public constructor ($days: number, $hours: number, $minutes: number, $seconds: number, $milliseconds: number)
            public CompareTo ($obj: any) : number
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
            public constructor ()
        }
        class DateTimeOffset extends System.ValueType implements System.Runtime.Serialization.IDeserializationCallback, System.IFormattable, System.Runtime.Serialization.ISerializable, System.ISpanFormattable, System.IComparable, System.IComparable$1<System.DateTimeOffset>, System.IEquatable$1<System.DateTimeOffset>
        {
            protected [__keep_incompatibility]: never;
            public static MinValue : System.DateTimeOffset
            public static MaxValue : System.DateTimeOffset
            public static UnixEpoch : System.DateTimeOffset
            public static get Now(): System.DateTimeOffset;
            public static get UtcNow(): System.DateTimeOffset;
            public get DateTime(): System.DateTime;
            public get UtcDateTime(): System.DateTime;
            public get LocalDateTime(): System.DateTime;
            public get Date(): System.DateTime;
            public get Day(): number;
            public get DayOfWeek(): System.DayOfWeek;
            public get DayOfYear(): number;
            public get Hour(): number;
            public get Millisecond(): number;
            public get Minute(): number;
            public get Month(): number;
            public get Offset(): System.TimeSpan;
            public get Second(): number;
            public get Ticks(): bigint;
            public get UtcTicks(): bigint;
            public get TimeOfDay(): System.TimeSpan;
            public get Year(): number;
            public ToOffset ($offset: System.TimeSpan) : System.DateTimeOffset
            public Add ($timeSpan: System.TimeSpan) : System.DateTimeOffset
            public AddDays ($days: number) : System.DateTimeOffset
            public AddHours ($hours: number) : System.DateTimeOffset
            public AddMilliseconds ($milliseconds: number) : System.DateTimeOffset
            public AddMinutes ($minutes: number) : System.DateTimeOffset
            public AddMonths ($months: number) : System.DateTimeOffset
            public AddSeconds ($seconds: number) : System.DateTimeOffset
            public AddTicks ($ticks: bigint) : System.DateTimeOffset
            public AddYears ($years: number) : System.DateTimeOffset
            public static Compare ($first: System.DateTimeOffset, $second: System.DateTimeOffset) : number
            public CompareTo ($other: System.DateTimeOffset) : number
            public Equals ($obj: any) : boolean
            public Equals ($other: System.DateTimeOffset) : boolean
            public EqualsExact ($other: System.DateTimeOffset) : boolean
            public static Equals ($first: System.DateTimeOffset, $second: System.DateTimeOffset) : boolean
            public static FromFileTime ($fileTime: bigint) : System.DateTimeOffset
            public static FromUnixTimeSeconds ($seconds: bigint) : System.DateTimeOffset
            public static FromUnixTimeMilliseconds ($milliseconds: bigint) : System.DateTimeOffset
            public static Parse ($input: string) : System.DateTimeOffset
            public static Parse ($input: string, $formatProvider: System.IFormatProvider) : System.DateTimeOffset
            public static Parse ($input: string, $formatProvider: System.IFormatProvider, $styles: System.Globalization.DateTimeStyles) : System.DateTimeOffset
            public static ParseExact ($input: string, $format: string, $formatProvider: System.IFormatProvider) : System.DateTimeOffset
            public static ParseExact ($input: string, $format: string, $formatProvider: System.IFormatProvider, $styles: System.Globalization.DateTimeStyles) : System.DateTimeOffset
            public static ParseExact ($input: string, $formats: System.Array$1<string>, $formatProvider: System.IFormatProvider, $styles: System.Globalization.DateTimeStyles) : System.DateTimeOffset
            public Subtract ($value: System.DateTimeOffset) : System.TimeSpan
            public Subtract ($value: System.TimeSpan) : System.DateTimeOffset
            public ToFileTime () : bigint
            public ToUnixTimeSeconds () : bigint
            public ToUnixTimeMilliseconds () : bigint
            public ToLocalTime () : System.DateTimeOffset
            public ToString () : string
            public ToString ($format: string) : string
            public ToString ($formatProvider: System.IFormatProvider) : string
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            public ToUniversalTime () : System.DateTimeOffset
            public static TryParse ($input: string, $result: $Ref<System.DateTimeOffset>) : boolean
            public static TryParse ($input: string, $formatProvider: System.IFormatProvider, $styles: System.Globalization.DateTimeStyles, $result: $Ref<System.DateTimeOffset>) : boolean
            public static TryParseExact ($input: string, $format: string, $formatProvider: System.IFormatProvider, $styles: System.Globalization.DateTimeStyles, $result: $Ref<System.DateTimeOffset>) : boolean
            public static TryParseExact ($input: string, $formats: System.Array$1<string>, $formatProvider: System.IFormatProvider, $styles: System.Globalization.DateTimeStyles, $result: $Ref<System.DateTimeOffset>) : boolean
            public static op_Implicit ($dateTime: System.DateTime) : System.DateTimeOffset
            public static op_Addition ($dateTimeOffset: System.DateTimeOffset, $timeSpan: System.TimeSpan) : System.DateTimeOffset
            public static op_Subtraction ($dateTimeOffset: System.DateTimeOffset, $timeSpan: System.TimeSpan) : System.DateTimeOffset
            public static op_Subtraction ($left: System.DateTimeOffset, $right: System.DateTimeOffset) : System.TimeSpan
            public static op_Equality ($left: System.DateTimeOffset, $right: System.DateTimeOffset) : boolean
            public static op_Inequality ($left: System.DateTimeOffset, $right: System.DateTimeOffset) : boolean
            public static op_LessThan ($left: System.DateTimeOffset, $right: System.DateTimeOffset) : boolean
            public static op_LessThanOrEqual ($left: System.DateTimeOffset, $right: System.DateTimeOffset) : boolean
            public static op_GreaterThan ($left: System.DateTimeOffset, $right: System.DateTimeOffset) : boolean
            public static op_GreaterThanOrEqual ($left: System.DateTimeOffset, $right: System.DateTimeOffset) : boolean
            public constructor ($ticks: bigint, $offset: System.TimeSpan)
            public constructor ($dateTime: System.DateTime)
            public constructor ($dateTime: System.DateTime, $offset: System.TimeSpan)
            public constructor ($year: number, $month: number, $day: number, $hour: number, $minute: number, $second: number, $offset: System.TimeSpan)
            public constructor ($year: number, $month: number, $day: number, $hour: number, $minute: number, $second: number, $millisecond: number, $offset: System.TimeSpan)
            public constructor ($year: number, $month: number, $day: number, $hour: number, $minute: number, $second: number, $millisecond: number, $calendar: System.Globalization.Calendar, $offset: System.TimeSpan)
            public OnDeserialization ($sender: any) : void
            public CompareTo ($obj: any) : number
            public static Equals ($objA: any, $objB: any) : boolean
            public constructor ()
        }
        class DateTime extends System.ValueType implements System.IFormattable, System.Runtime.Serialization.ISerializable, System.ISpanFormattable, System.IComparable, System.IComparable$1<System.DateTime>, System.IConvertible, System.IEquatable$1<System.DateTime>
        {
            protected [__keep_incompatibility]: never;
            public static MinValue : System.DateTime
            public static MaxValue : System.DateTime
            public static UnixEpoch : System.DateTime
            public get Date(): System.DateTime;
            public get Day(): number;
            public get DayOfWeek(): System.DayOfWeek;
            public get DayOfYear(): number;
            public get Hour(): number;
            public get Kind(): System.DateTimeKind;
            public get Millisecond(): number;
            public get Minute(): number;
            public get Month(): number;
            public static get Now(): System.DateTime;
            public get Second(): number;
            public get Ticks(): bigint;
            public get TimeOfDay(): System.TimeSpan;
            public static get Today(): System.DateTime;
            public get Year(): number;
            public static get UtcNow(): System.DateTime;
            public Add ($value: System.TimeSpan) : System.DateTime
            public AddDays ($value: number) : System.DateTime
            public AddHours ($value: number) : System.DateTime
            public AddMilliseconds ($value: number) : System.DateTime
            public AddMinutes ($value: number) : System.DateTime
            public AddMonths ($months: number) : System.DateTime
            public AddSeconds ($value: number) : System.DateTime
            public AddTicks ($value: bigint) : System.DateTime
            public AddYears ($value: number) : System.DateTime
            public static Compare ($t1: System.DateTime, $t2: System.DateTime) : number
            public CompareTo ($value: any) : number
            public CompareTo ($value: System.DateTime) : number
            public static DaysInMonth ($year: number, $month: number) : number
            public Equals ($value: any) : boolean
            public Equals ($value: System.DateTime) : boolean
            public static Equals ($t1: System.DateTime, $t2: System.DateTime) : boolean
            public static FromBinary ($dateData: bigint) : System.DateTime
            public static FromFileTime ($fileTime: bigint) : System.DateTime
            public static FromFileTimeUtc ($fileTime: bigint) : System.DateTime
            public static FromOADate ($d: number) : System.DateTime
            public IsDaylightSavingTime () : boolean
            public static SpecifyKind ($value: System.DateTime, $kind: System.DateTimeKind) : System.DateTime
            public ToBinary () : bigint
            public static IsLeapYear ($year: number) : boolean
            public static Parse ($s: string) : System.DateTime
            public static Parse ($s: string, $provider: System.IFormatProvider) : System.DateTime
            public static Parse ($s: string, $provider: System.IFormatProvider, $styles: System.Globalization.DateTimeStyles) : System.DateTime
            public static ParseExact ($s: string, $format: string, $provider: System.IFormatProvider) : System.DateTime
            public static ParseExact ($s: string, $format: string, $provider: System.IFormatProvider, $style: System.Globalization.DateTimeStyles) : System.DateTime
            public static ParseExact ($s: string, $formats: System.Array$1<string>, $provider: System.IFormatProvider, $style: System.Globalization.DateTimeStyles) : System.DateTime
            public Subtract ($value: System.DateTime) : System.TimeSpan
            public Subtract ($value: System.TimeSpan) : System.DateTime
            public ToOADate () : number
            public ToFileTime () : bigint
            public ToFileTimeUtc () : bigint
            public ToLocalTime () : System.DateTime
            public ToLongDateString () : string
            public ToLongTimeString () : string
            public ToShortDateString () : string
            public ToShortTimeString () : string
            public ToString () : string
            public ToString ($format: string) : string
            public ToString ($provider: System.IFormatProvider) : string
            public ToString ($format: string, $provider: System.IFormatProvider) : string
            public ToUniversalTime () : System.DateTime
            public static TryParse ($s: string, $result: $Ref<System.DateTime>) : boolean
            public static TryParse ($s: string, $provider: System.IFormatProvider, $styles: System.Globalization.DateTimeStyles, $result: $Ref<System.DateTime>) : boolean
            public static TryParseExact ($s: string, $format: string, $provider: System.IFormatProvider, $style: System.Globalization.DateTimeStyles, $result: $Ref<System.DateTime>) : boolean
            public static TryParseExact ($s: string, $formats: System.Array$1<string>, $provider: System.IFormatProvider, $style: System.Globalization.DateTimeStyles, $result: $Ref<System.DateTime>) : boolean
            public static op_Addition ($d: System.DateTime, $t: System.TimeSpan) : System.DateTime
            public static op_Subtraction ($d: System.DateTime, $t: System.TimeSpan) : System.DateTime
            public static op_Subtraction ($d1: System.DateTime, $d2: System.DateTime) : System.TimeSpan
            public static op_Equality ($d1: System.DateTime, $d2: System.DateTime) : boolean
            public static op_Inequality ($d1: System.DateTime, $d2: System.DateTime) : boolean
            public static op_LessThan ($t1: System.DateTime, $t2: System.DateTime) : boolean
            public static op_LessThanOrEqual ($t1: System.DateTime, $t2: System.DateTime) : boolean
            public static op_GreaterThan ($t1: System.DateTime, $t2: System.DateTime) : boolean
            public static op_GreaterThanOrEqual ($t1: System.DateTime, $t2: System.DateTime) : boolean
            public GetDateTimeFormats () : System.Array$1<string>
            public GetDateTimeFormats ($provider: System.IFormatProvider) : System.Array$1<string>
            public GetDateTimeFormats ($format: number) : System.Array$1<string>
            public GetDateTimeFormats ($format: number, $provider: System.IFormatProvider) : System.Array$1<string>
            public GetTypeCode () : System.TypeCode
            public constructor ($ticks: bigint)
            public constructor ($ticks: bigint, $kind: System.DateTimeKind)
            public constructor ($year: number, $month: number, $day: number)
            public constructor ($year: number, $month: number, $day: number, $calendar: System.Globalization.Calendar)
            public constructor ($year: number, $month: number, $day: number, $hour: number, $minute: number, $second: number)
            public constructor ($year: number, $month: number, $day: number, $hour: number, $minute: number, $second: number, $kind: System.DateTimeKind)
            public constructor ($year: number, $month: number, $day: number, $hour: number, $minute: number, $second: number, $calendar: System.Globalization.Calendar)
            public constructor ($year: number, $month: number, $day: number, $hour: number, $minute: number, $second: number, $millisecond: number)
            public constructor ($year: number, $month: number, $day: number, $hour: number, $minute: number, $second: number, $millisecond: number, $kind: System.DateTimeKind)
            public constructor ($year: number, $month: number, $day: number, $hour: number, $minute: number, $second: number, $millisecond: number, $calendar: System.Globalization.Calendar)
            public constructor ($year: number, $month: number, $day: number, $hour: number, $minute: number, $second: number, $millisecond: number, $calendar: System.Globalization.Calendar, $kind: System.DateTimeKind)
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            public CompareTo ($obj: any) : number
            public ToBoolean ($provider: System.IFormatProvider) : boolean
            public ToChar ($provider: System.IFormatProvider) : number
            public ToSByte ($provider: System.IFormatProvider) : number
            public ToByte ($provider: System.IFormatProvider) : number
            public ToInt16 ($provider: System.IFormatProvider) : number
            public ToUInt16 ($provider: System.IFormatProvider) : number
            public ToInt32 ($provider: System.IFormatProvider) : number
            public ToUInt32 ($provider: System.IFormatProvider) : number
            public ToInt64 ($provider: System.IFormatProvider) : bigint
            public ToUInt64 ($provider: System.IFormatProvider) : bigint
            public ToSingle ($provider: System.IFormatProvider) : number
            public ToDouble ($provider: System.IFormatProvider) : number
            public ToDecimal ($provider: System.IFormatProvider) : System.Decimal
            public ToDateTime ($provider: System.IFormatProvider) : System.DateTime
            public ToType ($conversionType: System.Type, $provider: System.IFormatProvider) : any
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
            public constructor ()
        }
        enum DayOfWeek
        { Sunday = 0, Monday = 1, Tuesday = 2, Wednesday = 3, Thursday = 4, Friday = 5, Saturday = 6 }
        class Exception extends System.Object implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public get Message(): string;
            public get Data(): System.Collections.IDictionary;
            public get InnerException(): System.Exception;
            public get TargetSite(): System.Reflection.MethodBase;
            public get StackTrace(): string;
            public get HelpLink(): string;
            public set HelpLink(value: string);
            public get Source(): string;
            public set Source(value: string);
            public get HResult(): number;
            public GetBaseException () : System.Exception
            public GetObjectData ($info: System.Runtime.Serialization.SerializationInfo, $context: System.Runtime.Serialization.StreamingContext) : void
            public GetType () : System.Type
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class SystemException extends System.Exception implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class AccessViolationException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        interface Action
        { 
        () : void; 
        Invoke?: () => void;
        }
        var Action: { new (func: () => void): Action; }
        interface IAsyncResult
        {
            IsCompleted : boolean
            AsyncWaitHandle : System.Threading.WaitHandle
            AsyncState : any
            CompletedSynchronously : boolean
        }
        interface AsyncCallback
        { 
        (ar: System.IAsyncResult) : void; 
        Invoke?: (ar: System.IAsyncResult) => void;
        }
        var AsyncCallback: { new (func: (ar: System.IAsyncResult) => void): AsyncCallback; }
        interface Action$1<T>
        { 
        (obj: T) : void; 
        Invoke?: (obj: T) => void;
        }
        interface Action$2<T1, T2>
        { 
        (arg1: T1, arg2: T2) : void; 
        Invoke?: (arg1: T1, arg2: T2) => void;
        }
        interface Action$3<T1, T2, T3>
        { 
        (arg1: T1, arg2: T2, arg3: T3) : void; 
        Invoke?: (arg1: T1, arg2: T2, arg3: T3) => void;
        }
        interface Action$4<T1, T2, T3, T4>
        { 
        (arg1: T1, arg2: T2, arg3: T3, arg4: T4) : void; 
        Invoke?: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => void;
        }
        interface Action$5<T1, T2, T3, T4, T5>
        { 
        (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) : void; 
        Invoke?: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => void;
        }
        interface Action$6<T1, T2, T3, T4, T5, T6>
        { 
        (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6) : void; 
        Invoke?: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6) => void;
        }
        interface Action$7<T1, T2, T3, T4, T5, T6, T7>
        { 
        (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7) : void; 
        Invoke?: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7) => void;
        }
        interface Action$8<T1, T2, T3, T4, T5, T6, T7, T8>
        { 
        (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8) : void; 
        Invoke?: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8) => void;
        }
        interface Func$1<TResult>
        { 
        () : TResult; 
        Invoke?: () => TResult;
        }
        interface Func$2<T, TResult>
        { 
        (arg: T) : TResult; 
        Invoke?: (arg: T) => TResult;
        }
        interface Func$3<T1, T2, TResult>
        { 
        (arg1: T1, arg2: T2) : TResult; 
        Invoke?: (arg1: T1, arg2: T2) => TResult;
        }
        interface Func$4<T1, T2, T3, TResult>
        { 
        (arg1: T1, arg2: T2, arg3: T3) : TResult; 
        Invoke?: (arg1: T1, arg2: T2, arg3: T3) => TResult;
        }
        interface Func$5<T1, T2, T3, T4, TResult>
        { 
        (arg1: T1, arg2: T2, arg3: T3, arg4: T4) : TResult; 
        Invoke?: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => TResult;
        }
        interface Func$6<T1, T2, T3, T4, T5, TResult>
        { 
        (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) : TResult; 
        Invoke?: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => TResult;
        }
        interface Func$7<T1, T2, T3, T4, T5, T6, TResult>
        { 
        (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6) : TResult; 
        Invoke?: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6) => TResult;
        }
        interface Func$8<T1, T2, T3, T4, T5, T6, T7, TResult>
        { 
        (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7) : TResult; 
        Invoke?: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7) => TResult;
        }
        interface Func$9<T1, T2, T3, T4, T5, T6, T7, T8, TResult>
        { 
        (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8) : TResult; 
        Invoke?: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8) => TResult;
        }
        interface Comparison$1<T>
        { 
        (x: T, y: T) : number; 
        Invoke?: (x: T, y: T) => number;
        }
        interface Converter$2<TInput, TOutput>
        { 
        (input: TInput) : TOutput; 
        Invoke?: (input: TInput) => TOutput;
        }
        interface Predicate$1<T>
        { 
        (obj: T) : boolean; 
        Invoke?: (obj: T) => boolean;
        }
        class AggregateException extends System.Exception implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public get InnerExceptions(): System.Collections.ObjectModel.ReadOnlyCollection$1<System.Exception>;
            public get Message(): string;
            public Handle ($predicate: System.Func$2<System.Exception, boolean>) : void
            public Flatten () : System.AggregateException
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
            public constructor ($innerExceptions: System.Collections.Generic.IEnumerable$1<System.Exception>)
            public constructor (...innerExceptions: System.Exception[])
            public constructor ($message: string, $innerExceptions: System.Collections.Generic.IEnumerable$1<System.Exception>)
            public constructor ($message: string, ...innerExceptions: System.Exception[])
        }
        class ApplicationException extends System.Exception implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class ArgumentException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public get Message(): string;
            public get ParamName(): string;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
            public constructor ($message: string, $paramName: string, $innerException: System.Exception)
            public constructor ($message: string, $paramName: string)
        }
        class ArgumentNullException extends System.ArgumentException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($paramName: string)
            public constructor ($message: string, $innerException: System.Exception)
            public constructor ($paramName: string, $message: string)
            public constructor ($message: string)
            public constructor ($message: string, $paramName: string, $innerException: System.Exception)
            public constructor ($message: string, $paramName: string)
        }
        class ArgumentOutOfRangeException extends System.ArgumentException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public get Message(): string;
            public get ActualValue(): any;
            public constructor ()
            public constructor ($paramName: string)
            public constructor ($paramName: string, $message: string)
            public constructor ($message: string, $innerException: System.Exception)
            public constructor ($paramName: string, $actualValue: any, $message: string)
            public constructor ($message: string)
            public constructor ($message: string, $paramName: string, $innerException: System.Exception)
            public constructor ($message: string, $paramName: string)
        }
        class ArithmeticException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class ArraySegment$1<T> extends System.ValueType implements System.Collections.Generic.IReadOnlyList$1<T>, System.Collections.Generic.IEnumerable$1<T>, System.Collections.IEnumerable, System.Collections.Generic.IList$1<T>, System.Collections.Generic.IReadOnlyCollection$1<T>, System.Collections.Generic.ICollection$1<T>
        {
            protected [__keep_incompatibility]: never;
            public static get Empty(): any;
            public get Array(): System.Array$1<T>;
            public get Offset(): number;
            public get Count(): number;
            public get_Item ($index: number) : T
            public set_Item ($index: number, $value: T) : void
            public GetEnumerator () : System.ArraySegment$1.Enumerator<T>
            public CopyTo ($destination: System.Array$1<T>) : void
            public CopyTo ($destination: System.Array$1<T>, $destinationIndex: number) : void
            public CopyTo ($destination: System.ArraySegment$1<T>) : void
            public Equals ($obj: any) : boolean
            public Equals ($obj: System.ArraySegment$1<T>) : boolean
            public Slice ($index: number) : System.ArraySegment$1<T>
            public Slice ($index: number, $count: number) : System.ArraySegment$1<T>
            public ToArray () : System.Array$1<T>
            public static op_Equality ($a: any, $b: any) : any
            public static op_Inequality ($a: any, $b: any) : any
            public static op_Implicit ($array: any) : any
            public constructor ($array: System.Array$1<T>)
            public constructor ($array: System.Array$1<T>, $offset: number, $count: number)
            public GetEnumerator () : System.Collections.IEnumerator
            public static Equals ($objA: any, $objB: any) : any
            public constructor ()
            public [Symbol.iterator]() : IterableIterator<T>
        }
        class ArrayTypeMismatchException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class EventArgs extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static Empty : System.EventArgs
            public constructor ()
        }
        class AssemblyLoadEventArgs extends System.EventArgs
        {
            protected [__keep_incompatibility]: never;
            public get LoadedAssembly(): System.Reflection.Assembly;
            public constructor ($loadedAssembly: System.Reflection.Assembly)
            public constructor ()
        }
        interface AssemblyLoadEventHandler
        { 
        (sender: any, args: System.AssemblyLoadEventArgs) : void; 
        Invoke?: (sender: any, args: System.AssemblyLoadEventArgs) => void;
        }
        var AssemblyLoadEventHandler: { new (func: (sender: any, args: System.AssemblyLoadEventArgs) => void): AssemblyLoadEventHandler; }
        enum AttributeTargets
        { Assembly = 1, Module = 2, Class = 4, Struct = 8, Enum = 16, Constructor = 32, Method = 64, Property = 128, Field = 256, Event = 512, Interface = 1024, Parameter = 2048, Delegate = 4096, ReturnValue = 8192, GenericParameter = 16384, All = 32767 }
        class Attribute extends System.Object implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get TypeId(): any;
            public static GetCustomAttributes ($element: System.Reflection.MemberInfo, $type: System.Type) : System.Array$1<System.Attribute>
            public static GetCustomAttributes ($element: System.Reflection.MemberInfo, $type: System.Type, $inherit: boolean) : System.Array$1<System.Attribute>
            public static GetCustomAttributes ($element: System.Reflection.MemberInfo) : System.Array$1<System.Attribute>
            public static GetCustomAttributes ($element: System.Reflection.MemberInfo, $inherit: boolean) : System.Array$1<System.Attribute>
            public static IsDefined ($element: System.Reflection.MemberInfo, $attributeType: System.Type) : boolean
            public static IsDefined ($element: System.Reflection.MemberInfo, $attributeType: System.Type, $inherit: boolean) : boolean
            public static GetCustomAttribute ($element: System.Reflection.MemberInfo, $attributeType: System.Type) : System.Attribute
            public static GetCustomAttribute ($element: System.Reflection.MemberInfo, $attributeType: System.Type, $inherit: boolean) : System.Attribute
            public static GetCustomAttributes ($element: System.Reflection.ParameterInfo) : System.Array$1<System.Attribute>
            public static GetCustomAttributes ($element: System.Reflection.ParameterInfo, $attributeType: System.Type) : System.Array$1<System.Attribute>
            public static GetCustomAttributes ($element: System.Reflection.ParameterInfo, $attributeType: System.Type, $inherit: boolean) : System.Array$1<System.Attribute>
            public static GetCustomAttributes ($element: System.Reflection.ParameterInfo, $inherit: boolean) : System.Array$1<System.Attribute>
            public static IsDefined ($element: System.Reflection.ParameterInfo, $attributeType: System.Type) : boolean
            public static IsDefined ($element: System.Reflection.ParameterInfo, $attributeType: System.Type, $inherit: boolean) : boolean
            public static GetCustomAttribute ($element: System.Reflection.ParameterInfo, $attributeType: System.Type) : System.Attribute
            public static GetCustomAttribute ($element: System.Reflection.ParameterInfo, $attributeType: System.Type, $inherit: boolean) : System.Attribute
            public static GetCustomAttributes ($element: System.Reflection.Module, $attributeType: System.Type) : System.Array$1<System.Attribute>
            public static GetCustomAttributes ($element: System.Reflection.Module) : System.Array$1<System.Attribute>
            public static GetCustomAttributes ($element: System.Reflection.Module, $inherit: boolean) : System.Array$1<System.Attribute>
            public static GetCustomAttributes ($element: System.Reflection.Module, $attributeType: System.Type, $inherit: boolean) : System.Array$1<System.Attribute>
            public static IsDefined ($element: System.Reflection.Module, $attributeType: System.Type) : boolean
            public static IsDefined ($element: System.Reflection.Module, $attributeType: System.Type, $inherit: boolean) : boolean
            public static GetCustomAttribute ($element: System.Reflection.Module, $attributeType: System.Type) : System.Attribute
            public static GetCustomAttribute ($element: System.Reflection.Module, $attributeType: System.Type, $inherit: boolean) : System.Attribute
            public static GetCustomAttributes ($element: System.Reflection.Assembly, $attributeType: System.Type) : System.Array$1<System.Attribute>
            public static GetCustomAttributes ($element: System.Reflection.Assembly, $attributeType: System.Type, $inherit: boolean) : System.Array$1<System.Attribute>
            public static GetCustomAttributes ($element: System.Reflection.Assembly) : System.Array$1<System.Attribute>
            public static GetCustomAttributes ($element: System.Reflection.Assembly, $inherit: boolean) : System.Array$1<System.Attribute>
            public static IsDefined ($element: System.Reflection.Assembly, $attributeType: System.Type) : boolean
            public static IsDefined ($element: System.Reflection.Assembly, $attributeType: System.Type, $inherit: boolean) : boolean
            public static GetCustomAttribute ($element: System.Reflection.Assembly, $attributeType: System.Type) : System.Attribute
            public static GetCustomAttribute ($element: System.Reflection.Assembly, $attributeType: System.Type, $inherit: boolean) : System.Attribute
            public Match ($obj: any) : boolean
            public IsDefaultAttribute () : boolean
            public GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            public GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            public GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            public Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
        }
        class AttributeUsageAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get ValidOn(): System.AttributeTargets;
            public get AllowMultiple(): boolean;
            public set AllowMultiple(value: boolean);
            public get Inherited(): boolean;
            public set Inherited(value: boolean);
            public constructor ($validOn: System.AttributeTargets)
            public constructor ()
        }
        class BadImageFormatException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public get Message(): string;
            public get FileName(): string;
            public get FusionLog(): string;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $inner: System.Exception)
            public constructor ($message: string, $fileName: string)
            public constructor ($message: string, $fileName: string, $inner: System.Exception)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class BitConverter extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static IsLittleEndian : boolean
            public static GetBytes ($value: boolean) : System.Array$1<number>
            public static GetBytes ($value: number) : System.Array$1<number>
            public static GetBytes ($value: bigint) : System.Array$1<number>
            public static ToChar ($value: System.Array$1<number>, $startIndex: number) : number
            public static ToInt16 ($value: System.Array$1<number>, $startIndex: number) : number
            public static ToInt32 ($value: System.Array$1<number>, $startIndex: number) : number
            public static ToInt64 ($value: System.Array$1<number>, $startIndex: number) : bigint
            public static ToUInt16 ($value: System.Array$1<number>, $startIndex: number) : number
            public static ToUInt32 ($value: System.Array$1<number>, $startIndex: number) : number
            public static ToUInt64 ($value: System.Array$1<number>, $startIndex: number) : bigint
            public static ToSingle ($value: System.Array$1<number>, $startIndex: number) : number
            public static ToDouble ($value: System.Array$1<number>, $startIndex: number) : number
            public static ToString ($value: System.Array$1<number>, $startIndex: number, $length: number) : string
            public static ToString ($value: System.Array$1<number>) : string
            public static ToString ($value: System.Array$1<number>, $startIndex: number) : string
            public static ToBoolean ($value: System.Array$1<number>, $startIndex: number) : boolean
            public static DoubleToInt64Bits ($value: number) : bigint
            public static Int64BitsToDouble ($value: bigint) : number
            public static SingleToInt32Bits ($value: number) : number
            public static Int32BitsToSingle ($value: number) : number
            public ToString () : string
        }
        class Byte extends System.ValueType implements System.IFormattable, System.ISpanFormattable, System.IComparable, System.IComparable$1<number>, System.IConvertible, System.IEquatable$1<number>
        {
            protected [__keep_incompatibility]: never;
            public static MaxValue : number
            public static MinValue : number
            public CompareTo ($value: any) : number
            public CompareTo ($value: number) : number
            public Equals ($obj: any) : boolean
            public Equals ($obj: number) : boolean
            public static Parse ($s: string) : number
            public static Parse ($s: string, $style: System.Globalization.NumberStyles) : number
            public static Parse ($s: string, $provider: System.IFormatProvider) : number
            public static Parse ($s: string, $style: System.Globalization.NumberStyles, $provider: System.IFormatProvider) : number
            public static TryParse ($s: string, $result: $Ref<number>) : boolean
            public static TryParse ($s: string, $style: System.Globalization.NumberStyles, $provider: System.IFormatProvider, $result: $Ref<number>) : boolean
            public ToString () : string
            public ToString ($format: string) : string
            public ToString ($provider: System.IFormatProvider) : string
            public ToString ($format: string, $provider: System.IFormatProvider) : string
            public GetTypeCode () : System.TypeCode
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            public CompareTo ($obj: any) : number
            public ToBoolean ($provider: System.IFormatProvider) : boolean
            public ToChar ($provider: System.IFormatProvider) : number
            public ToSByte ($provider: System.IFormatProvider) : number
            public ToByte ($provider: System.IFormatProvider) : number
            public ToInt16 ($provider: System.IFormatProvider) : number
            public ToUInt16 ($provider: System.IFormatProvider) : number
            public ToInt32 ($provider: System.IFormatProvider) : number
            public ToUInt32 ($provider: System.IFormatProvider) : number
            public ToInt64 ($provider: System.IFormatProvider) : bigint
            public ToUInt64 ($provider: System.IFormatProvider) : bigint
            public ToSingle ($provider: System.IFormatProvider) : number
            public ToDouble ($provider: System.IFormatProvider) : number
            public ToDecimal ($provider: System.IFormatProvider) : System.Decimal
            public ToDateTime ($provider: System.IFormatProvider) : System.DateTime
            public ToType ($conversionType: System.Type, $provider: System.IFormatProvider) : any
            public static Equals ($objA: any, $objB: any) : boolean
        }
        class Int16 extends System.ValueType implements System.IFormattable, System.ISpanFormattable, System.IComparable, System.IComparable$1<number>, System.IConvertible, System.IEquatable$1<number>
        {
            protected [__keep_incompatibility]: never;
            public static MaxValue : number
            public static MinValue : number
            public CompareTo ($value: any) : number
            public CompareTo ($value: number) : number
            public Equals ($obj: any) : boolean
            public Equals ($obj: number) : boolean
            public ToString () : string
            public ToString ($provider: System.IFormatProvider) : string
            public ToString ($format: string) : string
            public ToString ($format: string, $provider: System.IFormatProvider) : string
            public static Parse ($s: string) : number
            public static Parse ($s: string, $style: System.Globalization.NumberStyles) : number
            public static Parse ($s: string, $provider: System.IFormatProvider) : number
            public static Parse ($s: string, $style: System.Globalization.NumberStyles, $provider: System.IFormatProvider) : number
            public static TryParse ($s: string, $result: $Ref<number>) : boolean
            public static TryParse ($s: string, $style: System.Globalization.NumberStyles, $provider: System.IFormatProvider, $result: $Ref<number>) : boolean
            public GetTypeCode () : System.TypeCode
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            public CompareTo ($obj: any) : number
            public ToBoolean ($provider: System.IFormatProvider) : boolean
            public ToChar ($provider: System.IFormatProvider) : number
            public ToSByte ($provider: System.IFormatProvider) : number
            public ToByte ($provider: System.IFormatProvider) : number
            public ToInt16 ($provider: System.IFormatProvider) : number
            public ToUInt16 ($provider: System.IFormatProvider) : number
            public ToInt32 ($provider: System.IFormatProvider) : number
            public ToUInt32 ($provider: System.IFormatProvider) : number
            public ToInt64 ($provider: System.IFormatProvider) : bigint
            public ToUInt64 ($provider: System.IFormatProvider) : bigint
            public ToSingle ($provider: System.IFormatProvider) : number
            public ToDouble ($provider: System.IFormatProvider) : number
            public ToDecimal ($provider: System.IFormatProvider) : System.Decimal
            public ToDateTime ($provider: System.IFormatProvider) : System.DateTime
            public ToType ($conversionType: System.Type, $provider: System.IFormatProvider) : any
            public static Equals ($objA: any, $objB: any) : boolean
        }
        class Int64 extends System.ValueType implements System.IFormattable, System.ISpanFormattable, System.IComparable, System.IComparable$1<bigint>, System.IConvertible, System.IEquatable$1<bigint>
        {
            protected [__keep_incompatibility]: never;
            public static MaxValue : bigint
            public static MinValue : bigint
            public CompareTo ($value: any) : number
            public CompareTo ($value: bigint) : number
            public Equals ($obj: any) : boolean
            public Equals ($obj: bigint) : boolean
            public ToString () : string
            public ToString ($provider: System.IFormatProvider) : string
            public ToString ($format: string) : string
            public ToString ($format: string, $provider: System.IFormatProvider) : string
            public static Parse ($s: string) : bigint
            public static Parse ($s: string, $style: System.Globalization.NumberStyles) : bigint
            public static Parse ($s: string, $provider: System.IFormatProvider) : bigint
            public static Parse ($s: string, $style: System.Globalization.NumberStyles, $provider: System.IFormatProvider) : bigint
            public static TryParse ($s: string, $result: $Ref<bigint>) : boolean
            public static TryParse ($s: string, $style: System.Globalization.NumberStyles, $provider: System.IFormatProvider, $result: $Ref<bigint>) : boolean
            public GetTypeCode () : System.TypeCode
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            public CompareTo ($obj: any) : number
            public ToBoolean ($provider: System.IFormatProvider) : boolean
            public ToChar ($provider: System.IFormatProvider) : number
            public ToSByte ($provider: System.IFormatProvider) : number
            public ToByte ($provider: System.IFormatProvider) : number
            public ToInt16 ($provider: System.IFormatProvider) : number
            public ToUInt16 ($provider: System.IFormatProvider) : number
            public ToInt32 ($provider: System.IFormatProvider) : number
            public ToUInt32 ($provider: System.IFormatProvider) : number
            public ToInt64 ($provider: System.IFormatProvider) : bigint
            public ToUInt64 ($provider: System.IFormatProvider) : bigint
            public ToSingle ($provider: System.IFormatProvider) : number
            public ToDouble ($provider: System.IFormatProvider) : number
            public ToDecimal ($provider: System.IFormatProvider) : System.Decimal
            public ToDateTime ($provider: System.IFormatProvider) : System.DateTime
            public ToType ($conversionType: System.Type, $provider: System.IFormatProvider) : any
            public static Equals ($objA: any, $objB: any) : boolean
        }
        class UInt16 extends System.ValueType implements System.IFormattable, System.ISpanFormattable, System.IComparable, System.IComparable$1<number>, System.IConvertible, System.IEquatable$1<number>
        {
            protected [__keep_incompatibility]: never;
            public static MaxValue : number
            public static MinValue : number
            public CompareTo ($value: any) : number
            public CompareTo ($value: number) : number
            public Equals ($obj: any) : boolean
            public Equals ($obj: number) : boolean
            public ToString () : string
            public ToString ($provider: System.IFormatProvider) : string
            public ToString ($format: string) : string
            public ToString ($format: string, $provider: System.IFormatProvider) : string
            public static Parse ($s: string) : number
            public static Parse ($s: string, $style: System.Globalization.NumberStyles) : number
            public static Parse ($s: string, $provider: System.IFormatProvider) : number
            public static Parse ($s: string, $style: System.Globalization.NumberStyles, $provider: System.IFormatProvider) : number
            public static TryParse ($s: string, $result: $Ref<number>) : boolean
            public static TryParse ($s: string, $style: System.Globalization.NumberStyles, $provider: System.IFormatProvider, $result: $Ref<number>) : boolean
            public GetTypeCode () : System.TypeCode
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            public CompareTo ($obj: any) : number
            public ToBoolean ($provider: System.IFormatProvider) : boolean
            public ToChar ($provider: System.IFormatProvider) : number
            public ToSByte ($provider: System.IFormatProvider) : number
            public ToByte ($provider: System.IFormatProvider) : number
            public ToInt16 ($provider: System.IFormatProvider) : number
            public ToUInt16 ($provider: System.IFormatProvider) : number
            public ToInt32 ($provider: System.IFormatProvider) : number
            public ToUInt32 ($provider: System.IFormatProvider) : number
            public ToInt64 ($provider: System.IFormatProvider) : bigint
            public ToUInt64 ($provider: System.IFormatProvider) : bigint
            public ToSingle ($provider: System.IFormatProvider) : number
            public ToDouble ($provider: System.IFormatProvider) : number
            public ToDecimal ($provider: System.IFormatProvider) : System.Decimal
            public ToDateTime ($provider: System.IFormatProvider) : System.DateTime
            public ToType ($conversionType: System.Type, $provider: System.IFormatProvider) : any
            public static Equals ($objA: any, $objB: any) : boolean
        }
        class UInt32 extends System.ValueType implements System.IFormattable, System.ISpanFormattable, System.IComparable, System.IComparable$1<number>, System.IConvertible, System.IEquatable$1<number>
        {
            protected [__keep_incompatibility]: never;
            public static MaxValue : number
            public static MinValue : number
            public CompareTo ($value: any) : number
            public CompareTo ($value: number) : number
            public Equals ($obj: any) : boolean
            public Equals ($obj: number) : boolean
            public ToString () : string
            public ToString ($provider: System.IFormatProvider) : string
            public ToString ($format: string) : string
            public ToString ($format: string, $provider: System.IFormatProvider) : string
            public static Parse ($s: string) : number
            public static Parse ($s: string, $style: System.Globalization.NumberStyles) : number
            public static Parse ($s: string, $provider: System.IFormatProvider) : number
            public static Parse ($s: string, $style: System.Globalization.NumberStyles, $provider: System.IFormatProvider) : number
            public static TryParse ($s: string, $result: $Ref<number>) : boolean
            public static TryParse ($s: string, $style: System.Globalization.NumberStyles, $provider: System.IFormatProvider, $result: $Ref<number>) : boolean
            public GetTypeCode () : System.TypeCode
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            public CompareTo ($obj: any) : number
            public ToBoolean ($provider: System.IFormatProvider) : boolean
            public ToChar ($provider: System.IFormatProvider) : number
            public ToSByte ($provider: System.IFormatProvider) : number
            public ToByte ($provider: System.IFormatProvider) : number
            public ToInt16 ($provider: System.IFormatProvider) : number
            public ToUInt16 ($provider: System.IFormatProvider) : number
            public ToInt32 ($provider: System.IFormatProvider) : number
            public ToUInt32 ($provider: System.IFormatProvider) : number
            public ToInt64 ($provider: System.IFormatProvider) : bigint
            public ToUInt64 ($provider: System.IFormatProvider) : bigint
            public ToSingle ($provider: System.IFormatProvider) : number
            public ToDouble ($provider: System.IFormatProvider) : number
            public ToDecimal ($provider: System.IFormatProvider) : System.Decimal
            public ToDateTime ($provider: System.IFormatProvider) : System.DateTime
            public ToType ($conversionType: System.Type, $provider: System.IFormatProvider) : any
            public static Equals ($objA: any, $objB: any) : boolean
        }
        class UInt64 extends System.ValueType implements System.IFormattable, System.ISpanFormattable, System.IComparable, System.IComparable$1<bigint>, System.IConvertible, System.IEquatable$1<bigint>
        {
            protected [__keep_incompatibility]: never;
            public static MaxValue : bigint
            public static MinValue : bigint
            public CompareTo ($value: any) : number
            public CompareTo ($value: bigint) : number
            public Equals ($obj: any) : boolean
            public Equals ($obj: bigint) : boolean
            public ToString () : string
            public ToString ($provider: System.IFormatProvider) : string
            public ToString ($format: string) : string
            public ToString ($format: string, $provider: System.IFormatProvider) : string
            public static Parse ($s: string) : bigint
            public static Parse ($s: string, $style: System.Globalization.NumberStyles) : bigint
            public static Parse ($s: string, $provider: System.IFormatProvider) : bigint
            public static Parse ($s: string, $style: System.Globalization.NumberStyles, $provider: System.IFormatProvider) : bigint
            public static TryParse ($s: string, $result: $Ref<bigint>) : boolean
            public static TryParse ($s: string, $style: System.Globalization.NumberStyles, $provider: System.IFormatProvider, $result: $Ref<bigint>) : boolean
            public GetTypeCode () : System.TypeCode
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            public CompareTo ($obj: any) : number
            public ToBoolean ($provider: System.IFormatProvider) : boolean
            public ToChar ($provider: System.IFormatProvider) : number
            public ToSByte ($provider: System.IFormatProvider) : number
            public ToByte ($provider: System.IFormatProvider) : number
            public ToInt16 ($provider: System.IFormatProvider) : number
            public ToUInt16 ($provider: System.IFormatProvider) : number
            public ToInt32 ($provider: System.IFormatProvider) : number
            public ToUInt32 ($provider: System.IFormatProvider) : number
            public ToInt64 ($provider: System.IFormatProvider) : bigint
            public ToUInt64 ($provider: System.IFormatProvider) : bigint
            public ToSingle ($provider: System.IFormatProvider) : number
            public ToDouble ($provider: System.IFormatProvider) : number
            public ToDecimal ($provider: System.IFormatProvider) : System.Decimal
            public ToDateTime ($provider: System.IFormatProvider) : System.DateTime
            public ToType ($conversionType: System.Type, $provider: System.IFormatProvider) : any
            public static Equals ($objA: any, $objB: any) : boolean
        }
        class Single extends System.ValueType implements System.IFormattable, System.ISpanFormattable, System.IComparable, System.IComparable$1<number>, System.IConvertible, System.IEquatable$1<number>
        {
            protected [__keep_incompatibility]: never;
            public static MinValue : number
            public static Epsilon : number
            public static MaxValue : number
            public static PositiveInfinity : number
            public static NegativeInfinity : number
            public static NaN : number
            public static IsFinite ($f: number) : boolean
            public static IsInfinity ($f: number) : boolean
            public static IsNaN ($f: number) : boolean
            public static IsNegative ($f: number) : boolean
            public static IsNegativeInfinity ($f: number) : boolean
            public static IsNormal ($f: number) : boolean
            public static IsPositiveInfinity ($f: number) : boolean
            public static IsSubnormal ($f: number) : boolean
            public CompareTo ($value: any) : number
            public CompareTo ($value: number) : number
            public static op_Equality ($left: number, $right: number) : boolean
            public static op_Inequality ($left: number, $right: number) : boolean
            public static op_LessThan ($left: number, $right: number) : boolean
            public static op_GreaterThan ($left: number, $right: number) : boolean
            public static op_LessThanOrEqual ($left: number, $right: number) : boolean
            public static op_GreaterThanOrEqual ($left: number, $right: number) : boolean
            public Equals ($obj: any) : boolean
            public Equals ($obj: number) : boolean
            public ToString () : string
            public ToString ($provider: System.IFormatProvider) : string
            public ToString ($format: string) : string
            public ToString ($format: string, $provider: System.IFormatProvider) : string
            public static Parse ($s: string) : number
            public static Parse ($s: string, $style: System.Globalization.NumberStyles) : number
            public static Parse ($s: string, $provider: System.IFormatProvider) : number
            public static Parse ($s: string, $style: System.Globalization.NumberStyles, $provider: System.IFormatProvider) : number
            public static TryParse ($s: string, $result: $Ref<number>) : boolean
            public static TryParse ($s: string, $style: System.Globalization.NumberStyles, $provider: System.IFormatProvider, $result: $Ref<number>) : boolean
            public GetTypeCode () : System.TypeCode
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            public CompareTo ($obj: any) : number
            public ToBoolean ($provider: System.IFormatProvider) : boolean
            public ToChar ($provider: System.IFormatProvider) : number
            public ToSByte ($provider: System.IFormatProvider) : number
            public ToByte ($provider: System.IFormatProvider) : number
            public ToInt16 ($provider: System.IFormatProvider) : number
            public ToUInt16 ($provider: System.IFormatProvider) : number
            public ToInt32 ($provider: System.IFormatProvider) : number
            public ToUInt32 ($provider: System.IFormatProvider) : number
            public ToInt64 ($provider: System.IFormatProvider) : bigint
            public ToUInt64 ($provider: System.IFormatProvider) : bigint
            public ToSingle ($provider: System.IFormatProvider) : number
            public ToDouble ($provider: System.IFormatProvider) : number
            public ToDecimal ($provider: System.IFormatProvider) : System.Decimal
            public ToDateTime ($provider: System.IFormatProvider) : System.DateTime
            public ToType ($conversionType: System.Type, $provider: System.IFormatProvider) : any
            public static Equals ($objA: any, $objB: any) : boolean
        }
        class Double extends System.ValueType implements System.IFormattable, System.ISpanFormattable, System.IComparable, System.IComparable$1<number>, System.IConvertible, System.IEquatable$1<number>
        {
            protected [__keep_incompatibility]: never;
            public static MinValue : number
            public static MaxValue : number
            public static Epsilon : number
            public static NegativeInfinity : number
            public static PositiveInfinity : number
            public static NaN : number
            public static IsFinite ($d: number) : boolean
            public static IsInfinity ($d: number) : boolean
            public static IsNaN ($d: number) : boolean
            public static IsNegative ($d: number) : boolean
            public static IsNegativeInfinity ($d: number) : boolean
            public static IsNormal ($d: number) : boolean
            public static IsPositiveInfinity ($d: number) : boolean
            public static IsSubnormal ($d: number) : boolean
            public CompareTo ($value: any) : number
            public CompareTo ($value: number) : number
            public Equals ($obj: any) : boolean
            public static op_Equality ($left: number, $right: number) : boolean
            public static op_Inequality ($left: number, $right: number) : boolean
            public static op_LessThan ($left: number, $right: number) : boolean
            public static op_GreaterThan ($left: number, $right: number) : boolean
            public static op_LessThanOrEqual ($left: number, $right: number) : boolean
            public static op_GreaterThanOrEqual ($left: number, $right: number) : boolean
            public Equals ($obj: number) : boolean
            public ToString () : string
            public ToString ($format: string) : string
            public ToString ($provider: System.IFormatProvider) : string
            public ToString ($format: string, $provider: System.IFormatProvider) : string
            public static Parse ($s: string) : number
            public static Parse ($s: string, $style: System.Globalization.NumberStyles) : number
            public static Parse ($s: string, $provider: System.IFormatProvider) : number
            public static Parse ($s: string, $style: System.Globalization.NumberStyles, $provider: System.IFormatProvider) : number
            public static TryParse ($s: string, $result: $Ref<number>) : boolean
            public static TryParse ($s: string, $style: System.Globalization.NumberStyles, $provider: System.IFormatProvider, $result: $Ref<number>) : boolean
            public GetTypeCode () : System.TypeCode
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            public CompareTo ($obj: any) : number
            public ToBoolean ($provider: System.IFormatProvider) : boolean
            public ToChar ($provider: System.IFormatProvider) : number
            public ToSByte ($provider: System.IFormatProvider) : number
            public ToByte ($provider: System.IFormatProvider) : number
            public ToInt16 ($provider: System.IFormatProvider) : number
            public ToUInt16 ($provider: System.IFormatProvider) : number
            public ToInt32 ($provider: System.IFormatProvider) : number
            public ToUInt32 ($provider: System.IFormatProvider) : number
            public ToInt64 ($provider: System.IFormatProvider) : bigint
            public ToUInt64 ($provider: System.IFormatProvider) : bigint
            public ToSingle ($provider: System.IFormatProvider) : number
            public ToDouble ($provider: System.IFormatProvider) : number
            public ToDecimal ($provider: System.IFormatProvider) : System.Decimal
            public ToDateTime ($provider: System.IFormatProvider) : System.DateTime
            public ToType ($conversionType: System.Type, $provider: System.IFormatProvider) : any
            public static Equals ($objA: any, $objB: any) : boolean
        }
        class CLSCompliantAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get IsCompliant(): boolean;
            public constructor ($isCompliant: boolean)
            public constructor ()
        }
        class Convert extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static DBNull : any
            public static GetTypeCode ($value: any) : System.TypeCode
            public static IsDBNull ($value: any) : boolean
            public static ChangeType ($value: any, $typeCode: System.TypeCode) : any
            public static ChangeType ($value: any, $typeCode: System.TypeCode, $provider: System.IFormatProvider) : any
            public static ChangeType ($value: any, $conversionType: System.Type) : any
            public static ChangeType ($value: any, $conversionType: System.Type, $provider: System.IFormatProvider) : any
            public static ToBoolean ($value: any) : boolean
            public static ToBoolean ($value: any, $provider: System.IFormatProvider) : boolean
            public static ToBoolean ($value: boolean) : boolean
            public static ToBoolean ($value: number) : boolean
            public static ToBoolean ($value: bigint) : boolean
            public static ToBoolean ($value: string) : boolean
            public static ToBoolean ($value: string, $provider: System.IFormatProvider) : boolean
            public static ToBoolean ($value: System.Decimal) : boolean
            public static ToBoolean ($value: System.DateTime) : boolean
            public static ToChar ($value: any) : number
            public static ToChar ($value: any, $provider: System.IFormatProvider) : number
            public static ToChar ($value: boolean) : number
            public static ToChar ($value: number) : number
            public static ToChar ($value: bigint) : number
            public static ToChar ($value: string) : number
            public static ToChar ($value: string, $provider: System.IFormatProvider) : number
            public static ToChar ($value: System.Decimal) : number
            public static ToChar ($value: System.DateTime) : number
            public static ToSByte ($value: any) : number
            public static ToSByte ($value: any, $provider: System.IFormatProvider) : number
            public static ToSByte ($value: boolean) : number
            public static ToSByte ($value: number) : number
            public static ToSByte ($value: bigint) : number
            public static ToSByte ($value: System.Decimal) : number
            public static ToSByte ($value: string) : number
            public static ToSByte ($value: string, $provider: System.IFormatProvider) : number
            public static ToSByte ($value: System.DateTime) : number
            public static ToByte ($value: any) : number
            public static ToByte ($value: any, $provider: System.IFormatProvider) : number
            public static ToByte ($value: boolean) : number
            public static ToByte ($value: number) : number
            public static ToByte ($value: bigint) : number
            public static ToByte ($value: System.Decimal) : number
            public static ToByte ($value: string) : number
            public static ToByte ($value: string, $provider: System.IFormatProvider) : number
            public static ToByte ($value: System.DateTime) : number
            public static ToInt16 ($value: any) : number
            public static ToInt16 ($value: any, $provider: System.IFormatProvider) : number
            public static ToInt16 ($value: boolean) : number
            public static ToInt16 ($value: number) : number
            public static ToInt16 ($value: bigint) : number
            public static ToInt16 ($value: System.Decimal) : number
            public static ToInt16 ($value: string) : number
            public static ToInt16 ($value: string, $provider: System.IFormatProvider) : number
            public static ToInt16 ($value: System.DateTime) : number
            public static ToUInt16 ($value: any) : number
            public static ToUInt16 ($value: any, $provider: System.IFormatProvider) : number
            public static ToUInt16 ($value: boolean) : number
            public static ToUInt16 ($value: number) : number
            public static ToUInt16 ($value: bigint) : number
            public static ToUInt16 ($value: System.Decimal) : number
            public static ToUInt16 ($value: string) : number
            public static ToUInt16 ($value: string, $provider: System.IFormatProvider) : number
            public static ToUInt16 ($value: System.DateTime) : number
            public static ToInt32 ($value: any) : number
            public static ToInt32 ($value: any, $provider: System.IFormatProvider) : number
            public static ToInt32 ($value: boolean) : number
            public static ToInt32 ($value: number) : number
            public static ToInt32 ($value: bigint) : number
            public static ToInt32 ($value: System.Decimal) : number
            public static ToInt32 ($value: string) : number
            public static ToInt32 ($value: string, $provider: System.IFormatProvider) : number
            public static ToInt32 ($value: System.DateTime) : number
            public static ToUInt32 ($value: any) : number
            public static ToUInt32 ($value: any, $provider: System.IFormatProvider) : number
            public static ToUInt32 ($value: boolean) : number
            public static ToUInt32 ($value: number) : number
            public static ToUInt32 ($value: bigint) : number
            public static ToUInt32 ($value: System.Decimal) : number
            public static ToUInt32 ($value: string) : number
            public static ToUInt32 ($value: string, $provider: System.IFormatProvider) : number
            public static ToUInt32 ($value: System.DateTime) : number
            public static ToInt64 ($value: any) : bigint
            public static ToInt64 ($value: any, $provider: System.IFormatProvider) : bigint
            public static ToInt64 ($value: boolean) : bigint
            public static ToInt64 ($value: number) : bigint
            public static ToInt64 ($value: bigint) : bigint
            public static ToInt64 ($value: System.Decimal) : bigint
            public static ToInt64 ($value: string) : bigint
            public static ToInt64 ($value: string, $provider: System.IFormatProvider) : bigint
            public static ToInt64 ($value: System.DateTime) : bigint
            public static ToUInt64 ($value: any) : bigint
            public static ToUInt64 ($value: any, $provider: System.IFormatProvider) : bigint
            public static ToUInt64 ($value: boolean) : bigint
            public static ToUInt64 ($value: number) : bigint
            public static ToUInt64 ($value: bigint) : bigint
            public static ToUInt64 ($value: System.Decimal) : bigint
            public static ToUInt64 ($value: string) : bigint
            public static ToUInt64 ($value: string, $provider: System.IFormatProvider) : bigint
            public static ToUInt64 ($value: System.DateTime) : bigint
            public static ToSingle ($value: any) : number
            public static ToSingle ($value: any, $provider: System.IFormatProvider) : number
            public static ToSingle ($value: number) : number
            public static ToSingle ($value: bigint) : number
            public static ToSingle ($value: System.Decimal) : number
            public static ToSingle ($value: string) : number
            public static ToSingle ($value: string, $provider: System.IFormatProvider) : number
            public static ToSingle ($value: boolean) : number
            public static ToSingle ($value: System.DateTime) : number
            public static ToDouble ($value: any) : number
            public static ToDouble ($value: any, $provider: System.IFormatProvider) : number
            public static ToDouble ($value: number) : number
            public static ToDouble ($value: bigint) : number
            public static ToDouble ($value: System.Decimal) : number
            public static ToDouble ($value: string) : number
            public static ToDouble ($value: string, $provider: System.IFormatProvider) : number
            public static ToDouble ($value: boolean) : number
            public static ToDouble ($value: System.DateTime) : number
            public static ToDecimal ($value: any) : System.Decimal
            public static ToDecimal ($value: any, $provider: System.IFormatProvider) : System.Decimal
            public static ToDecimal ($value: number) : System.Decimal
            public static ToDecimal ($value: bigint) : System.Decimal
            public static ToDecimal ($value: string) : System.Decimal
            public static ToDecimal ($value: string, $provider: System.IFormatProvider) : System.Decimal
            public static ToDecimal ($value: System.Decimal) : System.Decimal
            public static ToDecimal ($value: boolean) : System.Decimal
            public static ToDecimal ($value: System.DateTime) : System.Decimal
            public static ToDateTime ($value: System.DateTime) : System.DateTime
            public static ToDateTime ($value: any) : System.DateTime
            public static ToDateTime ($value: any, $provider: System.IFormatProvider) : System.DateTime
            public static ToDateTime ($value: string) : System.DateTime
            public static ToDateTime ($value: string, $provider: System.IFormatProvider) : System.DateTime
            public static ToDateTime ($value: number) : System.DateTime
            public static ToDateTime ($value: bigint) : System.DateTime
            public static ToDateTime ($value: boolean) : System.DateTime
            public static ToDateTime ($value: System.Decimal) : System.DateTime
            public static ToString ($value: any) : string
            public static ToString ($value: any, $provider: System.IFormatProvider) : string
            public static ToString ($value: boolean) : string
            public static ToString ($value: boolean, $provider: System.IFormatProvider) : string
            public static ToString ($value: number) : string
            public static ToString ($value: number, $provider: System.IFormatProvider) : string
            public static ToString ($value: bigint) : string
            public static ToString ($value: bigint, $provider: System.IFormatProvider) : string
            public static ToString ($value: System.Decimal) : string
            public static ToString ($value: System.Decimal, $provider: System.IFormatProvider) : string
            public static ToString ($value: System.DateTime) : string
            public static ToString ($value: System.DateTime, $provider: System.IFormatProvider) : string
            public static ToString ($value: string) : string
            public static ToString ($value: string, $provider: System.IFormatProvider) : string
            public static ToByte ($value: string, $fromBase: number) : number
            public static ToSByte ($value: string, $fromBase: number) : number
            public static ToInt16 ($value: string, $fromBase: number) : number
            public static ToUInt16 ($value: string, $fromBase: number) : number
            public static ToInt32 ($value: string, $fromBase: number) : number
            public static ToUInt32 ($value: string, $fromBase: number) : number
            public static ToInt64 ($value: string, $fromBase: number) : bigint
            public static ToUInt64 ($value: string, $fromBase: number) : bigint
            public static ToString ($value: number, $toBase: number) : string
            public static ToString ($value: bigint, $toBase: number) : string
            public static ToBase64String ($inArray: System.Array$1<number>) : string
            public static ToBase64String ($inArray: System.Array$1<number>, $options: System.Base64FormattingOptions) : string
            public static ToBase64String ($inArray: System.Array$1<number>, $offset: number, $length: number) : string
            public static ToBase64String ($inArray: System.Array$1<number>, $offset: number, $length: number, $options: System.Base64FormattingOptions) : string
            public static ToBase64CharArray ($inArray: System.Array$1<number>, $offsetIn: number, $length: number, $outArray: System.Array$1<number>, $offsetOut: number) : number
            public static ToBase64CharArray ($inArray: System.Array$1<number>, $offsetIn: number, $length: number, $outArray: System.Array$1<number>, $offsetOut: number, $options: System.Base64FormattingOptions) : number
            public static FromBase64String ($s: string) : System.Array$1<number>
            public static FromBase64CharArray ($inArray: System.Array$1<number>, $offset: number, $length: number) : System.Array$1<number>
            public ToString () : string
        }
        class Type extends System.Reflection.MemberInfo implements System.Runtime.InteropServices._MemberInfo, System.Runtime.InteropServices._Type, System.Reflection.ICustomAttributeProvider, System.Reflection.IReflect
        {
            protected [__keep_incompatibility]: never;
            public static Delimiter : number
            public static EmptyTypes : System.Array$1<System.Type>
            public static Missing : any
            public static FilterAttribute : System.Reflection.MemberFilter
            public static FilterName : System.Reflection.MemberFilter
            public static FilterNameIgnoreCase : System.Reflection.MemberFilter
            public get IsSerializable(): boolean;
            public get ContainsGenericParameters(): boolean;
            public get IsVisible(): boolean;
            public get MemberType(): System.Reflection.MemberTypes;
            public get Namespace(): string;
            public get AssemblyQualifiedName(): string;
            public get FullName(): string;
            public get Assembly(): System.Reflection.Assembly;
            public get Module(): System.Reflection.Module;
            public get IsNested(): boolean;
            public get DeclaringType(): System.Type;
            public get DeclaringMethod(): System.Reflection.MethodBase;
            public get ReflectedType(): System.Type;
            public get UnderlyingSystemType(): System.Type;
            public get IsTypeDefinition(): boolean;
            public get IsArray(): boolean;
            public get IsByRef(): boolean;
            public get IsPointer(): boolean;
            public get IsConstructedGenericType(): boolean;
            public get IsGenericParameter(): boolean;
            public get IsGenericTypeParameter(): boolean;
            public get IsGenericMethodParameter(): boolean;
            public get IsGenericType(): boolean;
            public get IsGenericTypeDefinition(): boolean;
            public get IsSZArray(): boolean;
            public get IsVariableBoundArray(): boolean;
            public get IsByRefLike(): boolean;
            public get HasElementType(): boolean;
            public get GenericTypeArguments(): System.Array$1<System.Type>;
            public get GenericParameterPosition(): number;
            public get GenericParameterAttributes(): System.Reflection.GenericParameterAttributes;
            public get Attributes(): System.Reflection.TypeAttributes;
            public get IsAbstract(): boolean;
            public get IsImport(): boolean;
            public get IsSealed(): boolean;
            public get IsSpecialName(): boolean;
            public get IsClass(): boolean;
            public get IsNestedAssembly(): boolean;
            public get IsNestedFamANDAssem(): boolean;
            public get IsNestedFamily(): boolean;
            public get IsNestedFamORAssem(): boolean;
            public get IsNestedPrivate(): boolean;
            public get IsNestedPublic(): boolean;
            public get IsNotPublic(): boolean;
            public get IsPublic(): boolean;
            public get IsAutoLayout(): boolean;
            public get IsExplicitLayout(): boolean;
            public get IsLayoutSequential(): boolean;
            public get IsAnsiClass(): boolean;
            public get IsAutoClass(): boolean;
            public get IsUnicodeClass(): boolean;
            public get IsCOMObject(): boolean;
            public get IsContextful(): boolean;
            public get IsCollectible(): boolean;
            public get IsEnum(): boolean;
            public get IsMarshalByRef(): boolean;
            public get IsPrimitive(): boolean;
            public get IsValueType(): boolean;
            public get IsSignatureType(): boolean;
            public get IsSecurityCritical(): boolean;
            public get IsSecuritySafeCritical(): boolean;
            public get IsSecurityTransparent(): boolean;
            public get StructLayoutAttribute(): System.Runtime.InteropServices.StructLayoutAttribute;
            public get TypeInitializer(): System.Reflection.ConstructorInfo;
            public get TypeHandle(): System.RuntimeTypeHandle;
            public get GUID(): System.Guid;
            public get BaseType(): System.Type;
            public static get DefaultBinder(): System.Reflection.Binder;
            public get IsInterface(): boolean;
            public IsEnumDefined ($value: any) : boolean
            public GetEnumName ($value: any) : string
            public GetEnumNames () : System.Array$1<string>
            public FindInterfaces ($filter: System.Reflection.TypeFilter, $filterCriteria: any) : System.Array$1<System.Type>
            public FindMembers ($memberType: System.Reflection.MemberTypes, $bindingAttr: System.Reflection.BindingFlags, $filter: System.Reflection.MemberFilter, $filterCriteria: any) : System.Array$1<System.Reflection.MemberInfo>
            public IsSubclassOf ($c: System.Type) : boolean
            public IsAssignableFrom ($c: System.Type) : boolean
            public GetType () : System.Type
            public GetElementType () : System.Type
            public GetArrayRank () : number
            public GetGenericTypeDefinition () : System.Type
            public GetGenericArguments () : System.Array$1<System.Type>
            public GetGenericParameterConstraints () : System.Array$1<System.Type>
            public GetConstructor ($types: System.Array$1<System.Type>) : System.Reflection.ConstructorInfo
            public GetConstructor ($bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>) : System.Reflection.ConstructorInfo
            public GetConstructor ($bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $callConvention: System.Reflection.CallingConventions, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>) : System.Reflection.ConstructorInfo
            public GetConstructors () : System.Array$1<System.Reflection.ConstructorInfo>
            public GetConstructors ($bindingAttr: System.Reflection.BindingFlags) : System.Array$1<System.Reflection.ConstructorInfo>
            public GetEvent ($name: string) : System.Reflection.EventInfo
            public GetEvent ($name: string, $bindingAttr: System.Reflection.BindingFlags) : System.Reflection.EventInfo
            public GetEvents () : System.Array$1<System.Reflection.EventInfo>
            public GetEvents ($bindingAttr: System.Reflection.BindingFlags) : System.Array$1<System.Reflection.EventInfo>
            public GetField ($name: string) : System.Reflection.FieldInfo
            public GetField ($name: string, $bindingAttr: System.Reflection.BindingFlags) : System.Reflection.FieldInfo
            public GetFields () : System.Array$1<System.Reflection.FieldInfo>
            public GetFields ($bindingAttr: System.Reflection.BindingFlags) : System.Array$1<System.Reflection.FieldInfo>
            public GetMember ($name: string) : System.Array$1<System.Reflection.MemberInfo>
            public GetMember ($name: string, $bindingAttr: System.Reflection.BindingFlags) : System.Array$1<System.Reflection.MemberInfo>
            public GetMember ($name: string, $type: System.Reflection.MemberTypes, $bindingAttr: System.Reflection.BindingFlags) : System.Array$1<System.Reflection.MemberInfo>
            public GetMembers () : System.Array$1<System.Reflection.MemberInfo>
            public GetMembers ($bindingAttr: System.Reflection.BindingFlags) : System.Array$1<System.Reflection.MemberInfo>
            public GetMethod ($name: string) : System.Reflection.MethodInfo
            public GetMethod ($name: string, $bindingAttr: System.Reflection.BindingFlags) : System.Reflection.MethodInfo
            public GetMethod ($name: string, $types: System.Array$1<System.Type>) : System.Reflection.MethodInfo
            public GetMethod ($name: string, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>) : System.Reflection.MethodInfo
            public GetMethod ($name: string, $bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>) : System.Reflection.MethodInfo
            public GetMethod ($name: string, $bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $callConvention: System.Reflection.CallingConventions, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>) : System.Reflection.MethodInfo
            public GetMethod ($name: string, $genericParameterCount: number, $types: System.Array$1<System.Type>) : System.Reflection.MethodInfo
            public GetMethod ($name: string, $genericParameterCount: number, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>) : System.Reflection.MethodInfo
            public GetMethod ($name: string, $genericParameterCount: number, $bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>) : System.Reflection.MethodInfo
            public GetMethod ($name: string, $genericParameterCount: number, $bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $callConvention: System.Reflection.CallingConventions, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>) : System.Reflection.MethodInfo
            public GetMethods () : System.Array$1<System.Reflection.MethodInfo>
            public GetMethods ($bindingAttr: System.Reflection.BindingFlags) : System.Array$1<System.Reflection.MethodInfo>
            public GetNestedType ($name: string) : System.Type
            public GetNestedType ($name: string, $bindingAttr: System.Reflection.BindingFlags) : System.Type
            public GetNestedTypes () : System.Array$1<System.Type>
            public GetNestedTypes ($bindingAttr: System.Reflection.BindingFlags) : System.Array$1<System.Type>
            public GetProperty ($name: string) : System.Reflection.PropertyInfo
            public GetProperty ($name: string, $bindingAttr: System.Reflection.BindingFlags) : System.Reflection.PropertyInfo
            public GetProperty ($name: string, $returnType: System.Type) : System.Reflection.PropertyInfo
            public GetProperty ($name: string, $types: System.Array$1<System.Type>) : System.Reflection.PropertyInfo
            public GetProperty ($name: string, $returnType: System.Type, $types: System.Array$1<System.Type>) : System.Reflection.PropertyInfo
            public GetProperty ($name: string, $returnType: System.Type, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>) : System.Reflection.PropertyInfo
            public GetProperty ($name: string, $bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $returnType: System.Type, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>) : System.Reflection.PropertyInfo
            public GetProperties () : System.Array$1<System.Reflection.PropertyInfo>
            public GetProperties ($bindingAttr: System.Reflection.BindingFlags) : System.Array$1<System.Reflection.PropertyInfo>
            public GetDefaultMembers () : System.Array$1<System.Reflection.MemberInfo>
            public static GetTypeHandle ($o: any) : System.RuntimeTypeHandle
            public static GetTypeArray ($args: System.Array$1<any>) : System.Array$1<System.Type>
            public static GetTypeCode ($type: System.Type) : System.TypeCode
            public static GetTypeFromCLSID ($clsid: System.Guid) : System.Type
            public static GetTypeFromCLSID ($clsid: System.Guid, $throwOnError: boolean) : System.Type
            public static GetTypeFromCLSID ($clsid: System.Guid, $server: string) : System.Type
            public static GetTypeFromProgID ($progID: string) : System.Type
            public static GetTypeFromProgID ($progID: string, $throwOnError: boolean) : System.Type
            public static GetTypeFromProgID ($progID: string, $server: string) : System.Type
            public InvokeMember ($name: string, $invokeAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $target: any, $args: System.Array$1<any>) : any
            public InvokeMember ($name: string, $invokeAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $target: any, $args: System.Array$1<any>, $culture: System.Globalization.CultureInfo) : any
            public InvokeMember ($name: string, $invokeAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $target: any, $args: System.Array$1<any>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>, $culture: System.Globalization.CultureInfo, $namedParameters: System.Array$1<string>) : any
            public GetInterface ($name: string) : System.Type
            public GetInterface ($name: string, $ignoreCase: boolean) : System.Type
            public GetInterfaces () : System.Array$1<System.Type>
            public GetInterfaceMap ($interfaceType: System.Type) : System.Reflection.InterfaceMapping
            public IsInstanceOfType ($o: any) : boolean
            public IsEquivalentTo ($other: System.Type) : boolean
            public GetEnumUnderlyingType () : System.Type
            public GetEnumValues () : System.Array
            public MakeArrayType () : System.Type
            public MakeArrayType ($rank: number) : System.Type
            public MakeByRefType () : System.Type
            public MakeGenericType (...typeArguments: System.Type[]) : System.Type
            public MakePointerType () : System.Type
            public static MakeGenericSignatureType ($genericTypeDefinition: System.Type, ...typeArguments: System.Type[]) : System.Type
            public static MakeGenericMethodParameter ($position: number) : System.Type
            public Equals ($o: any) : boolean
            public Equals ($o: System.Type) : boolean
            public static GetTypeFromHandle ($handle: System.RuntimeTypeHandle) : System.Type
            public static GetType ($typeName: string, $throwOnError: boolean, $ignoreCase: boolean) : System.Type
            public static GetType ($typeName: string, $throwOnError: boolean) : System.Type
            public static GetType ($typeName: string) : System.Type
            public static GetType ($typeName: string, $assemblyResolver: System.Func$2<System.Reflection.AssemblyName, System.Reflection.Assembly>, $typeResolver: System.Func$4<System.Reflection.Assembly, string, boolean, System.Type>) : System.Type
            public static GetType ($typeName: string, $assemblyResolver: System.Func$2<System.Reflection.AssemblyName, System.Reflection.Assembly>, $typeResolver: System.Func$4<System.Reflection.Assembly, string, boolean, System.Type>, $throwOnError: boolean) : System.Type
            public static GetType ($typeName: string, $assemblyResolver: System.Func$2<System.Reflection.AssemblyName, System.Reflection.Assembly>, $typeResolver: System.Func$4<System.Reflection.Assembly, string, boolean, System.Type>, $throwOnError: boolean, $ignoreCase: boolean) : System.Type
            public static op_Equality ($left: System.Type, $right: System.Type) : boolean
            public static op_Inequality ($left: System.Type, $right: System.Type) : boolean
            public static ReflectionOnlyGetType ($typeName: string, $throwIfNotFound: boolean, $ignoreCase: boolean) : System.Type
            public static GetTypeFromCLSID ($clsid: System.Guid, $server: string, $throwOnError: boolean) : System.Type
            public static GetTypeFromProgID ($progID: string, $server: string, $throwOnError: boolean) : System.Type
            public static op_Equality ($left: System.Reflection.MemberInfo, $right: System.Reflection.MemberInfo) : boolean
            public static op_Inequality ($left: System.Reflection.MemberInfo, $right: System.Reflection.MemberInfo) : boolean
            public Equals ($other: any) : boolean
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
        }
        interface Type {
            GetTypeInfo () : System.Reflection.TypeInfo;
            GetRuntimeFields () : System.Collections.Generic.IEnumerable$1<System.Reflection.FieldInfo>;
            GetRuntimeMethods () : System.Collections.Generic.IEnumerable$1<System.Reflection.MethodInfo>;
            GetRuntimeProperties () : System.Collections.Generic.IEnumerable$1<System.Reflection.PropertyInfo>;
            GetRuntimeEvents () : System.Collections.Generic.IEnumerable$1<System.Reflection.EventInfo>;
            GetRuntimeField ($name: string) : System.Reflection.FieldInfo;
            GetRuntimeMethod ($name: string, $parameters: System.Array$1<System.Type>) : System.Reflection.MethodInfo;
            GetRuntimeProperty ($name: string) : System.Reflection.PropertyInfo;
            GetRuntimeEvent ($name: string) : System.Reflection.EventInfo;
        }
        class SByte extends System.ValueType implements System.IFormattable, System.ISpanFormattable, System.IComparable, System.IComparable$1<number>, System.IConvertible, System.IEquatable$1<number>
        {
            protected [__keep_incompatibility]: never;
            public static MaxValue : number
            public static MinValue : number
            public CompareTo ($obj: any) : number
            public CompareTo ($value: number) : number
            public Equals ($obj: any) : boolean
            public Equals ($obj: number) : boolean
            public ToString () : string
            public ToString ($provider: System.IFormatProvider) : string
            public ToString ($format: string) : string
            public ToString ($format: string, $provider: System.IFormatProvider) : string
            public static Parse ($s: string) : number
            public static Parse ($s: string, $style: System.Globalization.NumberStyles) : number
            public static Parse ($s: string, $provider: System.IFormatProvider) : number
            public static Parse ($s: string, $style: System.Globalization.NumberStyles, $provider: System.IFormatProvider) : number
            public static TryParse ($s: string, $result: $Ref<number>) : boolean
            public static TryParse ($s: string, $style: System.Globalization.NumberStyles, $provider: System.IFormatProvider, $result: $Ref<number>) : boolean
            public GetTypeCode () : System.TypeCode
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            public ToBoolean ($provider: System.IFormatProvider) : boolean
            public ToChar ($provider: System.IFormatProvider) : number
            public ToSByte ($provider: System.IFormatProvider) : number
            public ToByte ($provider: System.IFormatProvider) : number
            public ToInt16 ($provider: System.IFormatProvider) : number
            public ToUInt16 ($provider: System.IFormatProvider) : number
            public ToInt32 ($provider: System.IFormatProvider) : number
            public ToUInt32 ($provider: System.IFormatProvider) : number
            public ToInt64 ($provider: System.IFormatProvider) : bigint
            public ToUInt64 ($provider: System.IFormatProvider) : bigint
            public ToSingle ($provider: System.IFormatProvider) : number
            public ToDouble ($provider: System.IFormatProvider) : number
            public ToDecimal ($provider: System.IFormatProvider) : System.Decimal
            public ToDateTime ($provider: System.IFormatProvider) : System.DateTime
            public ToType ($conversionType: System.Type, $provider: System.IFormatProvider) : any
            public static Equals ($objA: any, $objB: any) : boolean
        }
        class Decimal extends System.ValueType implements System.Runtime.Serialization.IDeserializationCallback, System.IFormattable, System.ISpanFormattable, System.IComparable, System.IComparable$1<System.Decimal>, System.IConvertible, System.IEquatable$1<System.Decimal>
        {
            protected [__keep_incompatibility]: never;
            public static Zero : System.Decimal
            public static One : System.Decimal
            public static MinusOne : System.Decimal
            public static MaxValue : System.Decimal
            public static MinValue : System.Decimal
            public static FromOACurrency ($cy: bigint) : System.Decimal
            public static ToOACurrency ($value: System.Decimal) : bigint
            public static Add ($d1: System.Decimal, $d2: System.Decimal) : System.Decimal
            public static Ceiling ($d: System.Decimal) : System.Decimal
            public static Compare ($d1: System.Decimal, $d2: System.Decimal) : number
            public CompareTo ($value: any) : number
            public CompareTo ($value: System.Decimal) : number
            public static Divide ($d1: System.Decimal, $d2: System.Decimal) : System.Decimal
            public Equals ($value: any) : boolean
            public Equals ($value: System.Decimal) : boolean
            public static Equals ($d1: System.Decimal, $d2: System.Decimal) : boolean
            public static Floor ($d: System.Decimal) : System.Decimal
            public ToString () : string
            public ToString ($format: string) : string
            public ToString ($provider: System.IFormatProvider) : string
            public ToString ($format: string, $provider: System.IFormatProvider) : string
            public static Parse ($s: string) : System.Decimal
            public static Parse ($s: string, $style: System.Globalization.NumberStyles) : System.Decimal
            public static Parse ($s: string, $provider: System.IFormatProvider) : System.Decimal
            public static Parse ($s: string, $style: System.Globalization.NumberStyles, $provider: System.IFormatProvider) : System.Decimal
            public static TryParse ($s: string, $result: $Ref<System.Decimal>) : boolean
            public static TryParse ($s: string, $style: System.Globalization.NumberStyles, $provider: System.IFormatProvider, $result: $Ref<System.Decimal>) : boolean
            public static GetBits ($d: System.Decimal) : System.Array$1<number>
            public static Remainder ($d1: System.Decimal, $d2: System.Decimal) : System.Decimal
            public static Multiply ($d1: System.Decimal, $d2: System.Decimal) : System.Decimal
            public static Negate ($d: System.Decimal) : System.Decimal
            public static Round ($d: System.Decimal) : System.Decimal
            public static Round ($d: System.Decimal, $decimals: number) : System.Decimal
            public static Round ($d: System.Decimal, $mode: System.MidpointRounding) : System.Decimal
            public static Round ($d: System.Decimal, $decimals: number, $mode: System.MidpointRounding) : System.Decimal
            public static Subtract ($d1: System.Decimal, $d2: System.Decimal) : System.Decimal
            public static ToByte ($value: System.Decimal) : number
            public static ToSByte ($value: System.Decimal) : number
            public static ToInt16 ($value: System.Decimal) : number
            public static ToDouble ($d: System.Decimal) : number
            public static ToInt32 ($d: System.Decimal) : number
            public static ToInt64 ($d: System.Decimal) : bigint
            public static ToUInt16 ($value: System.Decimal) : number
            public static ToUInt32 ($d: System.Decimal) : number
            public static ToUInt64 ($d: System.Decimal) : bigint
            public static ToSingle ($d: System.Decimal) : number
            public static Truncate ($d: System.Decimal) : System.Decimal
            public static op_Implicit ($value: number) : System.Decimal
            public static op_Implicit ($value: bigint) : System.Decimal
            public static op_Explicit ($value: number) : System.Decimal
            public static op_Explicit ($value: System.Decimal) : number
            public static op_Explicit ($value: System.Decimal) : bigint
            public static op_UnaryPlus ($d: System.Decimal) : System.Decimal
            public static op_UnaryNegation ($d: System.Decimal) : System.Decimal
            public static op_Increment ($d: System.Decimal) : System.Decimal
            public static op_Decrement ($d: System.Decimal) : System.Decimal
            public static op_Addition ($d1: System.Decimal, $d2: System.Decimal) : System.Decimal
            public static op_Subtraction ($d1: System.Decimal, $d2: System.Decimal) : System.Decimal
            public static op_Multiply ($d1: System.Decimal, $d2: System.Decimal) : System.Decimal
            public static op_Division ($d1: System.Decimal, $d2: System.Decimal) : System.Decimal
            public static op_Modulus ($d1: System.Decimal, $d2: System.Decimal) : System.Decimal
            public static op_Equality ($d1: System.Decimal, $d2: System.Decimal) : boolean
            public static op_Inequality ($d1: System.Decimal, $d2: System.Decimal) : boolean
            public static op_LessThan ($d1: System.Decimal, $d2: System.Decimal) : boolean
            public static op_LessThanOrEqual ($d1: System.Decimal, $d2: System.Decimal) : boolean
            public static op_GreaterThan ($d1: System.Decimal, $d2: System.Decimal) : boolean
            public static op_GreaterThanOrEqual ($d1: System.Decimal, $d2: System.Decimal) : boolean
            public GetTypeCode () : System.TypeCode
            public constructor ($value: number)
            public constructor ($value: bigint)
            public constructor ($bits: System.Array$1<number>)
            public constructor ($lo: number, $mid: number, $hi: number, $isNegative: boolean, $scale: number)
            public OnDeserialization ($sender: any) : void
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            public CompareTo ($obj: any) : number
            public ToBoolean ($provider: System.IFormatProvider) : boolean
            public ToChar ($provider: System.IFormatProvider) : number
            public ToSByte ($provider: System.IFormatProvider) : number
            public ToByte ($provider: System.IFormatProvider) : number
            public ToInt16 ($provider: System.IFormatProvider) : number
            public ToUInt16 ($provider: System.IFormatProvider) : number
            public ToInt32 ($provider: System.IFormatProvider) : number
            public ToUInt32 ($provider: System.IFormatProvider) : number
            public ToInt64 ($provider: System.IFormatProvider) : bigint
            public ToUInt64 ($provider: System.IFormatProvider) : bigint
            public ToSingle ($provider: System.IFormatProvider) : number
            public ToDouble ($provider: System.IFormatProvider) : number
            public ToDecimal ($provider: System.IFormatProvider) : System.Decimal
            public ToDateTime ($provider: System.IFormatProvider) : System.DateTime
            public ToType ($conversionType: System.Type, $provider: System.IFormatProvider) : any
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
            public constructor ()
        }
        enum Base64FormattingOptions
        { None = 0, InsertLineBreaks = 1 }
        class DBNull extends System.Object implements System.Runtime.Serialization.ISerializable, System.IConvertible
        {
            protected [__keep_incompatibility]: never;
            public static Value : System.DBNull
            public GetObjectData ($info: System.Runtime.Serialization.SerializationInfo, $context: System.Runtime.Serialization.StreamingContext) : void
            public ToString () : string
            public ToString ($provider: System.IFormatProvider) : string
            public GetTypeCode () : System.TypeCode
            public ToBoolean ($provider: System.IFormatProvider) : boolean
            public ToChar ($provider: System.IFormatProvider) : number
            public ToSByte ($provider: System.IFormatProvider) : number
            public ToByte ($provider: System.IFormatProvider) : number
            public ToInt16 ($provider: System.IFormatProvider) : number
            public ToUInt16 ($provider: System.IFormatProvider) : number
            public ToInt32 ($provider: System.IFormatProvider) : number
            public ToUInt32 ($provider: System.IFormatProvider) : number
            public ToInt64 ($provider: System.IFormatProvider) : bigint
            public ToUInt64 ($provider: System.IFormatProvider) : bigint
            public ToSingle ($provider: System.IFormatProvider) : number
            public ToDouble ($provider: System.IFormatProvider) : number
            public ToDecimal ($provider: System.IFormatProvider) : System.Decimal
            public ToDateTime ($provider: System.IFormatProvider) : System.DateTime
            public ToType ($conversionType: System.Type, $provider: System.IFormatProvider) : any
        }
        class DataMisalignedException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        enum DateTimeKind
        { Unspecified = 0, Utc = 1, Local = 2 }
        class DivideByZeroException extends System.ArithmeticException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class TypeLoadException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public get Message(): string;
            public get TypeName(): string;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $inner: System.Exception)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class DllNotFoundException extends System.TypeLoadException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $inner: System.Exception)
        }
        class DuplicateWaitObjectException extends System.ArgumentException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($parameterName: string)
            public constructor ($parameterName: string, $message: string)
            public constructor ($message: string, $innerException: System.Exception)
            public constructor ($message: string)
            public constructor ($message: string, $paramName: string, $innerException: System.Exception)
            public constructor ($message: string, $paramName: string)
        }
        class EntryPointNotFoundException extends System.TypeLoadException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $inner: System.Exception)
        }
        interface EventHandler
        { 
        (sender: any, e: System.EventArgs) : void; 
        Invoke?: (sender: any, e: System.EventArgs) => void;
        }
        var EventHandler: { new (func: (sender: any, e: System.EventArgs) => void): EventHandler; }
        interface EventHandler$1<TEventArgs>
        { 
        (sender: any, e: TEventArgs) : void; 
        Invoke?: (sender: any, e: TEventArgs) => void;
        }
        class ExecutionEngineException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class MemberAccessException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $inner: System.Exception)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class FieldAccessException extends System.MemberAccessException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $inner: System.Exception)
        }
        class FlagsAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class FormatException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class FormattableString extends System.Object implements System.IFormattable
        {
            protected [__keep_incompatibility]: never;
            public get Format(): string;
            public get ArgumentCount(): number;
            public GetArguments () : System.Array$1<any>
            public GetArgument ($index: number) : any
            public ToString ($formatProvider: System.IFormatProvider) : string
            public static Invariant ($formattable: System.FormattableString) : string
            public ToString () : string
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
        }
        class Guid extends System.ValueType implements System.IFormattable, System.ISpanFormattable, System.IComparable, System.IComparable$1<System.Guid>, System.IEquatable$1<System.Guid>
        {
            protected [__keep_incompatibility]: never;
            public static Empty : System.Guid
            public static NewGuid () : System.Guid
            public static Parse ($input: string) : System.Guid
            public static TryParse ($input: string, $result: $Ref<System.Guid>) : boolean
            public static ParseExact ($input: string, $format: string) : System.Guid
            public static TryParseExact ($input: string, $format: string, $result: $Ref<System.Guid>) : boolean
            public ToByteArray () : System.Array$1<number>
            public ToString () : string
            public Equals ($o: any) : boolean
            public Equals ($g: System.Guid) : boolean
            public CompareTo ($value: any) : number
            public CompareTo ($value: System.Guid) : number
            public static op_Equality ($a: System.Guid, $b: System.Guid) : boolean
            public static op_Inequality ($a: System.Guid, $b: System.Guid) : boolean
            public ToString ($format: string) : string
            public ToString ($format: string, $provider: System.IFormatProvider) : string
            public constructor ($b: System.Array$1<number>)
            public constructor ($a: number, $b: number, $c: number, $d: number, $e: number, $f: number, $g: number, $h: number, $i: number, $j: number, $k: number)
            public constructor ($a: number, $b: number, $c: number, $d: System.Array$1<number>)
            public constructor ($g: string)
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            public CompareTo ($obj: any) : number
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
            public constructor ()
        }
        class HashCode extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public ToHashCode () : number
        }
        interface IAsyncDisposable
        {
            DisposeAsync () : System.Threading.Tasks.ValueTask
        }
        interface IAsyncDisposable {
            ConfigureAwait ($continueOnCapturedContext: boolean) : System.Runtime.CompilerServices.ConfiguredAsyncDisposable;
        }
        interface ICustomFormatter
        {
            Format ($format: string, $arg: any, $formatProvider: System.IFormatProvider) : string
        }
        interface IObservable$1<T>
        {
            Subscribe ($observer: System.IObserver$1<T>) : System.IDisposable
        }
        interface IObserver$1<T>
        {
            OnNext ($value: T) : void
            OnError ($error: System.Exception) : void
            OnCompleted () : void
        }
        interface IProgress$1<T>
        {
            Report ($value: T) : void
        }
        class Index extends System.ValueType implements System.IEquatable$1<System.Index>
        {
            protected [__keep_incompatibility]: never;
            public static get Start(): System.Index;
            public static get End(): System.Index;
            public get Value(): number;
            public get IsFromEnd(): boolean;
            public static FromStart ($value: number) : System.Index
            public static FromEnd ($value: number) : System.Index
            public GetOffset ($length: number) : number
            public Equals ($value: any) : boolean
            public Equals ($other: System.Index) : boolean
            public static op_Implicit ($value: number) : System.Index
            public constructor ($value: number, $fromEnd?: boolean)
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
            public constructor ()
        }
        class IndexOutOfRangeException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class InsufficientExecutionStackException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class InvalidCastException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
            public constructor ($message: string, $errorCode: number)
        }
        class InvalidOperationException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class InvalidProgramException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $inner: System.Exception)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class InvalidTimeZoneException extends System.Exception implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class Lazy$1<T> extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get IsValueCreated(): boolean;
            public get Value(): T;
            public constructor ()
            public constructor ($value: T)
            public constructor ($valueFactory: System.Func$1<T>)
            public constructor ($isThreadSafe: boolean)
            public constructor ($mode: System.Threading.LazyThreadSafetyMode)
            public constructor ($valueFactory: System.Func$1<T>, $isThreadSafe: boolean)
            public constructor ($valueFactory: System.Func$1<T>, $mode: System.Threading.LazyThreadSafetyMode)
        }
        class Math extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static E : number
            public static PI : number
            public static Abs ($value: number) : number
            public static Abs ($value: bigint) : bigint
            public static Abs ($value: System.Decimal) : System.Decimal
            public static BigMul ($a: number, $b: number) : bigint
            public static DivRem ($a: number, $b: number, $result: $Ref<number>) : number
            public static DivRem ($a: bigint, $b: bigint, $result: $Ref<bigint>) : bigint
            public static Ceiling ($d: System.Decimal) : System.Decimal
            public static Clamp ($value: number, $min: number, $max: number) : number
            public static Clamp ($value: System.Decimal, $min: System.Decimal, $max: System.Decimal) : System.Decimal
            public static Clamp ($value: bigint, $min: bigint, $max: bigint) : bigint
            public static Floor ($d: System.Decimal) : System.Decimal
            public static IEEERemainder ($x: number, $y: number) : number
            public static Log ($a: number, $newBase: number) : number
            public static Max ($val1: number, $val2: number) : number
            public static Max ($val1: System.Decimal, $val2: System.Decimal) : System.Decimal
            public static Max ($val1: bigint, $val2: bigint) : bigint
            public static Min ($val1: number, $val2: number) : number
            public static Min ($val1: System.Decimal, $val2: System.Decimal) : System.Decimal
            public static Min ($val1: bigint, $val2: bigint) : bigint
            public static Round ($d: System.Decimal) : System.Decimal
            public static Round ($d: System.Decimal, $decimals: number) : System.Decimal
            public static Round ($d: System.Decimal, $mode: System.MidpointRounding) : System.Decimal
            public static Round ($d: System.Decimal, $decimals: number, $mode: System.MidpointRounding) : System.Decimal
            public static Round ($a: number) : number
            public static Round ($value: number, $digits: number) : number
            public static Round ($value: number, $mode: System.MidpointRounding) : number
            public static Round ($value: number, $digits: number, $mode: System.MidpointRounding) : number
            public static Sign ($value: System.Decimal) : number
            public static Sign ($value: number) : number
            public static Sign ($value: bigint) : number
            public static Truncate ($d: System.Decimal) : System.Decimal
            public static Truncate ($d: number) : number
            public static Acos ($d: number) : number
            public static Acosh ($d: number) : number
            public static Asin ($d: number) : number
            public static Asinh ($d: number) : number
            public static Atan ($d: number) : number
            public static Atan2 ($y: number, $x: number) : number
            public static Atanh ($d: number) : number
            public static Cbrt ($d: number) : number
            public static Ceiling ($a: number) : number
            public static Cos ($d: number) : number
            public static Cosh ($value: number) : number
            public static Exp ($d: number) : number
            public static Floor ($d: number) : number
            public static Log ($d: number) : number
            public static Log10 ($d: number) : number
            public static Pow ($x: number, $y: number) : number
            public static Sin ($a: number) : number
            public static Sinh ($value: number) : number
            public static Sqrt ($d: number) : number
            public static Tan ($a: number) : number
            public static Tanh ($value: number) : number
        }
        enum MidpointRounding
        { ToEven = 0, AwayFromZero = 1 }
        class MathF extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static E : number
            public static PI : number
            public static Abs ($x: number) : number
            public static IEEERemainder ($x: number, $y: number) : number
            public static Log ($x: number, $y: number) : number
            public static Max ($x: number, $y: number) : number
            public static Min ($x: number, $y: number) : number
            public static Round ($x: number) : number
            public static Round ($x: number, $digits: number) : number
            public static Round ($x: number, $mode: System.MidpointRounding) : number
            public static Round ($x: number, $digits: number, $mode: System.MidpointRounding) : number
            public static Sign ($x: number) : number
            public static Truncate ($x: number) : number
            public static Acos ($x: number) : number
            public static Acosh ($x: number) : number
            public static Asin ($x: number) : number
            public static Asinh ($x: number) : number
            public static Atan ($x: number) : number
            public static Atan2 ($y: number, $x: number) : number
            public static Atanh ($x: number) : number
            public static Cbrt ($x: number) : number
            public static Ceiling ($x: number) : number
            public static Cos ($x: number) : number
            public static Cosh ($x: number) : number
            public static Exp ($x: number) : number
            public static Floor ($x: number) : number
            public static Log ($x: number) : number
            public static Log10 ($x: number) : number
            public static Pow ($x: number, $y: number) : number
            public static Sin ($x: number) : number
            public static Sinh ($x: number) : number
            public static Sqrt ($x: number) : number
            public static Tan ($x: number) : number
            public static Tanh ($x: number) : number
        }
        class Memory$1<T> extends System.ValueType implements System.IEquatable$1<System.Memory$1<T>>
        {
            protected [__keep_incompatibility]: never;
            public static get Empty(): any;
            public get Length(): number;
            public get IsEmpty(): boolean;
            public static op_Implicit ($array: any) : any
            public static op_Implicit ($segment: any) : any
            public static op_Implicit ($memory: any) : any
            public Slice ($start: number) : System.Memory$1<T>
            public Slice ($start: number, $length: number) : System.Memory$1<T>
            public CopyTo ($destination: System.Memory$1<T>) : void
            public TryCopyTo ($destination: System.Memory$1<T>) : boolean
            public Pin () : System.Buffers.MemoryHandle
            public ToArray () : System.Array$1<T>
            public Equals ($obj: any) : boolean
            public Equals ($other: System.Memory$1<T>) : boolean
            public constructor ($array: System.Array$1<T>)
            public constructor ($array: System.Array$1<T>, $start: number, $length: number)
            public static Equals ($objA: any, $objB: any) : any
            public constructor ()
        }
        class ReadOnlyMemory$1<T> extends System.ValueType implements System.IEquatable$1<System.ReadOnlyMemory$1<T>>
        {
            protected [__keep_incompatibility]: never;
            public static get Empty(): any;
            public get Length(): number;
            public get IsEmpty(): boolean;
            public static op_Implicit ($array: any) : any
            public static op_Implicit ($segment: any) : any
            public Slice ($start: number) : System.ReadOnlyMemory$1<T>
            public Slice ($start: number, $length: number) : System.ReadOnlyMemory$1<T>
            public CopyTo ($destination: System.Memory$1<T>) : void
            public TryCopyTo ($destination: System.Memory$1<T>) : boolean
            public Pin () : System.Buffers.MemoryHandle
            public ToArray () : System.Array$1<T>
            public Equals ($obj: any) : boolean
            public Equals ($other: System.ReadOnlyMemory$1<T>) : boolean
            public constructor ($array: System.Array$1<T>)
            public constructor ($array: System.Array$1<T>, $start: number, $length: number)
            public static Equals ($objA: any, $objB: any) : any
            public constructor ()
        }
        class MemoryExtensions extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static AsMemory ($text: string) : System.ReadOnlyMemory$1<number>
            public static AsMemory ($text: string, $start: number) : System.ReadOnlyMemory$1<number>
            public static AsMemory ($text: string, $startIndex: System.Index) : System.ReadOnlyMemory$1<number>
            public static AsMemory ($text: string, $start: number, $length: number) : System.ReadOnlyMemory$1<number>
            public static AsMemory ($text: string, $range: System.Range) : System.ReadOnlyMemory$1<number>
        }
        class Range extends System.ValueType implements System.IEquatable$1<System.Range>
        {
            protected [__keep_incompatibility]: never;
            public get Start(): System.Index;
            public get End(): System.Index;
            public static get All(): System.Range;
            public Equals ($value: any) : boolean
            public Equals ($other: System.Range) : boolean
            public static StartAt ($start: System.Index) : System.Range
            public static EndAt ($end: System.Index) : System.Range
            public GetOffsetAndLength ($length: number) : System.ValueTuple$2<number, number>
            public constructor ($start: System.Index, $end: System.Index)
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
            public constructor ()
        }
        class MethodAccessException extends System.MemberAccessException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $inner: System.Exception)
        }
        class MissingMemberException extends System.MemberAccessException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public get Message(): string;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $inner: System.Exception)
            public constructor ($className: string, $memberName: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class MissingMethodException extends System.MissingMemberException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public get Message(): string;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $inner: System.Exception)
            public constructor ($className: string, $methodName: string)
            public constructor ($className: string, $memberName: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class MulticastNotSupportedException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $inner: System.Exception)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class NonSerializedAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class NotFiniteNumberException extends System.ArithmeticException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public get OffendingNumber(): number;
            public constructor ()
            public constructor ($offendingNumber: number)
            public constructor ($message: string)
            public constructor ($message: string, $offendingNumber: number)
            public constructor ($message: string, $innerException: System.Exception)
            public constructor ($message: string, $offendingNumber: number, $innerException: System.Exception)
        }
        class NotImplementedException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $inner: System.Exception)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class NotSupportedException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class NullReferenceException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class Nullable$1<T> extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get HasValue(): boolean;
            public get Value(): T;
            public GetValueOrDefault () : T
            public GetValueOrDefault ($defaultValue: T) : T
            public static op_Implicit ($value: any) : any
            public static op_Explicit ($value: any) : any
            public constructor ($value: T)
            public constructor ()
        }
        class Nullable extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static GetUnderlyingType ($nullableType: System.Type) : System.Type
        }
        class ObjectDisposedException extends System.InvalidOperationException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public get Message(): string;
            public get ObjectName(): string;
            public constructor ($objectName: string)
            public constructor ($objectName: string, $message: string)
            public constructor ($message: string, $innerException: System.Exception)
            public constructor ()
            public constructor ($message: string)
        }
        class ObsoleteAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Message(): string;
            public get IsError(): boolean;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $error: boolean)
        }
        class OperationCanceledException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public get CancellationToken(): System.Threading.CancellationToken;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
            public constructor ($token: System.Threading.CancellationToken)
            public constructor ($message: string, $token: System.Threading.CancellationToken)
            public constructor ($message: string, $innerException: System.Exception, $token: System.Threading.CancellationToken)
        }
        class OverflowException extends System.ArithmeticException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class ParamArrayAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class PlatformNotSupportedException extends System.NotSupportedException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $inner: System.Exception)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class Progress$1<T> extends System.Object implements System.IProgress$1<T>
        {
            protected [__keep_incompatibility]: never;
            public add_ProgressChanged ($value: System.EventHandler$1<T>) : void
            public remove_ProgressChanged ($value: System.EventHandler$1<T>) : void
            public constructor ()
            public constructor ($handler: System.Action$1<T>)
            public Report ($value: T) : void
        }
        class Random extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public Next () : number
            public Next ($minValue: number, $maxValue: number) : number
            public Next ($maxValue: number) : number
            public NextDouble () : number
            public NextBytes ($buffer: System.Array$1<number>) : void
            public constructor ()
            public constructor ($Seed: number)
        }
        class ValueTuple$2<T1, T2> extends System.ValueType implements System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.Runtime.CompilerServices.ITuple, System.IComparable, System.IComparable$1<System.ValueTuple$2<T1, T2>>, System.IValueTupleInternal, System.IEquatable$1<System.ValueTuple$2<T1, T2>>
        {
            protected [__keep_incompatibility]: never;
            public Item1 : T1
            public Item2 : T2
            public get Length(): number;
            public Equals ($obj: any) : boolean
            public Equals ($other: System.ValueTuple$2<T1, T2>) : boolean
            public CompareTo ($other: System.ValueTuple$2<T1, T2>) : number
            public constructor ($item1: T1, $item2: T2)
            public CompareTo ($other: any, $comparer: System.Collections.IComparer) : number
            public Equals ($other: any, $comparer: System.Collections.IEqualityComparer) : boolean
            public GetHashCode ($comparer: System.Collections.IEqualityComparer) : number
            public get_Item ($index: number) : any
            public CompareTo ($obj: any) : number
            public static Equals ($objA: any, $objB: any) : any
            public GetHashCode () : number
            public constructor ()
        }
        interface IValueTupleInternal extends System.Runtime.CompilerServices.ITuple
        {
            Length : number
            get_Item ($index: number) : any
        }
        class RankException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class ResolveEventArgs extends System.EventArgs
        {
            protected [__keep_incompatibility]: never;
            public get Name(): string;
            public get RequestingAssembly(): System.Reflection.Assembly;
            public constructor ($name: string)
            public constructor ($name: string, $requestingAssembly: System.Reflection.Assembly)
            public constructor ()
        }
        interface ResolveEventHandler
        { 
        (sender: any, args: System.ResolveEventArgs) : System.Reflection.Assembly; 
        Invoke?: (sender: any, args: System.ResolveEventArgs) => System.Reflection.Assembly;
        }
        var ResolveEventHandler: { new (func: (sender: any, args: System.ResolveEventArgs) => System.Reflection.Assembly): ResolveEventHandler; }
        class SerializableAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class StackOverflowException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class StringComparer extends System.Object implements System.Collections.Generic.IComparer$1<string>, System.Collections.IComparer, System.Collections.Generic.IEqualityComparer$1<string>, System.Collections.IEqualityComparer
        {
            protected [__keep_incompatibility]: never;
            public static get InvariantCulture(): System.StringComparer;
            public static get InvariantCultureIgnoreCase(): System.StringComparer;
            public static get CurrentCulture(): System.StringComparer;
            public static get CurrentCultureIgnoreCase(): System.StringComparer;
            public static get Ordinal(): System.StringComparer;
            public static get OrdinalIgnoreCase(): System.StringComparer;
            public static FromComparison ($comparisonType: System.StringComparison) : System.StringComparer
            public static Create ($culture: System.Globalization.CultureInfo, $ignoreCase: boolean) : System.StringComparer
            public static Create ($culture: System.Globalization.CultureInfo, $options: System.Globalization.CompareOptions) : System.StringComparer
            public Compare ($x: any, $y: any) : number
            public Equals ($x: any, $y: any) : boolean
            public GetHashCode ($obj: any) : number
            public Compare ($x: string, $y: string) : number
            public Equals ($x: string, $y: string) : boolean
            public GetHashCode ($obj: string) : number
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
            public GetHashCode () : number
        }
        class CultureAwareComparer extends System.StringComparer implements System.Collections.Generic.IComparer$1<string>, System.Runtime.Serialization.ISerializable, System.Collections.IComparer, System.Collections.Generic.IEqualityComparer$1<string>, System.Collections.IEqualityComparer
        {
            protected [__keep_incompatibility]: never;
            public GetObjectData ($info: System.Runtime.Serialization.SerializationInfo, $context: System.Runtime.Serialization.StreamingContext) : void
        }
        class OrdinalComparer extends System.StringComparer implements System.Collections.Generic.IComparer$1<string>, System.Collections.IComparer, System.Collections.Generic.IEqualityComparer$1<string>, System.Collections.IEqualityComparer
        {
            protected [__keep_incompatibility]: never;
        }
        class STAThreadAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class MTAThreadAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class ThreadStaticAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class TimeZone extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get CurrentTimeZone(): System.TimeZone;
            public get StandardName(): string;
            public get DaylightName(): string;
            public GetUtcOffset ($time: System.DateTime) : System.TimeSpan
            public ToUniversalTime ($time: System.DateTime) : System.DateTime
            public ToLocalTime ($time: System.DateTime) : System.DateTime
            public GetDaylightChanges ($year: number) : System.Globalization.DaylightTime
            public IsDaylightSavingTime ($time: System.DateTime) : boolean
            public static IsDaylightSavingTime ($time: System.DateTime, $daylightTimes: System.Globalization.DaylightTime) : boolean
        }
        class TimeZoneNotFoundException extends System.Exception implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class TimeoutException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class Tuple extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class Tuple$1<T1> extends System.Object implements System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.Runtime.CompilerServices.ITuple, System.IComparable, System.ITupleInternal
        {
            protected [__keep_incompatibility]: never;
            public get Item1(): T1;
            public get Length(): number;
            public constructor ($item1: T1)
            public CompareTo ($other: any, $comparer: System.Collections.IComparer) : number
            public Equals ($other: any, $comparer: System.Collections.IEqualityComparer) : boolean
            public GetHashCode ($comparer: System.Collections.IEqualityComparer) : number
            public get_Item ($index: number) : any
            public CompareTo ($obj: any) : number
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : any
            public GetHashCode () : number
            public constructor ()
        }
        interface ITupleInternal extends System.Runtime.CompilerServices.ITuple
        {
            Length : number
            get_Item ($index: number) : any
        }
        class Tuple$2<T1, T2> extends System.Object implements System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.Runtime.CompilerServices.ITuple, System.IComparable, System.ITupleInternal
        {
            protected [__keep_incompatibility]: never;
            public get Item1(): T1;
            public get Item2(): T2;
            public get Length(): number;
            public constructor ($item1: T1, $item2: T2)
            public CompareTo ($other: any, $comparer: System.Collections.IComparer) : number
            public Equals ($other: any, $comparer: System.Collections.IEqualityComparer) : boolean
            public GetHashCode ($comparer: System.Collections.IEqualityComparer) : number
            public get_Item ($index: number) : any
            public CompareTo ($obj: any) : number
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : any
            public GetHashCode () : number
            public constructor ()
        }
        class Tuple$3<T1, T2, T3> extends System.Object implements System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.Runtime.CompilerServices.ITuple, System.IComparable, System.ITupleInternal
        {
            protected [__keep_incompatibility]: never;
            public get Item1(): T1;
            public get Item2(): T2;
            public get Item3(): T3;
            public get Length(): number;
            public constructor ($item1: T1, $item2: T2, $item3: T3)
            public CompareTo ($other: any, $comparer: System.Collections.IComparer) : number
            public Equals ($other: any, $comparer: System.Collections.IEqualityComparer) : boolean
            public GetHashCode ($comparer: System.Collections.IEqualityComparer) : number
            public get_Item ($index: number) : any
            public CompareTo ($obj: any) : number
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : any
            public GetHashCode () : number
            public constructor ()
        }
        class Tuple$4<T1, T2, T3, T4> extends System.Object implements System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.Runtime.CompilerServices.ITuple, System.IComparable, System.ITupleInternal
        {
            protected [__keep_incompatibility]: never;
            public get Item1(): T1;
            public get Item2(): T2;
            public get Item3(): T3;
            public get Item4(): T4;
            public get Length(): number;
            public constructor ($item1: T1, $item2: T2, $item3: T3, $item4: T4)
            public CompareTo ($other: any, $comparer: System.Collections.IComparer) : number
            public Equals ($other: any, $comparer: System.Collections.IEqualityComparer) : boolean
            public GetHashCode ($comparer: System.Collections.IEqualityComparer) : number
            public get_Item ($index: number) : any
            public CompareTo ($obj: any) : number
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : any
            public GetHashCode () : number
            public constructor ()
        }
        class Tuple$5<T1, T2, T3, T4, T5> extends System.Object implements System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.Runtime.CompilerServices.ITuple, System.IComparable, System.ITupleInternal
        {
            protected [__keep_incompatibility]: never;
            public get Item1(): T1;
            public get Item2(): T2;
            public get Item3(): T3;
            public get Item4(): T4;
            public get Item5(): T5;
            public get Length(): number;
            public constructor ($item1: T1, $item2: T2, $item3: T3, $item4: T4, $item5: T5)
            public CompareTo ($other: any, $comparer: System.Collections.IComparer) : number
            public Equals ($other: any, $comparer: System.Collections.IEqualityComparer) : boolean
            public GetHashCode ($comparer: System.Collections.IEqualityComparer) : number
            public get_Item ($index: number) : any
            public CompareTo ($obj: any) : number
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : any
            public GetHashCode () : number
            public constructor ()
        }
        class Tuple$6<T1, T2, T3, T4, T5, T6> extends System.Object implements System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.Runtime.CompilerServices.ITuple, System.IComparable, System.ITupleInternal
        {
            protected [__keep_incompatibility]: never;
            public get Item1(): T1;
            public get Item2(): T2;
            public get Item3(): T3;
            public get Item4(): T4;
            public get Item5(): T5;
            public get Item6(): T6;
            public get Length(): number;
            public constructor ($item1: T1, $item2: T2, $item3: T3, $item4: T4, $item5: T5, $item6: T6)
            public CompareTo ($other: any, $comparer: System.Collections.IComparer) : number
            public Equals ($other: any, $comparer: System.Collections.IEqualityComparer) : boolean
            public GetHashCode ($comparer: System.Collections.IEqualityComparer) : number
            public get_Item ($index: number) : any
            public CompareTo ($obj: any) : number
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : any
            public GetHashCode () : number
            public constructor ()
        }
        class Tuple$7<T1, T2, T3, T4, T5, T6, T7> extends System.Object implements System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.Runtime.CompilerServices.ITuple, System.IComparable, System.ITupleInternal
        {
            protected [__keep_incompatibility]: never;
            public get Item1(): T1;
            public get Item2(): T2;
            public get Item3(): T3;
            public get Item4(): T4;
            public get Item5(): T5;
            public get Item6(): T6;
            public get Item7(): T7;
            public get Length(): number;
            public constructor ($item1: T1, $item2: T2, $item3: T3, $item4: T4, $item5: T5, $item6: T6, $item7: T7)
            public CompareTo ($other: any, $comparer: System.Collections.IComparer) : number
            public Equals ($other: any, $comparer: System.Collections.IEqualityComparer) : boolean
            public GetHashCode ($comparer: System.Collections.IEqualityComparer) : number
            public get_Item ($index: number) : any
            public CompareTo ($obj: any) : number
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : any
            public GetHashCode () : number
            public constructor ()
        }
        class Tuple$8<T1, T2, T3, T4, T5, T6, T7, TRest> extends System.Object implements System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.Runtime.CompilerServices.ITuple, System.IComparable, System.ITupleInternal
        {
            protected [__keep_incompatibility]: never;
            public get Item1(): T1;
            public get Item2(): T2;
            public get Item3(): T3;
            public get Item4(): T4;
            public get Item5(): T5;
            public get Item6(): T6;
            public get Item7(): T7;
            public get Rest(): TRest;
            public get Length(): number;
            public constructor ($item1: T1, $item2: T2, $item3: T3, $item4: T4, $item5: T5, $item6: T6, $item7: T7, $rest: TRest)
            public CompareTo ($other: any, $comparer: System.Collections.IComparer) : number
            public Equals ($other: any, $comparer: System.Collections.IEqualityComparer) : boolean
            public GetHashCode ($comparer: System.Collections.IEqualityComparer) : number
            public get_Item ($index: number) : any
            public CompareTo ($obj: any) : number
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : any
            public GetHashCode () : number
            public constructor ()
        }
        class TupleExtensions extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class ValueTuple$1<T1> extends System.ValueType implements System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.Runtime.CompilerServices.ITuple, System.IComparable, System.IComparable$1<System.ValueTuple$1<T1>>, System.IValueTupleInternal, System.IEquatable$1<System.ValueTuple$1<T1>>
        {
            protected [__keep_incompatibility]: never;
            public Item1 : T1
            public get Length(): number;
            public Equals ($obj: any) : boolean
            public Equals ($other: System.ValueTuple$1<T1>) : boolean
            public CompareTo ($other: System.ValueTuple$1<T1>) : number
            public constructor ($item1: T1)
            public CompareTo ($other: any, $comparer: System.Collections.IComparer) : number
            public Equals ($other: any, $comparer: System.Collections.IEqualityComparer) : boolean
            public GetHashCode ($comparer: System.Collections.IEqualityComparer) : number
            public get_Item ($index: number) : any
            public CompareTo ($obj: any) : number
            public static Equals ($objA: any, $objB: any) : any
            public GetHashCode () : number
            public constructor ()
        }
        class ValueTuple$3<T1, T2, T3> extends System.ValueType implements System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.Runtime.CompilerServices.ITuple, System.IComparable, System.IComparable$1<System.ValueTuple$3<T1, T2, T3>>, System.IValueTupleInternal, System.IEquatable$1<System.ValueTuple$3<T1, T2, T3>>
        {
            protected [__keep_incompatibility]: never;
            public Item1 : T1
            public Item2 : T2
            public Item3 : T3
            public get Length(): number;
            public Equals ($obj: any) : boolean
            public Equals ($other: System.ValueTuple$3<T1, T2, T3>) : boolean
            public CompareTo ($other: System.ValueTuple$3<T1, T2, T3>) : number
            public constructor ($item1: T1, $item2: T2, $item3: T3)
            public CompareTo ($other: any, $comparer: System.Collections.IComparer) : number
            public Equals ($other: any, $comparer: System.Collections.IEqualityComparer) : boolean
            public GetHashCode ($comparer: System.Collections.IEqualityComparer) : number
            public get_Item ($index: number) : any
            public CompareTo ($obj: any) : number
            public static Equals ($objA: any, $objB: any) : any
            public GetHashCode () : number
            public constructor ()
        }
        class ValueTuple$4<T1, T2, T3, T4> extends System.ValueType implements System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.Runtime.CompilerServices.ITuple, System.IComparable, System.IComparable$1<System.ValueTuple$4<T1, T2, T3, T4>>, System.IValueTupleInternal, System.IEquatable$1<System.ValueTuple$4<T1, T2, T3, T4>>
        {
            protected [__keep_incompatibility]: never;
            public Item1 : T1
            public Item2 : T2
            public Item3 : T3
            public Item4 : T4
            public get Length(): number;
            public Equals ($obj: any) : boolean
            public Equals ($other: System.ValueTuple$4<T1, T2, T3, T4>) : boolean
            public CompareTo ($other: System.ValueTuple$4<T1, T2, T3, T4>) : number
            public constructor ($item1: T1, $item2: T2, $item3: T3, $item4: T4)
            public CompareTo ($other: any, $comparer: System.Collections.IComparer) : number
            public Equals ($other: any, $comparer: System.Collections.IEqualityComparer) : boolean
            public GetHashCode ($comparer: System.Collections.IEqualityComparer) : number
            public get_Item ($index: number) : any
            public CompareTo ($obj: any) : number
            public static Equals ($objA: any, $objB: any) : any
            public GetHashCode () : number
            public constructor ()
        }
        class ValueTuple$5<T1, T2, T3, T4, T5> extends System.ValueType implements System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.Runtime.CompilerServices.ITuple, System.IComparable, System.IComparable$1<System.ValueTuple$5<T1, T2, T3, T4, T5>>, System.IValueTupleInternal, System.IEquatable$1<System.ValueTuple$5<T1, T2, T3, T4, T5>>
        {
            protected [__keep_incompatibility]: never;
            public Item1 : T1
            public Item2 : T2
            public Item3 : T3
            public Item4 : T4
            public Item5 : T5
            public get Length(): number;
            public Equals ($obj: any) : boolean
            public Equals ($other: System.ValueTuple$5<T1, T2, T3, T4, T5>) : boolean
            public CompareTo ($other: System.ValueTuple$5<T1, T2, T3, T4, T5>) : number
            public constructor ($item1: T1, $item2: T2, $item3: T3, $item4: T4, $item5: T5)
            public CompareTo ($other: any, $comparer: System.Collections.IComparer) : number
            public Equals ($other: any, $comparer: System.Collections.IEqualityComparer) : boolean
            public GetHashCode ($comparer: System.Collections.IEqualityComparer) : number
            public get_Item ($index: number) : any
            public CompareTo ($obj: any) : number
            public static Equals ($objA: any, $objB: any) : any
            public GetHashCode () : number
            public constructor ()
        }
        class ValueTuple$6<T1, T2, T3, T4, T5, T6> extends System.ValueType implements System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.Runtime.CompilerServices.ITuple, System.IComparable, System.IComparable$1<System.ValueTuple$6<T1, T2, T3, T4, T5, T6>>, System.IValueTupleInternal, System.IEquatable$1<System.ValueTuple$6<T1, T2, T3, T4, T5, T6>>
        {
            protected [__keep_incompatibility]: never;
            public Item1 : T1
            public Item2 : T2
            public Item3 : T3
            public Item4 : T4
            public Item5 : T5
            public Item6 : T6
            public get Length(): number;
            public Equals ($obj: any) : boolean
            public Equals ($other: System.ValueTuple$6<T1, T2, T3, T4, T5, T6>) : boolean
            public CompareTo ($other: System.ValueTuple$6<T1, T2, T3, T4, T5, T6>) : number
            public constructor ($item1: T1, $item2: T2, $item3: T3, $item4: T4, $item5: T5, $item6: T6)
            public CompareTo ($other: any, $comparer: System.Collections.IComparer) : number
            public Equals ($other: any, $comparer: System.Collections.IEqualityComparer) : boolean
            public GetHashCode ($comparer: System.Collections.IEqualityComparer) : number
            public get_Item ($index: number) : any
            public CompareTo ($obj: any) : number
            public static Equals ($objA: any, $objB: any) : any
            public GetHashCode () : number
            public constructor ()
        }
        class ValueTuple$7<T1, T2, T3, T4, T5, T6, T7> extends System.ValueType implements System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.Runtime.CompilerServices.ITuple, System.IComparable, System.IComparable$1<System.ValueTuple$7<T1, T2, T3, T4, T5, T6, T7>>, System.IValueTupleInternal, System.IEquatable$1<System.ValueTuple$7<T1, T2, T3, T4, T5, T6, T7>>
        {
            protected [__keep_incompatibility]: never;
            public Item1 : T1
            public Item2 : T2
            public Item3 : T3
            public Item4 : T4
            public Item5 : T5
            public Item6 : T6
            public Item7 : T7
            public get Length(): number;
            public Equals ($obj: any) : boolean
            public Equals ($other: System.ValueTuple$7<T1, T2, T3, T4, T5, T6, T7>) : boolean
            public CompareTo ($other: System.ValueTuple$7<T1, T2, T3, T4, T5, T6, T7>) : number
            public constructor ($item1: T1, $item2: T2, $item3: T3, $item4: T4, $item5: T5, $item6: T6, $item7: T7)
            public CompareTo ($other: any, $comparer: System.Collections.IComparer) : number
            public Equals ($other: any, $comparer: System.Collections.IEqualityComparer) : boolean
            public GetHashCode ($comparer: System.Collections.IEqualityComparer) : number
            public get_Item ($index: number) : any
            public CompareTo ($obj: any) : number
            public static Equals ($objA: any, $objB: any) : any
            public GetHashCode () : number
            public constructor ()
        }
        class ValueTuple$8<T1, T2, T3, T4, T5, T6, T7, TRest> extends System.ValueType implements System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.Runtime.CompilerServices.ITuple, System.IComparable, System.IComparable$1<System.ValueTuple$8<T1, T2, T3, T4, T5, T6, T7, TRest>>, System.IValueTupleInternal, System.IEquatable$1<System.ValueTuple$8<T1, T2, T3, T4, T5, T6, T7, TRest>>
        {
            protected [__keep_incompatibility]: never;
            public Item1 : T1
            public Item2 : T2
            public Item3 : T3
            public Item4 : T4
            public Item5 : T5
            public Item6 : T6
            public Item7 : T7
            public Rest : TRest
            public get Length(): number;
            public Equals ($obj: any) : boolean
            public Equals ($other: System.ValueTuple$8<T1, T2, T3, T4, T5, T6, T7, TRest>) : boolean
            public CompareTo ($other: System.ValueTuple$8<T1, T2, T3, T4, T5, T6, T7, TRest>) : number
            public constructor ($item1: T1, $item2: T2, $item3: T3, $item4: T4, $item5: T5, $item6: T6, $item7: T7, $rest: TRest)
            public CompareTo ($other: any, $comparer: System.Collections.IComparer) : number
            public Equals ($other: any, $comparer: System.Collections.IEqualityComparer) : boolean
            public GetHashCode ($comparer: System.Collections.IEqualityComparer) : number
            public get_Item ($index: number) : any
            public CompareTo ($obj: any) : number
            public static Equals ($objA: any, $objB: any) : any
            public GetHashCode () : number
            public constructor ()
        }
        class RuntimeTypeHandle extends System.ValueType implements System.Runtime.Serialization.ISerializable
        {
            protected [__keep_incompatibility]: never;
            public get Value(): System.IntPtr;
            public GetObjectData ($info: System.Runtime.Serialization.SerializationInfo, $context: System.Runtime.Serialization.StreamingContext) : void
            public Equals ($obj: any) : boolean
            public Equals ($handle: System.RuntimeTypeHandle) : boolean
            public static op_Equality ($left: System.RuntimeTypeHandle, $right: any) : boolean
            public static op_Inequality ($left: System.RuntimeTypeHandle, $right: any) : boolean
            public static op_Equality ($left: any, $right: System.RuntimeTypeHandle) : boolean
            public static op_Inequality ($left: any, $right: System.RuntimeTypeHandle) : boolean
            public GetModuleHandle () : System.ModuleHandle
            public static Equals ($objA: any, $objB: any) : boolean
        }
        class TypeAccessException extends System.TypeLoadException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $inner: System.Exception)
        }
        class TypeInitializationException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public get TypeName(): string;
            public constructor ($fullTypeName: string, $innerException: System.Exception)
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class TypeUnloadedException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class UnauthorizedAccessException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $inner: System.Exception)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class UnhandledExceptionEventArgs extends System.EventArgs
        {
            protected [__keep_incompatibility]: never;
            public get ExceptionObject(): any;
            public get IsTerminating(): boolean;
            public constructor ($exception: any, $isTerminating: boolean)
            public constructor ()
        }
        interface UnhandledExceptionEventHandler
        { 
        (sender: any, e: System.UnhandledExceptionEventArgs) : void; 
        Invoke?: (sender: any, e: System.UnhandledExceptionEventArgs) => void;
        }
        var UnhandledExceptionEventHandler: { new (func: (sender: any, e: System.UnhandledExceptionEventArgs) => void): UnhandledExceptionEventHandler; }
        class ValueTuple extends System.ValueType implements System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.Runtime.CompilerServices.ITuple, System.IComparable, System.IComparable$1<System.ValueTuple>, System.IValueTupleInternal, System.IEquatable$1<System.ValueTuple>
        {
            protected [__keep_incompatibility]: never;
            public get Length(): number;
            public Equals ($obj: any) : boolean
            public Equals ($other: System.ValueTuple) : boolean
            public CompareTo ($other: System.ValueTuple) : number
            public static Create () : System.ValueTuple
            public CompareTo ($other: any, $comparer: System.Collections.IComparer) : number
            public Equals ($other: any, $comparer: System.Collections.IEqualityComparer) : boolean
            public GetHashCode ($comparer: System.Collections.IEqualityComparer) : number
            public get_Item ($index: number) : any
            public CompareTo ($obj: any) : number
            public static Equals ($objA: any, $objB: any) : boolean
            public GetHashCode () : number
        }
        class Version extends System.Object implements System.ICloneable, System.ISpanFormattable, System.IComparable, System.IComparable$1<System.Version>, System.IEquatable$1<System.Version>
        {
            protected [__keep_incompatibility]: never;
            public get Major(): number;
            public get Minor(): number;
            public get Build(): number;
            public get Revision(): number;
            public get MajorRevision(): number;
            public get MinorRevision(): number;
            public Clone () : any
            public CompareTo ($version: any) : number
            public CompareTo ($value: System.Version) : number
            public Equals ($obj: any) : boolean
            public Equals ($obj: System.Version) : boolean
            public ToString () : string
            public ToString ($fieldCount: number) : string
            public static Parse ($input: string) : System.Version
            public static TryParse ($input: string, $result: $Ref<System.Version>) : boolean
            public static op_Equality ($v1: System.Version, $v2: System.Version) : boolean
            public static op_Inequality ($v1: System.Version, $v2: System.Version) : boolean
            public static op_LessThan ($v1: System.Version, $v2: System.Version) : boolean
            public static op_LessThanOrEqual ($v1: System.Version, $v2: System.Version) : boolean
            public static op_GreaterThan ($v1: System.Version, $v2: System.Version) : boolean
            public static op_GreaterThanOrEqual ($v1: System.Version, $v2: System.Version) : boolean
            public constructor ($major: number, $minor: number, $build: number, $revision: number)
            public constructor ($major: number, $minor: number, $build: number)
            public constructor ($major: number, $minor: number)
            public constructor ($version: string)
            public constructor ()
            public CompareTo ($obj: any) : number
            public static Equals ($objA: any, $objB: any) : boolean
        }
        interface IServiceProvider
        {
            GetService ($serviceType: System.Type) : any
        }
        interface ConsoleCancelEventHandler
        { 
        (sender: any, e: System.ConsoleCancelEventArgs) : void; 
        Invoke?: (sender: any, e: System.ConsoleCancelEventArgs) => void;
        }
        var ConsoleCancelEventHandler: { new (func: (sender: any, e: System.ConsoleCancelEventArgs) => void): ConsoleCancelEventHandler; }
        class ConsoleCancelEventArgs extends System.EventArgs
        {
            protected [__keep_incompatibility]: never;
            public get Cancel(): boolean;
            public set Cancel(value: boolean);
            public get SpecialKey(): System.ConsoleSpecialKey;
        }
        enum ConsoleSpecialKey
        { ControlC = 0, ControlBreak = 1 }
        enum ConsoleColor
        { Black = 0, DarkBlue = 1, DarkGreen = 2, DarkCyan = 3, DarkRed = 4, DarkMagenta = 5, DarkYellow = 6, Gray = 7, DarkGray = 8, Blue = 9, Green = 10, Cyan = 11, Red = 12, Magenta = 13, Yellow = 14, White = 15 }
        enum ConsoleKey
        { Backspace = 8, Tab = 9, Clear = 12, Enter = 13, Pause = 19, Escape = 27, Spacebar = 32, PageUp = 33, PageDown = 34, End = 35, Home = 36, LeftArrow = 37, UpArrow = 38, RightArrow = 39, DownArrow = 40, Select = 41, Print = 42, Execute = 43, PrintScreen = 44, Insert = 45, Delete = 46, Help = 47, D0 = 48, D1 = 49, D2 = 50, D3 = 51, D4 = 52, D5 = 53, D6 = 54, D7 = 55, D8 = 56, D9 = 57, A = 65, B = 66, C = 67, D = 68, E = 69, F = 70, G = 71, H = 72, I = 73, J = 74, K = 75, L = 76, M = 77, N = 78, O = 79, P = 80, Q = 81, R = 82, S = 83, T = 84, U = 85, V = 86, W = 87, X = 88, Y = 89, Z = 90, LeftWindows = 91, RightWindows = 92, Applications = 93, Sleep = 95, NumPad0 = 96, NumPad1 = 97, NumPad2 = 98, NumPad3 = 99, NumPad4 = 100, NumPad5 = 101, NumPad6 = 102, NumPad7 = 103, NumPad8 = 104, NumPad9 = 105, Multiply = 106, Add = 107, Separator = 108, Subtract = 109, Decimal = 110, Divide = 111, F1 = 112, F2 = 113, F3 = 114, F4 = 115, F5 = 116, F6 = 117, F7 = 118, F8 = 119, F9 = 120, F10 = 121, F11 = 122, F12 = 123, F13 = 124, F14 = 125, F15 = 126, F16 = 127, F17 = 128, F18 = 129, F19 = 130, F20 = 131, F21 = 132, F22 = 133, F23 = 134, F24 = 135, BrowserBack = 166, BrowserForward = 167, BrowserRefresh = 168, BrowserStop = 169, BrowserSearch = 170, BrowserFavorites = 171, BrowserHome = 172, VolumeMute = 173, VolumeDown = 174, VolumeUp = 175, MediaNext = 176, MediaPrevious = 177, MediaStop = 178, MediaPlay = 179, LaunchMail = 180, LaunchMediaSelect = 181, LaunchApp1 = 182, LaunchApp2 = 183, Oem1 = 186, OemPlus = 187, OemComma = 188, OemMinus = 189, OemPeriod = 190, Oem2 = 191, Oem3 = 192, Oem4 = 219, Oem5 = 220, Oem6 = 221, Oem7 = 222, Oem8 = 223, Oem102 = 226, Process = 229, Packet = 231, Attention = 246, CrSel = 247, ExSel = 248, EraseEndOfFile = 249, Play = 250, Zoom = 251, NoName = 252, Pa1 = 253, OemClear = 254 }
        class ConsoleKeyInfo extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get KeyChar(): number;
            public get Key(): System.ConsoleKey;
            public get Modifiers(): System.ConsoleModifiers;
            public Equals ($value: any) : boolean
            public Equals ($obj: System.ConsoleKeyInfo) : boolean
            public static op_Equality ($a: System.ConsoleKeyInfo, $b: System.ConsoleKeyInfo) : boolean
            public static op_Inequality ($a: System.ConsoleKeyInfo, $b: System.ConsoleKeyInfo) : boolean
            public constructor ($keyChar: number, $key: System.ConsoleKey, $shift: boolean, $alt: boolean, $control: boolean)
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
            public constructor ()
        }
        enum ConsoleModifiers
        { Alt = 1, Shift = 2, Control = 4 }
        class SequencePosition extends System.ValueType implements System.IEquatable$1<System.SequencePosition>
        {
            protected [__keep_incompatibility]: never;
            public GetObject () : any
            public GetInteger () : number
            public Equals ($other: System.SequencePosition) : boolean
            public Equals ($obj: any) : boolean
            public constructor ($object: any, $integer: number)
            public static Equals ($objA: any, $objB: any) : boolean
            public constructor ()
        }
        class AppDomainUnloadedException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class ApplicationId extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get Culture(): string;
            public get Name(): string;
            public get ProcessorArchitecture(): string;
            public get Version(): System.Version;
            public get PublicKeyToken(): System.Array$1<number>;
            public Copy () : System.ApplicationId
            public constructor ($publicKeyToken: System.Array$1<number>, $name: string, $version: System.Version, $processorArchitecture: string, $culture: string)
            public constructor ()
        }
        class CannotUnloadAppDomainException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        enum LoaderOptimization
        { DisallowBindings = 4, DomainMask = 3, MultiDomain = 2, MultiDomainHost = 3, NotSpecified = 0, SingleDomain = 1 }
        class LoaderOptimizationAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Value(): System.LoaderOptimization;
            public constructor ($value: number)
            public constructor ($value: System.LoaderOptimization)
            public constructor ()
        }
        class OperatingSystem extends System.Object implements System.ICloneable, System.Runtime.Serialization.ISerializable
        {
            protected [__keep_incompatibility]: never;
            public get Platform(): System.PlatformID;
            public get ServicePack(): string;
            public get Version(): System.Version;
            public get VersionString(): string;
            public GetObjectData ($info: System.Runtime.Serialization.SerializationInfo, $context: System.Runtime.Serialization.StreamingContext) : void
            public Clone () : any
            public constructor ($platform: System.PlatformID, $version: System.Version)
            public constructor ()
        }
        enum PlatformID
        { Win32S = 0, Win32Windows = 1, Win32NT = 2, WinCE = 3, Unix = 4, Xbox = 5, MacOSX = 6 }
        class OutOfMemoryException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class InsufficientMemoryException extends System.OutOfMemoryException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class MissingFieldException extends System.MissingMemberException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public get Message(): string;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $inner: System.Exception)
            public constructor ($className: string, $fieldName: string)
            public constructor ($className: string, $memberName: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class AppContext extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get BaseDirectory(): string;
            public static get TargetFrameworkName(): string;
            public static GetData ($name: string) : any
            public static TryGetSwitch ($switchName: string, $isEnabled: $Ref<boolean>) : boolean
            public static SetSwitch ($switchName: string, $isEnabled: boolean) : void
        }
        class LocalDataStoreSlot extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class Activator extends System.Object implements System.Runtime.InteropServices._Activator
        {
            protected [__keep_incompatibility]: never;
            public static CreateInstance ($type: System.Type, $bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $args: System.Array$1<any>, $culture: System.Globalization.CultureInfo) : any
            public static CreateInstance ($type: System.Type, $bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $args: System.Array$1<any>, $culture: System.Globalization.CultureInfo, $activationAttributes: System.Array$1<any>) : any
            public static CreateInstance ($type: System.Type, ...args: any[]) : any
            public static CreateInstance ($type: System.Type, $args: System.Array$1<any>, $activationAttributes: System.Array$1<any>) : any
            public static CreateInstance ($type: System.Type) : any
            public static CreateInstance ($assemblyName: string, $typeName: string) : System.Runtime.Remoting.ObjectHandle
            public static CreateInstance ($assemblyName: string, $typeName: string, $activationAttributes: System.Array$1<any>) : System.Runtime.Remoting.ObjectHandle
            public static CreateInstance ($type: System.Type, $nonPublic: boolean) : any
            public static CreateInstanceFrom ($assemblyFile: string, $typeName: string) : System.Runtime.Remoting.ObjectHandle
            public static CreateInstanceFrom ($assemblyFile: string, $typeName: string, $activationAttributes: System.Array$1<any>) : System.Runtime.Remoting.ObjectHandle
            public static CreateInstance ($assemblyName: string, $typeName: string, $ignoreCase: boolean, $bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $args: System.Array$1<any>, $culture: System.Globalization.CultureInfo, $activationAttributes: System.Array$1<any>) : System.Runtime.Remoting.ObjectHandle
            public static CreateInstanceFrom ($assemblyFile: string, $typeName: string, $ignoreCase: boolean, $bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $args: System.Array$1<any>, $culture: System.Globalization.CultureInfo, $activationAttributes: System.Array$1<any>) : System.Runtime.Remoting.ObjectHandle
            public static CreateInstance ($domain: System.AppDomain, $assemblyName: string, $typeName: string) : System.Runtime.Remoting.ObjectHandle
            public static CreateInstance ($domain: System.AppDomain, $assemblyName: string, $typeName: string, $ignoreCase: boolean, $bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $args: System.Array$1<any>, $culture: System.Globalization.CultureInfo, $activationAttributes: System.Array$1<any>) : System.Runtime.Remoting.ObjectHandle
            public static CreateInstanceFrom ($domain: System.AppDomain, $assemblyFile: string, $typeName: string) : System.Runtime.Remoting.ObjectHandle
            public static CreateInstanceFrom ($domain: System.AppDomain, $assemblyFile: string, $typeName: string, $ignoreCase: boolean, $bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $args: System.Array$1<any>, $culture: System.Globalization.CultureInfo, $activationAttributes: System.Array$1<any>) : System.Runtime.Remoting.ObjectHandle
            public static CreateComInstanceFrom ($assemblyName: string, $typeName: string) : System.Runtime.Remoting.ObjectHandle
            public static CreateComInstanceFrom ($assemblyName: string, $typeName: string, $hashValue: System.Array$1<number>, $hashAlgorithm: System.Configuration.Assemblies.AssemblyHashAlgorithm) : System.Runtime.Remoting.ObjectHandle
            public static GetObject ($type: System.Type, $url: string) : any
            public static GetObject ($type: System.Type, $url: string, $state: any) : any
            public static CreateInstance ($activationContext: System.ActivationContext) : System.Runtime.Remoting.ObjectHandle
            public static CreateInstance ($activationContext: System.ActivationContext, $activationCustomData: System.Array$1<string>) : System.Runtime.Remoting.ObjectHandle
            public GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            public GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            public GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            public Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
        }
        class AppDomain extends System.MarshalByRefObject implements System._AppDomain, System.Security.IEvidenceFactory
        {
            protected [__keep_incompatibility]: never;
            public get SetupInformation(): System.AppDomainSetup;
            public get ApplicationTrust(): System.Security.Policy.ApplicationTrust;
            public get BaseDirectory(): string;
            public get RelativeSearchPath(): string;
            public get DynamicDirectory(): string;
            public get ShadowCopyFiles(): boolean;
            public get FriendlyName(): string;
            public get Evidence(): System.Security.Policy.Evidence;
            public get PermissionSet(): System.Security.PermissionSet;
            public static get CurrentDomain(): System.AppDomain;
            public get IsHomogenous(): boolean;
            public get IsFullyTrusted(): boolean;
            public get DomainManager(): System.AppDomainManager;
            public get ActivationContext(): System.ActivationContext;
            public get ApplicationIdentity(): System.ApplicationIdentity;
            public get Id(): number;
            public static get MonitoringIsEnabled(): boolean;
            public static set MonitoringIsEnabled(value: boolean);
            public get MonitoringSurvivedMemorySize(): bigint;
            public static get MonitoringSurvivedProcessMemorySize(): bigint;
            public get MonitoringTotalAllocatedMemorySize(): bigint;
            public get MonitoringTotalProcessorTime(): System.TimeSpan;
            public CreateComInstanceFrom ($assemblyName: string, $typeName: string) : System.Runtime.Remoting.ObjectHandle
            public CreateComInstanceFrom ($assemblyFile: string, $typeName: string, $hashValue: System.Array$1<number>, $hashAlgorithm: System.Configuration.Assemblies.AssemblyHashAlgorithm) : System.Runtime.Remoting.ObjectHandle
            public CreateInstance ($assemblyName: string, $typeName: string) : System.Runtime.Remoting.ObjectHandle
            public CreateInstance ($assemblyName: string, $typeName: string, $activationAttributes: System.Array$1<any>) : System.Runtime.Remoting.ObjectHandle
            public CreateInstanceAndUnwrap ($assemblyName: string, $typeName: string) : any
            public CreateInstanceAndUnwrap ($assemblyName: string, $typeName: string, $activationAttributes: System.Array$1<any>) : any
            public CreateInstance ($assemblyName: string, $typeName: string, $ignoreCase: boolean, $bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $args: System.Array$1<any>, $culture: System.Globalization.CultureInfo, $activationAttributes: System.Array$1<any>) : System.Runtime.Remoting.ObjectHandle
            public CreateInstanceAndUnwrap ($assemblyName: string, $typeName: string, $ignoreCase: boolean, $bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $args: System.Array$1<any>, $culture: System.Globalization.CultureInfo, $activationAttributes: System.Array$1<any>) : any
            public CreateInstanceFrom ($assemblyFile: string, $typeName: string, $ignoreCase: boolean, $bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $args: System.Array$1<any>, $culture: System.Globalization.CultureInfo, $activationAttributes: System.Array$1<any>) : System.Runtime.Remoting.ObjectHandle
            public CreateInstanceFromAndUnwrap ($assemblyFile: string, $typeName: string, $ignoreCase: boolean, $bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $args: System.Array$1<any>, $culture: System.Globalization.CultureInfo, $activationAttributes: System.Array$1<any>) : any
            public CreateInstanceFrom ($assemblyFile: string, $typeName: string) : System.Runtime.Remoting.ObjectHandle
            public CreateInstanceFrom ($assemblyFile: string, $typeName: string, $activationAttributes: System.Array$1<any>) : System.Runtime.Remoting.ObjectHandle
            public CreateInstanceFromAndUnwrap ($assemblyName: string, $typeName: string) : any
            public CreateInstanceFromAndUnwrap ($assemblyName: string, $typeName: string, $activationAttributes: System.Array$1<any>) : any
            public DefineDynamicAssembly ($name: System.Reflection.AssemblyName, $access: System.Reflection.Emit.AssemblyBuilderAccess) : System.Reflection.Emit.AssemblyBuilder
            public DefineDynamicAssembly ($name: System.Reflection.AssemblyName, $access: System.Reflection.Emit.AssemblyBuilderAccess, $dir: string) : System.Reflection.Emit.AssemblyBuilder
            public DefineDynamicAssembly ($name: System.Reflection.AssemblyName, $access: System.Reflection.Emit.AssemblyBuilderAccess, $assemblyAttributes: System.Collections.Generic.IEnumerable$1<System.Reflection.Emit.CustomAttributeBuilder>) : System.Reflection.Emit.AssemblyBuilder
            public DefineDynamicAssembly ($name: System.Reflection.AssemblyName, $access: System.Reflection.Emit.AssemblyBuilderAccess, $dir: string, $isSynchronized: boolean, $assemblyAttributes: System.Collections.Generic.IEnumerable$1<System.Reflection.Emit.CustomAttributeBuilder>) : System.Reflection.Emit.AssemblyBuilder
            public DefineDynamicAssembly ($name: System.Reflection.AssemblyName, $access: System.Reflection.Emit.AssemblyBuilderAccess, $assemblyAttributes: System.Collections.Generic.IEnumerable$1<System.Reflection.Emit.CustomAttributeBuilder>, $securityContextSource: System.Security.SecurityContextSource) : System.Reflection.Emit.AssemblyBuilder
            public DoCallBack ($callBackDelegate: System.CrossAppDomainDelegate) : void
            public ExecuteAssembly ($assemblyFile: string) : number
            public ExecuteAssembly ($assemblyFile: string, $args: System.Array$1<string>) : number
            public ExecuteAssembly ($assemblyFile: string, $args: System.Array$1<string>, $hashValue: System.Array$1<number>, $hashAlgorithm: System.Configuration.Assemblies.AssemblyHashAlgorithm) : number
            public GetAssemblies () : System.Array$1<System.Reflection.Assembly>
            public GetData ($name: string) : any
            public GetType () : System.Type
            public Load ($assemblyRef: System.Reflection.AssemblyName) : System.Reflection.Assembly
            public Load ($assemblyString: string) : System.Reflection.Assembly
            public Load ($rawAssembly: System.Array$1<number>) : System.Reflection.Assembly
            public Load ($rawAssembly: System.Array$1<number>, $rawSymbolStore: System.Array$1<number>) : System.Reflection.Assembly
            public SetPrincipalPolicy ($policy: System.Security.Principal.PrincipalPolicy) : void
            public SetThreadPrincipal ($principal: System.Security.Principal.IPrincipal) : void
            public static CreateDomain ($friendlyName: string) : System.AppDomain
            public static CreateDomain ($friendlyName: string, $securityInfo: System.Security.Policy.Evidence) : System.AppDomain
            public static CreateDomain ($friendlyName: string, $securityInfo: System.Security.Policy.Evidence, $info: System.AppDomainSetup) : System.AppDomain
            public static CreateDomain ($friendlyName: string, $securityInfo: System.Security.Policy.Evidence, $appBasePath: string, $appRelativeSearchPath: string, $shadowCopyFiles: boolean) : System.AppDomain
            public static CreateDomain ($friendlyName: string, $securityInfo: System.Security.Policy.Evidence, $info: System.AppDomainSetup, $grantSet: System.Security.PermissionSet, ...fullTrustAssemblies: System.Security.Policy.StrongName[]) : System.AppDomain
            public IsFinalizingForUnload () : boolean
            public static Unload ($domain: System.AppDomain) : void
            public SetData ($name: string, $data: any) : void
            public SetData ($name: string, $data: any, $permission: System.Security.IPermission) : void
            public add_AssemblyLoad ($value: System.AssemblyLoadEventHandler) : void
            public remove_AssemblyLoad ($value: System.AssemblyLoadEventHandler) : void
            public add_AssemblyResolve ($value: System.ResolveEventHandler) : void
            public remove_AssemblyResolve ($value: System.ResolveEventHandler) : void
            public add_DomainUnload ($value: System.EventHandler) : void
            public remove_DomainUnload ($value: System.EventHandler) : void
            public add_ProcessExit ($value: System.EventHandler) : void
            public remove_ProcessExit ($value: System.EventHandler) : void
            public add_ResourceResolve ($value: System.ResolveEventHandler) : void
            public remove_ResourceResolve ($value: System.ResolveEventHandler) : void
            public add_TypeResolve ($value: System.ResolveEventHandler) : void
            public remove_TypeResolve ($value: System.ResolveEventHandler) : void
            public add_UnhandledException ($value: System.UnhandledExceptionEventHandler) : void
            public remove_UnhandledException ($value: System.UnhandledExceptionEventHandler) : void
            public add_FirstChanceException ($value: System.EventHandler$1<System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs>) : void
            public remove_FirstChanceException ($value: System.EventHandler$1<System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs>) : void
            public add_ReflectionOnlyAssemblyResolve ($value: System.ResolveEventHandler) : void
            public remove_ReflectionOnlyAssemblyResolve ($value: System.ResolveEventHandler) : void
            public ApplyPolicy ($assemblyName: string) : string
            public static CreateDomain ($friendlyName: string, $securityInfo: System.Security.Policy.Evidence, $appBasePath: string, $appRelativeSearchPath: string, $shadowCopyFiles: boolean, $adInit: System.AppDomainInitializer, $adInitArgs: System.Array$1<string>) : System.AppDomain
            public ExecuteAssemblyByName ($assemblyName: string) : number
            public ExecuteAssemblyByName ($assemblyName: string, ...args: string[]) : number
            public ExecuteAssemblyByName ($assemblyName: System.Reflection.AssemblyName, ...args: string[]) : number
            public IsDefaultAppDomain () : boolean
            public ReflectionOnlyGetAssemblies () : System.Array$1<System.Reflection.Assembly>
            public IsCompatibilitySwitchSet ($value: string) : boolean | null
            public GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            public GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            public GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            public Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
            public Equals ($other: any) : boolean
            public DefineDynamicAssembly ($name: System.Reflection.AssemblyName, $access: System.Reflection.Emit.AssemblyBuilderAccess, $evidence: System.Security.Policy.Evidence) : System.Reflection.Emit.AssemblyBuilder
            public DefineDynamicAssembly ($name: System.Reflection.AssemblyName, $access: System.Reflection.Emit.AssemblyBuilderAccess, $requiredPermissions: System.Security.PermissionSet, $optionalPermissions: System.Security.PermissionSet, $refusedPermissions: System.Security.PermissionSet) : System.Reflection.Emit.AssemblyBuilder
            public DefineDynamicAssembly ($name: System.Reflection.AssemblyName, $access: System.Reflection.Emit.AssemblyBuilderAccess, $dir: string, $evidence: System.Security.Policy.Evidence) : System.Reflection.Emit.AssemblyBuilder
            public DefineDynamicAssembly ($name: System.Reflection.AssemblyName, $access: System.Reflection.Emit.AssemblyBuilderAccess, $dir: string, $requiredPermissions: System.Security.PermissionSet, $optionalPermissions: System.Security.PermissionSet, $refusedPermissions: System.Security.PermissionSet) : System.Reflection.Emit.AssemblyBuilder
            public DefineDynamicAssembly ($name: System.Reflection.AssemblyName, $access: System.Reflection.Emit.AssemblyBuilderAccess, $evidence: System.Security.Policy.Evidence, $requiredPermissions: System.Security.PermissionSet, $optionalPermissions: System.Security.PermissionSet, $refusedPermissions: System.Security.PermissionSet) : System.Reflection.Emit.AssemblyBuilder
            public DefineDynamicAssembly ($name: System.Reflection.AssemblyName, $access: System.Reflection.Emit.AssemblyBuilderAccess, $dir: string, $evidence: System.Security.Policy.Evidence, $requiredPermissions: System.Security.PermissionSet, $optionalPermissions: System.Security.PermissionSet, $refusedPermissions: System.Security.PermissionSet) : System.Reflection.Emit.AssemblyBuilder
            public DefineDynamicAssembly ($name: System.Reflection.AssemblyName, $access: System.Reflection.Emit.AssemblyBuilderAccess, $dir: string, $evidence: System.Security.Policy.Evidence, $requiredPermissions: System.Security.PermissionSet, $optionalPermissions: System.Security.PermissionSet, $refusedPermissions: System.Security.PermissionSet, $isSynchronized: boolean) : System.Reflection.Emit.AssemblyBuilder
            public CreateInstance ($assemblyName: string, $typeName: string, $ignoreCase: boolean, $bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $args: System.Array$1<any>, $culture: System.Globalization.CultureInfo, $activationAttributes: System.Array$1<any>, $securityAttributes: System.Security.Policy.Evidence) : System.Runtime.Remoting.ObjectHandle
            public CreateInstanceFrom ($assemblyFile: string, $typeName: string, $ignoreCase: boolean, $bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $args: System.Array$1<any>, $culture: System.Globalization.CultureInfo, $activationAttributes: System.Array$1<any>, $securityAttributes: System.Security.Policy.Evidence) : System.Runtime.Remoting.ObjectHandle
            public Load ($rawAssembly: System.Array$1<number>, $rawSymbolStore: System.Array$1<number>, $securityEvidence: System.Security.Policy.Evidence) : System.Reflection.Assembly
            public Load ($assemblyRef: System.Reflection.AssemblyName, $assemblySecurity: System.Security.Policy.Evidence) : System.Reflection.Assembly
            public Load ($assemblyString: string, $assemblySecurity: System.Security.Policy.Evidence) : System.Reflection.Assembly
            public ExecuteAssembly ($assemblyFile: string, $assemblySecurity: System.Security.Policy.Evidence) : number
            public ExecuteAssembly ($assemblyFile: string, $assemblySecurity: System.Security.Policy.Evidence, $args: System.Array$1<string>) : number
            public AppendPrivatePath ($path: string) : void
            public ClearPrivatePath () : void
            public SetShadowCopyPath ($s: string) : void
            public ClearShadowCopyPath () : void
            public SetCachePath ($s: string) : void
            public DoCallBack ($theDelegate: System.CrossAppDomainDelegate) : void
            public SetAppDomainPolicy ($domainPolicy: System.Security.Policy.PolicyLevel) : void
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
        }
        interface _AppDomain
        {
            FriendlyName : string
            BaseDirectory : string
            RelativeSearchPath : string
            ShadowCopyFiles : boolean
            DynamicDirectory : string
            Evidence : System.Security.Policy.Evidence
            GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
            ToString () : string
            Equals ($other: any) : boolean
            GetHashCode () : number
            GetType () : System.Type
            InitializeLifetimeService () : any
            GetLifetimeService () : any
            add_DomainUnload ($value: System.EventHandler) : void
            remove_DomainUnload ($value: System.EventHandler) : void
            add_AssemblyLoad ($value: System.AssemblyLoadEventHandler) : void
            remove_AssemblyLoad ($value: System.AssemblyLoadEventHandler) : void
            add_ProcessExit ($value: System.EventHandler) : void
            remove_ProcessExit ($value: System.EventHandler) : void
            add_TypeResolve ($value: System.ResolveEventHandler) : void
            remove_TypeResolve ($value: System.ResolveEventHandler) : void
            add_ResourceResolve ($value: System.ResolveEventHandler) : void
            remove_ResourceResolve ($value: System.ResolveEventHandler) : void
            add_AssemblyResolve ($value: System.ResolveEventHandler) : void
            remove_AssemblyResolve ($value: System.ResolveEventHandler) : void
            add_UnhandledException ($value: System.UnhandledExceptionEventHandler) : void
            remove_UnhandledException ($value: System.UnhandledExceptionEventHandler) : void
            DefineDynamicAssembly ($name: System.Reflection.AssemblyName, $access: System.Reflection.Emit.AssemblyBuilderAccess) : System.Reflection.Emit.AssemblyBuilder
            DefineDynamicAssembly ($name: System.Reflection.AssemblyName, $access: System.Reflection.Emit.AssemblyBuilderAccess, $dir: string) : System.Reflection.Emit.AssemblyBuilder
            DefineDynamicAssembly ($name: System.Reflection.AssemblyName, $access: System.Reflection.Emit.AssemblyBuilderAccess, $evidence: System.Security.Policy.Evidence) : System.Reflection.Emit.AssemblyBuilder
            DefineDynamicAssembly ($name: System.Reflection.AssemblyName, $access: System.Reflection.Emit.AssemblyBuilderAccess, $requiredPermissions: System.Security.PermissionSet, $optionalPermissions: System.Security.PermissionSet, $refusedPermissions: System.Security.PermissionSet) : System.Reflection.Emit.AssemblyBuilder
            DefineDynamicAssembly ($name: System.Reflection.AssemblyName, $access: System.Reflection.Emit.AssemblyBuilderAccess, $dir: string, $evidence: System.Security.Policy.Evidence) : System.Reflection.Emit.AssemblyBuilder
            DefineDynamicAssembly ($name: System.Reflection.AssemblyName, $access: System.Reflection.Emit.AssemblyBuilderAccess, $dir: string, $requiredPermissions: System.Security.PermissionSet, $optionalPermissions: System.Security.PermissionSet, $refusedPermissions: System.Security.PermissionSet) : System.Reflection.Emit.AssemblyBuilder
            DefineDynamicAssembly ($name: System.Reflection.AssemblyName, $access: System.Reflection.Emit.AssemblyBuilderAccess, $evidence: System.Security.Policy.Evidence, $requiredPermissions: System.Security.PermissionSet, $optionalPermissions: System.Security.PermissionSet, $refusedPermissions: System.Security.PermissionSet) : System.Reflection.Emit.AssemblyBuilder
            DefineDynamicAssembly ($name: System.Reflection.AssemblyName, $access: System.Reflection.Emit.AssemblyBuilderAccess, $dir: string, $evidence: System.Security.Policy.Evidence, $requiredPermissions: System.Security.PermissionSet, $optionalPermissions: System.Security.PermissionSet, $refusedPermissions: System.Security.PermissionSet) : System.Reflection.Emit.AssemblyBuilder
            DefineDynamicAssembly ($name: System.Reflection.AssemblyName, $access: System.Reflection.Emit.AssemblyBuilderAccess, $dir: string, $evidence: System.Security.Policy.Evidence, $requiredPermissions: System.Security.PermissionSet, $optionalPermissions: System.Security.PermissionSet, $refusedPermissions: System.Security.PermissionSet, $isSynchronized: boolean) : System.Reflection.Emit.AssemblyBuilder
            CreateInstance ($assemblyName: string, $typeName: string) : System.Runtime.Remoting.ObjectHandle
            CreateInstanceFrom ($assemblyFile: string, $typeName: string) : System.Runtime.Remoting.ObjectHandle
            CreateInstance ($assemblyName: string, $typeName: string, $activationAttributes: System.Array$1<any>) : System.Runtime.Remoting.ObjectHandle
            CreateInstanceFrom ($assemblyFile: string, $typeName: string, $activationAttributes: System.Array$1<any>) : System.Runtime.Remoting.ObjectHandle
            CreateInstance ($assemblyName: string, $typeName: string, $ignoreCase: boolean, $bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $args: System.Array$1<any>, $culture: System.Globalization.CultureInfo, $activationAttributes: System.Array$1<any>, $securityAttributes: System.Security.Policy.Evidence) : System.Runtime.Remoting.ObjectHandle
            CreateInstanceFrom ($assemblyFile: string, $typeName: string, $ignoreCase: boolean, $bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $args: System.Array$1<any>, $culture: System.Globalization.CultureInfo, $activationAttributes: System.Array$1<any>, $securityAttributes: System.Security.Policy.Evidence) : System.Runtime.Remoting.ObjectHandle
            Load ($assemblyRef: System.Reflection.AssemblyName) : System.Reflection.Assembly
            Load ($assemblyString: string) : System.Reflection.Assembly
            Load ($rawAssembly: System.Array$1<number>) : System.Reflection.Assembly
            Load ($rawAssembly: System.Array$1<number>, $rawSymbolStore: System.Array$1<number>) : System.Reflection.Assembly
            Load ($rawAssembly: System.Array$1<number>, $rawSymbolStore: System.Array$1<number>, $securityEvidence: System.Security.Policy.Evidence) : System.Reflection.Assembly
            Load ($assemblyRef: System.Reflection.AssemblyName, $assemblySecurity: System.Security.Policy.Evidence) : System.Reflection.Assembly
            Load ($assemblyString: string, $assemblySecurity: System.Security.Policy.Evidence) : System.Reflection.Assembly
            ExecuteAssembly ($assemblyFile: string, $assemblySecurity: System.Security.Policy.Evidence) : number
            ExecuteAssembly ($assemblyFile: string) : number
            ExecuteAssembly ($assemblyFile: string, $assemblySecurity: System.Security.Policy.Evidence, $args: System.Array$1<string>) : number
            GetAssemblies () : System.Array$1<System.Reflection.Assembly>
            AppendPrivatePath ($path: string) : void
            ClearPrivatePath () : void
            SetShadowCopyPath ($s: string) : void
            ClearShadowCopyPath () : void
            SetCachePath ($s: string) : void
            SetData ($name: string, $data: any) : void
            GetData ($name: string) : any
            DoCallBack ($theDelegate: System.CrossAppDomainDelegate) : void
            SetAppDomainPolicy ($domainPolicy: System.Security.Policy.PolicyLevel) : void
            SetPrincipalPolicy ($policy: System.Security.Principal.PrincipalPolicy) : void
            SetThreadPrincipal ($principal: System.Security.Principal.IPrincipal) : void
        }
        class ActivationContext extends System.Object implements System.Runtime.Serialization.ISerializable, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get Form(): System.ActivationContext.ContextForm;
            public get Identity(): System.ApplicationIdentity;
            public get ApplicationManifestBytes(): System.Array$1<number>;
            public get DeploymentManifestBytes(): System.Array$1<number>;
            public static CreatePartialActivationContext ($identity: System.ApplicationIdentity) : System.ActivationContext
            public static CreatePartialActivationContext ($identity: System.ApplicationIdentity, $manifestPaths: System.Array$1<string>) : System.ActivationContext
            public Dispose () : void
        }
        class Buffer extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static ByteLength ($array: System.Array) : number
            public static GetByte ($array: System.Array, $index: number) : number
            public static SetByte ($array: System.Array, $index: number, $value: number) : void
            public static BlockCopy ($src: System.Array, $srcOffset: number, $dst: System.Array, $dstOffset: number, $count: number) : void
        }
        class ContextBoundObject extends System.MarshalByRefObject
        {
            protected [__keep_incompatibility]: never;
        }
        class ContextMarshalException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $inner: System.Exception)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class ContextStaticAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        enum GCCollectionMode
        { Default = 0, Forced = 1, Optimized = 2 }
        enum GCNotificationStatus
        { Succeeded = 0, Failed = 1, Canceled = 2, Timeout = 3, NotApplicable = 4 }
        class GC extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get MaxGeneration(): number;
            public static GetAllocatedBytesForCurrentThread () : bigint
            public static AddMemoryPressure ($bytesAllocated: bigint) : void
            public static RemoveMemoryPressure ($bytesAllocated: bigint) : void
            public static GetGeneration ($obj: any) : number
            public static Collect ($generation: number) : void
            public static Collect () : void
            public static Collect ($generation: number, $mode: System.GCCollectionMode) : void
            public static Collect ($generation: number, $mode: System.GCCollectionMode, $blocking: boolean) : void
            public static Collect ($generation: number, $mode: System.GCCollectionMode, $blocking: boolean, $compacting: boolean) : void
            public static CollectionCount ($generation: number) : number
            public static KeepAlive ($obj: any) : void
            public static GetGeneration ($wo: System.WeakReference) : number
            public static WaitForPendingFinalizers () : void
            public static SuppressFinalize ($obj: any) : void
            public static ReRegisterForFinalize ($obj: any) : void
            public static GetTotalMemory ($forceFullCollection: boolean) : bigint
            public static RegisterForFullGCNotification ($maxGenerationThreshold: number, $largeObjectHeapThreshold: number) : void
            public static CancelFullGCNotification () : void
            public static WaitForFullGCApproach () : System.GCNotificationStatus
            public static WaitForFullGCApproach ($millisecondsTimeout: number) : System.GCNotificationStatus
            public static WaitForFullGCComplete () : System.GCNotificationStatus
            public static WaitForFullGCComplete ($millisecondsTimeout: number) : System.GCNotificationStatus
            public static TryStartNoGCRegion ($totalSize: bigint) : boolean
            public static TryStartNoGCRegion ($totalSize: bigint, $lohSize: bigint) : boolean
            public static TryStartNoGCRegion ($totalSize: bigint, $disallowFullBlockingGC: boolean) : boolean
            public static TryStartNoGCRegion ($totalSize: bigint, $lohSize: bigint, $disallowFullBlockingGC: boolean) : boolean
            public static EndNoGCRegion () : void
        }
        class WeakReference extends System.Object implements System.Runtime.Serialization.ISerializable
        {
            protected [__keep_incompatibility]: never;
            public get IsAlive(): boolean;
            public get Target(): any;
            public set Target(value: any);
            public get TrackResurrection(): boolean;
            public GetObjectData ($info: System.Runtime.Serialization.SerializationInfo, $context: System.Runtime.Serialization.StreamingContext) : void
            public constructor ($target: any)
            public constructor ($target: any, $trackResurrection: boolean)
            public constructor ()
        }
        interface CrossAppDomainDelegate
        { 
        () : void; 
        Invoke?: () => void;
        }
        var CrossAppDomainDelegate: { new (func: () => void): CrossAppDomainDelegate; }
        interface IAppDomainSetup
        {
            ApplicationBase : string
            ApplicationName : string
            CachePath : string
            ConfigurationFile : string
            DynamicBase : string
            LicenseFile : string
            PrivateBinPath : string
            PrivateBinPathProbe : string
            ShadowCopyDirectories : string
            ShadowCopyFiles : string
        }
        class TypedReference extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class AppDomainSetup extends System.Object implements System.IAppDomainSetup
        {
            protected [__keep_incompatibility]: never;
            public get ApplicationBase(): string;
            public set ApplicationBase(value: string);
            public get ApplicationName(): string;
            public set ApplicationName(value: string);
            public get CachePath(): string;
            public set CachePath(value: string);
            public get ConfigurationFile(): string;
            public set ConfigurationFile(value: string);
            public get DisallowPublisherPolicy(): boolean;
            public set DisallowPublisherPolicy(value: boolean);
            public get DynamicBase(): string;
            public set DynamicBase(value: string);
            public get LicenseFile(): string;
            public set LicenseFile(value: string);
            public get LoaderOptimization(): System.LoaderOptimization;
            public set LoaderOptimization(value: System.LoaderOptimization);
            public get AppDomainManagerAssembly(): string;
            public set AppDomainManagerAssembly(value: string);
            public get AppDomainManagerType(): string;
            public set AppDomainManagerType(value: string);
            public get PartialTrustVisibleAssemblies(): System.Array$1<string>;
            public set PartialTrustVisibleAssemblies(value: System.Array$1<string>);
            public get PrivateBinPath(): string;
            public set PrivateBinPath(value: string);
            public get PrivateBinPathProbe(): string;
            public set PrivateBinPathProbe(value: string);
            public get ShadowCopyDirectories(): string;
            public set ShadowCopyDirectories(value: string);
            public get ShadowCopyFiles(): string;
            public set ShadowCopyFiles(value: string);
            public get DisallowBindingRedirects(): boolean;
            public set DisallowBindingRedirects(value: boolean);
            public get DisallowCodeDownload(): boolean;
            public set DisallowCodeDownload(value: boolean);
            public get TargetFrameworkName(): string;
            public set TargetFrameworkName(value: string);
            public get ActivationArguments(): System.Runtime.Hosting.ActivationArguments;
            public set ActivationArguments(value: System.Runtime.Hosting.ActivationArguments);
            public get AppDomainInitializer(): System.AppDomainInitializer;
            public set AppDomainInitializer(value: System.AppDomainInitializer);
            public get AppDomainInitializerArguments(): System.Array$1<string>;
            public set AppDomainInitializerArguments(value: System.Array$1<string>);
            public get ApplicationTrust(): System.Security.Policy.ApplicationTrust;
            public set ApplicationTrust(value: System.Security.Policy.ApplicationTrust);
            public get DisallowApplicationBaseProbing(): boolean;
            public set DisallowApplicationBaseProbing(value: boolean);
            public get SandboxInterop(): boolean;
            public set SandboxInterop(value: boolean);
            public GetConfigurationBytes () : System.Array$1<number>
            public SetConfigurationBytes ($value: System.Array$1<number>) : void
            public SetCompatibilitySwitches ($switches: System.Collections.Generic.IEnumerable$1<string>) : void
            public SetNativeFunction ($functionName: string, $functionVersion: number, $functionPointer: System.IntPtr) : void
            public constructor ()
            public constructor ($activationArguments: System.Runtime.Hosting.ActivationArguments)
            public constructor ($activationContext: System.ActivationContext)
        }
        class AppDomainManager extends System.MarshalByRefObject
        {
            protected [__keep_incompatibility]: never;
            public get ApplicationActivator(): System.Runtime.Hosting.ApplicationActivator;
            public get EntryAssembly(): System.Reflection.Assembly;
            public get HostExecutionContextManager(): System.Threading.HostExecutionContextManager;
            public get HostSecurityManager(): System.Security.HostSecurityManager;
            public get InitializationFlags(): System.AppDomainManagerInitializationOptions;
            public set InitializationFlags(value: System.AppDomainManagerInitializationOptions);
            public CreateDomain ($friendlyName: string, $securityInfo: System.Security.Policy.Evidence, $appDomainInfo: System.AppDomainSetup) : System.AppDomain
            public InitializeNewDomain ($appDomainInfo: System.AppDomainSetup) : void
            public CheckSecuritySettings ($state: System.Security.SecurityState) : boolean
            public constructor ()
        }
        class ApplicationIdentity extends System.Object implements System.Runtime.Serialization.ISerializable
        {
            protected [__keep_incompatibility]: never;
            public get CodeBase(): string;
            public get FullName(): string;
            public constructor ($applicationIdentityFullName: string)
            public constructor ()
        }
        interface AppDomainInitializer
        { 
        (args: System.Array$1<string>) : void; 
        Invoke?: (args: System.Array$1<string>) => void;
        }
        var AppDomainInitializer: { new (func: (args: System.Array$1<string>) => void): AppDomainInitializer; }
        class Environment extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get CommandLine(): string;
            public static get CurrentDirectory(): string;
            public static set CurrentDirectory(value: string);
            public static get CurrentManagedThreadId(): number;
            public static get ExitCode(): number;
            public static set ExitCode(value: number);
            public static get HasShutdownStarted(): boolean;
            public static get MachineName(): string;
            public static get NewLine(): string;
            public static get OSVersion(): System.OperatingSystem;
            public static get StackTrace(): string;
            public static get SystemDirectory(): string;
            public static get TickCount(): number;
            public static get UserDomainName(): string;
            public static get UserInteractive(): boolean;
            public static get UserName(): string;
            public static get Version(): System.Version;
            public static get WorkingSet(): bigint;
            public static get Is64BitOperatingSystem(): boolean;
            public static get SystemPageSize(): number;
            public static get Is64BitProcess(): boolean;
            public static get ProcessorCount(): number;
            public static Exit ($exitCode: number) : void
            public static ExpandEnvironmentVariables ($name: string) : string
            public static GetCommandLineArgs () : System.Array$1<string>
            public static GetEnvironmentVariable ($variable: string) : string
            public static GetEnvironmentVariables () : System.Collections.IDictionary
            public static GetFolderPath ($folder: System.Environment.SpecialFolder) : string
            public static GetFolderPath ($folder: System.Environment.SpecialFolder, $option: System.Environment.SpecialFolderOption) : string
            public static GetLogicalDrives () : System.Array$1<string>
            public static GetEnvironmentVariable ($variable: string, $target: System.EnvironmentVariableTarget) : string
            public static GetEnvironmentVariables ($target: System.EnvironmentVariableTarget) : System.Collections.IDictionary
            public static SetEnvironmentVariable ($variable: string, $value: string) : void
            public static SetEnvironmentVariable ($variable: string, $value: string, $target: System.EnvironmentVariableTarget) : void
            public static FailFast ($message: string) : void
            public static FailFast ($message: string, $exception: System.Exception) : void
        }
        enum EnvironmentVariableTarget
        { Process = 0, User = 1, Machine = 2 }
        enum AppDomainManagerInitializationOptions
        { None = 0, RegisterWithHost = 1 }
        class ArgIterator extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public End () : void
            public GetNextArgType () : System.RuntimeTypeHandle
            public GetRemainingCount () : number
        }
        class RuntimeArgumentHandle extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class Console extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get Error(): System.IO.TextWriter;
            public static get Out(): System.IO.TextWriter;
            public static get In(): System.IO.TextReader;
            public static get InputEncoding(): System.Text.Encoding;
            public static set InputEncoding(value: System.Text.Encoding);
            public static get OutputEncoding(): System.Text.Encoding;
            public static set OutputEncoding(value: System.Text.Encoding);
            public static get BackgroundColor(): System.ConsoleColor;
            public static set BackgroundColor(value: System.ConsoleColor);
            public static get BufferHeight(): number;
            public static set BufferHeight(value: number);
            public static get BufferWidth(): number;
            public static set BufferWidth(value: number);
            public static get CapsLock(): boolean;
            public static get CursorLeft(): number;
            public static set CursorLeft(value: number);
            public static get CursorTop(): number;
            public static set CursorTop(value: number);
            public static get CursorSize(): number;
            public static set CursorSize(value: number);
            public static get CursorVisible(): boolean;
            public static set CursorVisible(value: boolean);
            public static get ForegroundColor(): System.ConsoleColor;
            public static set ForegroundColor(value: System.ConsoleColor);
            public static get KeyAvailable(): boolean;
            public static get LargestWindowHeight(): number;
            public static get LargestWindowWidth(): number;
            public static get NumberLock(): boolean;
            public static get Title(): string;
            public static set Title(value: string);
            public static get TreatControlCAsInput(): boolean;
            public static set TreatControlCAsInput(value: boolean);
            public static get WindowHeight(): number;
            public static set WindowHeight(value: number);
            public static get WindowLeft(): number;
            public static set WindowLeft(value: number);
            public static get WindowTop(): number;
            public static set WindowTop(value: number);
            public static get WindowWidth(): number;
            public static set WindowWidth(value: number);
            public static get IsErrorRedirected(): boolean;
            public static get IsOutputRedirected(): boolean;
            public static get IsInputRedirected(): boolean;
            public static OpenStandardError () : System.IO.Stream
            public static OpenStandardError ($bufferSize: number) : System.IO.Stream
            public static OpenStandardInput () : System.IO.Stream
            public static OpenStandardInput ($bufferSize: number) : System.IO.Stream
            public static OpenStandardOutput () : System.IO.Stream
            public static OpenStandardOutput ($bufferSize: number) : System.IO.Stream
            public static SetError ($newError: System.IO.TextWriter) : void
            public static SetIn ($newIn: System.IO.TextReader) : void
            public static SetOut ($newOut: System.IO.TextWriter) : void
            public static Write ($value: boolean) : void
            public static Write ($value: number) : void
            public static Write ($buffer: System.Array$1<number>) : void
            public static Write ($value: System.Decimal) : void
            public static Write ($value: bigint) : void
            public static Write ($value: any) : void
            public static Write ($value: string) : void
            public static Write ($format: string, $arg0: any) : void
            public static Write ($format: string, ...arg: any[]) : void
            public static Write ($buffer: System.Array$1<number>, $index: number, $count: number) : void
            public static Write ($format: string, $arg0: any, $arg1: any) : void
            public static Write ($format: string, $arg0: any, $arg1: any, $arg2: any) : void
            public static Write ($format: string, $arg0: any, $arg1: any, $arg2: any, $arg3: any) : void
            public static WriteLine () : void
            public static WriteLine ($value: boolean) : void
            public static WriteLine ($value: number) : void
            public static WriteLine ($buffer: System.Array$1<number>) : void
            public static WriteLine ($value: System.Decimal) : void
            public static WriteLine ($value: bigint) : void
            public static WriteLine ($value: any) : void
            public static WriteLine ($value: string) : void
            public static WriteLine ($format: string, $arg0: any) : void
            public static WriteLine ($format: string, ...arg: any[]) : void
            public static WriteLine ($buffer: System.Array$1<number>, $index: number, $count: number) : void
            public static WriteLine ($format: string, $arg0: any, $arg1: any) : void
            public static WriteLine ($format: string, $arg0: any, $arg1: any, $arg2: any) : void
            public static WriteLine ($format: string, $arg0: any, $arg1: any, $arg2: any, $arg3: any) : void
            public static Read () : number
            public static ReadLine () : string
            public static Beep () : void
            public static Beep ($frequency: number, $duration: number) : void
            public static Clear () : void
            public static MoveBufferArea ($sourceLeft: number, $sourceTop: number, $sourceWidth: number, $sourceHeight: number, $targetLeft: number, $targetTop: number) : void
            public static MoveBufferArea ($sourceLeft: number, $sourceTop: number, $sourceWidth: number, $sourceHeight: number, $targetLeft: number, $targetTop: number, $sourceChar: number, $sourceForeColor: System.ConsoleColor, $sourceBackColor: System.ConsoleColor) : void
            public static ReadKey () : System.ConsoleKeyInfo
            public static ReadKey ($intercept: boolean) : System.ConsoleKeyInfo
            public static ResetColor () : void
            public static SetBufferSize ($width: number, $height: number) : void
            public static SetCursorPosition ($left: number, $top: number) : void
            public static SetWindowPosition ($left: number, $top: number) : void
            public static SetWindowSize ($width: number, $height: number) : void
            public static add_CancelKeyPress ($value: System.ConsoleCancelEventHandler) : void
            public static remove_CancelKeyPress ($value: System.ConsoleCancelEventHandler) : void
        }
        class ModuleHandle extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public static EmptyHandle : System.ModuleHandle
            public get MDStreamVersion(): number;
            public ResolveFieldHandle ($fieldToken: number) : System.RuntimeFieldHandle
            public ResolveMethodHandle ($methodToken: number) : System.RuntimeMethodHandle
            public ResolveTypeHandle ($typeToken: number) : System.RuntimeTypeHandle
            public ResolveTypeHandle ($typeToken: number, $typeInstantiationContext: System.Array$1<System.RuntimeTypeHandle>, $methodInstantiationContext: System.Array$1<System.RuntimeTypeHandle>) : System.RuntimeTypeHandle
            public ResolveMethodHandle ($methodToken: number, $typeInstantiationContext: System.Array$1<System.RuntimeTypeHandle>, $methodInstantiationContext: System.Array$1<System.RuntimeTypeHandle>) : System.RuntimeMethodHandle
            public ResolveFieldHandle ($fieldToken: number, $typeInstantiationContext: System.Array$1<System.RuntimeTypeHandle>, $methodInstantiationContext: System.Array$1<System.RuntimeTypeHandle>) : System.RuntimeFieldHandle
            public GetRuntimeFieldHandleFromMetadataToken ($fieldToken: number) : System.RuntimeFieldHandle
            public GetRuntimeMethodHandleFromMetadataToken ($methodToken: number) : System.RuntimeMethodHandle
            public GetRuntimeTypeHandleFromMetadataToken ($typeToken: number) : System.RuntimeTypeHandle
            public Equals ($obj: any) : boolean
            public Equals ($handle: System.ModuleHandle) : boolean
            public static op_Equality ($left: System.ModuleHandle, $right: System.ModuleHandle) : boolean
            public static op_Inequality ($left: System.ModuleHandle, $right: System.ModuleHandle) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
        }
        class RuntimeFieldHandle extends System.ValueType implements System.Runtime.Serialization.ISerializable
        {
            protected [__keep_incompatibility]: never;
            public get Value(): System.IntPtr;
            public GetObjectData ($info: System.Runtime.Serialization.SerializationInfo, $context: System.Runtime.Serialization.StreamingContext) : void
            public Equals ($obj: any) : boolean
            public Equals ($handle: System.RuntimeFieldHandle) : boolean
            public static op_Equality ($left: System.RuntimeFieldHandle, $right: System.RuntimeFieldHandle) : boolean
            public static op_Inequality ($left: System.RuntimeFieldHandle, $right: System.RuntimeFieldHandle) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
        }
        class RuntimeMethodHandle extends System.ValueType implements System.Runtime.Serialization.ISerializable
        {
            protected [__keep_incompatibility]: never;
            public get Value(): System.IntPtr;
            public GetObjectData ($info: System.Runtime.Serialization.SerializationInfo, $context: System.Runtime.Serialization.StreamingContext) : void
            public GetFunctionPointer () : System.IntPtr
            public Equals ($obj: any) : boolean
            public Equals ($handle: System.RuntimeMethodHandle) : boolean
            public static op_Equality ($left: System.RuntimeMethodHandle, $right: System.RuntimeMethodHandle) : boolean
            public static op_Inequality ($left: System.RuntimeMethodHandle, $right: System.RuntimeMethodHandle) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
        }
        class UIntPtr extends System.ValueType implements System.Runtime.Serialization.ISerializable, System.IEquatable$1<System.UIntPtr>
        {
            protected [__keep_incompatibility]: never;
            public static Zero : System.UIntPtr
            public static get Size(): number;
            public ToUInt32 () : number
            public ToUInt64 () : bigint
            public static op_Equality ($value1: System.UIntPtr, $value2: System.UIntPtr) : boolean
            public static op_Inequality ($value1: System.UIntPtr, $value2: System.UIntPtr) : boolean
            public static op_Explicit ($value: System.UIntPtr) : bigint
            public static op_Explicit ($value: System.UIntPtr) : number
            public static op_Explicit ($value: bigint) : System.UIntPtr
            public static op_Explicit ($value: number) : System.UIntPtr
            public static Add ($pointer: System.UIntPtr, $offset: number) : System.UIntPtr
            public static Subtract ($pointer: System.UIntPtr, $offset: number) : System.UIntPtr
            public static op_Addition ($pointer: System.UIntPtr, $offset: number) : System.UIntPtr
            public static op_Subtraction ($pointer: System.UIntPtr, $offset: number) : System.UIntPtr
            public constructor ($value: bigint)
            public constructor ($value: number)
            public constructor ()
        }
        class WeakReference$1<T> extends System.Object implements System.Runtime.Serialization.ISerializable
        {
            protected [__keep_incompatibility]: never;
            public GetObjectData ($info: System.Runtime.Serialization.SerializationInfo, $context: System.Runtime.Serialization.StreamingContext) : void
            public SetTarget ($target: T) : void
            public TryGetTarget ($target: $Ref<T>) : boolean
            public constructor ($target: T)
            public constructor ($target: T, $trackResurrection: boolean)
            public constructor ()
        }
    }
    namespace Microsoft.Win32 {
        class Registry extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static CurrentUser : Microsoft.Win32.RegistryKey
            public static LocalMachine : Microsoft.Win32.RegistryKey
            public static ClassesRoot : Microsoft.Win32.RegistryKey
            public static Users : Microsoft.Win32.RegistryKey
            public static PerformanceData : Microsoft.Win32.RegistryKey
            public static CurrentConfig : Microsoft.Win32.RegistryKey
            public static GetValue ($keyName: string, $valueName: string, $defaultValue: any) : any
            public static SetValue ($keyName: string, $valueName: string, $value: any) : void
            public static SetValue ($keyName: string, $valueName: string, $value: any, $valueKind: Microsoft.Win32.RegistryValueKind) : void
        }
        class RegistryKey extends System.MarshalByRefObject implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get SubKeyCount(): number;
            public get View(): Microsoft.Win32.RegistryView;
            public get Handle(): Microsoft.Win32.SafeHandles.SafeRegistryHandle;
            public get ValueCount(): number;
            public get Name(): string;
            public Flush () : void
            public Close () : void
            public Dispose () : void
            public CreateSubKey ($subkey: string) : Microsoft.Win32.RegistryKey
            public CreateSubKey ($subkey: string, $writable: boolean) : Microsoft.Win32.RegistryKey
            public CreateSubKey ($subkey: string, $writable: boolean, $options: Microsoft.Win32.RegistryOptions) : Microsoft.Win32.RegistryKey
            public CreateSubKey ($subkey: string, $permissionCheck: Microsoft.Win32.RegistryKeyPermissionCheck) : Microsoft.Win32.RegistryKey
            public CreateSubKey ($subkey: string, $permissionCheck: Microsoft.Win32.RegistryKeyPermissionCheck, $registryOptions: Microsoft.Win32.RegistryOptions) : Microsoft.Win32.RegistryKey
            public CreateSubKey ($subkey: string, $permissionCheck: Microsoft.Win32.RegistryKeyPermissionCheck, $registryOptions: Microsoft.Win32.RegistryOptions, $registrySecurity: System.Security.AccessControl.RegistrySecurity) : Microsoft.Win32.RegistryKey
            public CreateSubKey ($subkey: string, $permissionCheck: Microsoft.Win32.RegistryKeyPermissionCheck, $registrySecurity: System.Security.AccessControl.RegistrySecurity) : Microsoft.Win32.RegistryKey
            public DeleteSubKey ($subkey: string) : void
            public DeleteSubKey ($subkey: string, $throwOnMissingSubKey: boolean) : void
            public DeleteSubKeyTree ($subkey: string) : void
            public DeleteSubKeyTree ($subkey: string, $throwOnMissingSubKey: boolean) : void
            public DeleteValue ($name: string) : void
            public DeleteValue ($name: string, $throwOnMissingValue: boolean) : void
            public static OpenBaseKey ($hKey: Microsoft.Win32.RegistryHive, $view: Microsoft.Win32.RegistryView) : Microsoft.Win32.RegistryKey
            public static OpenRemoteBaseKey ($hKey: Microsoft.Win32.RegistryHive, $machineName: string) : Microsoft.Win32.RegistryKey
            public static OpenRemoteBaseKey ($hKey: Microsoft.Win32.RegistryHive, $machineName: string, $view: Microsoft.Win32.RegistryView) : Microsoft.Win32.RegistryKey
            public OpenSubKey ($name: string) : Microsoft.Win32.RegistryKey
            public OpenSubKey ($name: string, $writable: boolean) : Microsoft.Win32.RegistryKey
            public OpenSubKey ($name: string, $permissionCheck: Microsoft.Win32.RegistryKeyPermissionCheck) : Microsoft.Win32.RegistryKey
            public OpenSubKey ($name: string, $rights: System.Security.AccessControl.RegistryRights) : Microsoft.Win32.RegistryKey
            public OpenSubKey ($name: string, $permissionCheck: Microsoft.Win32.RegistryKeyPermissionCheck, $rights: System.Security.AccessControl.RegistryRights) : Microsoft.Win32.RegistryKey
            public GetAccessControl () : System.Security.AccessControl.RegistrySecurity
            public GetAccessControl ($includeSections: System.Security.AccessControl.AccessControlSections) : System.Security.AccessControl.RegistrySecurity
            public SetAccessControl ($registrySecurity: System.Security.AccessControl.RegistrySecurity) : void
            public static FromHandle ($handle: Microsoft.Win32.SafeHandles.SafeRegistryHandle) : Microsoft.Win32.RegistryKey
            public static FromHandle ($handle: Microsoft.Win32.SafeHandles.SafeRegistryHandle, $view: Microsoft.Win32.RegistryView) : Microsoft.Win32.RegistryKey
            public GetSubKeyNames () : System.Array$1<string>
            public GetValueNames () : System.Array$1<string>
            public GetValue ($name: string) : any
            public GetValue ($name: string, $defaultValue: any) : any
            public GetValue ($name: string, $defaultValue: any, $options: Microsoft.Win32.RegistryValueOptions) : any
            public GetValueKind ($name: string) : Microsoft.Win32.RegistryValueKind
            public SetValue ($name: string, $value: any) : void
            public SetValue ($name: string, $value: any, $valueKind: Microsoft.Win32.RegistryValueKind) : void
        }
        enum RegistryValueKind
        { String = 1, ExpandString = 2, Binary = 3, DWord = 4, MultiString = 7, QWord = 11, Unknown = 0, None = -1 }
        enum RegistryHive
        { ClassesRoot = -2147483648, CurrentUser = -2147483647, LocalMachine = -2147483646, Users = -2147483645, PerformanceData = -2147483644, CurrentConfig = -2147483643, DynData = -2147483642 }
        enum RegistryOptions
        { None = 0, Volatile = 1 }
        enum RegistryKeyPermissionCheck
        { Default = 0, ReadSubTree = 1, ReadWriteSubTree = 2 }
        enum RegistryView
        { Default = 0, Registry64 = 256, Registry32 = 512 }
        enum RegistryValueOptions
        { None = 0, DoNotExpandEnvironmentNames = 1 }
    }
    namespace System.Collections.Generic {
        interface IEnumerable$1<T> extends System.Collections.IEnumerable
        {
            GetEnumerator () : System.Collections.IEnumerator
        }
        interface IEnumerator$1<T> extends System.Collections.IEnumerator, System.IDisposable
        {
        }
        interface IReadOnlyList$1<T> extends System.Collections.Generic.IEnumerable$1<T>, System.Collections.IEnumerable, System.Collections.Generic.IReadOnlyCollection$1<T>
        {
            GetEnumerator () : System.Collections.IEnumerator
        }
        interface IReadOnlyCollection$1<T> extends System.Collections.Generic.IEnumerable$1<T>, System.Collections.IEnumerable
        {
            GetEnumerator () : System.Collections.IEnumerator
        }
        interface IList$1<T> extends System.Collections.Generic.IEnumerable$1<T>, System.Collections.IEnumerable, System.Collections.Generic.ICollection$1<T>
        {
            GetEnumerator () : System.Collections.IEnumerator
        }
        interface ICollection$1<T> extends System.Collections.Generic.IEnumerable$1<T>, System.Collections.IEnumerable
        {
            GetEnumerator () : System.Collections.IEnumerator
        }
        interface IEqualityComparer$1<T>
        {
            Equals ($x: T, $y: T) : boolean
            GetHashCode ($obj: T) : number
        }
        interface IComparer$1<T>
        {
            Compare ($x: T, $y: T) : number
        }
        interface IAsyncEnumerable$1<T>
        {
            GetAsyncEnumerator ($cancellationToken?: System.Threading.CancellationToken) : System.Collections.Generic.IAsyncEnumerator$1<T>
        }
        interface IDictionary$2<TKey, TValue> extends System.Collections.Generic.IEnumerable$1<System.Collections.Generic.KeyValuePair$2<TKey, TValue>>, System.Collections.IEnumerable, System.Collections.Generic.ICollection$1<System.Collections.Generic.KeyValuePair$2<TKey, TValue>>
        {
            Keys : System.Collections.Generic.ICollection$1<TKey>
            Values : System.Collections.Generic.ICollection$1<TValue>
            get_Item ($key: TKey) : TValue
            set_Item ($key: TKey, $value: TValue) : void
            ContainsKey ($key: TKey) : boolean
            Add ($key: TKey, $value: TValue) : void
            Remove ($key: TKey) : boolean
            TryGetValue ($key: TKey, $value: $Ref<TValue>) : boolean
            GetEnumerator () : System.Collections.IEnumerator
        }
        class KeyValuePair$2<TKey, TValue> extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get Key(): TKey;
            public get Value(): TValue;
            public Deconstruct ($key: $Ref<TKey>, $value: $Ref<TValue>) : void
            public constructor ($key: TKey, $value: TValue)
            public constructor ()
        }
        class Dictionary$2<TKey, TValue> extends System.Object implements System.Runtime.Serialization.IDeserializationCallback, System.Collections.Generic.IReadOnlyDictionary$2<TKey, TValue>, System.Collections.Generic.IDictionary$2<TKey, TValue>, System.Runtime.Serialization.ISerializable, System.Collections.ICollection, System.Collections.IDictionary, System.Collections.Generic.IEnumerable$1<System.Collections.Generic.KeyValuePair$2<TKey, TValue>>, System.Collections.IEnumerable, System.Collections.Generic.IReadOnlyCollection$1<System.Collections.Generic.KeyValuePair$2<TKey, TValue>>, System.Collections.Generic.ICollection$1<System.Collections.Generic.KeyValuePair$2<TKey, TValue>>
        {
            protected [__keep_incompatibility]: never;
            public get Comparer(): System.Collections.Generic.IEqualityComparer$1<TKey>;
            public get Count(): number;
            public get Keys(): System.Collections.Generic.Dictionary$2.KeyCollection<TKey, TValue>;
            public get Values(): System.Collections.Generic.Dictionary$2.ValueCollection<TKey, TValue>;
            public get SyncRoot(): any;
            public get IsSynchronized(): boolean;
            public get IsReadOnly(): boolean;
            public get IsFixedSize(): boolean;
            public get_Item ($key: TKey) : TValue
            public set_Item ($key: TKey, $value: TValue) : void
            public Add ($key: TKey, $value: TValue) : void
            public Clear () : void
            public ContainsKey ($key: TKey) : boolean
            public ContainsValue ($value: TValue) : boolean
            public GetEnumerator () : System.Collections.Generic.Dictionary$2.Enumerator<TKey, TValue>
            public GetObjectData ($info: System.Runtime.Serialization.SerializationInfo, $context: System.Runtime.Serialization.StreamingContext) : void
            public OnDeserialization ($sender: any) : void
            public Remove ($key: TKey) : boolean
            public Remove ($key: TKey, $value: $Ref<TValue>) : boolean
            public TryGetValue ($key: TKey, $value: $Ref<TValue>) : boolean
            public TryAdd ($key: TKey, $value: TValue) : boolean
            public EnsureCapacity ($capacity: number) : number
            public TrimExcess () : void
            public TrimExcess ($capacity: number) : void
            public constructor ()
            public constructor ($capacity: number)
            public constructor ($comparer: System.Collections.Generic.IEqualityComparer$1<TKey>)
            public constructor ($capacity: number, $comparer: System.Collections.Generic.IEqualityComparer$1<TKey>)
            public constructor ($dictionary: System.Collections.Generic.IDictionary$2<TKey, TValue>)
            public constructor ($dictionary: System.Collections.Generic.IDictionary$2<TKey, TValue>, $comparer: System.Collections.Generic.IEqualityComparer$1<TKey>)
            public constructor ($collection: System.Collections.Generic.IEnumerable$1<System.Collections.Generic.KeyValuePair$2<TKey, TValue>>)
            public constructor ($collection: System.Collections.Generic.IEnumerable$1<System.Collections.Generic.KeyValuePair$2<TKey, TValue>>, $comparer: System.Collections.Generic.IEqualityComparer$1<TKey>)
            public CopyTo ($array: System.Array, $index: number) : void
            public GetEnumerator () : System.Collections.IEnumerator
            public get_Item ($key: any) : any
            public set_Item ($key: any, $value: any) : void
            public Contains ($key: any) : boolean
            public Add ($key: any, $value: any) : void
            public GetEnumerator () : System.Collections.IDictionaryEnumerator
            public Remove ($key: any) : void
            public [Symbol.iterator]() : IterableIterator<System.Collections.Generic.KeyValuePair$2<TKey, TValue>>
        }
        interface IReadOnlyDictionary$2<TKey, TValue> extends System.Collections.Generic.IEnumerable$1<System.Collections.Generic.KeyValuePair$2<TKey, TValue>>, System.Collections.IEnumerable, System.Collections.Generic.IReadOnlyCollection$1<System.Collections.Generic.KeyValuePair$2<TKey, TValue>>
        {
            Keys : System.Collections.Generic.IEnumerable$1<TKey>
            Values : System.Collections.Generic.IEnumerable$1<TValue>
            ContainsKey ($key: TKey) : boolean
            TryGetValue ($key: TKey, $value: $Ref<TValue>) : boolean
            get_Item ($key: TKey) : TValue
            GetEnumerator () : System.Collections.IEnumerator
        }
        interface IAsyncEnumerator$1<T> extends System.IAsyncDisposable
        {
            Current : T
            MoveNextAsync () : System.Threading.Tasks.ValueTask$1<boolean>
            DisposeAsync () : System.Threading.Tasks.ValueTask
            ConfigureAwait ($continueOnCapturedContext: boolean) : System.Runtime.CompilerServices.ConfiguredAsyncDisposable
        }
        class KeyNotFoundException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class KeyValuePair extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class List$1<T> extends System.Object implements System.Collections.Generic.IReadOnlyList$1<T>, System.Collections.ICollection, System.Collections.Generic.IEnumerable$1<T>, System.Collections.IEnumerable, System.Collections.Generic.IList$1<T>, System.Collections.Generic.IReadOnlyCollection$1<T>, System.Collections.IList, System.Collections.Generic.ICollection$1<T>
        {
            protected [__keep_incompatibility]: never;
            public get Capacity(): number;
            public set Capacity(value: number);
            public get Count(): number;
            public get SyncRoot(): any;
            public get IsSynchronized(): boolean;
            public get IsReadOnly(): boolean;
            public get IsFixedSize(): boolean;
            public get_Item ($index: number) : T
            public set_Item ($index: number, $value: T) : void
            public Add ($item: T) : void
            public AddRange ($collection: System.Collections.Generic.IEnumerable$1<T>) : void
            public AsReadOnly () : System.Collections.ObjectModel.ReadOnlyCollection$1<T>
            public BinarySearch ($index: number, $count: number, $item: T, $comparer: System.Collections.Generic.IComparer$1<T>) : number
            public BinarySearch ($item: T) : number
            public BinarySearch ($item: T, $comparer: System.Collections.Generic.IComparer$1<T>) : number
            public Clear () : void
            public Contains ($item: T) : boolean
            public CopyTo ($array: System.Array$1<T>) : void
            public CopyTo ($index: number, $array: System.Array$1<T>, $arrayIndex: number, $count: number) : void
            public CopyTo ($array: System.Array$1<T>, $arrayIndex: number) : void
            public Exists ($match: System.Predicate$1<T>) : boolean
            public Find ($match: System.Predicate$1<T>) : T
            public FindAll ($match: System.Predicate$1<T>) : System.Collections.Generic.List$1<T>
            public FindIndex ($match: System.Predicate$1<T>) : number
            public FindIndex ($startIndex: number, $match: System.Predicate$1<T>) : number
            public FindIndex ($startIndex: number, $count: number, $match: System.Predicate$1<T>) : number
            public FindLast ($match: System.Predicate$1<T>) : T
            public FindLastIndex ($match: System.Predicate$1<T>) : number
            public FindLastIndex ($startIndex: number, $match: System.Predicate$1<T>) : number
            public FindLastIndex ($startIndex: number, $count: number, $match: System.Predicate$1<T>) : number
            public ForEach ($action: System.Action$1<T>) : void
            public GetEnumerator () : System.Collections.Generic.List$1.Enumerator<T>
            public GetRange ($index: number, $count: number) : System.Collections.Generic.List$1<T>
            public IndexOf ($item: T) : number
            public IndexOf ($item: T, $index: number) : number
            public IndexOf ($item: T, $index: number, $count: number) : number
            public Insert ($index: number, $item: T) : void
            public InsertRange ($index: number, $collection: System.Collections.Generic.IEnumerable$1<T>) : void
            public LastIndexOf ($item: T) : number
            public LastIndexOf ($item: T, $index: number) : number
            public LastIndexOf ($item: T, $index: number, $count: number) : number
            public Remove ($item: T) : boolean
            public RemoveAll ($match: System.Predicate$1<T>) : number
            public RemoveAt ($index: number) : void
            public RemoveRange ($index: number, $count: number) : void
            public Reverse () : void
            public Reverse ($index: number, $count: number) : void
            public Sort () : void
            public Sort ($comparer: System.Collections.Generic.IComparer$1<T>) : void
            public Sort ($index: number, $count: number, $comparer: System.Collections.Generic.IComparer$1<T>) : void
            public Sort ($comparison: System.Comparison$1<T>) : void
            public ToArray () : System.Array$1<T>
            public TrimExcess () : void
            public TrueForAll ($match: System.Predicate$1<T>) : boolean
            public constructor ()
            public constructor ($capacity: number)
            public constructor ($collection: System.Collections.Generic.IEnumerable$1<T>)
            public GetEnumerator () : System.Collections.IEnumerator
            public CopyTo ($array: System.Array, $index: number) : void
            public get_Item ($index: number) : any
            public set_Item ($index: number, $value: any) : void
            public Add ($value: any) : number
            public Contains ($value: any) : boolean
            public IndexOf ($value: any) : number
            public Insert ($index: number, $value: any) : void
            public Remove ($value: any) : void
            public [Symbol.iterator]() : IterableIterator<T>
        }
        class CollectionExtensions extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class Queue$1<T> extends System.Object implements System.Collections.ICollection, System.Collections.Generic.IEnumerable$1<T>, System.Collections.IEnumerable, System.Collections.Generic.IReadOnlyCollection$1<T>
        {
            protected [__keep_incompatibility]: never;
            public get Count(): number;
            public get SyncRoot(): any;
            public get IsSynchronized(): boolean;
            public Clear () : void
            public CopyTo ($array: System.Array$1<T>, $arrayIndex: number) : void
            public Enqueue ($item: T) : void
            public GetEnumerator () : System.Collections.Generic.Queue$1.Enumerator<T>
            public Dequeue () : T
            public TryDequeue ($result: $Ref<T>) : boolean
            public Peek () : T
            public TryPeek ($result: $Ref<T>) : boolean
            public Contains ($item: T) : boolean
            public ToArray () : System.Array$1<T>
            public TrimExcess () : void
            public constructor ()
            public constructor ($capacity: number)
            public constructor ($collection: System.Collections.Generic.IEnumerable$1<T>)
            public CopyTo ($array: System.Array, $index: number) : void
            public GetEnumerator () : System.Collections.IEnumerator
            public [Symbol.iterator]() : IterableIterator<T>
        }
        class Stack$1<T> extends System.Object implements System.Collections.ICollection, System.Collections.Generic.IEnumerable$1<T>, System.Collections.IEnumerable, System.Collections.Generic.IReadOnlyCollection$1<T>
        {
            protected [__keep_incompatibility]: never;
            public get Count(): number;
            public get SyncRoot(): any;
            public get IsSynchronized(): boolean;
            public Clear () : void
            public Contains ($item: T) : boolean
            public CopyTo ($array: System.Array$1<T>, $arrayIndex: number) : void
            public GetEnumerator () : System.Collections.Generic.Stack$1.Enumerator<T>
            public TrimExcess () : void
            public Peek () : T
            public TryPeek ($result: $Ref<T>) : boolean
            public Pop () : T
            public TryPop ($result: $Ref<T>) : boolean
            public Push ($item: T) : void
            public ToArray () : System.Array$1<T>
            public constructor ()
            public constructor ($capacity: number)
            public constructor ($collection: System.Collections.Generic.IEnumerable$1<T>)
            public CopyTo ($array: System.Array, $index: number) : void
            public GetEnumerator () : System.Collections.IEnumerator
            public [Symbol.iterator]() : IterableIterator<T>
        }
        class Comparer$1<T> extends System.Object implements System.Collections.Generic.IComparer$1<T>, System.Collections.IComparer
        {
            protected [__keep_incompatibility]: never;
            public static get Default(): any;
            public static Create ($comparison: any) : any
            public Compare ($x: T, $y: T) : number
            public Compare ($x: any, $y: any) : number
        }
        class EqualityComparer$1<T> extends System.Object implements System.Collections.Generic.IEqualityComparer$1<T>, System.Collections.IEqualityComparer
        {
            protected [__keep_incompatibility]: never;
            public static get Default(): any;
            public Equals ($x: T, $y: T) : boolean
            public GetHashCode ($obj: T) : number
            public Equals ($x: any, $y: any) : boolean
            public GetHashCode ($obj: any) : number
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : any
            public GetHashCode () : number
        }
    }
    namespace System.Collections {
        interface IEnumerable
        {
            GetEnumerator () : System.Collections.IEnumerator
        }
        interface IStructuralComparable
        {
            CompareTo ($other: any, $comparer: System.Collections.IComparer) : number
        }
        interface IStructuralEquatable
        {
            Equals ($other: any, $comparer: System.Collections.IEqualityComparer) : boolean
            GetHashCode ($comparer: System.Collections.IEqualityComparer) : number
        }
        interface ICollection extends System.Collections.IEnumerable
        {
            Count : number
            SyncRoot : any
            IsSynchronized : boolean
            CopyTo ($array: System.Array, $index: number) : void
            GetEnumerator () : System.Collections.IEnumerator
        }
        interface IList extends System.Collections.ICollection, System.Collections.IEnumerable
        {
            IsReadOnly : boolean
            IsFixedSize : boolean
            Count : number
            SyncRoot : any
            IsSynchronized : boolean
            get_Item ($index: number) : any
            set_Item ($index: number, $value: any) : void
            Add ($value: any) : number
            Contains ($value: any) : boolean
            Clear () : void
            IndexOf ($value: any) : number
            Insert ($index: number, $value: any) : void
            Remove ($value: any) : void
            RemoveAt ($index: number) : void
            CopyTo ($array: System.Array, $index: number) : void
            GetEnumerator () : System.Collections.IEnumerator
        }
        interface IEnumerator
        {
        }
        interface IComparer
        {
            Compare ($x: any, $y: any) : number
        }
        interface IEqualityComparer
        {
            Equals ($x: any, $y: any) : boolean
            GetHashCode ($obj: any) : number
        }
        interface IDictionary extends System.Collections.ICollection, System.Collections.IEnumerable
        {
            Keys : System.Collections.ICollection
            Values : System.Collections.ICollection
            IsReadOnly : boolean
            IsFixedSize : boolean
            Count : number
            SyncRoot : any
            IsSynchronized : boolean
            get_Item ($key: any) : any
            set_Item ($key: any, $value: any) : void
            Contains ($key: any) : boolean
            Add ($key: any, $value: any) : void
            Clear () : void
            GetEnumerator () : System.Collections.IDictionaryEnumerator
            Remove ($key: any) : void
            CopyTo ($array: System.Array, $index: number) : void
            GetEnumerator () : System.Collections.IEnumerator
        }
        class Hashtable extends System.Object implements System.Runtime.Serialization.IDeserializationCallback, System.ICloneable, System.Runtime.Serialization.ISerializable, System.Collections.ICollection, System.Collections.IDictionary, System.Collections.IEnumerable
        {
            protected [__keep_incompatibility]: never;
            public get IsReadOnly(): boolean;
            public get IsFixedSize(): boolean;
            public get IsSynchronized(): boolean;
            public get Keys(): System.Collections.ICollection;
            public get Values(): System.Collections.ICollection;
            public get SyncRoot(): any;
            public get Count(): number;
            public Add ($key: any, $value: any) : void
            public Clear () : void
            public Clone () : any
            public Contains ($key: any) : boolean
            public ContainsKey ($key: any) : boolean
            public ContainsValue ($value: any) : boolean
            public CopyTo ($array: System.Array, $arrayIndex: number) : void
            public get_Item ($key: any) : any
            public set_Item ($key: any, $value: any) : void
            public GetEnumerator () : System.Collections.IDictionaryEnumerator
            public Remove ($key: any) : void
            public static Synchronized ($table: System.Collections.Hashtable) : System.Collections.Hashtable
            public GetObjectData ($info: System.Runtime.Serialization.SerializationInfo, $context: System.Runtime.Serialization.StreamingContext) : void
            public OnDeserialization ($sender: any) : void
            public constructor ()
            public constructor ($capacity: number)
            public constructor ($capacity: number, $loadFactor: number)
            public constructor ($capacity: number, $loadFactor: number, $equalityComparer: System.Collections.IEqualityComparer)
            public constructor ($equalityComparer: System.Collections.IEqualityComparer)
            public constructor ($capacity: number, $equalityComparer: System.Collections.IEqualityComparer)
            public constructor ($d: System.Collections.IDictionary)
            public constructor ($d: System.Collections.IDictionary, $loadFactor: number)
            public constructor ($d: System.Collections.IDictionary, $equalityComparer: System.Collections.IEqualityComparer)
            public constructor ($d: System.Collections.IDictionary, $loadFactor: number, $equalityComparer: System.Collections.IEqualityComparer)
            public CopyTo ($array: System.Array, $index: number) : void
            public GetEnumerator () : System.Collections.IEnumerator
        }
        class ArrayList extends System.Object implements System.ICloneable, System.Collections.ICollection, System.Collections.IEnumerable, System.Collections.IList
        {
            protected [__keep_incompatibility]: never;
            public get Capacity(): number;
            public set Capacity(value: number);
            public get Count(): number;
            public get IsFixedSize(): boolean;
            public get IsReadOnly(): boolean;
            public get IsSynchronized(): boolean;
            public get SyncRoot(): any;
            public get_Item ($index: number) : any
            public set_Item ($index: number, $value: any) : void
            public static Adapter ($list: System.Collections.IList) : System.Collections.ArrayList
            public Add ($value: any) : number
            public AddRange ($c: System.Collections.ICollection) : void
            public BinarySearch ($index: number, $count: number, $value: any, $comparer: System.Collections.IComparer) : number
            public BinarySearch ($value: any) : number
            public BinarySearch ($value: any, $comparer: System.Collections.IComparer) : number
            public Clear () : void
            public Clone () : any
            public Contains ($item: any) : boolean
            public CopyTo ($array: System.Array) : void
            public CopyTo ($array: System.Array, $arrayIndex: number) : void
            public CopyTo ($index: number, $array: System.Array, $arrayIndex: number, $count: number) : void
            public static FixedSize ($list: System.Collections.IList) : System.Collections.IList
            public static FixedSize ($list: System.Collections.ArrayList) : System.Collections.ArrayList
            public GetEnumerator () : System.Collections.IEnumerator
            public GetEnumerator ($index: number, $count: number) : System.Collections.IEnumerator
            public IndexOf ($value: any) : number
            public IndexOf ($value: any, $startIndex: number) : number
            public IndexOf ($value: any, $startIndex: number, $count: number) : number
            public Insert ($index: number, $value: any) : void
            public InsertRange ($index: number, $c: System.Collections.ICollection) : void
            public LastIndexOf ($value: any) : number
            public LastIndexOf ($value: any, $startIndex: number) : number
            public LastIndexOf ($value: any, $startIndex: number, $count: number) : number
            public static ReadOnly ($list: System.Collections.IList) : System.Collections.IList
            public static ReadOnly ($list: System.Collections.ArrayList) : System.Collections.ArrayList
            public Remove ($obj: any) : void
            public RemoveAt ($index: number) : void
            public RemoveRange ($index: number, $count: number) : void
            public static Repeat ($value: any, $count: number) : System.Collections.ArrayList
            public Reverse () : void
            public Reverse ($index: number, $count: number) : void
            public SetRange ($index: number, $c: System.Collections.ICollection) : void
            public GetRange ($index: number, $count: number) : System.Collections.ArrayList
            public Sort () : void
            public Sort ($comparer: System.Collections.IComparer) : void
            public Sort ($index: number, $count: number, $comparer: System.Collections.IComparer) : void
            public static Synchronized ($list: System.Collections.IList) : System.Collections.IList
            public static Synchronized ($list: System.Collections.ArrayList) : System.Collections.ArrayList
            public ToArray () : System.Array$1<any>
            public ToArray ($type: System.Type) : System.Array
            public TrimToSize () : void
            public constructor ()
            public constructor ($capacity: number)
            public constructor ($c: System.Collections.ICollection)
            public CopyTo ($array: System.Array, $index: number) : void
            public Contains ($value: any) : boolean
            public Remove ($value: any) : void
        }
        class DictionaryEntry extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get Key(): any;
            public set Key(value: any);
            public get Value(): any;
            public set Value(value: any);
            public Deconstruct ($key: $Ref<any>, $value: $Ref<any>) : void
            public constructor ($key: any, $value: any)
            public constructor ()
        }
        class ReadOnlyCollectionBase extends System.Object implements System.Collections.ICollection, System.Collections.IEnumerable
        {
            protected [__keep_incompatibility]: never;
            public get Count(): number;
            public get SyncRoot(): any;
            public get IsSynchronized(): boolean;
            public GetEnumerator () : System.Collections.IEnumerator
            public CopyTo ($array: System.Array, $index: number) : void
        }
        interface IDictionaryEnumerator extends System.Collections.IEnumerator
        {
            Key : any
            Value : any
            Entry : System.Collections.DictionaryEntry
        }
        class Comparer extends System.Object implements System.Runtime.Serialization.ISerializable, System.Collections.IComparer
        {
            protected [__keep_incompatibility]: never;
            public static Default : System.Collections.Comparer
            public static DefaultInvariant : System.Collections.Comparer
            public GetObjectData ($info: System.Runtime.Serialization.SerializationInfo, $context: System.Runtime.Serialization.StreamingContext) : void
            public Compare ($a: any, $b: any) : number
            public constructor ($culture: System.Globalization.CultureInfo)
            public Compare ($x: any, $y: any) : number
            public constructor ()
        }
        class CaseInsensitiveComparer extends System.Object implements System.Collections.IComparer
        {
            protected [__keep_incompatibility]: never;
            public static get Default(): System.Collections.CaseInsensitiveComparer;
            public static get DefaultInvariant(): System.Collections.CaseInsensitiveComparer;
            public Compare ($a: any, $b: any) : number
            public constructor ()
            public constructor ($culture: System.Globalization.CultureInfo)
            public Compare ($x: any, $y: any) : number
        }
        class CaseInsensitiveHashCodeProvider extends System.Object implements System.Collections.IHashCodeProvider
        {
            protected [__keep_incompatibility]: never;
            public static get Default(): System.Collections.CaseInsensitiveHashCodeProvider;
            public static get DefaultInvariant(): System.Collections.CaseInsensitiveHashCodeProvider;
            public GetHashCode ($obj: any) : number
            public constructor ()
            public constructor ($culture: System.Globalization.CultureInfo)
            public GetHashCode () : number
        }
        interface IHashCodeProvider
        {
            GetHashCode ($obj: any) : number
        }
        class CollectionBase extends System.Object implements System.Collections.ICollection, System.Collections.IEnumerable, System.Collections.IList
        {
            protected [__keep_incompatibility]: never;
            public get Capacity(): number;
            public set Capacity(value: number);
            public get Count(): number;
            public get SyncRoot(): any;
            public get IsSynchronized(): boolean;
            public get IsReadOnly(): boolean;
            public get IsFixedSize(): boolean;
            public Clear () : void
            public RemoveAt ($index: number) : void
            public GetEnumerator () : System.Collections.IEnumerator
            public CopyTo ($array: System.Array, $index: number) : void
            public get_Item ($index: number) : any
            public set_Item ($index: number, $value: any) : void
            public Add ($value: any) : number
            public Contains ($value: any) : boolean
            public IndexOf ($value: any) : number
            public Insert ($index: number, $value: any) : void
            public Remove ($value: any) : void
        }
        class DictionaryBase extends System.Object implements System.Collections.ICollection, System.Collections.IDictionary, System.Collections.IEnumerable
        {
            protected [__keep_incompatibility]: never;
            public get Count(): number;
            public get SyncRoot(): any;
            public get IsSynchronized(): boolean;
            public get Keys(): System.Collections.ICollection;
            public get Values(): System.Collections.ICollection;
            public get IsReadOnly(): boolean;
            public get IsFixedSize(): boolean;
            public CopyTo ($array: System.Array, $index: number) : void
            public Clear () : void
            public GetEnumerator () : System.Collections.IDictionaryEnumerator
            public GetEnumerator () : System.Collections.IEnumerator
            public get_Item ($key: any) : any
            public set_Item ($key: any, $value: any) : void
            public Contains ($key: any) : boolean
            public Add ($key: any, $value: any) : void
            public Remove ($key: any) : void
        }
        class Queue extends System.Object implements System.ICloneable, System.Collections.ICollection, System.Collections.IEnumerable
        {
            protected [__keep_incompatibility]: never;
            public get Count(): number;
            public get IsSynchronized(): boolean;
            public get SyncRoot(): any;
            public Clone () : any
            public Clear () : void
            public CopyTo ($array: System.Array, $index: number) : void
            public Enqueue ($obj: any) : void
            public GetEnumerator () : System.Collections.IEnumerator
            public Dequeue () : any
            public Peek () : any
            public static Synchronized ($queue: System.Collections.Queue) : System.Collections.Queue
            public Contains ($obj: any) : boolean
            public ToArray () : System.Array$1<any>
            public TrimToSize () : void
            public constructor ()
            public constructor ($capacity: number)
            public constructor ($capacity: number, $growFactor: number)
            public constructor ($col: System.Collections.ICollection)
        }
        class SortedList extends System.Object implements System.ICloneable, System.Collections.ICollection, System.Collections.IDictionary, System.Collections.IEnumerable
        {
            protected [__keep_incompatibility]: never;
            public get Capacity(): number;
            public set Capacity(value: number);
            public get Count(): number;
            public get Keys(): System.Collections.ICollection;
            public get Values(): System.Collections.ICollection;
            public get IsReadOnly(): boolean;
            public get IsFixedSize(): boolean;
            public get IsSynchronized(): boolean;
            public get SyncRoot(): any;
            public Add ($key: any, $value: any) : void
            public Clear () : void
            public Clone () : any
            public Contains ($key: any) : boolean
            public ContainsKey ($key: any) : boolean
            public ContainsValue ($value: any) : boolean
            public CopyTo ($array: System.Array, $arrayIndex: number) : void
            public GetByIndex ($index: number) : any
            public GetEnumerator () : System.Collections.IDictionaryEnumerator
            public GetKey ($index: number) : any
            public GetKeyList () : System.Collections.IList
            public GetValueList () : System.Collections.IList
            public get_Item ($key: any) : any
            public set_Item ($key: any, $value: any) : void
            public IndexOfKey ($key: any) : number
            public IndexOfValue ($value: any) : number
            public RemoveAt ($index: number) : void
            public Remove ($key: any) : void
            public SetByIndex ($index: number, $value: any) : void
            public static Synchronized ($list: System.Collections.SortedList) : System.Collections.SortedList
            public TrimToSize () : void
            public constructor ()
            public constructor ($initialCapacity: number)
            public constructor ($comparer: System.Collections.IComparer)
            public constructor ($comparer: System.Collections.IComparer, $capacity: number)
            public constructor ($d: System.Collections.IDictionary)
            public constructor ($d: System.Collections.IDictionary, $comparer: System.Collections.IComparer)
            public CopyTo ($array: System.Array, $index: number) : void
            public GetEnumerator () : System.Collections.IEnumerator
        }
        class Stack extends System.Object implements System.ICloneable, System.Collections.ICollection, System.Collections.IEnumerable
        {
            protected [__keep_incompatibility]: never;
            public get Count(): number;
            public get IsSynchronized(): boolean;
            public get SyncRoot(): any;
            public Clear () : void
            public Clone () : any
            public Contains ($obj: any) : boolean
            public CopyTo ($array: System.Array, $index: number) : void
            public GetEnumerator () : System.Collections.IEnumerator
            public Peek () : any
            public Pop () : any
            public Push ($obj: any) : void
            public static Synchronized ($stack: System.Collections.Stack) : System.Collections.Stack
            public ToArray () : System.Array$1<any>
            public constructor ()
            public constructor ($initialCapacity: number)
            public constructor ($col: System.Collections.ICollection)
        }
        class BitArray extends System.Object implements System.ICloneable, System.Collections.ICollection, System.Collections.IEnumerable
        {
            protected [__keep_incompatibility]: never;
            public get Length(): number;
            public set Length(value: number);
            public get Count(): number;
            public get SyncRoot(): any;
            public get IsSynchronized(): boolean;
            public get IsReadOnly(): boolean;
            public get_Item ($index: number) : boolean
            public set_Item ($index: number, $value: boolean) : void
            public Get ($index: number) : boolean
            public Set ($index: number, $value: boolean) : void
            public SetAll ($value: boolean) : void
            public And ($value: System.Collections.BitArray) : System.Collections.BitArray
            public Or ($value: System.Collections.BitArray) : System.Collections.BitArray
            public Xor ($value: System.Collections.BitArray) : System.Collections.BitArray
            public Not () : System.Collections.BitArray
            public RightShift ($count: number) : System.Collections.BitArray
            public LeftShift ($count: number) : System.Collections.BitArray
            public CopyTo ($array: System.Array, $index: number) : void
            public Clone () : any
            public GetEnumerator () : System.Collections.IEnumerator
            public constructor ($length: number)
            public constructor ($length: number, $defaultValue: boolean)
            public constructor ($bytes: System.Array$1<number>)
            public constructor ($values: System.Array$1<boolean>)
            public constructor ($values: System.Array$1<number>)
            public constructor ($bits: System.Collections.BitArray)
            public constructor ()
        }
        class StructuralComparisons extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get StructuralComparer(): System.Collections.IComparer;
            public static get StructuralEqualityComparer(): System.Collections.IEqualityComparer;
        }
    }
    namespace System.Security.AccessControl {
        class ObjectSecurity extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get AccessRightType(): System.Type;
            public get AccessRuleType(): System.Type;
            public get AuditRuleType(): System.Type;
            public get AreAccessRulesCanonical(): boolean;
            public get AreAccessRulesProtected(): boolean;
            public get AreAuditRulesCanonical(): boolean;
            public get AreAuditRulesProtected(): boolean;
            public AccessRuleFactory ($identityReference: System.Security.Principal.IdentityReference, $accessMask: number, $isInherited: boolean, $inheritanceFlags: System.Security.AccessControl.InheritanceFlags, $propagationFlags: System.Security.AccessControl.PropagationFlags, $type: System.Security.AccessControl.AccessControlType) : System.Security.AccessControl.AccessRule
            public AuditRuleFactory ($identityReference: System.Security.Principal.IdentityReference, $accessMask: number, $isInherited: boolean, $inheritanceFlags: System.Security.AccessControl.InheritanceFlags, $propagationFlags: System.Security.AccessControl.PropagationFlags, $flags: System.Security.AccessControl.AuditFlags) : System.Security.AccessControl.AuditRule
            public GetGroup ($targetType: System.Type) : System.Security.Principal.IdentityReference
            public GetOwner ($targetType: System.Type) : System.Security.Principal.IdentityReference
            public GetSecurityDescriptorBinaryForm () : System.Array$1<number>
            public GetSecurityDescriptorSddlForm ($includeSections: System.Security.AccessControl.AccessControlSections) : string
            public static IsSddlConversionSupported () : boolean
            public ModifyAccessRule ($modification: System.Security.AccessControl.AccessControlModification, $rule: System.Security.AccessControl.AccessRule, $modified: $Ref<boolean>) : boolean
            public ModifyAuditRule ($modification: System.Security.AccessControl.AccessControlModification, $rule: System.Security.AccessControl.AuditRule, $modified: $Ref<boolean>) : boolean
            public PurgeAccessRules ($identity: System.Security.Principal.IdentityReference) : void
            public PurgeAuditRules ($identity: System.Security.Principal.IdentityReference) : void
            public SetAccessRuleProtection ($isProtected: boolean, $preserveInheritance: boolean) : void
            public SetAuditRuleProtection ($isProtected: boolean, $preserveInheritance: boolean) : void
            public SetGroup ($identity: System.Security.Principal.IdentityReference) : void
            public SetOwner ($identity: System.Security.Principal.IdentityReference) : void
            public SetSecurityDescriptorBinaryForm ($binaryForm: System.Array$1<number>) : void
            public SetSecurityDescriptorBinaryForm ($binaryForm: System.Array$1<number>, $includeSections: System.Security.AccessControl.AccessControlSections) : void
            public SetSecurityDescriptorSddlForm ($sddlForm: string) : void
            public SetSecurityDescriptorSddlForm ($sddlForm: string, $includeSections: System.Security.AccessControl.AccessControlSections) : void
        }
        class CommonObjectSecurity extends System.Security.AccessControl.ObjectSecurity
        {
            protected [__keep_incompatibility]: never;
            public GetAccessRules ($includeExplicit: boolean, $includeInherited: boolean, $targetType: System.Type) : System.Security.AccessControl.AuthorizationRuleCollection
            public GetAuditRules ($includeExplicit: boolean, $includeInherited: boolean, $targetType: System.Type) : System.Security.AccessControl.AuthorizationRuleCollection
        }
        class NativeObjectSecurity extends System.Security.AccessControl.CommonObjectSecurity
        {
            protected [__keep_incompatibility]: never;
        }
        class RegistrySecurity extends System.Security.AccessControl.NativeObjectSecurity
        {
            protected [__keep_incompatibility]: never;
            public get AccessRightType(): System.Type;
            public get AccessRuleType(): System.Type;
            public get AuditRuleType(): System.Type;
            public AddAccessRule ($rule: System.Security.AccessControl.RegistryAccessRule) : void
            public SetAccessRule ($rule: System.Security.AccessControl.RegistryAccessRule) : void
            public ResetAccessRule ($rule: System.Security.AccessControl.RegistryAccessRule) : void
            public RemoveAccessRule ($rule: System.Security.AccessControl.RegistryAccessRule) : boolean
            public RemoveAccessRuleAll ($rule: System.Security.AccessControl.RegistryAccessRule) : void
            public RemoveAccessRuleSpecific ($rule: System.Security.AccessControl.RegistryAccessRule) : void
            public AddAuditRule ($rule: System.Security.AccessControl.RegistryAuditRule) : void
            public SetAuditRule ($rule: System.Security.AccessControl.RegistryAuditRule) : void
            public RemoveAuditRule ($rule: System.Security.AccessControl.RegistryAuditRule) : boolean
            public RemoveAuditRuleAll ($rule: System.Security.AccessControl.RegistryAuditRule) : void
            public RemoveAuditRuleSpecific ($rule: System.Security.AccessControl.RegistryAuditRule) : void
            public constructor ()
        }
        enum RegistryRights
        { QueryValues = 1, SetValue = 2, CreateSubKey = 4, EnumerateSubKeys = 8, Notify = 16, CreateLink = 32, Delete = 65536, ReadPermissions = 131072, WriteKey = 131078, ReadKey = 131097, ExecuteKey = 131097, ChangePermissions = 262144, TakeOwnership = 524288, FullControl = 983103 }
        enum AccessControlSections
        { None = 0, Audit = 1, Access = 2, Owner = 4, Group = 8, All = 15 }
        enum EventWaitHandleRights
        { Modify = 2, Delete = 65536, ReadPermissions = 131072, ChangePermissions = 262144, TakeOwnership = 524288, Synchronize = 1048576, FullControl = 2031619 }
        class EventWaitHandleSecurity extends System.Security.AccessControl.NativeObjectSecurity
        {
            protected [__keep_incompatibility]: never;
            public get AccessRightType(): System.Type;
            public get AccessRuleType(): System.Type;
            public get AuditRuleType(): System.Type;
            public AddAccessRule ($rule: System.Security.AccessControl.EventWaitHandleAccessRule) : void
            public RemoveAccessRule ($rule: System.Security.AccessControl.EventWaitHandleAccessRule) : boolean
            public RemoveAccessRuleAll ($rule: System.Security.AccessControl.EventWaitHandleAccessRule) : void
            public RemoveAccessRuleSpecific ($rule: System.Security.AccessControl.EventWaitHandleAccessRule) : void
            public ResetAccessRule ($rule: System.Security.AccessControl.EventWaitHandleAccessRule) : void
            public SetAccessRule ($rule: System.Security.AccessControl.EventWaitHandleAccessRule) : void
            public AddAuditRule ($rule: System.Security.AccessControl.EventWaitHandleAuditRule) : void
            public RemoveAuditRule ($rule: System.Security.AccessControl.EventWaitHandleAuditRule) : boolean
            public RemoveAuditRuleAll ($rule: System.Security.AccessControl.EventWaitHandleAuditRule) : void
            public RemoveAuditRuleSpecific ($rule: System.Security.AccessControl.EventWaitHandleAuditRule) : void
            public SetAuditRule ($rule: System.Security.AccessControl.EventWaitHandleAuditRule) : void
            public constructor ()
        }
        class MutexSecurity extends System.Security.AccessControl.NativeObjectSecurity
        {
            protected [__keep_incompatibility]: never;
            public get AccessRightType(): System.Type;
            public get AccessRuleType(): System.Type;
            public get AuditRuleType(): System.Type;
            public AddAccessRule ($rule: System.Security.AccessControl.MutexAccessRule) : void
            public RemoveAccessRule ($rule: System.Security.AccessControl.MutexAccessRule) : boolean
            public RemoveAccessRuleAll ($rule: System.Security.AccessControl.MutexAccessRule) : void
            public RemoveAccessRuleSpecific ($rule: System.Security.AccessControl.MutexAccessRule) : void
            public ResetAccessRule ($rule: System.Security.AccessControl.MutexAccessRule) : void
            public SetAccessRule ($rule: System.Security.AccessControl.MutexAccessRule) : void
            public AddAuditRule ($rule: System.Security.AccessControl.MutexAuditRule) : void
            public RemoveAuditRule ($rule: System.Security.AccessControl.MutexAuditRule) : boolean
            public RemoveAuditRuleAll ($rule: System.Security.AccessControl.MutexAuditRule) : void
            public RemoveAuditRuleSpecific ($rule: System.Security.AccessControl.MutexAuditRule) : void
            public SetAuditRule ($rule: System.Security.AccessControl.MutexAuditRule) : void
            public constructor ()
            public constructor ($name: string, $includeSections: System.Security.AccessControl.AccessControlSections)
        }
        enum MutexRights
        { Modify = 1, Delete = 65536, ReadPermissions = 131072, ChangePermissions = 262144, TakeOwnership = 524288, Synchronize = 1048576, FullControl = 2031617 }
        enum AccessControlActions
        { None = 0, View = 1, Change = 2 }
        class CryptoKeySecurity extends System.Security.AccessControl.NativeObjectSecurity
        {
            protected [__keep_incompatibility]: never;
            public get AccessRightType(): System.Type;
            public get AccessRuleType(): System.Type;
            public get AuditRuleType(): System.Type;
            public AddAccessRule ($rule: System.Security.AccessControl.CryptoKeyAccessRule) : void
            public RemoveAccessRule ($rule: System.Security.AccessControl.CryptoKeyAccessRule) : boolean
            public RemoveAccessRuleAll ($rule: System.Security.AccessControl.CryptoKeyAccessRule) : void
            public RemoveAccessRuleSpecific ($rule: System.Security.AccessControl.CryptoKeyAccessRule) : void
            public ResetAccessRule ($rule: System.Security.AccessControl.CryptoKeyAccessRule) : void
            public SetAccessRule ($rule: System.Security.AccessControl.CryptoKeyAccessRule) : void
            public AddAuditRule ($rule: System.Security.AccessControl.CryptoKeyAuditRule) : void
            public RemoveAuditRule ($rule: System.Security.AccessControl.CryptoKeyAuditRule) : boolean
            public RemoveAuditRuleAll ($rule: System.Security.AccessControl.CryptoKeyAuditRule) : void
            public RemoveAuditRuleSpecific ($rule: System.Security.AccessControl.CryptoKeyAuditRule) : void
            public SetAuditRule ($rule: System.Security.AccessControl.CryptoKeyAuditRule) : void
            public constructor ()
            public constructor ($securityDescriptor: System.Security.AccessControl.CommonSecurityDescriptor)
        }
        class AuthorizationRule extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get IdentityReference(): System.Security.Principal.IdentityReference;
            public get InheritanceFlags(): System.Security.AccessControl.InheritanceFlags;
            public get IsInherited(): boolean;
            public get PropagationFlags(): System.Security.AccessControl.PropagationFlags;
        }
        class AccessRule extends System.Security.AccessControl.AuthorizationRule
        {
            protected [__keep_incompatibility]: never;
            public get AccessControlType(): System.Security.AccessControl.AccessControlType;
        }
        enum InheritanceFlags
        { None = 0, ContainerInherit = 1, ObjectInherit = 2 }
        enum PropagationFlags
        { None = 0, NoPropagateInherit = 1, InheritOnly = 2 }
        enum AccessControlType
        { Allow = 0, Deny = 1 }
        class AuditRule extends System.Security.AccessControl.AuthorizationRule
        {
            protected [__keep_incompatibility]: never;
            public get AuditFlags(): System.Security.AccessControl.AuditFlags;
        }
        enum AuditFlags
        { None = 0, Success = 1, Failure = 2 }
        class RegistryAccessRule extends System.Security.AccessControl.AccessRule
        {
            protected [__keep_incompatibility]: never;
            public get RegistryRights(): System.Security.AccessControl.RegistryRights;
            public constructor ($identity: System.Security.Principal.IdentityReference, $registryRights: System.Security.AccessControl.RegistryRights, $type: System.Security.AccessControl.AccessControlType)
            public constructor ($identity: string, $registryRights: System.Security.AccessControl.RegistryRights, $type: System.Security.AccessControl.AccessControlType)
            public constructor ($identity: System.Security.Principal.IdentityReference, $registryRights: System.Security.AccessControl.RegistryRights, $inheritanceFlags: System.Security.AccessControl.InheritanceFlags, $propagationFlags: System.Security.AccessControl.PropagationFlags, $type: System.Security.AccessControl.AccessControlType)
            public constructor ($identity: string, $registryRights: System.Security.AccessControl.RegistryRights, $inheritanceFlags: System.Security.AccessControl.InheritanceFlags, $propagationFlags: System.Security.AccessControl.PropagationFlags, $type: System.Security.AccessControl.AccessControlType)
            public constructor ()
        }
        class RegistryAuditRule extends System.Security.AccessControl.AuditRule
        {
            protected [__keep_incompatibility]: never;
            public get RegistryRights(): System.Security.AccessControl.RegistryRights;
            public constructor ($identity: System.Security.Principal.IdentityReference, $registryRights: System.Security.AccessControl.RegistryRights, $inheritanceFlags: System.Security.AccessControl.InheritanceFlags, $propagationFlags: System.Security.AccessControl.PropagationFlags, $flags: System.Security.AccessControl.AuditFlags)
            public constructor ($identity: string, $registryRights: System.Security.AccessControl.RegistryRights, $inheritanceFlags: System.Security.AccessControl.InheritanceFlags, $propagationFlags: System.Security.AccessControl.PropagationFlags, $flags: System.Security.AccessControl.AuditFlags)
            public constructor ()
        }
        class PrivilegeNotHeldException extends System.UnauthorizedAccessException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public get PrivilegeName(): string;
            public constructor ()
            public constructor ($privilege: string)
            public constructor ($privilege: string, $inner: System.Exception)
            public constructor ($message: string)
            public constructor ($message: string, $inner: System.Exception)
            public constructor ($message: string, $innerException: System.Exception)
        }
        enum AccessControlModification
        { Add = 0, Set = 1, Reset = 2, Remove = 3, RemoveAll = 4, RemoveSpecific = 5 }
        class AccessRule$1<T> extends System.Security.AccessControl.AccessRule
        {
            protected [__keep_incompatibility]: never;
            public get Rights(): T;
            public constructor ($identity: string, $rights: T, $type: System.Security.AccessControl.AccessControlType)
            public constructor ($identity: System.Security.Principal.IdentityReference, $rights: T, $type: System.Security.AccessControl.AccessControlType)
            public constructor ($identity: string, $rights: T, $inheritanceFlags: System.Security.AccessControl.InheritanceFlags, $propagationFlags: System.Security.AccessControl.PropagationFlags, $type: System.Security.AccessControl.AccessControlType)
            public constructor ($identity: System.Security.Principal.IdentityReference, $rights: T, $inheritanceFlags: System.Security.AccessControl.InheritanceFlags, $propagationFlags: System.Security.AccessControl.PropagationFlags, $type: System.Security.AccessControl.AccessControlType)
            public constructor ()
        }
        class AceEnumerator extends System.Object implements System.Collections.IEnumerator
        {
            protected [__keep_incompatibility]: never;
            public get Current(): System.Security.AccessControl.GenericAce;
            public MoveNext () : boolean
            public Reset () : void
        }
        class GenericAce extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get AceFlags(): System.Security.AccessControl.AceFlags;
            public set AceFlags(value: System.Security.AccessControl.AceFlags);
            public get AceType(): System.Security.AccessControl.AceType;
            public get AuditFlags(): System.Security.AccessControl.AuditFlags;
            public get BinaryLength(): number;
            public get InheritanceFlags(): System.Security.AccessControl.InheritanceFlags;
            public get IsInherited(): boolean;
            public get PropagationFlags(): System.Security.AccessControl.PropagationFlags;
            public Copy () : System.Security.AccessControl.GenericAce
            public static CreateFromBinaryForm ($binaryForm: System.Array$1<number>, $offset: number) : System.Security.AccessControl.GenericAce
            public GetBinaryForm ($binaryForm: System.Array$1<number>, $offset: number) : void
            public static op_Equality ($left: System.Security.AccessControl.GenericAce, $right: System.Security.AccessControl.GenericAce) : boolean
            public static op_Inequality ($left: System.Security.AccessControl.GenericAce, $right: System.Security.AccessControl.GenericAce) : boolean
        }
        enum AceFlags
        { None = 0, ObjectInherit = 1, ContainerInherit = 2, NoPropagateInherit = 4, InheritOnly = 8, InheritanceFlags = 15, Inherited = 16, SuccessfulAccess = 64, FailedAccess = 128, AuditFlags = 192 }
        enum AceQualifier
        { AccessAllowed = 0, AccessDenied = 1, SystemAudit = 2, SystemAlarm = 3 }
        enum AceType
        { AccessAllowed = 0, AccessDenied = 1, SystemAudit = 2, SystemAlarm = 3, AccessAllowedCompound = 4, AccessAllowedObject = 5, AccessDeniedObject = 6, SystemAuditObject = 7, SystemAlarmObject = 8, AccessAllowedCallback = 9, AccessDeniedCallback = 10, AccessAllowedCallbackObject = 11, AccessDeniedCallbackObject = 12, SystemAuditCallback = 13, SystemAlarmCallback = 14, SystemAuditCallbackObject = 15, SystemAlarmCallbackObject = 16, MaxDefinedAceType = 16 }
        class AuditRule$1<T> extends System.Security.AccessControl.AuditRule
        {
            protected [__keep_incompatibility]: never;
            public get Rights(): T;
            public constructor ($identity: string, $rights: T, $flags: System.Security.AccessControl.AuditFlags)
            public constructor ($identity: System.Security.Principal.IdentityReference, $rights: T, $flags: System.Security.AccessControl.AuditFlags)
            public constructor ($identity: string, $rights: T, $inheritanceFlags: System.Security.AccessControl.InheritanceFlags, $propagationFlags: System.Security.AccessControl.PropagationFlags, $flags: System.Security.AccessControl.AuditFlags)
            public constructor ($identity: System.Security.Principal.IdentityReference, $rights: T, $inheritanceFlags: System.Security.AccessControl.InheritanceFlags, $propagationFlags: System.Security.AccessControl.PropagationFlags, $flags: System.Security.AccessControl.AuditFlags)
            public constructor ()
        }
        class AuthorizationRuleCollection extends System.Collections.ReadOnlyCollectionBase implements System.Collections.ICollection, System.Collections.IEnumerable
        {
            protected [__keep_incompatibility]: never;
            public AddRule ($rule: System.Security.AccessControl.AuthorizationRule) : void
            public get_Item ($index: number) : System.Security.AccessControl.AuthorizationRule
            public CopyTo ($rules: System.Array$1<System.Security.AccessControl.AuthorizationRule>, $index: number) : void
            public constructor ()
            public CopyTo ($array: System.Array, $index: number) : void
        }
        class KnownAce extends System.Security.AccessControl.GenericAce
        {
            protected [__keep_incompatibility]: never;
            public get AccessMask(): number;
            public set AccessMask(value: number);
            public get SecurityIdentifier(): System.Security.Principal.SecurityIdentifier;
            public set SecurityIdentifier(value: System.Security.Principal.SecurityIdentifier);
        }
        class QualifiedAce extends System.Security.AccessControl.KnownAce
        {
            protected [__keep_incompatibility]: never;
            public get AceQualifier(): System.Security.AccessControl.AceQualifier;
            public get IsCallback(): boolean;
            public get OpaqueLength(): number;
            public GetOpaque () : System.Array$1<number>
            public SetOpaque ($opaque: System.Array$1<number>) : void
        }
        class CommonAce extends System.Security.AccessControl.QualifiedAce
        {
            protected [__keep_incompatibility]: never;
            public get BinaryLength(): number;
            public static MaxOpaqueLength ($isCallback: boolean) : number
            public constructor ($flags: System.Security.AccessControl.AceFlags, $qualifier: System.Security.AccessControl.AceQualifier, $accessMask: number, $sid: System.Security.Principal.SecurityIdentifier, $isCallback: boolean, $opaque: System.Array$1<number>)
            public constructor ()
        }
        class GenericAcl extends System.Object implements System.Collections.ICollection, System.Collections.IEnumerable
        {
            protected [__keep_incompatibility]: never;
            public static AclRevision : number
            public static AclRevisionDS : number
            public static MaxBinaryLength : number
            public get BinaryLength(): number;
            public get Count(): number;
            public get IsSynchronized(): boolean;
            public get Revision(): number;
            public get SyncRoot(): any;
            public get_Item ($index: number) : System.Security.AccessControl.GenericAce
            public set_Item ($index: number, $value: System.Security.AccessControl.GenericAce) : void
            public CopyTo ($array: System.Array$1<System.Security.AccessControl.GenericAce>, $index: number) : void
            public GetBinaryForm ($binaryForm: System.Array$1<number>, $offset: number) : void
            public GetEnumerator () : System.Security.AccessControl.AceEnumerator
            public CopyTo ($array: System.Array, $index: number) : void
            public GetEnumerator () : System.Collections.IEnumerator
        }
        class CommonAcl extends System.Security.AccessControl.GenericAcl implements System.Collections.ICollection, System.Collections.IEnumerable
        {
            protected [__keep_incompatibility]: never;
            public get BinaryLength(): number;
            public get Count(): number;
            public get IsCanonical(): boolean;
            public get IsContainer(): boolean;
            public get IsDS(): boolean;
            public get Revision(): number;
            public Purge ($sid: System.Security.Principal.SecurityIdentifier) : void
            public RemoveInheritedAces () : void
        }
        class GenericSecurityDescriptor extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get BinaryLength(): number;
            public get ControlFlags(): System.Security.AccessControl.ControlFlags;
            public get Group(): System.Security.Principal.SecurityIdentifier;
            public set Group(value: System.Security.Principal.SecurityIdentifier);
            public get Owner(): System.Security.Principal.SecurityIdentifier;
            public set Owner(value: System.Security.Principal.SecurityIdentifier);
            public static get Revision(): number;
            public GetBinaryForm ($binaryForm: System.Array$1<number>, $offset: number) : void
            public GetSddlForm ($includeSections: System.Security.AccessControl.AccessControlSections) : string
            public static IsSddlConversionSupported () : boolean
        }
        class CommonSecurityDescriptor extends System.Security.AccessControl.GenericSecurityDescriptor
        {
            protected [__keep_incompatibility]: never;
            public get ControlFlags(): System.Security.AccessControl.ControlFlags;
            public get DiscretionaryAcl(): System.Security.AccessControl.DiscretionaryAcl;
            public set DiscretionaryAcl(value: System.Security.AccessControl.DiscretionaryAcl);
            public get Group(): System.Security.Principal.SecurityIdentifier;
            public set Group(value: System.Security.Principal.SecurityIdentifier);
            public get IsContainer(): boolean;
            public get IsDiscretionaryAclCanonical(): boolean;
            public get IsDS(): boolean;
            public get IsSystemAclCanonical(): boolean;
            public get Owner(): System.Security.Principal.SecurityIdentifier;
            public set Owner(value: System.Security.Principal.SecurityIdentifier);
            public get SystemAcl(): System.Security.AccessControl.SystemAcl;
            public set SystemAcl(value: System.Security.AccessControl.SystemAcl);
            public PurgeAccessControl ($sid: System.Security.Principal.SecurityIdentifier) : void
            public PurgeAudit ($sid: System.Security.Principal.SecurityIdentifier) : void
            public SetDiscretionaryAclProtection ($isProtected: boolean, $preserveInheritance: boolean) : void
            public SetSystemAclProtection ($isProtected: boolean, $preserveInheritance: boolean) : void
            public AddDiscretionaryAcl ($revision: number, $trusted: number) : void
            public AddSystemAcl ($revision: number, $trusted: number) : void
            public constructor ($isContainer: boolean, $isDS: boolean, $rawSecurityDescriptor: System.Security.AccessControl.RawSecurityDescriptor)
            public constructor ($isContainer: boolean, $isDS: boolean, $sddlForm: string)
            public constructor ($isContainer: boolean, $isDS: boolean, $binaryForm: System.Array$1<number>, $offset: number)
            public constructor ($isContainer: boolean, $isDS: boolean, $flags: System.Security.AccessControl.ControlFlags, $owner: System.Security.Principal.SecurityIdentifier, $group: System.Security.Principal.SecurityIdentifier, $systemAcl: System.Security.AccessControl.SystemAcl, $discretionaryAcl: System.Security.AccessControl.DiscretionaryAcl)
            public constructor ()
        }
        enum ControlFlags
        { None = 0, OwnerDefaulted = 1, GroupDefaulted = 2, DiscretionaryAclPresent = 4, DiscretionaryAclDefaulted = 8, SystemAclPresent = 16, SystemAclDefaulted = 32, DiscretionaryAclUntrusted = 64, ServerSecurity = 128, DiscretionaryAclAutoInheritRequired = 256, SystemAclAutoInheritRequired = 512, DiscretionaryAclAutoInherited = 1024, SystemAclAutoInherited = 2048, DiscretionaryAclProtected = 4096, SystemAclProtected = 8192, RMControlValid = 16384, SelfRelative = 32768 }
        class DiscretionaryAcl extends System.Security.AccessControl.CommonAcl implements System.Collections.ICollection, System.Collections.IEnumerable
        {
            protected [__keep_incompatibility]: never;
            public AddAccess ($accessType: System.Security.AccessControl.AccessControlType, $sid: System.Security.Principal.SecurityIdentifier, $accessMask: number, $inheritanceFlags: System.Security.AccessControl.InheritanceFlags, $propagationFlags: System.Security.AccessControl.PropagationFlags) : void
            public AddAccess ($accessType: System.Security.AccessControl.AccessControlType, $sid: System.Security.Principal.SecurityIdentifier, $accessMask: number, $inheritanceFlags: System.Security.AccessControl.InheritanceFlags, $propagationFlags: System.Security.AccessControl.PropagationFlags, $objectFlags: System.Security.AccessControl.ObjectAceFlags, $objectType: System.Guid, $inheritedObjectType: System.Guid) : void
            public AddAccess ($accessType: System.Security.AccessControl.AccessControlType, $sid: System.Security.Principal.SecurityIdentifier, $rule: System.Security.AccessControl.ObjectAccessRule) : void
            public RemoveAccess ($accessType: System.Security.AccessControl.AccessControlType, $sid: System.Security.Principal.SecurityIdentifier, $accessMask: number, $inheritanceFlags: System.Security.AccessControl.InheritanceFlags, $propagationFlags: System.Security.AccessControl.PropagationFlags) : boolean
            public RemoveAccess ($accessType: System.Security.AccessControl.AccessControlType, $sid: System.Security.Principal.SecurityIdentifier, $accessMask: number, $inheritanceFlags: System.Security.AccessControl.InheritanceFlags, $propagationFlags: System.Security.AccessControl.PropagationFlags, $objectFlags: System.Security.AccessControl.ObjectAceFlags, $objectType: System.Guid, $inheritedObjectType: System.Guid) : boolean
            public RemoveAccess ($accessType: System.Security.AccessControl.AccessControlType, $sid: System.Security.Principal.SecurityIdentifier, $rule: System.Security.AccessControl.ObjectAccessRule) : boolean
            public RemoveAccessSpecific ($accessType: System.Security.AccessControl.AccessControlType, $sid: System.Security.Principal.SecurityIdentifier, $accessMask: number, $inheritanceFlags: System.Security.AccessControl.InheritanceFlags, $propagationFlags: System.Security.AccessControl.PropagationFlags) : void
            public RemoveAccessSpecific ($accessType: System.Security.AccessControl.AccessControlType, $sid: System.Security.Principal.SecurityIdentifier, $accessMask: number, $inheritanceFlags: System.Security.AccessControl.InheritanceFlags, $propagationFlags: System.Security.AccessControl.PropagationFlags, $objectFlags: System.Security.AccessControl.ObjectAceFlags, $objectType: System.Guid, $inheritedObjectType: System.Guid) : void
            public RemoveAccessSpecific ($accessType: System.Security.AccessControl.AccessControlType, $sid: System.Security.Principal.SecurityIdentifier, $rule: System.Security.AccessControl.ObjectAccessRule) : void
            public SetAccess ($accessType: System.Security.AccessControl.AccessControlType, $sid: System.Security.Principal.SecurityIdentifier, $accessMask: number, $inheritanceFlags: System.Security.AccessControl.InheritanceFlags, $propagationFlags: System.Security.AccessControl.PropagationFlags) : void
            public SetAccess ($accessType: System.Security.AccessControl.AccessControlType, $sid: System.Security.Principal.SecurityIdentifier, $accessMask: number, $inheritanceFlags: System.Security.AccessControl.InheritanceFlags, $propagationFlags: System.Security.AccessControl.PropagationFlags, $objectFlags: System.Security.AccessControl.ObjectAceFlags, $objectType: System.Guid, $inheritedObjectType: System.Guid) : void
            public SetAccess ($accessType: System.Security.AccessControl.AccessControlType, $sid: System.Security.Principal.SecurityIdentifier, $rule: System.Security.AccessControl.ObjectAccessRule) : void
            public constructor ($isContainer: boolean, $isDS: boolean, $capacity: number)
            public constructor ($isContainer: boolean, $isDS: boolean, $rawAcl: System.Security.AccessControl.RawAcl)
            public constructor ($isContainer: boolean, $isDS: boolean, $revision: number, $capacity: number)
            public constructor ()
        }
        class SystemAcl extends System.Security.AccessControl.CommonAcl implements System.Collections.ICollection, System.Collections.IEnumerable
        {
            protected [__keep_incompatibility]: never;
            public AddAudit ($auditFlags: System.Security.AccessControl.AuditFlags, $sid: System.Security.Principal.SecurityIdentifier, $accessMask: number, $inheritanceFlags: System.Security.AccessControl.InheritanceFlags, $propagationFlags: System.Security.AccessControl.PropagationFlags) : void
            public AddAudit ($auditFlags: System.Security.AccessControl.AuditFlags, $sid: System.Security.Principal.SecurityIdentifier, $accessMask: number, $inheritanceFlags: System.Security.AccessControl.InheritanceFlags, $propagationFlags: System.Security.AccessControl.PropagationFlags, $objectFlags: System.Security.AccessControl.ObjectAceFlags, $objectType: System.Guid, $inheritedObjectType: System.Guid) : void
            public AddAudit ($sid: System.Security.Principal.SecurityIdentifier, $rule: System.Security.AccessControl.ObjectAuditRule) : void
            public RemoveAudit ($auditFlags: System.Security.AccessControl.AuditFlags, $sid: System.Security.Principal.SecurityIdentifier, $accessMask: number, $inheritanceFlags: System.Security.AccessControl.InheritanceFlags, $propagationFlags: System.Security.AccessControl.PropagationFlags) : boolean
            public RemoveAudit ($auditFlags: System.Security.AccessControl.AuditFlags, $sid: System.Security.Principal.SecurityIdentifier, $accessMask: number, $inheritanceFlags: System.Security.AccessControl.InheritanceFlags, $propagationFlags: System.Security.AccessControl.PropagationFlags, $objectFlags: System.Security.AccessControl.ObjectAceFlags, $objectType: System.Guid, $inheritedObjectType: System.Guid) : boolean
            public RemoveAudit ($sid: System.Security.Principal.SecurityIdentifier, $rule: System.Security.AccessControl.ObjectAuditRule) : boolean
            public RemoveAuditSpecific ($auditFlags: System.Security.AccessControl.AuditFlags, $sid: System.Security.Principal.SecurityIdentifier, $accessMask: number, $inheritanceFlags: System.Security.AccessControl.InheritanceFlags, $propagationFlags: System.Security.AccessControl.PropagationFlags) : void
            public RemoveAuditSpecific ($auditFlags: System.Security.AccessControl.AuditFlags, $sid: System.Security.Principal.SecurityIdentifier, $accessMask: number, $inheritanceFlags: System.Security.AccessControl.InheritanceFlags, $propagationFlags: System.Security.AccessControl.PropagationFlags, $objectFlags: System.Security.AccessControl.ObjectAceFlags, $objectType: System.Guid, $inheritedObjectType: System.Guid) : void
            public RemoveAuditSpecific ($sid: System.Security.Principal.SecurityIdentifier, $rule: System.Security.AccessControl.ObjectAuditRule) : void
            public SetAudit ($auditFlags: System.Security.AccessControl.AuditFlags, $sid: System.Security.Principal.SecurityIdentifier, $accessMask: number, $inheritanceFlags: System.Security.AccessControl.InheritanceFlags, $propagationFlags: System.Security.AccessControl.PropagationFlags) : void
            public SetAudit ($auditFlags: System.Security.AccessControl.AuditFlags, $sid: System.Security.Principal.SecurityIdentifier, $accessMask: number, $inheritanceFlags: System.Security.AccessControl.InheritanceFlags, $propagationFlags: System.Security.AccessControl.PropagationFlags, $objectFlags: System.Security.AccessControl.ObjectAceFlags, $objectType: System.Guid, $inheritedObjectType: System.Guid) : void
            public SetAudit ($sid: System.Security.Principal.SecurityIdentifier, $rule: System.Security.AccessControl.ObjectAuditRule) : void
            public constructor ($isContainer: boolean, $isDS: boolean, $capacity: number)
            public constructor ($isContainer: boolean, $isDS: boolean, $rawAcl: System.Security.AccessControl.RawAcl)
            public constructor ($isContainer: boolean, $isDS: boolean, $revision: number, $capacity: number)
            public constructor ()
        }
        class RawSecurityDescriptor extends System.Security.AccessControl.GenericSecurityDescriptor
        {
            protected [__keep_incompatibility]: never;
            public get ControlFlags(): System.Security.AccessControl.ControlFlags;
            public get DiscretionaryAcl(): System.Security.AccessControl.RawAcl;
            public set DiscretionaryAcl(value: System.Security.AccessControl.RawAcl);
            public get Group(): System.Security.Principal.SecurityIdentifier;
            public set Group(value: System.Security.Principal.SecurityIdentifier);
            public get Owner(): System.Security.Principal.SecurityIdentifier;
            public set Owner(value: System.Security.Principal.SecurityIdentifier);
            public get ResourceManagerControl(): number;
            public set ResourceManagerControl(value: number);
            public get SystemAcl(): System.Security.AccessControl.RawAcl;
            public set SystemAcl(value: System.Security.AccessControl.RawAcl);
            public SetFlags ($flags: System.Security.AccessControl.ControlFlags) : void
            public constructor ($sddlForm: string)
            public constructor ($binaryForm: System.Array$1<number>, $offset: number)
            public constructor ($flags: System.Security.AccessControl.ControlFlags, $owner: System.Security.Principal.SecurityIdentifier, $group: System.Security.Principal.SecurityIdentifier, $systemAcl: System.Security.AccessControl.RawAcl, $discretionaryAcl: System.Security.AccessControl.RawAcl)
            public constructor ()
        }
        class CompoundAce extends System.Security.AccessControl.KnownAce
        {
            protected [__keep_incompatibility]: never;
            public get BinaryLength(): number;
            public get CompoundAceType(): System.Security.AccessControl.CompoundAceType;
            public set CompoundAceType(value: System.Security.AccessControl.CompoundAceType);
            public constructor ($flags: System.Security.AccessControl.AceFlags, $accessMask: number, $compoundAceType: System.Security.AccessControl.CompoundAceType, $sid: System.Security.Principal.SecurityIdentifier)
            public constructor ()
        }
        enum CompoundAceType
        { Impersonation = 1 }
        class CryptoKeyAccessRule extends System.Security.AccessControl.AccessRule
        {
            protected [__keep_incompatibility]: never;
            public get CryptoKeyRights(): System.Security.AccessControl.CryptoKeyRights;
            public constructor ($identity: System.Security.Principal.IdentityReference, $cryptoKeyRights: System.Security.AccessControl.CryptoKeyRights, $type: System.Security.AccessControl.AccessControlType)
            public constructor ($identity: string, $cryptoKeyRights: System.Security.AccessControl.CryptoKeyRights, $type: System.Security.AccessControl.AccessControlType)
            public constructor ()
        }
        enum CryptoKeyRights
        { ReadData = 1, WriteData = 2, ReadExtendedAttributes = 8, WriteExtendedAttributes = 16, ReadAttributes = 128, WriteAttributes = 256, Delete = 65536, ReadPermissions = 131072, ChangePermissions = 262144, TakeOwnership = 524288, Synchronize = 1048576, FullControl = 2032027, GenericAll = 268435456, GenericExecute = 536870912, GenericWrite = 1073741824, GenericRead = -2147483648 }
        class CryptoKeyAuditRule extends System.Security.AccessControl.AuditRule
        {
            protected [__keep_incompatibility]: never;
            public get CryptoKeyRights(): System.Security.AccessControl.CryptoKeyRights;
            public constructor ($identity: System.Security.Principal.IdentityReference, $cryptoKeyRights: System.Security.AccessControl.CryptoKeyRights, $flags: System.Security.AccessControl.AuditFlags)
            public constructor ($identity: string, $cryptoKeyRights: System.Security.AccessControl.CryptoKeyRights, $flags: System.Security.AccessControl.AuditFlags)
            public constructor ()
        }
        class CustomAce extends System.Security.AccessControl.GenericAce
        {
            protected [__keep_incompatibility]: never;
            public static MaxOpaqueLength : number
            public get BinaryLength(): number;
            public get OpaqueLength(): number;
            public GetOpaque () : System.Array$1<number>
            public SetOpaque ($opaque: System.Array$1<number>) : void
            public constructor ($type: System.Security.AccessControl.AceType, $flags: System.Security.AccessControl.AceFlags, $opaque: System.Array$1<number>)
            public constructor ()
        }
        class DirectoryObjectSecurity extends System.Security.AccessControl.ObjectSecurity
        {
            protected [__keep_incompatibility]: never;
            public AccessRuleFactory ($identityReference: System.Security.Principal.IdentityReference, $accessMask: number, $isInherited: boolean, $inheritanceFlags: System.Security.AccessControl.InheritanceFlags, $propagationFlags: System.Security.AccessControl.PropagationFlags, $type: System.Security.AccessControl.AccessControlType, $objectType: System.Guid, $inheritedObjectType: System.Guid) : System.Security.AccessControl.AccessRule
            public AuditRuleFactory ($identityReference: System.Security.Principal.IdentityReference, $accessMask: number, $isInherited: boolean, $inheritanceFlags: System.Security.AccessControl.InheritanceFlags, $propagationFlags: System.Security.AccessControl.PropagationFlags, $flags: System.Security.AccessControl.AuditFlags, $objectType: System.Guid, $inheritedObjectType: System.Guid) : System.Security.AccessControl.AuditRule
            public GetAccessRules ($includeExplicit: boolean, $includeInherited: boolean, $targetType: System.Type) : System.Security.AccessControl.AuthorizationRuleCollection
            public GetAuditRules ($includeExplicit: boolean, $includeInherited: boolean, $targetType: System.Type) : System.Security.AccessControl.AuthorizationRuleCollection
            public AccessRuleFactory ($identityReference: System.Security.Principal.IdentityReference, $accessMask: number, $isInherited: boolean, $inheritanceFlags: System.Security.AccessControl.InheritanceFlags, $propagationFlags: System.Security.AccessControl.PropagationFlags, $type: System.Security.AccessControl.AccessControlType) : System.Security.AccessControl.AccessRule
            public AuditRuleFactory ($identityReference: System.Security.Principal.IdentityReference, $accessMask: number, $isInherited: boolean, $inheritanceFlags: System.Security.AccessControl.InheritanceFlags, $propagationFlags: System.Security.AccessControl.PropagationFlags, $flags: System.Security.AccessControl.AuditFlags) : System.Security.AccessControl.AuditRule
        }
        class FileSystemSecurity extends System.Security.AccessControl.NativeObjectSecurity
        {
            protected [__keep_incompatibility]: never;
            public get AccessRightType(): System.Type;
            public get AccessRuleType(): System.Type;
            public get AuditRuleType(): System.Type;
            public AddAccessRule ($rule: System.Security.AccessControl.FileSystemAccessRule) : void
            public RemoveAccessRule ($rule: System.Security.AccessControl.FileSystemAccessRule) : boolean
            public RemoveAccessRuleAll ($rule: System.Security.AccessControl.FileSystemAccessRule) : void
            public RemoveAccessRuleSpecific ($rule: System.Security.AccessControl.FileSystemAccessRule) : void
            public ResetAccessRule ($rule: System.Security.AccessControl.FileSystemAccessRule) : void
            public SetAccessRule ($rule: System.Security.AccessControl.FileSystemAccessRule) : void
            public AddAuditRule ($rule: System.Security.AccessControl.FileSystemAuditRule) : void
            public RemoveAuditRule ($rule: System.Security.AccessControl.FileSystemAuditRule) : boolean
            public RemoveAuditRuleAll ($rule: System.Security.AccessControl.FileSystemAuditRule) : void
            public RemoveAuditRuleSpecific ($rule: System.Security.AccessControl.FileSystemAuditRule) : void
            public SetAuditRule ($rule: System.Security.AccessControl.FileSystemAuditRule) : void
        }
        class DirectorySecurity extends System.Security.AccessControl.FileSystemSecurity
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($name: string, $includeSections: System.Security.AccessControl.AccessControlSections)
        }
        enum ObjectAceFlags
        { None = 0, ObjectAceTypePresent = 1, InheritedObjectAceTypePresent = 2 }
        class ObjectAccessRule extends System.Security.AccessControl.AccessRule
        {
            protected [__keep_incompatibility]: never;
            public get InheritedObjectType(): System.Guid;
            public get ObjectFlags(): System.Security.AccessControl.ObjectAceFlags;
            public get ObjectType(): System.Guid;
        }
        class RawAcl extends System.Security.AccessControl.GenericAcl implements System.Collections.ICollection, System.Collections.IEnumerable
        {
            protected [__keep_incompatibility]: never;
            public get BinaryLength(): number;
            public get Count(): number;
            public get Revision(): number;
            public InsertAce ($index: number, $ace: System.Security.AccessControl.GenericAce) : void
            public RemoveAce ($index: number) : void
            public constructor ($revision: number, $capacity: number)
            public constructor ($binaryForm: System.Array$1<number>, $offset: number)
            public constructor ()
        }
        class EventWaitHandleAccessRule extends System.Security.AccessControl.AccessRule
        {
            protected [__keep_incompatibility]: never;
            public get EventWaitHandleRights(): System.Security.AccessControl.EventWaitHandleRights;
            public constructor ($identity: System.Security.Principal.IdentityReference, $eventRights: System.Security.AccessControl.EventWaitHandleRights, $type: System.Security.AccessControl.AccessControlType)
            public constructor ($identity: string, $eventRights: System.Security.AccessControl.EventWaitHandleRights, $type: System.Security.AccessControl.AccessControlType)
            public constructor ()
        }
        class EventWaitHandleAuditRule extends System.Security.AccessControl.AuditRule
        {
            protected [__keep_incompatibility]: never;
            public get EventWaitHandleRights(): System.Security.AccessControl.EventWaitHandleRights;
            public constructor ($identity: System.Security.Principal.IdentityReference, $eventRights: System.Security.AccessControl.EventWaitHandleRights, $flags: System.Security.AccessControl.AuditFlags)
            public constructor ()
        }
        class FileSecurity extends System.Security.AccessControl.FileSystemSecurity
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($fileName: string, $includeSections: System.Security.AccessControl.AccessControlSections)
        }
        class FileSystemAccessRule extends System.Security.AccessControl.AccessRule
        {
            protected [__keep_incompatibility]: never;
            public get FileSystemRights(): System.Security.AccessControl.FileSystemRights;
            public constructor ($identity: System.Security.Principal.IdentityReference, $fileSystemRights: System.Security.AccessControl.FileSystemRights, $type: System.Security.AccessControl.AccessControlType)
            public constructor ($identity: string, $fileSystemRights: System.Security.AccessControl.FileSystemRights, $type: System.Security.AccessControl.AccessControlType)
            public constructor ($identity: System.Security.Principal.IdentityReference, $fileSystemRights: System.Security.AccessControl.FileSystemRights, $inheritanceFlags: System.Security.AccessControl.InheritanceFlags, $propagationFlags: System.Security.AccessControl.PropagationFlags, $type: System.Security.AccessControl.AccessControlType)
            public constructor ($identity: string, $fileSystemRights: System.Security.AccessControl.FileSystemRights, $inheritanceFlags: System.Security.AccessControl.InheritanceFlags, $propagationFlags: System.Security.AccessControl.PropagationFlags, $type: System.Security.AccessControl.AccessControlType)
            public constructor ()
        }
        enum FileSystemRights
        { ListDirectory = 1, ReadData = 1, CreateFiles = 2, WriteData = 2, AppendData = 4, CreateDirectories = 4, ReadExtendedAttributes = 8, WriteExtendedAttributes = 16, ExecuteFile = 32, Traverse = 32, DeleteSubdirectoriesAndFiles = 64, ReadAttributes = 128, WriteAttributes = 256, Write = 278, Delete = 65536, ReadPermissions = 131072, Read = 131209, ReadAndExecute = 131241, Modify = 197055, ChangePermissions = 262144, TakeOwnership = 524288, Synchronize = 1048576, FullControl = 2032127 }
        class FileSystemAuditRule extends System.Security.AccessControl.AuditRule
        {
            protected [__keep_incompatibility]: never;
            public get FileSystemRights(): System.Security.AccessControl.FileSystemRights;
            public constructor ($identity: System.Security.Principal.IdentityReference, $fileSystemRights: System.Security.AccessControl.FileSystemRights, $flags: System.Security.AccessControl.AuditFlags)
            public constructor ($identity: string, $fileSystemRights: System.Security.AccessControl.FileSystemRights, $flags: System.Security.AccessControl.AuditFlags)
            public constructor ($identity: System.Security.Principal.IdentityReference, $fileSystemRights: System.Security.AccessControl.FileSystemRights, $inheritanceFlags: System.Security.AccessControl.InheritanceFlags, $propagationFlags: System.Security.AccessControl.PropagationFlags, $flags: System.Security.AccessControl.AuditFlags)
            public constructor ($identity: string, $fileSystemRights: System.Security.AccessControl.FileSystemRights, $inheritanceFlags: System.Security.AccessControl.InheritanceFlags, $propagationFlags: System.Security.AccessControl.PropagationFlags, $flags: System.Security.AccessControl.AuditFlags)
            public constructor ()
        }
        class MutexAccessRule extends System.Security.AccessControl.AccessRule
        {
            protected [__keep_incompatibility]: never;
            public get MutexRights(): System.Security.AccessControl.MutexRights;
            public constructor ($identity: System.Security.Principal.IdentityReference, $eventRights: System.Security.AccessControl.MutexRights, $type: System.Security.AccessControl.AccessControlType)
            public constructor ($identity: string, $eventRights: System.Security.AccessControl.MutexRights, $type: System.Security.AccessControl.AccessControlType)
            public constructor ()
        }
        class MutexAuditRule extends System.Security.AccessControl.AuditRule
        {
            protected [__keep_incompatibility]: never;
            public get MutexRights(): System.Security.AccessControl.MutexRights;
            public constructor ($identity: System.Security.Principal.IdentityReference, $eventRights: System.Security.AccessControl.MutexRights, $flags: System.Security.AccessControl.AuditFlags)
            public constructor ()
        }
        class ObjectAce extends System.Security.AccessControl.QualifiedAce
        {
            protected [__keep_incompatibility]: never;
            public get BinaryLength(): number;
            public get InheritedObjectAceType(): System.Guid;
            public set InheritedObjectAceType(value: System.Guid);
            public get ObjectAceFlags(): System.Security.AccessControl.ObjectAceFlags;
            public set ObjectAceFlags(value: System.Security.AccessControl.ObjectAceFlags);
            public get ObjectAceType(): System.Guid;
            public set ObjectAceType(value: System.Guid);
            public static MaxOpaqueLength ($isCallback: boolean) : number
            public constructor ($aceFlags: System.Security.AccessControl.AceFlags, $qualifier: System.Security.AccessControl.AceQualifier, $accessMask: number, $sid: System.Security.Principal.SecurityIdentifier, $flags: System.Security.AccessControl.ObjectAceFlags, $type: System.Guid, $inheritedType: System.Guid, $isCallback: boolean, $opaque: System.Array$1<number>)
            public constructor ()
        }
        class ObjectAuditRule extends System.Security.AccessControl.AuditRule
        {
            protected [__keep_incompatibility]: never;
            public get InheritedObjectType(): System.Guid;
            public get ObjectFlags(): System.Security.AccessControl.ObjectAceFlags;
            public get ObjectType(): System.Guid;
        }
        class ObjectSecurity$1<T> extends System.Security.AccessControl.NativeObjectSecurity
        {
            protected [__keep_incompatibility]: never;
            public get AccessRightType(): System.Type;
            public get AccessRuleType(): System.Type;
            public get AuditRuleType(): System.Type;
            public AddAccessRule ($rule: System.Security.AccessControl.AccessRule$1<T>) : void
            public RemoveAccessRule ($rule: System.Security.AccessControl.AccessRule$1<T>) : boolean
            public RemoveAccessRuleAll ($rule: System.Security.AccessControl.AccessRule$1<T>) : void
            public RemoveAccessRuleSpecific ($rule: System.Security.AccessControl.AccessRule$1<T>) : void
            public ResetAccessRule ($rule: System.Security.AccessControl.AccessRule$1<T>) : void
            public SetAccessRule ($rule: System.Security.AccessControl.AccessRule$1<T>) : void
            public AddAuditRule ($rule: System.Security.AccessControl.AuditRule$1<T>) : void
            public RemoveAuditRule ($rule: System.Security.AccessControl.AuditRule$1<T>) : boolean
            public RemoveAuditRuleAll ($rule: System.Security.AccessControl.AuditRule$1<T>) : void
            public RemoveAuditRuleSpecific ($rule: System.Security.AccessControl.AuditRule$1<T>) : void
            public SetAuditRule ($rule: System.Security.AccessControl.AuditRule$1<T>) : void
        }
        enum ResourceType
        { Unknown = 0, FileObject = 1, Service = 2, Printer = 3, RegistryKey = 4, LMShare = 5, KernelObject = 6, WindowObject = 7, DSObject = 8, DSObjectAll = 9, ProviderDefined = 10, WmiGuidObject = 11, RegistryWow6432Key = 12 }
        enum SecurityInfos
        { Owner = 1, Group = 2, DiscretionaryAcl = 4, SystemAcl = 8 }
    }
    namespace System.Runtime.ConstrainedExecution {
        class CriticalFinalizerObject extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        enum Cer
        { None = 0, MayFail = 1, Success = 2 }
        enum Consistency
        { MayCorruptProcess = 0, MayCorruptAppDomain = 1, MayCorruptInstance = 2, WillNotCorruptState = 3 }
        class ReliabilityContractAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get ConsistencyGuarantee(): System.Runtime.ConstrainedExecution.Consistency;
            public get Cer(): System.Runtime.ConstrainedExecution.Cer;
            public constructor ($consistencyGuarantee: System.Runtime.ConstrainedExecution.Consistency, $cer: System.Runtime.ConstrainedExecution.Cer)
            public constructor ()
        }
        class PrePrepareMethodAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
    }
    namespace System.Runtime.InteropServices {
        class SafeHandle extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get IsClosed(): boolean;
            public get IsInvalid(): boolean;
            public DangerousGetHandle () : System.IntPtr
            public Close () : void
            public Dispose () : void
            public SetHandleAsInvalid () : void
            public DangerousAddRef ($success: $Ref<boolean>) : void
            public DangerousRelease () : void
        }
        class CriticalHandle extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get IsClosed(): boolean;
            public get IsInvalid(): boolean;
            public Close () : void
            public Dispose () : void
            public SetHandleAsInvalid () : void
        }
        interface _Exception
        {
            HelpLink : string
            InnerException : System.Exception
            Message : string
            Source : string
            StackTrace : string
            TargetSite : System.Reflection.MethodBase
            Equals ($obj: any) : boolean
            GetBaseException () : System.Exception
            GetHashCode () : number
            GetObjectData ($info: System.Runtime.Serialization.SerializationInfo, $context: System.Runtime.Serialization.StreamingContext) : void
            GetType () : System.Type
            ToString () : string
        }
        interface _Assembly
        {
            CodeBase : string
            EscapedCodeBase : string
            FullName : string
            EntryPoint : System.Reflection.MethodInfo
            Location : string
            Evidence : System.Security.Policy.Evidence
            GlobalAssemblyCache : boolean
            ToString () : string
            Equals ($other: any) : boolean
            GetHashCode () : number
            GetType () : System.Type
            GetName () : System.Reflection.AssemblyName
            GetName ($copiedName: boolean) : System.Reflection.AssemblyName
            GetType ($name: string) : System.Type
            GetType ($name: string, $throwOnError: boolean) : System.Type
            GetExportedTypes () : System.Array$1<System.Type>
            GetTypes () : System.Array$1<System.Type>
            GetManifestResourceStream ($type: System.Type, $name: string) : System.IO.Stream
            GetManifestResourceStream ($name: string) : System.IO.Stream
            GetFile ($name: string) : System.IO.FileStream
            GetFiles () : System.Array$1<System.IO.FileStream>
            GetFiles ($getResourceModules: boolean) : System.Array$1<System.IO.FileStream>
            GetManifestResourceNames () : System.Array$1<string>
            GetManifestResourceInfo ($resourceName: string) : System.Reflection.ManifestResourceInfo
            GetCustomAttributes ($attributeType: System.Type, $inherit: boolean) : System.Array$1<any>
            GetCustomAttributes ($inherit: boolean) : System.Array$1<any>
            IsDefined ($attributeType: System.Type, $inherit: boolean) : boolean
            GetObjectData ($info: System.Runtime.Serialization.SerializationInfo, $context: System.Runtime.Serialization.StreamingContext) : void
            GetType ($name: string, $throwOnError: boolean, $ignoreCase: boolean) : System.Type
            GetSatelliteAssembly ($culture: System.Globalization.CultureInfo) : System.Reflection.Assembly
            GetSatelliteAssembly ($culture: System.Globalization.CultureInfo, $version: System.Version) : System.Reflection.Assembly
            LoadModule ($moduleName: string, $rawModule: System.Array$1<number>) : System.Reflection.Module
            LoadModule ($moduleName: string, $rawModule: System.Array$1<number>, $rawSymbolStore: System.Array$1<number>) : System.Reflection.Module
            CreateInstance ($typeName: string) : any
            CreateInstance ($typeName: string, $ignoreCase: boolean) : any
            CreateInstance ($typeName: string, $ignoreCase: boolean, $bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $args: System.Array$1<any>, $culture: System.Globalization.CultureInfo, $activationAttributes: System.Array$1<any>) : any
            GetLoadedModules () : System.Array$1<System.Reflection.Module>
            GetLoadedModules ($getResourceModules: boolean) : System.Array$1<System.Reflection.Module>
            GetModules () : System.Array$1<System.Reflection.Module>
            GetModules ($getResourceModules: boolean) : System.Array$1<System.Reflection.Module>
            GetModule ($name: string) : System.Reflection.Module
            GetReferencedAssemblies () : System.Array$1<System.Reflection.AssemblyName>
            add_ModuleResolve ($value: System.Reflection.ModuleResolveEventHandler) : void
            remove_ModuleResolve ($value: System.Reflection.ModuleResolveEventHandler) : void
        }
        interface _Attribute
        {
            GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
        }
        interface _MemberInfo
        {
            DeclaringType : System.Type
            MemberType : System.Reflection.MemberTypes
            Name : string
            ReflectedType : System.Type
            Equals ($other: any) : boolean
            GetCustomAttributes ($inherit: boolean) : System.Array$1<any>
            GetCustomAttributes ($attributeType: System.Type, $inherit: boolean) : System.Array$1<any>
            GetHashCode () : number
            GetType () : System.Type
            IsDefined ($attributeType: System.Type, $inherit: boolean) : boolean
            ToString () : string
            GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
        }
        interface _Type
        {
            MemberType : System.Reflection.MemberTypes
            Name : string
            DeclaringType : System.Type
            ReflectedType : System.Type
            GUID : System.Guid
            Module : System.Reflection.Module
            Assembly : System.Reflection.Assembly
            TypeHandle : System.RuntimeTypeHandle
            FullName : string
            Namespace : string
            AssemblyQualifiedName : string
            BaseType : System.Type
            UnderlyingSystemType : System.Type
            TypeInitializer : System.Reflection.ConstructorInfo
            Attributes : System.Reflection.TypeAttributes
            IsNotPublic : boolean
            IsPublic : boolean
            IsNestedPublic : boolean
            IsNestedPrivate : boolean
            IsNestedFamily : boolean
            IsNestedAssembly : boolean
            IsNestedFamANDAssem : boolean
            IsNestedFamORAssem : boolean
            IsAutoLayout : boolean
            IsLayoutSequential : boolean
            IsExplicitLayout : boolean
            IsClass : boolean
            IsInterface : boolean
            IsValueType : boolean
            IsAbstract : boolean
            IsSealed : boolean
            IsEnum : boolean
            IsSpecialName : boolean
            IsImport : boolean
            IsSerializable : boolean
            IsAnsiClass : boolean
            IsUnicodeClass : boolean
            IsAutoClass : boolean
            IsArray : boolean
            IsByRef : boolean
            IsPointer : boolean
            IsPrimitive : boolean
            IsCOMObject : boolean
            HasElementType : boolean
            IsContextful : boolean
            IsMarshalByRef : boolean
            GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
            ToString () : string
            Equals ($other: any) : boolean
            GetHashCode () : number
            GetType () : System.Type
            GetCustomAttributes ($attributeType: System.Type, $inherit: boolean) : System.Array$1<any>
            GetCustomAttributes ($inherit: boolean) : System.Array$1<any>
            IsDefined ($attributeType: System.Type, $inherit: boolean) : boolean
            GetArrayRank () : number
            GetConstructors ($bindingAttr: System.Reflection.BindingFlags) : System.Array$1<System.Reflection.ConstructorInfo>
            GetInterface ($name: string, $ignoreCase: boolean) : System.Type
            GetInterfaces () : System.Array$1<System.Type>
            FindInterfaces ($filter: System.Reflection.TypeFilter, $filterCriteria: any) : System.Array$1<System.Type>
            GetEvent ($name: string, $bindingAttr: System.Reflection.BindingFlags) : System.Reflection.EventInfo
            GetEvents () : System.Array$1<System.Reflection.EventInfo>
            GetEvents ($bindingAttr: System.Reflection.BindingFlags) : System.Array$1<System.Reflection.EventInfo>
            GetNestedTypes ($bindingAttr: System.Reflection.BindingFlags) : System.Array$1<System.Type>
            GetNestedType ($name: string, $bindingAttr: System.Reflection.BindingFlags) : System.Type
            GetMember ($name: string, $type: System.Reflection.MemberTypes, $bindingAttr: System.Reflection.BindingFlags) : System.Array$1<System.Reflection.MemberInfo>
            GetDefaultMembers () : System.Array$1<System.Reflection.MemberInfo>
            FindMembers ($memberType: System.Reflection.MemberTypes, $bindingAttr: System.Reflection.BindingFlags, $filter: System.Reflection.MemberFilter, $filterCriteria: any) : System.Array$1<System.Reflection.MemberInfo>
            GetElementType () : System.Type
            IsSubclassOf ($c: System.Type) : boolean
            IsInstanceOfType ($o: any) : boolean
            IsAssignableFrom ($c: System.Type) : boolean
            GetInterfaceMap ($interfaceType: System.Type) : System.Reflection.InterfaceMapping
            GetMethod ($name: string, $bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>) : System.Reflection.MethodInfo
            GetMethod ($name: string, $bindingAttr: System.Reflection.BindingFlags) : System.Reflection.MethodInfo
            GetMethods ($bindingAttr: System.Reflection.BindingFlags) : System.Array$1<System.Reflection.MethodInfo>
            GetField ($name: string, $bindingAttr: System.Reflection.BindingFlags) : System.Reflection.FieldInfo
            GetFields ($bindingAttr: System.Reflection.BindingFlags) : System.Array$1<System.Reflection.FieldInfo>
            GetProperty ($name: string, $bindingAttr: System.Reflection.BindingFlags) : System.Reflection.PropertyInfo
            GetProperty ($name: string, $bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $returnType: System.Type, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>) : System.Reflection.PropertyInfo
            GetProperties ($bindingAttr: System.Reflection.BindingFlags) : System.Array$1<System.Reflection.PropertyInfo>
            GetMember ($name: string, $bindingAttr: System.Reflection.BindingFlags) : System.Array$1<System.Reflection.MemberInfo>
            GetMembers ($bindingAttr: System.Reflection.BindingFlags) : System.Array$1<System.Reflection.MemberInfo>
            InvokeMember ($name: string, $invokeAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $target: any, $args: System.Array$1<any>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>, $culture: System.Globalization.CultureInfo, $namedParameters: System.Array$1<string>) : any
            InvokeMember ($name: string, $invokeAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $target: any, $args: System.Array$1<any>, $culture: System.Globalization.CultureInfo) : any
            InvokeMember ($name: string, $invokeAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $target: any, $args: System.Array$1<any>) : any
            GetConstructor ($bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $callConvention: System.Reflection.CallingConventions, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>) : System.Reflection.ConstructorInfo
            GetConstructor ($bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>) : System.Reflection.ConstructorInfo
            GetConstructor ($types: System.Array$1<System.Type>) : System.Reflection.ConstructorInfo
            GetConstructors () : System.Array$1<System.Reflection.ConstructorInfo>
            GetMethod ($name: string, $bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $callConvention: System.Reflection.CallingConventions, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>) : System.Reflection.MethodInfo
            GetMethod ($name: string, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>) : System.Reflection.MethodInfo
            GetMethod ($name: string, $types: System.Array$1<System.Type>) : System.Reflection.MethodInfo
            GetMethod ($name: string) : System.Reflection.MethodInfo
            GetMethods () : System.Array$1<System.Reflection.MethodInfo>
            GetField ($name: string) : System.Reflection.FieldInfo
            GetFields () : System.Array$1<System.Reflection.FieldInfo>
            GetInterface ($name: string) : System.Type
            GetEvent ($name: string) : System.Reflection.EventInfo
            GetProperty ($name: string, $returnType: System.Type, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>) : System.Reflection.PropertyInfo
            GetProperty ($name: string, $returnType: System.Type, $types: System.Array$1<System.Type>) : System.Reflection.PropertyInfo
            GetProperty ($name: string, $types: System.Array$1<System.Type>) : System.Reflection.PropertyInfo
            GetProperty ($name: string, $returnType: System.Type) : System.Reflection.PropertyInfo
            GetProperty ($name: string) : System.Reflection.PropertyInfo
            GetProperties () : System.Array$1<System.Reflection.PropertyInfo>
            GetNestedTypes () : System.Array$1<System.Type>
            GetNestedType ($name: string) : System.Type
            GetMember ($name: string) : System.Array$1<System.Reflection.MemberInfo>
            GetMembers () : System.Array$1<System.Reflection.MemberInfo>
            Equals ($o: System.Type) : boolean
        }
        interface _Module
        {
            GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
        }
        interface _MethodBase
        {
            Attributes : System.Reflection.MethodAttributes
            CallingConvention : System.Reflection.CallingConventions
            DeclaringType : System.Type
            IsAbstract : boolean
            IsAssembly : boolean
            IsConstructor : boolean
            IsFamily : boolean
            IsFamilyAndAssembly : boolean
            IsFamilyOrAssembly : boolean
            IsFinal : boolean
            IsHideBySig : boolean
            IsPrivate : boolean
            IsPublic : boolean
            IsSpecialName : boolean
            IsStatic : boolean
            IsVirtual : boolean
            MemberType : System.Reflection.MemberTypes
            MethodHandle : System.RuntimeMethodHandle
            Name : string
            ReflectedType : System.Type
            Equals ($other: any) : boolean
            GetCustomAttributes ($inherit: boolean) : System.Array$1<any>
            GetCustomAttributes ($attributeType: System.Type, $inherit: boolean) : System.Array$1<any>
            GetHashCode () : number
            GetMethodImplementationFlags () : System.Reflection.MethodImplAttributes
            GetParameters () : System.Array$1<System.Reflection.ParameterInfo>
            GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
            GetType () : System.Type
            Invoke ($obj: any, $parameters: System.Array$1<any>) : any
            Invoke ($obj: any, $invokeAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $parameters: System.Array$1<any>, $culture: System.Globalization.CultureInfo) : any
            IsDefined ($attributeType: System.Type, $inherit: boolean) : boolean
            ToString () : string
        }
        class StructLayoutAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public Pack : number
            public Size : number
            public CharSet : System.Runtime.InteropServices.CharSet
            public get Value(): System.Runtime.InteropServices.LayoutKind;
            public constructor ($layoutKind: System.Runtime.InteropServices.LayoutKind)
            public constructor ($layoutKind: number)
            public constructor ()
        }
        interface _ConstructorInfo
        {
            Attributes : System.Reflection.MethodAttributes
            CallingConvention : System.Reflection.CallingConventions
            DeclaringType : System.Type
            IsAbstract : boolean
            IsAssembly : boolean
            IsConstructor : boolean
            IsFamily : boolean
            IsFamilyAndAssembly : boolean
            IsFamilyOrAssembly : boolean
            IsFinal : boolean
            IsHideBySig : boolean
            IsPrivate : boolean
            IsPublic : boolean
            IsSpecialName : boolean
            IsStatic : boolean
            IsVirtual : boolean
            MemberType : System.Reflection.MemberTypes
            MethodHandle : System.RuntimeMethodHandle
            Name : string
            ReflectedType : System.Type
            Equals ($other: any) : boolean
            GetCustomAttributes ($inherit: boolean) : System.Array$1<any>
            GetCustomAttributes ($attributeType: System.Type, $inherit: boolean) : System.Array$1<any>
            GetHashCode () : number
            GetMethodImplementationFlags () : System.Reflection.MethodImplAttributes
            GetParameters () : System.Array$1<System.Reflection.ParameterInfo>
            GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
            GetType () : System.Type
            Invoke_5 ($parameters: System.Array$1<any>) : any
            Invoke_3 ($obj: any, $parameters: System.Array$1<any>) : any
            Invoke_4 ($invokeAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $parameters: System.Array$1<any>, $culture: System.Globalization.CultureInfo) : any
            Invoke_2 ($obj: any, $invokeAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $parameters: System.Array$1<any>, $culture: System.Globalization.CultureInfo) : any
            IsDefined ($attributeType: System.Type, $inherit: boolean) : boolean
            ToString () : string
        }
        interface _EventInfo
        {
            Attributes : System.Reflection.EventAttributes
            DeclaringType : System.Type
            EventHandlerType : System.Type
            IsMulticast : boolean
            IsSpecialName : boolean
            MemberType : System.Reflection.MemberTypes
            Name : string
            ReflectedType : System.Type
            AddEventHandler ($target: any, $handler: Function) : void
            Equals ($other: any) : boolean
            GetAddMethod () : System.Reflection.MethodInfo
            GetAddMethod ($nonPublic: boolean) : System.Reflection.MethodInfo
            GetCustomAttributes ($inherit: boolean) : System.Array$1<any>
            GetCustomAttributes ($attributeType: System.Type, $inherit: boolean) : System.Array$1<any>
            GetHashCode () : number
            GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
            GetRaiseMethod () : System.Reflection.MethodInfo
            GetRaiseMethod ($nonPublic: boolean) : System.Reflection.MethodInfo
            GetRemoveMethod () : System.Reflection.MethodInfo
            GetRemoveMethod ($nonPublic: boolean) : System.Reflection.MethodInfo
            GetType () : System.Type
            IsDefined ($attributeType: System.Type, $inherit: boolean) : boolean
            RemoveEventHandler ($target: any, $handler: Function) : void
            ToString () : string
        }
        interface _FieldInfo
        {
            Attributes : System.Reflection.FieldAttributes
            DeclaringType : System.Type
            FieldHandle : System.RuntimeFieldHandle
            FieldType : System.Type
            IsAssembly : boolean
            IsFamily : boolean
            IsFamilyAndAssembly : boolean
            IsFamilyOrAssembly : boolean
            IsInitOnly : boolean
            IsLiteral : boolean
            IsNotSerialized : boolean
            IsPinvokeImpl : boolean
            IsPrivate : boolean
            IsPublic : boolean
            IsSpecialName : boolean
            IsStatic : boolean
            MemberType : System.Reflection.MemberTypes
            Name : string
            ReflectedType : System.Type
            Equals ($other: any) : boolean
            GetCustomAttributes ($inherit: boolean) : System.Array$1<any>
            GetCustomAttributes ($attributeType: System.Type, $inherit: boolean) : System.Array$1<any>
            GetHashCode () : number
            GetType () : System.Type
            GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
            GetValue ($obj: any) : any
            IsDefined ($attributeType: System.Type, $inherit: boolean) : boolean
            SetValue ($obj: any, $value: any) : void
            SetValue ($obj: any, $value: any, $invokeAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $culture: System.Globalization.CultureInfo) : void
            ToString () : string
        }
        interface _MethodInfo
        {
            MemberType : System.Reflection.MemberTypes
            Name : string
            DeclaringType : System.Type
            ReflectedType : System.Type
            MethodHandle : System.RuntimeMethodHandle
            Attributes : System.Reflection.MethodAttributes
            CallingConvention : System.Reflection.CallingConventions
            IsPublic : boolean
            IsPrivate : boolean
            IsFamily : boolean
            IsAssembly : boolean
            IsFamilyAndAssembly : boolean
            IsFamilyOrAssembly : boolean
            IsStatic : boolean
            IsFinal : boolean
            IsVirtual : boolean
            IsHideBySig : boolean
            IsAbstract : boolean
            IsSpecialName : boolean
            IsConstructor : boolean
            ReturnType : System.Type
            ReturnTypeCustomAttributes : System.Reflection.ICustomAttributeProvider
            GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
            ToString () : string
            Equals ($other: any) : boolean
            GetHashCode () : number
            GetType () : System.Type
            GetCustomAttributes ($attributeType: System.Type, $inherit: boolean) : System.Array$1<any>
            GetCustomAttributes ($inherit: boolean) : System.Array$1<any>
            IsDefined ($attributeType: System.Type, $inherit: boolean) : boolean
            GetParameters () : System.Array$1<System.Reflection.ParameterInfo>
            GetMethodImplementationFlags () : System.Reflection.MethodImplAttributes
            Invoke ($obj: any, $invokeAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $parameters: System.Array$1<any>, $culture: System.Globalization.CultureInfo) : any
            Invoke ($obj: any, $parameters: System.Array$1<any>) : any
            GetBaseDefinition () : System.Reflection.MethodInfo
        }
        interface _PropertyInfo
        {
            Attributes : System.Reflection.PropertyAttributes
            CanRead : boolean
            CanWrite : boolean
            DeclaringType : System.Type
            IsSpecialName : boolean
            MemberType : System.Reflection.MemberTypes
            Name : string
            PropertyType : System.Type
            ReflectedType : System.Type
            Equals ($other: any) : boolean
            GetAccessors () : System.Array$1<System.Reflection.MethodInfo>
            GetAccessors ($nonPublic: boolean) : System.Array$1<System.Reflection.MethodInfo>
            GetCustomAttributes ($inherit: boolean) : System.Array$1<any>
            GetCustomAttributes ($attributeType: System.Type, $inherit: boolean) : System.Array$1<any>
            GetGetMethod () : System.Reflection.MethodInfo
            GetGetMethod ($nonPublic: boolean) : System.Reflection.MethodInfo
            GetHashCode () : number
            GetIndexParameters () : System.Array$1<System.Reflection.ParameterInfo>
            GetSetMethod () : System.Reflection.MethodInfo
            GetSetMethod ($nonPublic: boolean) : System.Reflection.MethodInfo
            GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
            GetType () : System.Type
            GetValue ($obj: any, $index: System.Array$1<any>) : any
            GetValue ($obj: any, $invokeAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $index: System.Array$1<any>, $culture: System.Globalization.CultureInfo) : any
            IsDefined ($attributeType: System.Type, $inherit: boolean) : boolean
            SetValue ($obj: any, $value: any, $index: System.Array$1<any>) : void
            SetValue ($obj: any, $value: any, $invokeAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $index: System.Array$1<any>, $culture: System.Globalization.CultureInfo) : void
            ToString () : string
        }
        interface _AssemblyName
        {
            GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
        }
        interface _Activator
        {
            GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
        }
        interface _ParameterInfo
        {
            GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
        }
        interface _AssemblyBuilder
        {
            GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
        }
        interface _CustomAttributeBuilder
        {
            GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
        }
        interface _Thread
        {
            GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
        }
        enum CharSet
        { None = 1, Ansi = 2, Unicode = 3, Auto = 4 }
        class ExternalException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public get ErrorCode(): number;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $inner: System.Exception)
            public constructor ($message: string, $errorCode: number)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class HandleRef extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get Wrapper(): any;
            public get Handle(): System.IntPtr;
            public static op_Explicit ($value: System.Runtime.InteropServices.HandleRef) : System.IntPtr
            public static ToIntPtr ($value: System.Runtime.InteropServices.HandleRef) : System.IntPtr
            public constructor ($wrapper: any, $handle: System.IntPtr)
            public constructor ()
        }
        enum LayoutKind
        { Sequential = 0, Explicit = 2, Auto = 3 }
        class MarshalDirectiveException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $inner: System.Exception)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class MemoryMarshal extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static TryGetString ($memory: System.ReadOnlyMemory$1<number>, $text: $Ref<string>, $start: $Ref<number>, $length: $Ref<number>) : boolean
        }
        class SequenceMarshal extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        enum Architecture
        { X86 = 0, X64 = 1, Arm = 2, Arm64 = 3 }
        class OSPlatform extends System.ValueType implements System.IEquatable$1<System.Runtime.InteropServices.OSPlatform>
        {
            protected [__keep_incompatibility]: never;
            public static get Linux(): System.Runtime.InteropServices.OSPlatform;
            public static get OSX(): System.Runtime.InteropServices.OSPlatform;
            public static get Windows(): System.Runtime.InteropServices.OSPlatform;
            public static Create ($osPlatform: string) : System.Runtime.InteropServices.OSPlatform
            public Equals ($other: System.Runtime.InteropServices.OSPlatform) : boolean
            public Equals ($obj: any) : boolean
            public static op_Equality ($left: System.Runtime.InteropServices.OSPlatform, $right: System.Runtime.InteropServices.OSPlatform) : boolean
            public static op_Inequality ($left: System.Runtime.InteropServices.OSPlatform, $right: System.Runtime.InteropServices.OSPlatform) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
        }
        enum RegistrationConnectionType
        { SingleUse = 0, MultipleUse = 1, MultiSeparate = 2, Suspended = 4, Surrogate = 8 }
        enum GCHandleType
        { Weak = 0, WeakTrackResurrection = 1, Normal = 2, Pinned = 3 }
        class SafeBuffer extends Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get ByteLength(): bigint;
            public Initialize ($numBytes: bigint) : void
            public Initialize ($numElements: number, $sizeOfEachElement: number) : void
            public AcquirePointer ($pointer: $Ref<System.Byte>) : void
            public ReleasePointer () : void
        }
        class COMException extends System.Runtime.InteropServices.ExternalException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $inner: System.Exception)
            public constructor ($message: string, $errorCode: number)
        }
        class BStrWrapper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get WrappedObject(): string;
            public constructor ($value: string)
            public constructor ($value: any)
            public constructor ()
        }
        enum ComMemberType
        { Method = 0, PropGet = 1, PropSet = 2 }
        class CurrencyWrapper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get WrappedObject(): System.Decimal;
            public constructor ($obj: System.Decimal)
            public constructor ($obj: any)
            public constructor ()
        }
        enum CustomQueryInterfaceMode
        { Ignore = 0, Allow = 1 }
        class ErrorWrapper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get ErrorCode(): number;
            public constructor ($errorCode: number)
            public constructor ($errorCode: any)
            public constructor ($e: System.Exception)
            public constructor ()
        }
        interface ICustomAdapter
        {
            GetUnderlyingObject () : any
        }
        interface ICustomFactory
        {
            CreateInstance ($serverType: System.Type) : System.MarshalByRefObject
        }
        interface ICustomMarshaler
        {
            MarshalNativeToManaged ($pNativeData: System.IntPtr) : any
            MarshalManagedToNative ($ManagedObj: any) : System.IntPtr
            CleanUpNativeData ($pNativeData: System.IntPtr) : void
            CleanUpManagedData ($ManagedObj: any) : void
            GetNativeDataSize () : number
        }
        class InvalidComObjectException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $inner: System.Exception)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class InvalidOleVariantTypeException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $inner: System.Exception)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class SEHException extends System.Runtime.InteropServices.ExternalException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public CanResume () : boolean
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $inner: System.Exception)
        }
        class SafeArrayRankMismatchException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $inner: System.Exception)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class SafeArrayTypeMismatchException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $inner: System.Exception)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class UnknownWrapper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get WrappedObject(): any;
            public constructor ($obj: any)
            public constructor ()
        }
        class VariantWrapper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get WrappedObject(): any;
            public constructor ($obj: any)
            public constructor ()
        }
        class ArrayWithOffset extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public GetArray () : any
            public GetOffset () : number
            public Equals ($obj: any) : boolean
            public Equals ($obj: System.Runtime.InteropServices.ArrayWithOffset) : boolean
            public static op_Equality ($a: System.Runtime.InteropServices.ArrayWithOffset, $b: System.Runtime.InteropServices.ArrayWithOffset) : boolean
            public static op_Inequality ($a: System.Runtime.InteropServices.ArrayWithOffset, $b: System.Runtime.InteropServices.ArrayWithOffset) : boolean
            public constructor ($array: any, $offset: number)
            public static Equals ($objA: any, $objB: any) : boolean
            public constructor ()
        }
        class UnmanagedFunctionPointerAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public CharSet : System.Runtime.InteropServices.CharSet
            public BestFitMapping : boolean
            public ThrowOnUnmappableChar : boolean
            public SetLastError : boolean
            public get CallingConvention(): System.Runtime.InteropServices.CallingConvention;
            public constructor ($callingConvention: System.Runtime.InteropServices.CallingConvention)
            public constructor ()
        }
        enum CallingConvention
        { Winapi = 1, Cdecl = 2, StdCall = 3, ThisCall = 4, FastCall = 5 }
        class TypeIdentifierAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Scope(): string;
            public get Identifier(): string;
            public constructor ()
            public constructor ($scope: string, $identifier: string)
        }
        class AllowReversePInvokeCallsAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class DispIdAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Value(): number;
            public constructor ($dispId: number)
            public constructor ()
        }
        enum ComInterfaceType
        { InterfaceIsDual = 0, InterfaceIsIUnknown = 1, InterfaceIsIDispatch = 2, InterfaceIsIInspectable = 3 }
        class InterfaceTypeAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Value(): System.Runtime.InteropServices.ComInterfaceType;
            public constructor ($interfaceType: System.Runtime.InteropServices.ComInterfaceType)
            public constructor ($interfaceType: number)
            public constructor ()
        }
        class ComDefaultInterfaceAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Value(): System.Type;
            public constructor ($defaultInterface: System.Type)
            public constructor ()
        }
        enum ClassInterfaceType
        { None = 0, AutoDispatch = 1, AutoDual = 2 }
        class ClassInterfaceAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Value(): System.Runtime.InteropServices.ClassInterfaceType;
            public constructor ($classInterfaceType: System.Runtime.InteropServices.ClassInterfaceType)
            public constructor ($classInterfaceType: number)
            public constructor ()
        }
        class ComVisibleAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Value(): boolean;
            public constructor ($visibility: boolean)
            public constructor ()
        }
        class TypeLibImportClassAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Value(): string;
            public constructor ($importClass: System.Type)
            public constructor ()
        }
        class LCIDConversionAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Value(): number;
            public constructor ($lcid: number)
            public constructor ()
        }
        class ComRegisterFunctionAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class ComUnregisterFunctionAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class ProgIdAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Value(): string;
            public constructor ($progId: string)
            public constructor ()
        }
        class ImportedFromTypeLibAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Value(): string;
            public constructor ($tlbFile: string)
            public constructor ()
        }
        enum IDispatchImplType
        { SystemDefinedImpl = 0, InternalImpl = 1, CompatibleImpl = 2 }
        class IDispatchImplAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Value(): System.Runtime.InteropServices.IDispatchImplType;
            public constructor ($implType: System.Runtime.InteropServices.IDispatchImplType)
            public constructor ($implType: number)
            public constructor ()
        }
        class ComSourceInterfacesAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Value(): string;
            public constructor ($sourceInterfaces: string)
            public constructor ($sourceInterface: System.Type)
            public constructor ($sourceInterface1: System.Type, $sourceInterface2: System.Type)
            public constructor ($sourceInterface1: System.Type, $sourceInterface2: System.Type, $sourceInterface3: System.Type)
            public constructor ($sourceInterface1: System.Type, $sourceInterface2: System.Type, $sourceInterface3: System.Type, $sourceInterface4: System.Type)
            public constructor ()
        }
        class ComConversionLossAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        enum TypeLibTypeFlags
        { FAppObject = 1, FCanCreate = 2, FLicensed = 4, FPreDeclId = 8, FHidden = 16, FControl = 32, FDual = 64, FNonExtensible = 128, FOleAutomation = 256, FRestricted = 512, FAggregatable = 1024, FReplaceable = 2048, FDispatchable = 4096, FReverseBind = 8192 }
        enum TypeLibFuncFlags
        { FRestricted = 1, FSource = 2, FBindable = 4, FRequestEdit = 8, FDisplayBind = 16, FDefaultBind = 32, FHidden = 64, FUsesGetLastError = 128, FDefaultCollelem = 256, FUiDefault = 512, FNonBrowsable = 1024, FReplaceable = 2048, FImmediateBind = 4096 }
        enum TypeLibVarFlags
        { FReadOnly = 1, FSource = 2, FBindable = 4, FRequestEdit = 8, FDisplayBind = 16, FDefaultBind = 32, FHidden = 64, FRestricted = 128, FDefaultCollelem = 256, FUiDefault = 512, FNonBrowsable = 1024, FReplaceable = 2048, FImmediateBind = 4096 }
        class TypeLibTypeAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Value(): System.Runtime.InteropServices.TypeLibTypeFlags;
            public constructor ($flags: System.Runtime.InteropServices.TypeLibTypeFlags)
            public constructor ($flags: number)
            public constructor ()
        }
        class TypeLibFuncAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Value(): System.Runtime.InteropServices.TypeLibFuncFlags;
            public constructor ($flags: System.Runtime.InteropServices.TypeLibFuncFlags)
            public constructor ($flags: number)
            public constructor ()
        }
        class TypeLibVarAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Value(): System.Runtime.InteropServices.TypeLibVarFlags;
            public constructor ($flags: System.Runtime.InteropServices.TypeLibVarFlags)
            public constructor ($flags: number)
            public constructor ()
        }
        enum VarEnum
        { VT_EMPTY = 0, VT_NULL = 1, VT_I2 = 2, VT_I4 = 3, VT_R4 = 4, VT_R8 = 5, VT_CY = 6, VT_DATE = 7, VT_BSTR = 8, VT_DISPATCH = 9, VT_ERROR = 10, VT_BOOL = 11, VT_VARIANT = 12, VT_UNKNOWN = 13, VT_DECIMAL = 14, VT_I1 = 16, VT_UI1 = 17, VT_UI2 = 18, VT_UI4 = 19, VT_I8 = 20, VT_UI8 = 21, VT_INT = 22, VT_UINT = 23, VT_VOID = 24, VT_HRESULT = 25, VT_PTR = 26, VT_SAFEARRAY = 27, VT_CARRAY = 28, VT_USERDEFINED = 29, VT_LPSTR = 30, VT_LPWSTR = 31, VT_RECORD = 36, VT_FILETIME = 64, VT_BLOB = 65, VT_STREAM = 66, VT_STORAGE = 67, VT_STREAMED_OBJECT = 68, VT_STORED_OBJECT = 69, VT_BLOB_OBJECT = 70, VT_CF = 71, VT_CLSID = 72, VT_VECTOR = 4096, VT_ARRAY = 8192, VT_BYREF = 16384 }
        enum UnmanagedType
        { Bool = 2, I1 = 3, U1 = 4, I2 = 5, U2 = 6, I4 = 7, U4 = 8, I8 = 9, U8 = 10, R4 = 11, R8 = 12, Currency = 15, BStr = 19, LPStr = 20, LPWStr = 21, LPTStr = 22, ByValTStr = 23, IUnknown = 25, IDispatch = 26, Struct = 27, Interface = 28, SafeArray = 29, ByValArray = 30, SysInt = 31, SysUInt = 32, VBByRefStr = 34, AnsiBStr = 35, TBStr = 36, VariantBool = 37, FunctionPtr = 38, AsAny = 40, LPArray = 42, LPStruct = 43, CustomMarshaler = 44, Error = 45, IInspectable = 46, HString = 47, LPUTF8Str = 48 }
        class ComImportAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class GuidAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Value(): string;
            public constructor ($guid: string)
            public constructor ()
        }
        class PreserveSigAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class InAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class OutAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class OptionalAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        enum DllImportSearchPath
        { UseDllDirectoryForDependencies = 256, ApplicationDirectory = 512, UserDirectories = 1024, System32 = 2048, SafeDirectories = 4096, AssemblyDirectory = 2, LegacyBehavior = 0 }
        class DefaultDllImportSearchPathsAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Paths(): System.Runtime.InteropServices.DllImportSearchPath;
            public constructor ($paths: System.Runtime.InteropServices.DllImportSearchPath)
            public constructor ()
        }
        class DllImportAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public EntryPoint : string
            public CharSet : System.Runtime.InteropServices.CharSet
            public SetLastError : boolean
            public ExactSpelling : boolean
            public PreserveSig : boolean
            public CallingConvention : System.Runtime.InteropServices.CallingConvention
            public BestFitMapping : boolean
            public ThrowOnUnmappableChar : boolean
            public get Value(): string;
            public constructor ($dllName: string)
            public constructor ()
        }
        class FieldOffsetAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Value(): number;
            public constructor ($offset: number)
            public constructor ()
        }
        class ComAliasNameAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Value(): string;
            public constructor ($alias: string)
            public constructor ()
        }
        class AutomationProxyAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Value(): boolean;
            public constructor ($val: boolean)
            public constructor ()
        }
        class PrimaryInteropAssemblyAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get MajorVersion(): number;
            public get MinorVersion(): number;
            public constructor ($major: number, $minor: number)
            public constructor ()
        }
        class CoClassAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get CoClass(): System.Type;
            public constructor ($coClass: System.Type)
            public constructor ()
        }
        class ComEventInterfaceAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get SourceInterface(): System.Type;
            public get EventProvider(): System.Type;
            public constructor ($SourceInterface: System.Type, $EventProvider: System.Type)
            public constructor ()
        }
        class TypeLibVersionAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get MajorVersion(): number;
            public get MinorVersion(): number;
            public constructor ($major: number, $minor: number)
            public constructor ()
        }
        class ComCompatibleVersionAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get MajorVersion(): number;
            public get MinorVersion(): number;
            public get BuildNumber(): number;
            public get RevisionNumber(): number;
            public constructor ($major: number, $minor: number, $build: number, $revision: number)
            public constructor ()
        }
        class BestFitMappingAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public ThrowOnUnmappableChar : boolean
            public get BestFitMapping(): boolean;
            public constructor ($BestFitMapping: boolean)
            public constructor ()
        }
        class DefaultCharSetAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get CharSet(): System.Runtime.InteropServices.CharSet;
            public constructor ($charSet: System.Runtime.InteropServices.CharSet)
            public constructor ()
        }
        class SetWin32ContextInIDispatchAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class ManagedToNativeComInteropStubAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get ClassType(): System.Type;
            public get MethodName(): string;
            public constructor ($classType: System.Type, $methodName: string)
            public constructor ()
        }
        class DispatchWrapper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get WrappedObject(): any;
            public constructor ($obj: any)
            public constructor ()
        }
        enum CustomQueryInterfaceResult
        { Handled = 0, NotHandled = 1, Failed = 2 }
        interface ICustomQueryInterface
        {
            GetInterface ($iid: $Ref<System.Guid>, $ppv: $Ref<System.IntPtr>) : System.Runtime.InteropServices.CustomQueryInterfaceResult
        }
        enum AssemblyRegistrationFlags
        { None = 0, SetCodeBase = 1 }
        interface IRegistrationServices
        {
            RegisterAssembly ($assembly: System.Reflection.Assembly, $flags: System.Runtime.InteropServices.AssemblyRegistrationFlags) : boolean
            UnregisterAssembly ($assembly: System.Reflection.Assembly) : boolean
            GetRegistrableTypesInAssembly ($assembly: System.Reflection.Assembly) : System.Array$1<System.Type>
            GetProgIdForType ($type: System.Type) : string
            RegisterTypeForComClients ($type: System.Type, $g: $Ref<System.Guid>) : void
            GetManagedCategoryGuid () : System.Guid
            TypeRequiresRegistration ($type: System.Type) : boolean
            TypeRepresentsComType ($type: System.Type) : boolean
        }
        interface ObjectCreationDelegate
        { 
        (aggregator: System.IntPtr) : System.IntPtr; 
        Invoke?: (aggregator: System.IntPtr) => System.IntPtr;
        }
        var ObjectCreationDelegate: { new (func: (aggregator: System.IntPtr) => System.IntPtr): ObjectCreationDelegate; }
        class RuntimeEnvironment extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get SystemConfigurationFile(): string;
            public static FromGlobalAccessCache ($a: System.Reflection.Assembly) : boolean
            public static GetSystemVersion () : string
            public static GetRuntimeDirectory () : string
            public static GetRuntimeInterfaceAsIntPtr ($clsid: System.Guid, $riid: System.Guid) : System.IntPtr
            public static GetRuntimeInterfaceAsObject ($clsid: System.Guid, $riid: System.Guid) : any
        }
        class CONNECTDATA extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public pUnk : any
            public dwCookie : number
        }
        interface UCOMIEnumConnections
        {
            Next ($celt: number, $rgelt: System.Array$1<System.Runtime.InteropServices.CONNECTDATA>, $pceltFetched: $Ref<number>) : number
            Skip ($celt: number) : number
            Reset () : void
            Clone ($ppenum: $Ref<System.Runtime.InteropServices.UCOMIEnumConnections>) : void
        }
        enum TYPEKIND
        { TKIND_ENUM = 0, TKIND_RECORD = 1, TKIND_MODULE = 2, TKIND_INTERFACE = 3, TKIND_DISPATCH = 4, TKIND_COCLASS = 5, TKIND_ALIAS = 6, TKIND_UNION = 7, TKIND_MAX = 8 }
        enum TYPEFLAGS
        { TYPEFLAG_FAPPOBJECT = 1, TYPEFLAG_FCANCREATE = 2, TYPEFLAG_FLICENSED = 4, TYPEFLAG_FPREDECLID = 8, TYPEFLAG_FHIDDEN = 16, TYPEFLAG_FCONTROL = 32, TYPEFLAG_FDUAL = 64, TYPEFLAG_FNONEXTENSIBLE = 128, TYPEFLAG_FOLEAUTOMATION = 256, TYPEFLAG_FRESTRICTED = 512, TYPEFLAG_FAGGREGATABLE = 1024, TYPEFLAG_FREPLACEABLE = 2048, TYPEFLAG_FDISPATCHABLE = 4096, TYPEFLAG_FREVERSEBIND = 8192, TYPEFLAG_FPROXY = 16384 }
        enum IMPLTYPEFLAGS
        { IMPLTYPEFLAG_FDEFAULT = 1, IMPLTYPEFLAG_FSOURCE = 2, IMPLTYPEFLAG_FRESTRICTED = 4, IMPLTYPEFLAG_FDEFAULTVTABLE = 8 }
        class TYPEATTR extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public static MEMBER_ID_NIL : number
            public guid : System.Guid
            public lcid : number
            public dwReserved : number
            public memidConstructor : number
            public memidDestructor : number
            public lpstrSchema : System.IntPtr
            public cbSizeInstance : number
            public typekind : System.Runtime.InteropServices.TYPEKIND
            public cFuncs : number
            public cVars : number
            public cImplTypes : number
            public cbSizeVft : number
            public cbAlignment : number
            public wTypeFlags : System.Runtime.InteropServices.TYPEFLAGS
            public wMajorVerNum : number
            public wMinorVerNum : number
            public tdescAlias : System.Runtime.InteropServices.TYPEDESC
            public idldescType : System.Runtime.InteropServices.IDLDESC
        }
        class TYPEDESC extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public lpValue : System.IntPtr
            public vt : number
        }
        class IDLDESC extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public dwReserved : number
            public wIDLFlags : System.Runtime.InteropServices.IDLFLAG
        }
        class FUNCDESC extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public memid : number
            public lprgscode : System.IntPtr
            public lprgelemdescParam : System.IntPtr
            public funckind : System.Runtime.InteropServices.FUNCKIND
            public invkind : System.Runtime.InteropServices.INVOKEKIND
            public callconv : System.Runtime.InteropServices.CALLCONV
            public cParams : number
            public cParamsOpt : number
            public oVft : number
            public cScodes : number
            public elemdescFunc : System.Runtime.InteropServices.ELEMDESC
            public wFuncFlags : number
        }
        enum FUNCKIND
        { FUNC_VIRTUAL = 0, FUNC_PUREVIRTUAL = 1, FUNC_NONVIRTUAL = 2, FUNC_STATIC = 3, FUNC_DISPATCH = 4 }
        enum INVOKEKIND
        { INVOKE_FUNC = 1, INVOKE_PROPERTYGET = 2, INVOKE_PROPERTYPUT = 4, INVOKE_PROPERTYPUTREF = 8 }
        enum CALLCONV
        { CC_CDECL = 1, CC_MSCPASCAL = 2, CC_PASCAL = 2, CC_MACPASCAL = 3, CC_STDCALL = 4, CC_RESERVED = 5, CC_SYSCALL = 6, CC_MPWCDECL = 7, CC_MPWPASCAL = 8, CC_MAX = 9 }
        class ELEMDESC extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public tdesc : System.Runtime.InteropServices.TYPEDESC
            public desc : System.Runtime.InteropServices.ELEMDESC.DESCUNION
        }
        enum IDLFLAG
        { IDLFLAG_NONE = 0, IDLFLAG_FIN = 1, IDLFLAG_FOUT = 2, IDLFLAG_FLCID = 4, IDLFLAG_FRETVAL = 8 }
        enum PARAMFLAG
        { PARAMFLAG_NONE = 0, PARAMFLAG_FIN = 1, PARAMFLAG_FOUT = 2, PARAMFLAG_FLCID = 4, PARAMFLAG_FRETVAL = 8, PARAMFLAG_FOPT = 16, PARAMFLAG_FHASDEFAULT = 32, PARAMFLAG_FHASCUSTDATA = 64 }
        class PARAMDESC extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public lpVarValue : System.IntPtr
            public wParamFlags : System.Runtime.InteropServices.PARAMFLAG
        }
        class VARDESC extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public memid : number
            public lpstrSchema : string
            public elemdescVar : System.Runtime.InteropServices.ELEMDESC
            public wVarFlags : number
            public varkind : System.Runtime.InteropServices.VarEnum
        }
        class DISPPARAMS extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public rgvarg : System.IntPtr
            public rgdispidNamedArgs : System.IntPtr
            public cArgs : number
            public cNamedArgs : number
        }
        class EXCEPINFO extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public wCode : number
            public wReserved : number
            public bstrSource : string
            public bstrDescription : string
            public bstrHelpFile : string
            public dwHelpContext : number
            public pvReserved : System.IntPtr
            public pfnDeferredFillIn : System.IntPtr
        }
        enum FUNCFLAGS
        { FUNCFLAG_FRESTRICTED = 1, FUNCFLAG_FSOURCE = 2, FUNCFLAG_FBINDABLE = 4, FUNCFLAG_FREQUESTEDIT = 8, FUNCFLAG_FDISPLAYBIND = 16, FUNCFLAG_FDEFAULTBIND = 32, FUNCFLAG_FHIDDEN = 64, FUNCFLAG_FUSESGETLASTERROR = 128, FUNCFLAG_FDEFAULTCOLLELEM = 256, FUNCFLAG_FUIDEFAULT = 512, FUNCFLAG_FNONBROWSABLE = 1024, FUNCFLAG_FREPLACEABLE = 2048, FUNCFLAG_FIMMEDIATEBIND = 4096 }
        enum VARFLAGS
        { VARFLAG_FREADONLY = 1, VARFLAG_FSOURCE = 2, VARFLAG_FBINDABLE = 4, VARFLAG_FREQUESTEDIT = 8, VARFLAG_FDISPLAYBIND = 16, VARFLAG_FDEFAULTBIND = 32, VARFLAG_FHIDDEN = 64, VARFLAG_FRESTRICTED = 128, VARFLAG_FDEFAULTCOLLELEM = 256, VARFLAG_FUIDEFAULT = 512, VARFLAG_FNONBROWSABLE = 1024, VARFLAG_FREPLACEABLE = 2048, VARFLAG_FIMMEDIATEBIND = 4096 }
        interface UCOMITypeInfo
        {
            GetTypeAttr ($ppTypeAttr: $Ref<System.IntPtr>) : void
            GetTypeComp ($ppTComp: $Ref<System.Runtime.InteropServices.UCOMITypeComp>) : void
            GetFuncDesc ($index: number, $ppFuncDesc: $Ref<System.IntPtr>) : void
            GetVarDesc ($index: number, $ppVarDesc: $Ref<System.IntPtr>) : void
            GetNames ($memid: number, $rgBstrNames: System.Array$1<string>, $cMaxNames: number, $pcNames: $Ref<number>) : void
            GetRefTypeOfImplType ($index: number, $href: $Ref<number>) : void
            GetImplTypeFlags ($index: number, $pImplTypeFlags: $Ref<number>) : void
            GetIDsOfNames ($rgszNames: System.Array$1<string>, $cNames: number, $pMemId: System.Array$1<number>) : void
            Invoke ($pvInstance: any, $memid: number, $wFlags: number, $pDispParams: $Ref<System.Runtime.InteropServices.DISPPARAMS>, $pVarResult: $Ref<any>, $pExcepInfo: $Ref<System.Runtime.InteropServices.EXCEPINFO>, $puArgErr: $Ref<number>) : void
            GetDocumentation ($index: number, $strName: $Ref<string>, $strDocString: $Ref<string>, $dwHelpContext: $Ref<number>, $strHelpFile: $Ref<string>) : void
            GetDllEntry ($memid: number, $invKind: System.Runtime.InteropServices.INVOKEKIND, $pBstrDllName: $Ref<string>, $pBstrName: $Ref<string>, $pwOrdinal: $Ref<number>) : void
            GetRefTypeInfo ($hRef: number, $ppTI: $Ref<System.Runtime.InteropServices.UCOMITypeInfo>) : void
            AddressOfMember ($memid: number, $invKind: System.Runtime.InteropServices.INVOKEKIND, $ppv: $Ref<System.IntPtr>) : void
            CreateInstance ($pUnkOuter: any, $riid: $Ref<System.Guid>, $ppvObj: $Ref<any>) : void
            GetMops ($memid: number, $pBstrMops: $Ref<string>) : void
            GetContainingTypeLib ($ppTLB: $Ref<System.Runtime.InteropServices.UCOMITypeLib>, $pIndex: $Ref<number>) : void
            ReleaseTypeAttr ($pTypeAttr: System.IntPtr) : void
            ReleaseFuncDesc ($pFuncDesc: System.IntPtr) : void
            ReleaseVarDesc ($pVarDesc: System.IntPtr) : void
        }
        interface UCOMITypeComp
        {
            Bind ($szName: string, $lHashVal: number, $wFlags: number, $ppTInfo: $Ref<System.Runtime.InteropServices.UCOMITypeInfo>, $pDescKind: $Ref<System.Runtime.InteropServices.DESCKIND>, $pBindPtr: $Ref<System.Runtime.InteropServices.BINDPTR>) : void
            BindType ($szName: string, $lHashVal: number, $ppTInfo: $Ref<System.Runtime.InteropServices.UCOMITypeInfo>, $ppTComp: $Ref<System.Runtime.InteropServices.UCOMITypeComp>) : void
        }
        interface UCOMITypeLib
        {
            GetTypeInfoCount () : number
            GetTypeInfo ($index: number, $ppTI: $Ref<System.Runtime.InteropServices.UCOMITypeInfo>) : void
            GetTypeInfoType ($index: number, $pTKind: $Ref<System.Runtime.InteropServices.TYPEKIND>) : void
            GetTypeInfoOfGuid ($guid: $Ref<System.Guid>, $ppTInfo: $Ref<System.Runtime.InteropServices.UCOMITypeInfo>) : void
            GetLibAttr ($ppTLibAttr: $Ref<System.IntPtr>) : void
            GetTypeComp ($ppTComp: $Ref<System.Runtime.InteropServices.UCOMITypeComp>) : void
            GetDocumentation ($index: number, $strName: $Ref<string>, $strDocString: $Ref<string>, $dwHelpContext: $Ref<number>, $strHelpFile: $Ref<string>) : void
            IsName ($szNameBuf: string, $lHashVal: number) : boolean
            FindName ($szNameBuf: string, $lHashVal: number, $ppTInfo: System.Array$1<System.Runtime.InteropServices.UCOMITypeInfo>, $rgMemId: System.Array$1<number>, $pcFound: $Ref<number>) : void
            ReleaseTLibAttr ($pTLibAttr: System.IntPtr) : void
        }
        class RuntimeInformation extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get FrameworkDescription(): string;
            public static get OSDescription(): string;
            public static get OSArchitecture(): System.Runtime.InteropServices.Architecture;
            public static get ProcessArchitecture(): System.Runtime.InteropServices.Architecture;
            public static IsOSPlatform ($osPlatform: System.Runtime.InteropServices.OSPlatform) : boolean
        }
        class BINDPTR extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public lpfuncdesc : System.IntPtr
            public lptcomp : System.IntPtr
            public lpvardesc : System.IntPtr
        }
        class BIND_OPTS extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public cbStruct : number
            public grfFlags : number
            public grfMode : number
            public dwTickCountDeadline : number
        }
        class ComEventsHelper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static Combine ($rcw: any, $iid: System.Guid, $dispid: number, $d: Function) : void
            public static Remove ($rcw: any, $iid: System.Guid, $dispid: number, $d: Function) : Function
        }
        enum DESCKIND
        { DESCKIND_NONE = 0, DESCKIND_FUNCDESC = 1, DESCKIND_VARDESC = 2, DESCKIND_TYPECOMP = 3, DESCKIND_IMPLICITAPPOBJ = 4, DESCKIND_MAX = 5 }
        enum ExporterEventKind
        { NOTIF_TYPECONVERTED = 0, NOTIF_CONVERTWARNING = 1, ERROR_REFTOINVALIDASSEMBLY = 2 }
        class ExtensibleClassFactory extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static RegisterObjectCreationCallback ($callback: System.Runtime.InteropServices.ObjectCreationDelegate) : void
        }
        class FILETIME extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public dwLowDateTime : number
            public dwHighDateTime : number
        }
        class GCHandle extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get IsAllocated(): boolean;
            public get Target(): any;
            public set Target(value: any);
            public AddrOfPinnedObject () : System.IntPtr
            public static Alloc ($value: any) : System.Runtime.InteropServices.GCHandle
            public static Alloc ($value: any, $type: System.Runtime.InteropServices.GCHandleType) : System.Runtime.InteropServices.GCHandle
            public Free () : void
            public static op_Explicit ($value: System.Runtime.InteropServices.GCHandle) : System.IntPtr
            public static op_Explicit ($value: System.IntPtr) : System.Runtime.InteropServices.GCHandle
            public static op_Equality ($a: System.Runtime.InteropServices.GCHandle, $b: System.Runtime.InteropServices.GCHandle) : boolean
            public static op_Inequality ($a: System.Runtime.InteropServices.GCHandle, $b: System.Runtime.InteropServices.GCHandle) : boolean
            public static FromIntPtr ($value: System.IntPtr) : System.Runtime.InteropServices.GCHandle
            public static ToIntPtr ($value: System.Runtime.InteropServices.GCHandle) : System.IntPtr
        }
        interface ITypeLibConverter
        {
            ConvertAssemblyToTypeLib ($assembly: System.Reflection.Assembly, $typeLibName: string, $flags: System.Runtime.InteropServices.TypeLibExporterFlags, $notifySink: System.Runtime.InteropServices.ITypeLibExporterNotifySink) : any
            ConvertTypeLibToAssembly ($typeLib: any, $asmFileName: string, $flags: number, $notifySink: System.Runtime.InteropServices.ITypeLibImporterNotifySink, $publicKey: System.Array$1<number>, $keyPair: System.Reflection.StrongNameKeyPair, $unsafeInterfaces: boolean) : System.Reflection.Emit.AssemblyBuilder
            ConvertTypeLibToAssembly ($typeLib: any, $asmFileName: string, $flags: System.Runtime.InteropServices.TypeLibImporterFlags, $notifySink: System.Runtime.InteropServices.ITypeLibImporterNotifySink, $publicKey: System.Array$1<number>, $keyPair: System.Reflection.StrongNameKeyPair, $asmNamespace: string, $asmVersion: System.Version) : System.Reflection.Emit.AssemblyBuilder
            GetPrimaryInteropAssembly ($g: System.Guid, $major: number, $minor: number, $lcid: number, $asmName: $Ref<string>, $asmCodeBase: $Ref<string>) : boolean
        }
        enum TypeLibExporterFlags
        { OnlyReferenceRegistered = 1, None = 0, CallerResolvedReferences = 2, OldNames = 4, ExportAs32Bit = 16, ExportAs64Bit = 32 }
        interface ITypeLibExporterNotifySink
        {
            ReportEvent ($eventKind: System.Runtime.InteropServices.ExporterEventKind, $eventCode: number, $eventMsg: string) : void
            ResolveRef ($assembly: System.Reflection.Assembly) : any
        }
        interface ITypeLibImporterNotifySink
        {
            ReportEvent ($eventKind: System.Runtime.InteropServices.ImporterEventKind, $eventCode: number, $eventMsg: string) : void
            ResolveRef ($typeLib: any) : System.Reflection.Assembly
        }
        enum TypeLibImporterFlags
        { PrimaryInteropAssembly = 1, UnsafeInterfaces = 2, SafeArrayAsSystemArray = 4, TransformDispRetVals = 8, None = 0, PreventClassMembers = 16, ImportAsAgnostic = 2048, ImportAsItanium = 1024, ImportAsX64 = 512, ImportAsX86 = 256, ReflectionOnlyLoading = 4096, SerializableValueClasses = 32, NoDefineVersionResource = 8192, ImportAsArm = 16384 }
        interface ITypeLibExporterNameProvider
        {
            GetNames () : System.Array$1<string>
        }
        enum ImporterEventKind
        { NOTIF_TYPECONVERTED = 0, NOTIF_CONVERTWARNING = 1, ERROR_REFTOINVALIDTYPELIB = 2 }
        enum LIBFLAGS
        { LIBFLAG_FRESTRICTED = 1, LIBFLAG_FCONTROL = 2, LIBFLAG_FHIDDEN = 4, LIBFLAG_FHASDISKIMAGE = 8 }
        class Marshal extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static SystemMaxDBCSCharSize : number
            public static SystemDefaultCharSize : number
            public static AddRef ($pUnk: System.IntPtr) : number
            public static AreComObjectsAvailableForCleanup () : boolean
            public static CleanupUnusedObjectsInCurrentContext () : void
            public static AllocCoTaskMem ($cb: number) : System.IntPtr
            public static AllocHGlobal ($cb: System.IntPtr) : System.IntPtr
            public static AllocHGlobal ($cb: number) : System.IntPtr
            public static BindToMoniker ($monikerName: string) : any
            public static ChangeWrapperHandleStrength ($otp: any, $fIsWeak: boolean) : void
            public static Copy ($source: System.Array$1<number>, $startIndex: number, $destination: System.IntPtr, $length: number) : void
            public static Copy ($source: System.Array$1<bigint>, $startIndex: number, $destination: System.IntPtr, $length: number) : void
            public static Copy ($source: System.Array$1<System.IntPtr>, $startIndex: number, $destination: System.IntPtr, $length: number) : void
            public static Copy ($source: System.IntPtr, $destination: System.Array$1<number>, $startIndex: number, $length: number) : void
            public static Copy ($source: System.IntPtr, $destination: System.Array$1<bigint>, $startIndex: number, $length: number) : void
            public static Copy ($source: System.IntPtr, $destination: System.Array$1<System.IntPtr>, $startIndex: number, $length: number) : void
            public static CreateAggregatedObject ($pOuter: System.IntPtr, $o: any) : System.IntPtr
            public static CreateWrapperOfType ($o: any, $t: System.Type) : any
            public static DestroyStructure ($ptr: System.IntPtr, $structuretype: System.Type) : void
            public static FreeBSTR ($ptr: System.IntPtr) : void
            public static FreeCoTaskMem ($ptr: System.IntPtr) : void
            public static FreeHGlobal ($hglobal: System.IntPtr) : void
            public static ZeroFreeBSTR ($s: System.IntPtr) : void
            public static ZeroFreeCoTaskMemAnsi ($s: System.IntPtr) : void
            public static ZeroFreeCoTaskMemUnicode ($s: System.IntPtr) : void
            public static ZeroFreeCoTaskMemUTF8 ($s: System.IntPtr) : void
            public static ZeroFreeGlobalAllocAnsi ($s: System.IntPtr) : void
            public static ZeroFreeGlobalAllocUnicode ($s: System.IntPtr) : void
            public static GenerateGuidForType ($type: System.Type) : System.Guid
            public static GenerateProgIdForType ($type: System.Type) : string
            public static GetActiveObject ($progID: string) : any
            public static GetComInterfaceForObject ($o: any, $T: System.Type) : System.IntPtr
            public static GetComInterfaceForObject ($o: any, $T: System.Type, $mode: System.Runtime.InteropServices.CustomQueryInterfaceMode) : System.IntPtr
            public static GetComInterfaceForObjectInContext ($o: any, $t: System.Type) : System.IntPtr
            public static GetComObjectData ($obj: any, $key: any) : any
            public static GetComSlotForMethodInfo ($m: System.Reflection.MemberInfo) : number
            public static GetEndComSlot ($t: System.Type) : number
            public static GetExceptionPointers () : System.IntPtr
            public static GetHINSTANCE ($m: System.Reflection.Module) : System.IntPtr
            public static GetExceptionCode () : number
            public static GetHRForException ($e: System.Exception) : number
            public static GetHRForLastWin32Error () : number
            public static GetIDispatchForObject ($o: any) : System.IntPtr
            public static GetIDispatchForObjectInContext ($o: any) : System.IntPtr
            public static GetITypeInfoForType ($t: System.Type) : System.IntPtr
            public static GetIUnknownForObjectInContext ($o: any) : System.IntPtr
            public static GetMethodInfoForComSlot ($t: System.Type, $slot: number, $memberType: $Ref<System.Runtime.InteropServices.ComMemberType>) : System.Reflection.MemberInfo
            public static GetIUnknownForObject ($o: any) : System.IntPtr
            public static GetNativeVariantForObject ($obj: any, $pDstNativeVariant: System.IntPtr) : void
            public static GetObjectForIUnknown ($pUnk: System.IntPtr) : any
            public static GetObjectForNativeVariant ($pSrcNativeVariant: System.IntPtr) : any
            public static GetObjectsForNativeVariants ($aSrcNativeVariant: System.IntPtr, $cVars: number) : System.Array$1<any>
            public static GetStartComSlot ($t: System.Type) : number
            public static GetTypedObjectForIUnknown ($pUnk: System.IntPtr, $t: System.Type) : any
            public static GetTypeForITypeInfo ($piTypeInfo: System.IntPtr) : System.Type
            public static GetTypeLibGuid ($typelib: System.Runtime.InteropServices.ComTypes.ITypeLib) : System.Guid
            public static GetTypeLibGuidForAssembly ($asm: System.Reflection.Assembly) : System.Guid
            public static GetTypeLibLcid ($typelib: System.Runtime.InteropServices.ComTypes.ITypeLib) : number
            public static GetTypeLibName ($typelib: System.Runtime.InteropServices.ComTypes.ITypeLib) : string
            public static GetTypeLibVersionForAssembly ($inputAssembly: System.Reflection.Assembly, $majorVersion: $Ref<number>, $minorVersion: $Ref<number>) : void
            public static IsTypeVisibleFromCom ($t: System.Type) : boolean
            public static NumParamBytes ($m: System.Reflection.MethodInfo) : number
            public static GetTypeFromCLSID ($clsid: System.Guid) : System.Type
            public static GetTypeInfoName ($typeInfo: System.Runtime.InteropServices.ComTypes.ITypeInfo) : string
            public static GetUniqueObjectForIUnknown ($unknown: System.IntPtr) : any
            public static IsComObject ($o: any) : boolean
            public static GetLastWin32Error () : number
            public static OffsetOf ($t: System.Type, $fieldName: string) : System.IntPtr
            public static Prelink ($m: System.Reflection.MethodInfo) : void
            public static PrelinkAll ($c: System.Type) : void
            public static PtrToStringAnsi ($ptr: System.IntPtr) : string
            public static PtrToStringAnsi ($ptr: System.IntPtr, $len: number) : string
            public static PtrToStringUTF8 ($ptr: System.IntPtr) : string
            public static PtrToStringUTF8 ($ptr: System.IntPtr, $byteLen: number) : string
            public static PtrToStringAuto ($ptr: System.IntPtr) : string
            public static PtrToStringAuto ($ptr: System.IntPtr, $len: number) : string
            public static PtrToStringUni ($ptr: System.IntPtr) : string
            public static PtrToStringUni ($ptr: System.IntPtr, $len: number) : string
            public static PtrToStringBSTR ($ptr: System.IntPtr) : string
            public static PtrToStructure ($ptr: System.IntPtr, $structure: any) : void
            public static PtrToStructure ($ptr: System.IntPtr, $structureType: System.Type) : any
            public static QueryInterface ($pUnk: System.IntPtr, $iid: $Ref<System.Guid>, $ppv: $Ref<System.IntPtr>) : number
            public static ReadByte ($ptr: System.IntPtr) : number
            public static ReadByte ($ptr: System.IntPtr, $ofs: number) : number
            public static ReadByte ($ptr: any, $ofs: number) : number
            public static ReadInt16 ($ptr: System.IntPtr) : number
            public static ReadInt16 ($ptr: System.IntPtr, $ofs: number) : number
            public static ReadInt16 ($ptr: any, $ofs: number) : number
            public static ReadInt32 ($ptr: System.IntPtr) : number
            public static ReadInt32 ($ptr: System.IntPtr, $ofs: number) : number
            public static ReadInt32 ($ptr: any, $ofs: number) : number
            public static ReadInt64 ($ptr: System.IntPtr) : bigint
            public static ReadInt64 ($ptr: System.IntPtr, $ofs: number) : bigint
            public static ReadInt64 ($ptr: any, $ofs: number) : bigint
            public static ReadIntPtr ($ptr: System.IntPtr) : System.IntPtr
            public static ReadIntPtr ($ptr: System.IntPtr, $ofs: number) : System.IntPtr
            public static ReadIntPtr ($ptr: any, $ofs: number) : System.IntPtr
            public static ReAllocCoTaskMem ($pv: System.IntPtr, $cb: number) : System.IntPtr
            public static ReAllocHGlobal ($pv: System.IntPtr, $cb: System.IntPtr) : System.IntPtr
            public static Release ($pUnk: System.IntPtr) : number
            public static ReleaseComObject ($o: any) : number
            public static SetComObjectData ($obj: any, $key: any, $data: any) : boolean
            public static SizeOf ($structure: any) : number
            public static SizeOf ($t: System.Type) : number
            public static StringToBSTR ($s: string) : System.IntPtr
            public static StringToCoTaskMemAnsi ($s: string) : System.IntPtr
            public static StringToCoTaskMemAuto ($s: string) : System.IntPtr
            public static StringToCoTaskMemUni ($s: string) : System.IntPtr
            public static StringToHGlobalAnsi ($s: string) : System.IntPtr
            public static StringToAllocatedMemoryUTF8 ($s: string) : System.IntPtr
            public static StringToHGlobalAuto ($s: string) : System.IntPtr
            public static StringToHGlobalUni ($s: string) : System.IntPtr
            public static SecureStringToBSTR ($s: System.Security.SecureString) : System.IntPtr
            public static SecureStringToCoTaskMemAnsi ($s: System.Security.SecureString) : System.IntPtr
            public static SecureStringToCoTaskMemUnicode ($s: System.Security.SecureString) : System.IntPtr
            public static SecureStringToGlobalAllocAnsi ($s: System.Security.SecureString) : System.IntPtr
            public static SecureStringToGlobalAllocUnicode ($s: System.Security.SecureString) : System.IntPtr
            public static StructureToPtr ($structure: any, $ptr: System.IntPtr, $fDeleteOld: boolean) : void
            public static ThrowExceptionForHR ($errorCode: number) : void
            public static ThrowExceptionForHR ($errorCode: number, $errorInfo: System.IntPtr) : void
            public static UnsafeAddrOfPinnedArrayElement ($arr: System.Array, $index: number) : System.IntPtr
            public static WriteByte ($ptr: System.IntPtr, $val: number) : void
            public static WriteByte ($ptr: System.IntPtr, $ofs: number, $val: number) : void
            public static WriteByte ($ptr: any, $ofs: number, $val: number) : void
            public static WriteInt16 ($ptr: System.IntPtr, $val: number) : void
            public static WriteInt16 ($ptr: System.IntPtr, $ofs: number, $val: number) : void
            public static WriteInt16 ($ptr: any, $ofs: number, $val: number) : void
            public static WriteInt32 ($ptr: System.IntPtr, $val: number) : void
            public static WriteInt32 ($ptr: System.IntPtr, $ofs: number, $val: number) : void
            public static WriteInt32 ($ptr: any, $ofs: number, $val: number) : void
            public static WriteInt64 ($ptr: System.IntPtr, $val: bigint) : void
            public static WriteInt64 ($ptr: System.IntPtr, $ofs: number, $val: bigint) : void
            public static WriteInt64 ($ptr: any, $ofs: number, $val: bigint) : void
            public static WriteIntPtr ($ptr: System.IntPtr, $val: System.IntPtr) : void
            public static WriteIntPtr ($ptr: System.IntPtr, $ofs: number, $val: System.IntPtr) : void
            public static WriteIntPtr ($ptr: any, $ofs: number, $val: System.IntPtr) : void
            public static GetExceptionForHR ($errorCode: number) : System.Exception
            public static GetExceptionForHR ($errorCode: number, $errorInfo: System.IntPtr) : System.Exception
            public static FinalReleaseComObject ($o: any) : number
            public static GetDelegateForFunctionPointer ($ptr: System.IntPtr, $t: System.Type) : Function
            public static GetFunctionPointerForDelegate ($d: Function) : System.IntPtr
            public static StringToCoTaskMemUTF8 ($s: string) : System.IntPtr
        }
        class MarshalAsAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public MarshalCookie : string
            public MarshalType : string
            public MarshalTypeRef : System.Type
            public SafeArrayUserDefinedSubType : System.Type
            public ArraySubType : System.Runtime.InteropServices.UnmanagedType
            public SafeArraySubType : System.Runtime.InteropServices.VarEnum
            public SizeConst : number
            public IidParameterIndex : number
            public SizeParamIndex : number
            public get Value(): System.Runtime.InteropServices.UnmanagedType;
            public constructor ($unmanagedType: number)
            public constructor ($unmanagedType: System.Runtime.InteropServices.UnmanagedType)
            public constructor ()
        }
        enum RegistrationClassContext
        { DisableActivateAsActivator = 32768, EnableActivateAsActivator = 65536, EnableCodeDownload = 8192, FromDefaultContext = 131072, InProcessHandler = 2, InProcessHandler16 = 32, InProcessServer = 1, InProcessServer16 = 8, LocalServer = 4, NoCodeDownload = 1024, NoCustomMarshal = 4096, NoFailureLog = 16384, RemoteServer = 16, Reserved1 = 64, Reserved2 = 128, Reserved3 = 256, Reserved4 = 512, Reserved5 = 2048 }
        class RegistrationServices extends System.Object implements System.Runtime.InteropServices.IRegistrationServices
        {
            protected [__keep_incompatibility]: never;
            public GetManagedCategoryGuid () : System.Guid
            public GetProgIdForType ($type: System.Type) : string
            public GetRegistrableTypesInAssembly ($assembly: System.Reflection.Assembly) : System.Array$1<System.Type>
            public RegisterAssembly ($assembly: System.Reflection.Assembly, $flags: System.Runtime.InteropServices.AssemblyRegistrationFlags) : boolean
            public RegisterTypeForComClients ($type: System.Type, $g: $Ref<System.Guid>) : void
            public TypeRepresentsComType ($type: System.Type) : boolean
            public TypeRequiresRegistration ($type: System.Type) : boolean
            public UnregisterAssembly ($assembly: System.Reflection.Assembly) : boolean
            public RegisterTypeForComClients ($type: System.Type, $classContext: System.Runtime.InteropServices.RegistrationClassContext, $flags: System.Runtime.InteropServices.RegistrationConnectionType) : number
            public UnregisterTypeForComClients ($cookie: number) : void
            public constructor ()
        }
        class STATSTG extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public pwcsName : string
            public type : number
            public cbSize : bigint
            public mtime : System.Runtime.InteropServices.FILETIME
            public ctime : System.Runtime.InteropServices.FILETIME
            public atime : System.Runtime.InteropServices.FILETIME
            public grfMode : number
            public grfLocksSupported : number
            public clsid : System.Guid
            public grfStateBits : number
            public reserved : number
        }
        enum SYSKIND
        { SYS_WIN16 = 0, SYS_WIN32 = 1, SYS_MAC = 2 }
        class TYPELIBATTR extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public guid : System.Guid
            public lcid : number
            public syskind : System.Runtime.InteropServices.SYSKIND
            public wMajorVerNum : number
            public wMinorVerNum : number
            public wLibFlags : System.Runtime.InteropServices.LIBFLAGS
        }
        class TypeLibConverter extends System.Object implements System.Runtime.InteropServices.ITypeLibConverter
        {
            protected [__keep_incompatibility]: never;
            public ConvertAssemblyToTypeLib ($assembly: System.Reflection.Assembly, $strTypeLibName: string, $flags: System.Runtime.InteropServices.TypeLibExporterFlags, $notifySink: System.Runtime.InteropServices.ITypeLibExporterNotifySink) : any
            public ConvertTypeLibToAssembly ($typeLib: any, $asmFileName: string, $flags: number, $notifySink: System.Runtime.InteropServices.ITypeLibImporterNotifySink, $publicKey: System.Array$1<number>, $keyPair: System.Reflection.StrongNameKeyPair, $unsafeInterfaces: boolean) : System.Reflection.Emit.AssemblyBuilder
            public ConvertTypeLibToAssembly ($typeLib: any, $asmFileName: string, $flags: System.Runtime.InteropServices.TypeLibImporterFlags, $notifySink: System.Runtime.InteropServices.ITypeLibImporterNotifySink, $publicKey: System.Array$1<number>, $keyPair: System.Reflection.StrongNameKeyPair, $asmNamespace: string, $asmVersion: System.Version) : System.Reflection.Emit.AssemblyBuilder
            public GetPrimaryInteropAssembly ($g: System.Guid, $major: number, $minor: number, $lcid: number, $asmName: $Ref<string>, $asmCodeBase: $Ref<string>) : boolean
            public constructor ()
            public ConvertAssemblyToTypeLib ($assembly: System.Reflection.Assembly, $typeLibName: string, $flags: System.Runtime.InteropServices.TypeLibExporterFlags, $notifySink: System.Runtime.InteropServices.ITypeLibExporterNotifySink) : any
        }
        interface UCOMIBindCtx
        {
            RegisterObjectBound ($punk: any) : void
            RevokeObjectBound ($punk: any) : void
            ReleaseBoundObjects () : void
            SetBindOptions ($pbindopts: $Ref<System.Runtime.InteropServices.BIND_OPTS>) : void
            GetBindOptions ($pbindopts: $Ref<System.Runtime.InteropServices.BIND_OPTS>) : void
            GetRunningObjectTable ($pprot: $Ref<System.Runtime.InteropServices.UCOMIRunningObjectTable>) : void
            RegisterObjectParam ($pszKey: string, $punk: any) : void
            GetObjectParam ($pszKey: string, $ppunk: $Ref<any>) : void
            EnumObjectParam ($ppenum: $Ref<System.Runtime.InteropServices.UCOMIEnumString>) : void
            RevokeObjectParam ($pszKey: string) : void
        }
        interface UCOMIRunningObjectTable
        {
            Register ($grfFlags: number, $punkObject: any, $pmkObjectName: System.Runtime.InteropServices.UCOMIMoniker, $pdwRegister: $Ref<number>) : void
            Revoke ($dwRegister: number) : void
            IsRunning ($pmkObjectName: System.Runtime.InteropServices.UCOMIMoniker) : void
            GetObject ($pmkObjectName: System.Runtime.InteropServices.UCOMIMoniker, $ppunkObject: $Ref<any>) : void
            NoteChangeTime ($dwRegister: number, $pfiletime: $Ref<System.Runtime.InteropServices.FILETIME>) : void
            GetTimeOfLastChange ($pmkObjectName: System.Runtime.InteropServices.UCOMIMoniker, $pfiletime: $Ref<System.Runtime.InteropServices.FILETIME>) : void
            EnumRunning ($ppenumMoniker: $Ref<System.Runtime.InteropServices.UCOMIEnumMoniker>) : void
        }
        interface UCOMIEnumString
        {
            Next ($celt: number, $rgelt: System.Array$1<string>, $pceltFetched: $Ref<number>) : number
            Skip ($celt: number) : number
            Reset () : number
            Clone ($ppenum: $Ref<System.Runtime.InteropServices.UCOMIEnumString>) : void
        }
        interface UCOMIConnectionPoint
        {
            GetConnectionInterface ($pIID: $Ref<System.Guid>) : void
            GetConnectionPointContainer ($ppCPC: $Ref<System.Runtime.InteropServices.UCOMIConnectionPointContainer>) : void
            Advise ($pUnkSink: any, $pdwCookie: $Ref<number>) : void
            Unadvise ($dwCookie: number) : void
            EnumConnections ($ppEnum: $Ref<System.Runtime.InteropServices.UCOMIEnumConnections>) : void
        }
        interface UCOMIConnectionPointContainer
        {
            EnumConnectionPoints ($ppEnum: $Ref<System.Runtime.InteropServices.UCOMIEnumConnectionPoints>) : void
            FindConnectionPoint ($riid: $Ref<System.Guid>, $ppCP: $Ref<System.Runtime.InteropServices.UCOMIConnectionPoint>) : void
        }
        interface UCOMIEnumConnectionPoints
        {
            Next ($celt: number, $rgelt: System.Array$1<System.Runtime.InteropServices.UCOMIConnectionPoint>, $pceltFetched: $Ref<number>) : number
            Skip ($celt: number) : number
            Reset () : number
            Clone ($ppenum: $Ref<System.Runtime.InteropServices.UCOMIEnumConnectionPoints>) : void
        }
        interface UCOMIEnumMoniker
        {
            Next ($celt: number, $rgelt: System.Array$1<System.Runtime.InteropServices.UCOMIMoniker>, $pceltFetched: $Ref<number>) : number
            Skip ($celt: number) : number
            Reset () : number
            Clone ($ppenum: $Ref<System.Runtime.InteropServices.UCOMIEnumMoniker>) : void
        }
        interface UCOMIMoniker
        {
            GetClassID ($pClassID: $Ref<System.Guid>) : void
            IsDirty () : number
            Load ($pStm: System.Runtime.InteropServices.UCOMIStream) : void
            Save ($pStm: System.Runtime.InteropServices.UCOMIStream, $fClearDirty: boolean) : void
            GetSizeMax ($pcbSize: $Ref<bigint>) : void
            BindToObject ($pbc: System.Runtime.InteropServices.UCOMIBindCtx, $pmkToLeft: System.Runtime.InteropServices.UCOMIMoniker, $riidResult: $Ref<System.Guid>, $ppvResult: $Ref<any>) : void
            BindToStorage ($pbc: System.Runtime.InteropServices.UCOMIBindCtx, $pmkToLeft: System.Runtime.InteropServices.UCOMIMoniker, $riid: $Ref<System.Guid>, $ppvObj: $Ref<any>) : void
            Reduce ($pbc: System.Runtime.InteropServices.UCOMIBindCtx, $dwReduceHowFar: number, $ppmkToLeft: $Ref<System.Runtime.InteropServices.UCOMIMoniker>, $ppmkReduced: $Ref<System.Runtime.InteropServices.UCOMIMoniker>) : void
            ComposeWith ($pmkRight: System.Runtime.InteropServices.UCOMIMoniker, $fOnlyIfNotGeneric: boolean, $ppmkComposite: $Ref<System.Runtime.InteropServices.UCOMIMoniker>) : void
            Enum ($fForward: boolean, $ppenumMoniker: $Ref<System.Runtime.InteropServices.UCOMIEnumMoniker>) : void
            IsEqual ($pmkOtherMoniker: System.Runtime.InteropServices.UCOMIMoniker) : void
            Hash ($pdwHash: $Ref<number>) : void
            IsRunning ($pbc: System.Runtime.InteropServices.UCOMIBindCtx, $pmkToLeft: System.Runtime.InteropServices.UCOMIMoniker, $pmkNewlyRunning: System.Runtime.InteropServices.UCOMIMoniker) : void
            GetTimeOfLastChange ($pbc: System.Runtime.InteropServices.UCOMIBindCtx, $pmkToLeft: System.Runtime.InteropServices.UCOMIMoniker, $pFileTime: $Ref<System.Runtime.InteropServices.FILETIME>) : void
            Inverse ($ppmk: $Ref<System.Runtime.InteropServices.UCOMIMoniker>) : void
            CommonPrefixWith ($pmkOther: System.Runtime.InteropServices.UCOMIMoniker, $ppmkPrefix: $Ref<System.Runtime.InteropServices.UCOMIMoniker>) : void
            RelativePathTo ($pmkOther: System.Runtime.InteropServices.UCOMIMoniker, $ppmkRelPath: $Ref<System.Runtime.InteropServices.UCOMIMoniker>) : void
            GetDisplayName ($pbc: System.Runtime.InteropServices.UCOMIBindCtx, $pmkToLeft: System.Runtime.InteropServices.UCOMIMoniker, $ppszDisplayName: $Ref<string>) : void
            ParseDisplayName ($pbc: System.Runtime.InteropServices.UCOMIBindCtx, $pmkToLeft: System.Runtime.InteropServices.UCOMIMoniker, $pszDisplayName: string, $pchEaten: $Ref<number>, $ppmkOut: $Ref<System.Runtime.InteropServices.UCOMIMoniker>) : void
            IsSystemMoniker ($pdwMksys: $Ref<number>) : void
        }
        interface UCOMIEnumVARIANT
        {
            Next ($celt: number, $rgvar: number, $pceltFetched: number) : number
            Skip ($celt: number) : number
            Reset () : number
            Clone ($ppenum: number) : void
        }
        interface UCOMIStream
        {
            Read ($pv: System.Array$1<number>, $cb: number, $pcbRead: System.IntPtr) : void
            Write ($pv: System.Array$1<number>, $cb: number, $pcbWritten: System.IntPtr) : void
            Seek ($dlibMove: bigint, $dwOrigin: number, $plibNewPosition: System.IntPtr) : void
            SetSize ($libNewSize: bigint) : void
            CopyTo ($pstm: System.Runtime.InteropServices.UCOMIStream, $cb: bigint, $pcbRead: System.IntPtr, $pcbWritten: System.IntPtr) : void
            Commit ($grfCommitFlags: number) : void
            Revert () : void
            LockRegion ($libOffset: bigint, $cb: bigint, $dwLockType: number) : void
            UnlockRegion ($libOffset: bigint, $cb: bigint, $dwLockType: number) : void
            Stat ($pstatstg: $Ref<System.Runtime.InteropServices.STATSTG>, $grfStatFlag: number) : void
            Clone ($ppstm: $Ref<System.Runtime.InteropServices.UCOMIStream>) : void
        }
        interface UCOMIPersistFile
        {
            GetClassID ($pClassID: $Ref<System.Guid>) : void
            IsDirty () : number
            Load ($pszFileName: string, $dwMode: number) : void
            Save ($pszFileName: string, $fRemember: boolean) : void
            SaveCompleted ($pszFileName: string) : void
            GetCurFile ($ppszFileName: $Ref<string>) : void
        }
        interface _ConstructorBuilder
        {
            GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
        }
        interface _EnumBuilder
        {
            GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
        }
        interface _EventBuilder
        {
            GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
        }
        interface _FieldBuilder
        {
            GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
        }
        interface _ILGenerator
        {
            GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
        }
        interface _LocalBuilder
        {
            GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
        }
        interface _MethodBuilder
        {
            GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
        }
        interface _MethodRental
        {
            GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
        }
        interface _ModuleBuilder
        {
            GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
        }
        interface _ParameterBuilder
        {
            GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
        }
        interface _PropertyBuilder
        {
            GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
        }
        interface _SignatureHelper
        {
            GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
        }
        interface _TypeBuilder
        {
            GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
        }
    }
    namespace Microsoft.Win32.SafeHandles {
        class SafeHandleZeroOrMinusOneIsInvalid extends System.Runtime.InteropServices.SafeHandle implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get IsInvalid(): boolean;
        }
        class SafeRegistryHandle extends Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public constructor ($preexistingHandle: System.IntPtr, $ownsHandle: boolean)
            public constructor ()
        }
        class SafeFileHandle extends Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public constructor ($preexistingHandle: System.IntPtr, $ownsHandle: boolean)
            public constructor ()
        }
        class SafeWaitHandle extends Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public constructor ($existingHandle: System.IntPtr, $ownsHandle: boolean)
            public constructor ()
        }
        class SafeHandleMinusOneIsInvalid extends System.Runtime.InteropServices.SafeHandle implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get IsInvalid(): boolean;
        }
        class CriticalHandleZeroOrMinusOneIsInvalid extends System.Runtime.InteropServices.CriticalHandle implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get IsInvalid(): boolean;
        }
        class CriticalHandleMinusOneIsInvalid extends System.Runtime.InteropServices.CriticalHandle implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get IsInvalid(): boolean;
        }
        class SafeAccessTokenHandle extends System.Runtime.InteropServices.SafeHandle implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public static get InvalidHandle(): Microsoft.Win32.SafeHandles.SafeAccessTokenHandle;
            public get IsInvalid(): boolean;
            public constructor ($handle: System.IntPtr)
            public constructor ()
        }
    }
    namespace System.Runtime.Serialization {
        interface ISerializable
        {
        }
        interface IDeserializationCallback
        {
            OnDeserialization ($sender: any) : void
        }
        class SerializationInfo extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get FullTypeName(): string;
            public set FullTypeName(value: string);
            public get AssemblyName(): string;
            public set AssemblyName(value: string);
            public get MemberCount(): number;
            public get ObjectType(): System.Type;
            public get IsFullTypeNameSetExplicit(): boolean;
            public get IsAssemblyNameSetExplicit(): boolean;
            public SetType ($type: System.Type) : void
            public GetEnumerator () : System.Runtime.Serialization.SerializationInfoEnumerator
            public AddValue ($name: string, $value: any, $type: System.Type) : void
            public AddValue ($name: string, $value: any) : void
            public AddValue ($name: string, $value: boolean) : void
            public AddValue ($name: string, $value: number) : void
            public AddValue ($name: string, $value: bigint) : void
            public AddValue ($name: string, $value: System.Decimal) : void
            public AddValue ($name: string, $value: System.DateTime) : void
            public GetValue ($name: string, $type: System.Type) : any
            public GetBoolean ($name: string) : boolean
            public GetChar ($name: string) : number
            public GetSByte ($name: string) : number
            public GetByte ($name: string) : number
            public GetInt16 ($name: string) : number
            public GetUInt16 ($name: string) : number
            public GetInt32 ($name: string) : number
            public GetUInt32 ($name: string) : number
            public GetInt64 ($name: string) : bigint
            public GetUInt64 ($name: string) : bigint
            public GetSingle ($name: string) : number
            public GetDouble ($name: string) : number
            public GetDecimal ($name: string) : System.Decimal
            public GetDateTime ($name: string) : System.DateTime
            public GetString ($name: string) : string
            public constructor ($type: System.Type, $converter: System.Runtime.Serialization.IFormatterConverter)
            public constructor ($type: System.Type, $converter: System.Runtime.Serialization.IFormatterConverter, $requireSameTokenInPartialTrust: boolean)
            public constructor ()
        }
        class StreamingContext extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get Context(): any;
            public get State(): System.Runtime.Serialization.StreamingContextStates;
            public constructor ($state: System.Runtime.Serialization.StreamingContextStates)
            public constructor ($state: System.Runtime.Serialization.StreamingContextStates, $additional: any)
            public constructor ()
        }
        interface IObjectReference
        {
            GetRealObject ($context: System.Runtime.Serialization.StreamingContext) : any
        }
        interface IFormatter
        {
            SurrogateSelector : System.Runtime.Serialization.ISurrogateSelector
            Binder : System.Runtime.Serialization.SerializationBinder
            Context : System.Runtime.Serialization.StreamingContext
            Deserialize ($serializationStream: System.IO.Stream) : any
            Serialize ($serializationStream: System.IO.Stream, $graph: any) : void
        }
        interface ISurrogateSelector
        {
            ChainSelector ($selector: System.Runtime.Serialization.ISurrogateSelector) : void
            GetSurrogate ($type: System.Type, $context: System.Runtime.Serialization.StreamingContext, $selector: $Ref<System.Runtime.Serialization.ISurrogateSelector>) : System.Runtime.Serialization.ISerializationSurrogate
            GetNextSelector () : System.Runtime.Serialization.ISurrogateSelector
        }
        interface ISerializationSurrogate
        {
            GetObjectData ($obj: any, $info: System.Runtime.Serialization.SerializationInfo, $context: System.Runtime.Serialization.StreamingContext) : void
            SetObjectData ($obj: any, $info: System.Runtime.Serialization.SerializationInfo, $context: System.Runtime.Serialization.StreamingContext, $selector: System.Runtime.Serialization.ISurrogateSelector) : any
        }
        interface IFormatterConverter
        {
            Convert ($value: any, $type: System.Type) : any
            Convert ($value: any, $typeCode: System.TypeCode) : any
            ToBoolean ($value: any) : boolean
            ToChar ($value: any) : number
            ToSByte ($value: any) : number
            ToByte ($value: any) : number
            ToInt16 ($value: any) : number
            ToUInt16 ($value: any) : number
            ToInt32 ($value: any) : number
            ToUInt32 ($value: any) : number
            ToInt64 ($value: any) : bigint
            ToUInt64 ($value: any) : bigint
            ToSingle ($value: any) : number
            ToDouble ($value: any) : number
            ToDecimal ($value: any) : System.Decimal
            ToDateTime ($value: any) : System.DateTime
            ToString ($value: any) : string
        }
        class SerializationException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class SerializationEntry extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get Value(): any;
            public get Name(): string;
            public get ObjectType(): System.Type;
        }
        class SerializationInfoEnumerator extends System.Object implements System.Collections.IEnumerator
        {
            protected [__keep_incompatibility]: never;
            public get Current(): System.Runtime.Serialization.SerializationEntry;
            public get Name(): string;
            public get Value(): any;
            public get ObjectType(): System.Type;
            public MoveNext () : boolean
            public Reset () : void
        }
        interface SerializationEventHandler
        { 
        (context: System.Runtime.Serialization.StreamingContext) : void; 
        Invoke?: (context: System.Runtime.Serialization.StreamingContext) => void;
        }
        var SerializationEventHandler: { new (func: (context: System.Runtime.Serialization.StreamingContext) => void): SerializationEventHandler; }
        class Formatter extends System.Object implements System.Runtime.Serialization.IFormatter
        {
            protected [__keep_incompatibility]: never;
            public get SurrogateSelector(): System.Runtime.Serialization.ISurrogateSelector;
            public set SurrogateSelector(value: System.Runtime.Serialization.ISurrogateSelector);
            public get Binder(): System.Runtime.Serialization.SerializationBinder;
            public set Binder(value: System.Runtime.Serialization.SerializationBinder);
            public get Context(): System.Runtime.Serialization.StreamingContext;
            public set Context(value: System.Runtime.Serialization.StreamingContext);
            public Deserialize ($serializationStream: System.IO.Stream) : any
            public Serialize ($serializationStream: System.IO.Stream, $graph: any) : void
        }
        class SerializationBinder extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public BindToName ($serializedType: System.Type, $assemblyName: $Ref<string>, $typeName: $Ref<string>) : void
            public BindToType ($assemblyName: string, $typeName: string) : System.Type
        }
        class FormatterConverter extends System.Object implements System.Runtime.Serialization.IFormatterConverter
        {
            protected [__keep_incompatibility]: never;
            public Convert ($value: any, $type: System.Type) : any
            public Convert ($value: any, $typeCode: System.TypeCode) : any
            public ToBoolean ($value: any) : boolean
            public ToChar ($value: any) : number
            public ToSByte ($value: any) : number
            public ToByte ($value: any) : number
            public ToInt16 ($value: any) : number
            public ToUInt16 ($value: any) : number
            public ToInt32 ($value: any) : number
            public ToUInt32 ($value: any) : number
            public ToInt64 ($value: any) : bigint
            public ToUInt64 ($value: any) : bigint
            public ToSingle ($value: any) : number
            public ToDouble ($value: any) : number
            public ToDecimal ($value: any) : System.Decimal
            public ToDateTime ($value: any) : System.DateTime
            public ToString ($value: any) : string
            public constructor ()
            public ToString () : string
        }
        class SerializationObjectManager extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public RegisterObject ($obj: any) : void
            public RaiseOnSerializedEvent () : void
            public constructor ($context: System.Runtime.Serialization.StreamingContext)
            public constructor ()
        }
        class FormatterServices extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static GetSerializableMembers ($type: System.Type) : System.Array$1<System.Reflection.MemberInfo>
            public static GetSerializableMembers ($type: System.Type, $context: System.Runtime.Serialization.StreamingContext) : System.Array$1<System.Reflection.MemberInfo>
            public static CheckTypeSecurity ($t: System.Type, $securityLevel: System.Runtime.Serialization.Formatters.TypeFilterLevel) : void
            public static GetUninitializedObject ($type: System.Type) : any
            public static GetSafeUninitializedObject ($type: System.Type) : any
            public static PopulateObjectMembers ($obj: any, $members: System.Array$1<System.Reflection.MemberInfo>, $data: System.Array$1<any>) : any
            public static GetObjectData ($obj: any, $members: System.Array$1<System.Reflection.MemberInfo>) : System.Array$1<any>
            public static GetSurrogateForCyclicalReference ($innerSurrogate: System.Runtime.Serialization.ISerializationSurrogate) : System.Runtime.Serialization.ISerializationSurrogate
            public static GetTypeFromAssembly ($assem: System.Reflection.Assembly, $name: string) : System.Type
        }
        class ObjectIDGenerator extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public GetId ($obj: any, $firstTime: $Ref<boolean>) : bigint
            public HasId ($obj: any, $firstTime: $Ref<boolean>) : bigint
            public constructor ()
        }
        class ObjectManager extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public GetObject ($objectID: bigint) : any
            public RegisterObject ($obj: any, $objectID: bigint) : void
            public RegisterObject ($obj: any, $objectID: bigint, $info: System.Runtime.Serialization.SerializationInfo) : void
            public RegisterObject ($obj: any, $objectID: bigint, $info: System.Runtime.Serialization.SerializationInfo, $idOfContainingObj: bigint, $member: System.Reflection.MemberInfo) : void
            public RegisterObject ($obj: any, $objectID: bigint, $info: System.Runtime.Serialization.SerializationInfo, $idOfContainingObj: bigint, $member: System.Reflection.MemberInfo, $arrayIndex: System.Array$1<number>) : void
            public DoFixups () : void
            public RecordFixup ($objectToBeFixed: bigint, $member: System.Reflection.MemberInfo, $objectRequired: bigint) : void
            public RecordDelayedFixup ($objectToBeFixed: bigint, $memberName: string, $objectRequired: bigint) : void
            public RecordArrayElementFixup ($arrayToBeFixed: bigint, $index: number, $objectRequired: bigint) : void
            public RecordArrayElementFixup ($arrayToBeFixed: bigint, $indices: System.Array$1<number>, $objectRequired: bigint) : void
            public RaiseDeserializationEvent () : void
            public RaiseOnDeserializingEvent ($obj: any) : void
            public constructor ($selector: System.Runtime.Serialization.ISurrogateSelector, $context: System.Runtime.Serialization.StreamingContext)
            public constructor ()
        }
        class SafeSerializationEventArgs extends System.EventArgs
        {
            protected [__keep_incompatibility]: never;
            public get StreamingContext(): System.Runtime.Serialization.StreamingContext;
            public AddSerializedState ($serializedState: System.Runtime.Serialization.ISafeSerializationData) : void
        }
        interface ISafeSerializationData
        {
            CompleteDeserialization ($deserialized: any) : void
        }
        class OptionalFieldAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get VersionAdded(): number;
            public set VersionAdded(value: number);
            public constructor ()
        }
        class OnSerializingAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class OnSerializedAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class OnDeserializingAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class OnDeserializedAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        enum StreamingContextStates
        { CrossProcess = 1, CrossMachine = 2, File = 4, Persistence = 8, Remoting = 16, Other = 32, Clone = 64, CrossAppDomain = 128, All = 255 }
        class SurrogateSelector extends System.Object implements System.Runtime.Serialization.ISurrogateSelector
        {
            protected [__keep_incompatibility]: never;
            public AddSurrogate ($type: System.Type, $context: System.Runtime.Serialization.StreamingContext, $surrogate: System.Runtime.Serialization.ISerializationSurrogate) : void
            public ChainSelector ($selector: System.Runtime.Serialization.ISurrogateSelector) : void
            public GetNextSelector () : System.Runtime.Serialization.ISurrogateSelector
            public GetSurrogate ($type: System.Type, $context: System.Runtime.Serialization.StreamingContext, $selector: $Ref<System.Runtime.Serialization.ISurrogateSelector>) : System.Runtime.Serialization.ISerializationSurrogate
            public RemoveSurrogate ($type: System.Type, $context: System.Runtime.Serialization.StreamingContext) : void
            public constructor ()
        }
    }
    namespace System.Globalization {
        class CultureInfo extends System.Object implements System.ICloneable, System.IFormatProvider
        {
            protected [__keep_incompatibility]: never;
            public static get InvariantCulture(): System.Globalization.CultureInfo;
            public static get CurrentCulture(): System.Globalization.CultureInfo;
            public static set CurrentCulture(value: System.Globalization.CultureInfo);
            public static get CurrentUICulture(): System.Globalization.CultureInfo;
            public static set CurrentUICulture(value: System.Globalization.CultureInfo);
            public get CultureTypes(): System.Globalization.CultureTypes;
            public get IetfLanguageTag(): string;
            public get KeyboardLayoutId(): number;
            public get LCID(): number;
            public get Name(): string;
            public get NativeName(): string;
            public get Calendar(): System.Globalization.Calendar;
            public get OptionalCalendars(): System.Array$1<System.Globalization.Calendar>;
            public get Parent(): System.Globalization.CultureInfo;
            public get TextInfo(): System.Globalization.TextInfo;
            public get ThreeLetterISOLanguageName(): string;
            public get ThreeLetterWindowsLanguageName(): string;
            public get TwoLetterISOLanguageName(): string;
            public get UseUserOverride(): boolean;
            public get CompareInfo(): System.Globalization.CompareInfo;
            public get IsNeutralCulture(): boolean;
            public get NumberFormat(): System.Globalization.NumberFormatInfo;
            public set NumberFormat(value: System.Globalization.NumberFormatInfo);
            public get DateTimeFormat(): System.Globalization.DateTimeFormatInfo;
            public set DateTimeFormat(value: System.Globalization.DateTimeFormatInfo);
            public get DisplayName(): string;
            public get EnglishName(): string;
            public static get InstalledUICulture(): System.Globalization.CultureInfo;
            public get IsReadOnly(): boolean;
            public static get DefaultThreadCurrentCulture(): System.Globalization.CultureInfo;
            public static set DefaultThreadCurrentCulture(value: System.Globalization.CultureInfo);
            public static get DefaultThreadCurrentUICulture(): System.Globalization.CultureInfo;
            public static set DefaultThreadCurrentUICulture(value: System.Globalization.CultureInfo);
            public GetConsoleFallbackUICulture () : System.Globalization.CultureInfo
            public ClearCachedData () : void
            public Clone () : any
            public static GetCultures ($types: System.Globalization.CultureTypes) : System.Array$1<System.Globalization.CultureInfo>
            public static ReadOnly ($ci: System.Globalization.CultureInfo) : System.Globalization.CultureInfo
            public GetFormat ($formatType: System.Type) : any
            public static GetCultureInfo ($culture: number) : System.Globalization.CultureInfo
            public static GetCultureInfo ($name: string) : System.Globalization.CultureInfo
            public static GetCultureInfo ($name: string, $altName: string) : System.Globalization.CultureInfo
            public static GetCultureInfoByIetfLanguageTag ($name: string) : System.Globalization.CultureInfo
            public static CreateSpecificCulture ($name: string) : System.Globalization.CultureInfo
            public constructor ($culture: number)
            public constructor ($culture: number, $useUserOverride: boolean)
            public constructor ($name: string)
            public constructor ($name: string, $useUserOverride: boolean)
            public constructor ()
        }
        enum CompareOptions
        { None = 0, IgnoreCase = 1, IgnoreNonSpace = 2, IgnoreSymbols = 4, IgnoreKanaType = 8, IgnoreWidth = 16, OrdinalIgnoreCase = 268435456, StringSort = 536870912, Ordinal = 1073741824 }
        enum NumberStyles
        { None = 0, AllowLeadingWhite = 1, AllowTrailingWhite = 2, AllowLeadingSign = 4, AllowTrailingSign = 8, AllowParentheses = 16, AllowDecimalPoint = 32, AllowThousands = 64, AllowExponent = 128, AllowCurrencySymbol = 256, AllowHexSpecifier = 512, Integer = 7, HexNumber = 515, Number = 111, Float = 167, Currency = 383, Any = 511 }
        enum UnicodeCategory
        { UppercaseLetter = 0, LowercaseLetter = 1, TitlecaseLetter = 2, ModifierLetter = 3, OtherLetter = 4, NonSpacingMark = 5, SpacingCombiningMark = 6, EnclosingMark = 7, DecimalDigitNumber = 8, LetterNumber = 9, OtherNumber = 10, SpaceSeparator = 11, LineSeparator = 12, ParagraphSeparator = 13, Control = 14, Format = 15, Surrogate = 16, PrivateUse = 17, ConnectorPunctuation = 18, DashPunctuation = 19, OpenPunctuation = 20, ClosePunctuation = 21, InitialQuotePunctuation = 22, FinalQuotePunctuation = 23, OtherPunctuation = 24, MathSymbol = 25, CurrencySymbol = 26, ModifierSymbol = 27, OtherSymbol = 28, OtherNotAssigned = 29 }
        enum DateTimeStyles
        { None = 0, AllowLeadingWhite = 1, AllowTrailingWhite = 2, AllowInnerWhite = 4, AllowWhiteSpaces = 7, NoCurrentDateDefault = 8, AdjustToUniversal = 16, AssumeLocal = 32, AssumeUniversal = 64, RoundtripKind = 128 }
        class Calendar extends System.Object implements System.ICloneable
        {
            protected [__keep_incompatibility]: never;
            public static CurrentEra : number
            public get MinSupportedDateTime(): System.DateTime;
            public get MaxSupportedDateTime(): System.DateTime;
            public get AlgorithmType(): System.Globalization.CalendarAlgorithmType;
            public get IsReadOnly(): boolean;
            public get Eras(): System.Array$1<number>;
            public get TwoDigitYearMax(): number;
            public set TwoDigitYearMax(value: number);
            public Clone () : any
            public static ReadOnly ($calendar: System.Globalization.Calendar) : System.Globalization.Calendar
            public AddMilliseconds ($time: System.DateTime, $milliseconds: number) : System.DateTime
            public AddDays ($time: System.DateTime, $days: number) : System.DateTime
            public AddHours ($time: System.DateTime, $hours: number) : System.DateTime
            public AddMinutes ($time: System.DateTime, $minutes: number) : System.DateTime
            public AddMonths ($time: System.DateTime, $months: number) : System.DateTime
            public AddSeconds ($time: System.DateTime, $seconds: number) : System.DateTime
            public AddWeeks ($time: System.DateTime, $weeks: number) : System.DateTime
            public AddYears ($time: System.DateTime, $years: number) : System.DateTime
            public GetDayOfMonth ($time: System.DateTime) : number
            public GetDayOfWeek ($time: System.DateTime) : System.DayOfWeek
            public GetDayOfYear ($time: System.DateTime) : number
            public GetDaysInMonth ($year: number, $month: number) : number
            public GetDaysInMonth ($year: number, $month: number, $era: number) : number
            public GetDaysInYear ($year: number) : number
            public GetDaysInYear ($year: number, $era: number) : number
            public GetEra ($time: System.DateTime) : number
            public GetHour ($time: System.DateTime) : number
            public GetMilliseconds ($time: System.DateTime) : number
            public GetMinute ($time: System.DateTime) : number
            public GetMonth ($time: System.DateTime) : number
            public GetMonthsInYear ($year: number) : number
            public GetMonthsInYear ($year: number, $era: number) : number
            public GetSecond ($time: System.DateTime) : number
            public GetWeekOfYear ($time: System.DateTime, $rule: System.Globalization.CalendarWeekRule, $firstDayOfWeek: System.DayOfWeek) : number
            public GetYear ($time: System.DateTime) : number
            public IsLeapDay ($year: number, $month: number, $day: number) : boolean
            public IsLeapDay ($year: number, $month: number, $day: number, $era: number) : boolean
            public IsLeapMonth ($year: number, $month: number) : boolean
            public IsLeapMonth ($year: number, $month: number, $era: number) : boolean
            public GetLeapMonth ($year: number) : number
            public GetLeapMonth ($year: number, $era: number) : number
            public IsLeapYear ($year: number) : boolean
            public IsLeapYear ($year: number, $era: number) : boolean
            public ToDateTime ($year: number, $month: number, $day: number, $hour: number, $minute: number, $second: number, $millisecond: number) : System.DateTime
            public ToDateTime ($year: number, $month: number, $day: number, $hour: number, $minute: number, $second: number, $millisecond: number, $era: number) : System.DateTime
            public ToFourDigitYear ($year: number) : number
        }
        enum TimeSpanStyles
        { None = 0, AssumeNegative = 1 }
        class DaylightTime extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get Start(): System.DateTime;
            public get End(): System.DateTime;
            public get Delta(): System.TimeSpan;
            public constructor ($start: System.DateTime, $end: System.DateTime, $delta: System.TimeSpan)
            public constructor ()
        }
        enum CalendarAlgorithmType
        { Unknown = 0, SolarCalendar = 1, LunarCalendar = 2, LunisolarCalendar = 3 }
        enum CalendarWeekRule
        { FirstDay = 0, FirstFullWeek = 1, FirstFourDayWeek = 2 }
        class CharUnicodeInfo extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static GetNumericValue ($ch: number) : number
            public static GetNumericValue ($s: string, $index: number) : number
            public static GetDecimalDigitValue ($ch: number) : number
            public static GetDecimalDigitValue ($s: string, $index: number) : number
            public static GetDigitValue ($ch: number) : number
            public static GetDigitValue ($s: string, $index: number) : number
            public static GetUnicodeCategory ($ch: number) : System.Globalization.UnicodeCategory
            public static GetUnicodeCategory ($s: string, $index: number) : System.Globalization.UnicodeCategory
            public static GetUnicodeCategory ($codePoint: number) : System.Globalization.UnicodeCategory
        }
        class CompareInfo extends System.Object implements System.Runtime.Serialization.IDeserializationCallback
        {
            protected [__keep_incompatibility]: never;
            public get Name(): string;
            public get Version(): System.Globalization.SortVersion;
            public get LCID(): number;
            public static GetCompareInfo ($culture: number, $assembly: System.Reflection.Assembly) : System.Globalization.CompareInfo
            public static GetCompareInfo ($name: string, $assembly: System.Reflection.Assembly) : System.Globalization.CompareInfo
            public static GetCompareInfo ($culture: number) : System.Globalization.CompareInfo
            public static GetCompareInfo ($name: string) : System.Globalization.CompareInfo
            public static IsSortable ($ch: number) : boolean
            public static IsSortable ($text: string) : boolean
            public Compare ($string1: string, $string2: string) : number
            public Compare ($string1: string, $string2: string, $options: System.Globalization.CompareOptions) : number
            public Compare ($string1: string, $offset1: number, $length1: number, $string2: string, $offset2: number, $length2: number) : number
            public Compare ($string1: string, $offset1: number, $string2: string, $offset2: number, $options: System.Globalization.CompareOptions) : number
            public Compare ($string1: string, $offset1: number, $string2: string, $offset2: number) : number
            public Compare ($string1: string, $offset1: number, $length1: number, $string2: string, $offset2: number, $length2: number, $options: System.Globalization.CompareOptions) : number
            public IsPrefix ($source: string, $prefix: string, $options: System.Globalization.CompareOptions) : boolean
            public IsPrefix ($source: string, $prefix: string) : boolean
            public IsSuffix ($source: string, $suffix: string, $options: System.Globalization.CompareOptions) : boolean
            public IsSuffix ($source: string, $suffix: string) : boolean
            public IndexOf ($source: string, $value: number) : number
            public IndexOf ($source: string, $value: string) : number
            public IndexOf ($source: string, $value: number, $options: System.Globalization.CompareOptions) : number
            public IndexOf ($source: string, $value: string, $options: System.Globalization.CompareOptions) : number
            public IndexOf ($source: string, $value: number, $startIndex: number) : number
            public IndexOf ($source: string, $value: string, $startIndex: number) : number
            public IndexOf ($source: string, $value: number, $startIndex: number, $options: System.Globalization.CompareOptions) : number
            public IndexOf ($source: string, $value: string, $startIndex: number, $options: System.Globalization.CompareOptions) : number
            public IndexOf ($source: string, $value: number, $startIndex: number, $count: number) : number
            public IndexOf ($source: string, $value: string, $startIndex: number, $count: number) : number
            public IndexOf ($source: string, $value: number, $startIndex: number, $count: number, $options: System.Globalization.CompareOptions) : number
            public IndexOf ($source: string, $value: string, $startIndex: number, $count: number, $options: System.Globalization.CompareOptions) : number
            public LastIndexOf ($source: string, $value: number) : number
            public LastIndexOf ($source: string, $value: string) : number
            public LastIndexOf ($source: string, $value: number, $options: System.Globalization.CompareOptions) : number
            public LastIndexOf ($source: string, $value: string, $options: System.Globalization.CompareOptions) : number
            public LastIndexOf ($source: string, $value: number, $startIndex: number) : number
            public LastIndexOf ($source: string, $value: string, $startIndex: number) : number
            public LastIndexOf ($source: string, $value: number, $startIndex: number, $options: System.Globalization.CompareOptions) : number
            public LastIndexOf ($source: string, $value: string, $startIndex: number, $options: System.Globalization.CompareOptions) : number
            public LastIndexOf ($source: string, $value: number, $startIndex: number, $count: number) : number
            public LastIndexOf ($source: string, $value: string, $startIndex: number, $count: number) : number
            public LastIndexOf ($source: string, $value: number, $startIndex: number, $count: number, $options: System.Globalization.CompareOptions) : number
            public LastIndexOf ($source: string, $value: string, $startIndex: number, $count: number, $options: System.Globalization.CompareOptions) : number
            public GetSortKey ($source: string, $options: System.Globalization.CompareOptions) : System.Globalization.SortKey
            public GetSortKey ($source: string) : System.Globalization.SortKey
            public GetHashCode () : number
            public GetHashCode ($source: string, $options: System.Globalization.CompareOptions) : number
            public OnDeserialization ($sender: any) : void
        }
        interface CompareInfo {
            GetStringComparer ($options: System.Globalization.CompareOptions) : System.StringComparer;
        }
        class SortKey extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get OriginalString(): string;
            public get KeyData(): System.Array$1<number>;
            public static Compare ($sortkey1: System.Globalization.SortKey, $sortkey2: System.Globalization.SortKey) : number
        }
        class SortVersion extends System.Object implements System.IEquatable$1<System.Globalization.SortVersion>
        {
            protected [__keep_incompatibility]: never;
            public get FullVersion(): number;
            public get SortId(): System.Guid;
            public Equals ($obj: any) : boolean
            public Equals ($other: System.Globalization.SortVersion) : boolean
            public static op_Equality ($left: System.Globalization.SortVersion, $right: System.Globalization.SortVersion) : boolean
            public static op_Inequality ($left: System.Globalization.SortVersion, $right: System.Globalization.SortVersion) : boolean
            public constructor ($fullVersion: number, $sortId: System.Guid)
            public static Equals ($objA: any, $objB: any) : boolean
            public constructor ()
        }
        class CultureNotFoundException extends System.ArgumentException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public get InvalidCultureId(): number | null;
            public get InvalidCultureName(): string;
            public get Message(): string;
            public constructor ()
            public constructor ($message: string)
            public constructor ($paramName: string, $message: string)
            public constructor ($message: string, $innerException: System.Exception)
            public constructor ($paramName: string, $invalidCultureName: string, $message: string)
            public constructor ($message: string, $invalidCultureName: string, $innerException: System.Exception)
            public constructor ($message: string, $invalidCultureId: number, $innerException: System.Exception)
            public constructor ($paramName: string, $invalidCultureId: number, $message: string)
            public constructor ($message: string, $paramName: string, $innerException: System.Exception)
            public constructor ($message: string, $paramName: string)
        }
        enum CultureTypes
        { NeutralCultures = 1, SpecificCultures = 2, InstalledWin32Cultures = 4, AllCultures = 7, UserCustomCulture = 8, ReplacementCultures = 16, WindowsOnlyCultures = 32, FrameworkCultures = 64 }
        class DateTimeFormatInfo extends System.Object implements System.ICloneable, System.IFormatProvider
        {
            protected [__keep_incompatibility]: never;
            public static get InvariantInfo(): System.Globalization.DateTimeFormatInfo;
            public static get CurrentInfo(): System.Globalization.DateTimeFormatInfo;
            public get AMDesignator(): string;
            public set AMDesignator(value: string);
            public get Calendar(): System.Globalization.Calendar;
            public set Calendar(value: System.Globalization.Calendar);
            public get DateSeparator(): string;
            public set DateSeparator(value: string);
            public get FirstDayOfWeek(): System.DayOfWeek;
            public set FirstDayOfWeek(value: System.DayOfWeek);
            public get CalendarWeekRule(): System.Globalization.CalendarWeekRule;
            public set CalendarWeekRule(value: System.Globalization.CalendarWeekRule);
            public get FullDateTimePattern(): string;
            public set FullDateTimePattern(value: string);
            public get LongDatePattern(): string;
            public set LongDatePattern(value: string);
            public get LongTimePattern(): string;
            public set LongTimePattern(value: string);
            public get MonthDayPattern(): string;
            public set MonthDayPattern(value: string);
            public get PMDesignator(): string;
            public set PMDesignator(value: string);
            public get RFC1123Pattern(): string;
            public get ShortDatePattern(): string;
            public set ShortDatePattern(value: string);
            public get ShortTimePattern(): string;
            public set ShortTimePattern(value: string);
            public get SortableDateTimePattern(): string;
            public get TimeSeparator(): string;
            public set TimeSeparator(value: string);
            public get UniversalSortableDateTimePattern(): string;
            public get YearMonthPattern(): string;
            public set YearMonthPattern(value: string);
            public get AbbreviatedDayNames(): System.Array$1<string>;
            public set AbbreviatedDayNames(value: System.Array$1<string>);
            public get ShortestDayNames(): System.Array$1<string>;
            public set ShortestDayNames(value: System.Array$1<string>);
            public get DayNames(): System.Array$1<string>;
            public set DayNames(value: System.Array$1<string>);
            public get AbbreviatedMonthNames(): System.Array$1<string>;
            public set AbbreviatedMonthNames(value: System.Array$1<string>);
            public get MonthNames(): System.Array$1<string>;
            public set MonthNames(value: System.Array$1<string>);
            public get IsReadOnly(): boolean;
            public get NativeCalendarName(): string;
            public get AbbreviatedMonthGenitiveNames(): System.Array$1<string>;
            public set AbbreviatedMonthGenitiveNames(value: System.Array$1<string>);
            public get MonthGenitiveNames(): System.Array$1<string>;
            public set MonthGenitiveNames(value: System.Array$1<string>);
            public static GetInstance ($provider: System.IFormatProvider) : System.Globalization.DateTimeFormatInfo
            public GetFormat ($formatType: System.Type) : any
            public Clone () : any
            public GetEra ($eraName: string) : number
            public GetEraName ($era: number) : string
            public GetAbbreviatedEraName ($era: number) : string
            public GetAbbreviatedDayName ($dayofweek: System.DayOfWeek) : string
            public GetShortestDayName ($dayOfWeek: System.DayOfWeek) : string
            public GetAllDateTimePatterns () : System.Array$1<string>
            public GetAllDateTimePatterns ($format: number) : System.Array$1<string>
            public GetDayName ($dayofweek: System.DayOfWeek) : string
            public GetAbbreviatedMonthName ($month: number) : string
            public GetMonthName ($month: number) : string
            public static ReadOnly ($dtfi: System.Globalization.DateTimeFormatInfo) : System.Globalization.DateTimeFormatInfo
            public SetAllDateTimePatterns ($patterns: System.Array$1<string>, $format: number) : void
            public constructor ()
        }
        enum DigitShapes
        { Context = 0, None = 1, NativeNational = 2 }
        class GlobalizationExtensions extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static GetStringComparer ($compareInfo: System.Globalization.CompareInfo, $options: System.Globalization.CompareOptions) : System.StringComparer
        }
        class ISOWeek extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static GetWeekOfYear ($date: System.DateTime) : number
            public static GetYear ($date: System.DateTime) : number
            public static GetYearStart ($year: number) : System.DateTime
            public static GetYearEnd ($year: number) : System.DateTime
            public static GetWeeksInYear ($year: number) : number
            public static ToDateTime ($year: number, $week: number, $dayOfWeek: System.DayOfWeek) : System.DateTime
        }
        class PersianCalendar extends System.Globalization.Calendar implements System.ICloneable
        {
            protected [__keep_incompatibility]: never;
            public static PersianEra : number
            public get MinSupportedDateTime(): System.DateTime;
            public get MaxSupportedDateTime(): System.DateTime;
            public get AlgorithmType(): System.Globalization.CalendarAlgorithmType;
            public get Eras(): System.Array$1<number>;
            public get TwoDigitYearMax(): number;
            public set TwoDigitYearMax(value: number);
            public constructor ()
        }
        class EastAsianLunisolarCalendar extends System.Globalization.Calendar implements System.ICloneable
        {
            protected [__keep_incompatibility]: never;
            public get AlgorithmType(): System.Globalization.CalendarAlgorithmType;
            public get TwoDigitYearMax(): number;
            public set TwoDigitYearMax(value: number);
            public GetSexagenaryYear ($time: System.DateTime) : number
            public GetCelestialStem ($sexagenaryYear: number) : number
            public GetTerrestrialBranch ($sexagenaryYear: number) : number
        }
        class ChineseLunisolarCalendar extends System.Globalization.EastAsianLunisolarCalendar implements System.ICloneable
        {
            protected [__keep_incompatibility]: never;
            public static ChineseEra : number
            public get MinSupportedDateTime(): System.DateTime;
            public get MaxSupportedDateTime(): System.DateTime;
            public get Eras(): System.Array$1<number>;
            public constructor ()
        }
        class GregorianCalendar extends System.Globalization.Calendar implements System.ICloneable
        {
            protected [__keep_incompatibility]: never;
            public static ADEra : number
            public get MinSupportedDateTime(): System.DateTime;
            public get MaxSupportedDateTime(): System.DateTime;
            public get AlgorithmType(): System.Globalization.CalendarAlgorithmType;
            public get CalendarType(): System.Globalization.GregorianCalendarTypes;
            public set CalendarType(value: System.Globalization.GregorianCalendarTypes);
            public get Eras(): System.Array$1<number>;
            public get TwoDigitYearMax(): number;
            public set TwoDigitYearMax(value: number);
            public constructor ()
            public constructor ($type: System.Globalization.GregorianCalendarTypes)
        }
        enum GregorianCalendarTypes
        { Localized = 1, USEnglish = 2, MiddleEastFrench = 9, Arabic = 10, TransliteratedEnglish = 11, TransliteratedFrench = 12 }
        class HebrewCalendar extends System.Globalization.Calendar implements System.ICloneable
        {
            protected [__keep_incompatibility]: never;
            public static HebrewEra : number
            public get MinSupportedDateTime(): System.DateTime;
            public get MaxSupportedDateTime(): System.DateTime;
            public get AlgorithmType(): System.Globalization.CalendarAlgorithmType;
            public get Eras(): System.Array$1<number>;
            public get TwoDigitYearMax(): number;
            public set TwoDigitYearMax(value: number);
            public constructor ()
        }
        class HijriCalendar extends System.Globalization.Calendar implements System.ICloneable
        {
            protected [__keep_incompatibility]: never;
            public static HijriEra : number
            public get MinSupportedDateTime(): System.DateTime;
            public get MaxSupportedDateTime(): System.DateTime;
            public get AlgorithmType(): System.Globalization.CalendarAlgorithmType;
            public get HijriAdjustment(): number;
            public set HijriAdjustment(value: number);
            public get Eras(): System.Array$1<number>;
            public get TwoDigitYearMax(): number;
            public set TwoDigitYearMax(value: number);
            public constructor ()
        }
        class JapaneseCalendar extends System.Globalization.Calendar implements System.ICloneable
        {
            protected [__keep_incompatibility]: never;
            public get MinSupportedDateTime(): System.DateTime;
            public get MaxSupportedDateTime(): System.DateTime;
            public get AlgorithmType(): System.Globalization.CalendarAlgorithmType;
            public get Eras(): System.Array$1<number>;
            public get TwoDigitYearMax(): number;
            public set TwoDigitYearMax(value: number);
            public constructor ()
        }
        class JapaneseLunisolarCalendar extends System.Globalization.EastAsianLunisolarCalendar implements System.ICloneable
        {
            protected [__keep_incompatibility]: never;
            public static JapaneseEra : number
            public get MinSupportedDateTime(): System.DateTime;
            public get MaxSupportedDateTime(): System.DateTime;
            public get Eras(): System.Array$1<number>;
            public constructor ()
        }
        class JulianCalendar extends System.Globalization.Calendar implements System.ICloneable
        {
            protected [__keep_incompatibility]: never;
            public static JulianEra : number
            public get MinSupportedDateTime(): System.DateTime;
            public get MaxSupportedDateTime(): System.DateTime;
            public get AlgorithmType(): System.Globalization.CalendarAlgorithmType;
            public get Eras(): System.Array$1<number>;
            public get TwoDigitYearMax(): number;
            public set TwoDigitYearMax(value: number);
            public constructor ()
        }
        class KoreanCalendar extends System.Globalization.Calendar implements System.ICloneable
        {
            protected [__keep_incompatibility]: never;
            public static KoreanEra : number
            public get MinSupportedDateTime(): System.DateTime;
            public get MaxSupportedDateTime(): System.DateTime;
            public get AlgorithmType(): System.Globalization.CalendarAlgorithmType;
            public get Eras(): System.Array$1<number>;
            public get TwoDigitYearMax(): number;
            public set TwoDigitYearMax(value: number);
            public constructor ()
        }
        class KoreanLunisolarCalendar extends System.Globalization.EastAsianLunisolarCalendar implements System.ICloneable
        {
            protected [__keep_incompatibility]: never;
            public static GregorianEra : number
            public get MinSupportedDateTime(): System.DateTime;
            public get MaxSupportedDateTime(): System.DateTime;
            public get Eras(): System.Array$1<number>;
            public constructor ()
        }
        class NumberFormatInfo extends System.Object implements System.ICloneable, System.IFormatProvider
        {
            protected [__keep_incompatibility]: never;
            public static get InvariantInfo(): System.Globalization.NumberFormatInfo;
            public get CurrencyDecimalDigits(): number;
            public set CurrencyDecimalDigits(value: number);
            public get CurrencyDecimalSeparator(): string;
            public set CurrencyDecimalSeparator(value: string);
            public get IsReadOnly(): boolean;
            public get CurrencyGroupSizes(): System.Array$1<number>;
            public set CurrencyGroupSizes(value: System.Array$1<number>);
            public get NumberGroupSizes(): System.Array$1<number>;
            public set NumberGroupSizes(value: System.Array$1<number>);
            public get PercentGroupSizes(): System.Array$1<number>;
            public set PercentGroupSizes(value: System.Array$1<number>);
            public get CurrencyGroupSeparator(): string;
            public set CurrencyGroupSeparator(value: string);
            public get CurrencySymbol(): string;
            public set CurrencySymbol(value: string);
            public static get CurrentInfo(): System.Globalization.NumberFormatInfo;
            public get NaNSymbol(): string;
            public set NaNSymbol(value: string);
            public get CurrencyNegativePattern(): number;
            public set CurrencyNegativePattern(value: number);
            public get NumberNegativePattern(): number;
            public set NumberNegativePattern(value: number);
            public get PercentPositivePattern(): number;
            public set PercentPositivePattern(value: number);
            public get PercentNegativePattern(): number;
            public set PercentNegativePattern(value: number);
            public get NegativeInfinitySymbol(): string;
            public set NegativeInfinitySymbol(value: string);
            public get NegativeSign(): string;
            public set NegativeSign(value: string);
            public get NumberDecimalDigits(): number;
            public set NumberDecimalDigits(value: number);
            public get NumberDecimalSeparator(): string;
            public set NumberDecimalSeparator(value: string);
            public get NumberGroupSeparator(): string;
            public set NumberGroupSeparator(value: string);
            public get CurrencyPositivePattern(): number;
            public set CurrencyPositivePattern(value: number);
            public get PositiveInfinitySymbol(): string;
            public set PositiveInfinitySymbol(value: string);
            public get PositiveSign(): string;
            public set PositiveSign(value: string);
            public get PercentDecimalDigits(): number;
            public set PercentDecimalDigits(value: number);
            public get PercentDecimalSeparator(): string;
            public set PercentDecimalSeparator(value: string);
            public get PercentGroupSeparator(): string;
            public set PercentGroupSeparator(value: string);
            public get PercentSymbol(): string;
            public set PercentSymbol(value: string);
            public get PerMilleSymbol(): string;
            public set PerMilleSymbol(value: string);
            public get NativeDigits(): System.Array$1<string>;
            public set NativeDigits(value: System.Array$1<string>);
            public get DigitSubstitution(): System.Globalization.DigitShapes;
            public set DigitSubstitution(value: System.Globalization.DigitShapes);
            public static GetInstance ($formatProvider: System.IFormatProvider) : System.Globalization.NumberFormatInfo
            public Clone () : any
            public GetFormat ($formatType: System.Type) : any
            public static ReadOnly ($nfi: System.Globalization.NumberFormatInfo) : System.Globalization.NumberFormatInfo
            public constructor ()
        }
        class StringInfo extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get String(): string;
            public set String(value: string);
            public get LengthInTextElements(): number;
            public SubstringByTextElements ($startingTextElement: number) : string
            public SubstringByTextElements ($startingTextElement: number, $lengthInTextElements: number) : string
            public static GetNextTextElement ($str: string) : string
            public static GetNextTextElement ($str: string, $index: number) : string
            public static GetTextElementEnumerator ($str: string) : System.Globalization.TextElementEnumerator
            public static GetTextElementEnumerator ($str: string, $index: number) : System.Globalization.TextElementEnumerator
            public static ParseCombiningCharacters ($str: string) : System.Array$1<number>
            public constructor ()
            public constructor ($value: string)
        }
        class TextElementEnumerator extends System.Object implements System.Collections.IEnumerator
        {
            protected [__keep_incompatibility]: never;
            public get Current(): any;
            public get ElementIndex(): number;
            public MoveNext () : boolean
            public GetTextElement () : string
            public Reset () : void
        }
        class TaiwanCalendar extends System.Globalization.Calendar implements System.ICloneable
        {
            protected [__keep_incompatibility]: never;
            public get MinSupportedDateTime(): System.DateTime;
            public get MaxSupportedDateTime(): System.DateTime;
            public get AlgorithmType(): System.Globalization.CalendarAlgorithmType;
            public get Eras(): System.Array$1<number>;
            public get TwoDigitYearMax(): number;
            public set TwoDigitYearMax(value: number);
            public constructor ()
        }
        class TaiwanLunisolarCalendar extends System.Globalization.EastAsianLunisolarCalendar implements System.ICloneable
        {
            protected [__keep_incompatibility]: never;
            public get MinSupportedDateTime(): System.DateTime;
            public get MaxSupportedDateTime(): System.DateTime;
            public get Eras(): System.Array$1<number>;
            public constructor ()
        }
        class TextInfo extends System.Object implements System.Runtime.Serialization.IDeserializationCallback, System.ICloneable
        {
            protected [__keep_incompatibility]: never;
            public get ANSICodePage(): number;
            public get OEMCodePage(): number;
            public get MacCodePage(): number;
            public get EBCDICCodePage(): number;
            public get LCID(): number;
            public get CultureName(): string;
            public get IsReadOnly(): boolean;
            public get ListSeparator(): string;
            public set ListSeparator(value: string);
            public get IsRightToLeft(): boolean;
            public Clone () : any
            public static ReadOnly ($textInfo: System.Globalization.TextInfo) : System.Globalization.TextInfo
            public ToLower ($c: number) : number
            public ToLower ($str: string) : string
            public ToUpper ($c: number) : number
            public ToUpper ($str: string) : string
            public ToTitleCase ($str: string) : string
            public OnDeserialization ($sender: any) : void
        }
        class ThaiBuddhistCalendar extends System.Globalization.Calendar implements System.ICloneable
        {
            protected [__keep_incompatibility]: never;
            public static ThaiBuddhistEra : number
            public get MinSupportedDateTime(): System.DateTime;
            public get MaxSupportedDateTime(): System.DateTime;
            public get AlgorithmType(): System.Globalization.CalendarAlgorithmType;
            public get Eras(): System.Array$1<number>;
            public get TwoDigitYearMax(): number;
            public set TwoDigitYearMax(value: number);
            public constructor ()
        }
        class UmAlQuraCalendar extends System.Globalization.Calendar implements System.ICloneable
        {
            protected [__keep_incompatibility]: never;
            public static UmAlQuraEra : number
            public get MinSupportedDateTime(): System.DateTime;
            public get MaxSupportedDateTime(): System.DateTime;
            public get AlgorithmType(): System.Globalization.CalendarAlgorithmType;
            public get Eras(): System.Array$1<number>;
            public get TwoDigitYearMax(): number;
            public set TwoDigitYearMax(value: number);
            public constructor ()
        }
        class IdnMapping extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get AllowUnassigned(): boolean;
            public set AllowUnassigned(value: boolean);
            public get UseStd3AsciiRules(): boolean;
            public set UseStd3AsciiRules(value: boolean);
            public GetAscii ($unicode: string) : string
            public GetAscii ($unicode: string, $index: number) : string
            public GetAscii ($unicode: string, $index: number, $count: number) : string
            public GetUnicode ($ascii: string) : string
            public GetUnicode ($ascii: string, $index: number) : string
            public GetUnicode ($ascii: string, $index: number, $count: number) : string
            public constructor ()
        }
        class RegionInfo extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get CurrentRegion(): System.Globalization.RegionInfo;
            public get CurrencyEnglishName(): string;
            public get CurrencySymbol(): string;
            public get DisplayName(): string;
            public get EnglishName(): string;
            public get GeoId(): number;
            public get IsMetric(): boolean;
            public get ISOCurrencySymbol(): string;
            public get NativeName(): string;
            public get CurrencyNativeName(): string;
            public get Name(): string;
            public get ThreeLetterISORegionName(): string;
            public get ThreeLetterWindowsRegionName(): string;
            public get TwoLetterISORegionName(): string;
            public constructor ($culture: number)
            public constructor ($name: string)
            public constructor ()
        }
    }
    namespace System.Buffers {
        class SpanAction$2<T, TArg> extends System.MulticastDelegate implements System.Runtime.Serialization.ISerializable, System.ICloneable
        {
            protected [__keep_incompatibility]: never;
            public EndInvoke ($result: System.IAsyncResult) : void
            public constructor ($object: any, $method: System.IntPtr)
        }
        class MemoryHandle extends System.ValueType implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public Dispose () : void
        }
        interface IMemoryOwner$1<T> extends System.IDisposable
        {
            Memory : System.Memory$1<T>
        }
        interface IPinnable
        {
            Pin ($elementIndex: number) : System.Buffers.MemoryHandle
            Unpin () : void
        }
        class ReadOnlySequence$1<T> extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public static Empty : any
            public get Length(): bigint;
            public get IsEmpty(): boolean;
            public get IsSingleSegment(): boolean;
            public get First(): System.ReadOnlyMemory$1<T>;
            public get Start(): System.SequencePosition;
            public get End(): System.SequencePosition;
            public Slice ($start: bigint, $length: bigint) : System.Buffers.ReadOnlySequence$1<T>
            public Slice ($start: bigint, $end: System.SequencePosition) : System.Buffers.ReadOnlySequence$1<T>
            public Slice ($start: System.SequencePosition, $length: bigint) : System.Buffers.ReadOnlySequence$1<T>
            public Slice ($start: number, $length: number) : System.Buffers.ReadOnlySequence$1<T>
            public Slice ($start: number, $end: System.SequencePosition) : System.Buffers.ReadOnlySequence$1<T>
            public Slice ($start: System.SequencePosition, $length: number) : System.Buffers.ReadOnlySequence$1<T>
            public Slice ($start: System.SequencePosition, $end: System.SequencePosition) : System.Buffers.ReadOnlySequence$1<T>
            public Slice ($start: System.SequencePosition) : System.Buffers.ReadOnlySequence$1<T>
            public Slice ($start: bigint) : System.Buffers.ReadOnlySequence$1<T>
            public GetEnumerator () : System.Buffers.ReadOnlySequence$1.Enumerator<T>
            public GetPosition ($offset: bigint) : System.SequencePosition
            public GetPosition ($offset: bigint, $origin: System.SequencePosition) : System.SequencePosition
            public TryGet ($position: $Ref<System.SequencePosition>, $memory: $Ref<System.ReadOnlyMemory$1<T>>, $advance?: boolean) : boolean
            public constructor ($startSegment: System.Buffers.ReadOnlySequenceSegment$1<T>, $startIndex: number, $endSegment: System.Buffers.ReadOnlySequenceSegment$1<T>, $endIndex: number)
            public constructor ($array: System.Array$1<T>)
            public constructor ($array: System.Array$1<T>, $start: number, $length: number)
            public constructor ($memory: System.ReadOnlyMemory$1<T>)
            public constructor ()
        }
        class ReadOnlySequenceSegment$1<T> extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get Memory(): System.ReadOnlyMemory$1<T>;
            public get Next(): System.Buffers.ReadOnlySequenceSegment$1<T>;
            public get RunningIndex(): bigint;
        }
        class SequenceReader$1<T> extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get End(): boolean;
            public get Sequence(): System.Buffers.ReadOnlySequence$1<T>;
            public get Position(): System.SequencePosition;
            public get CurrentSpanIndex(): number;
            public get Consumed(): bigint;
            public get Remaining(): bigint;
            public get Length(): bigint;
            public TryReadTo ($span: $Ref<System.ReadOnlySpan$1<T>>, $delimiter: T, $advancePastDelimiter?: boolean) : boolean
            public TryReadTo ($span: $Ref<System.ReadOnlySpan$1<T>>, $delimiter: T, $delimiterEscape: T, $advancePastDelimiter?: boolean) : boolean
            public TryReadTo ($sequence: $Ref<System.Buffers.ReadOnlySequence$1<T>>, $delimiter: T, $advancePastDelimiter?: boolean) : boolean
            public TryReadTo ($sequence: $Ref<System.Buffers.ReadOnlySequence$1<T>>, $delimiter: T, $delimiterEscape: T, $advancePastDelimiter?: boolean) : boolean
            public TryAdvanceTo ($delimiter: T, $advancePastDelimiter?: boolean) : boolean
            public AdvancePast ($value: T) : bigint
            public AdvancePastAny ($value0: T, $value1: T, $value2: T, $value3: T) : bigint
            public AdvancePastAny ($value0: T, $value1: T, $value2: T) : bigint
            public AdvancePastAny ($value0: T, $value1: T) : bigint
            public IsNext ($next: T, $advancePast?: boolean) : boolean
            public TryPeek ($value: $Ref<T>) : boolean
            public TryRead ($value: $Ref<T>) : boolean
            public Rewind ($count: bigint) : void
            public Advance ($count: bigint) : void
            public constructor ($sequence: System.Buffers.ReadOnlySequence$1<T>)
            public constructor ()
        }
        class ReadOnlySpanAction$2<T, TArg> extends System.MulticastDelegate implements System.Runtime.Serialization.ISerializable, System.ICloneable
        {
            protected [__keep_incompatibility]: never;
            public EndInvoke ($result: System.IAsyncResult) : void
            public constructor ($object: any, $method: System.IntPtr)
        }
        class ArrayPool$1<T> extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get Shared(): any;
            public static Create () : any
            public static Create ($maxArrayLength: any, $maxArraysPerBucket: any) : any
            public Rent ($minimumLength: number) : System.Array$1<T>
            public Return ($array: System.Array$1<T>, $clearArray?: boolean) : void
        }
        class MemoryManager$1<T> extends System.Object implements System.Buffers.IMemoryOwner$1<T>, System.Buffers.IPinnable, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get Memory(): System.Memory$1<T>;
            public Pin ($elementIndex?: number) : System.Buffers.MemoryHandle
            public Unpin () : void
            public Pin ($elementIndex: number) : System.Buffers.MemoryHandle
        }
        class BuffersExtensions extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        interface IBufferWriter$1<T>
        {
            Advance ($count: number) : void
            GetMemory ($sizeHint?: number) : System.Memory$1<T>
        }
        class MemoryPool$1<T> extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public static get Shared(): any;
            public get MaxBufferSize(): number;
            public Rent ($minBufferSize?: number) : System.Buffers.IMemoryOwner$1<T>
            public Dispose () : void
        }
        enum OperationStatus
        { Done = 0, DestinationTooSmall = 1, NeedMoreData = 2, InvalidData = 3 }
        class StandardFormat extends System.ValueType implements System.IEquatable$1<System.Buffers.StandardFormat>
        {
            protected [__keep_incompatibility]: never;
            public static NoPrecision : number
            public static MaxPrecision : number
            public get Symbol(): number;
            public get Precision(): number;
            public get HasPrecision(): boolean;
            public get IsDefault(): boolean;
            public static op_Implicit ($symbol: number) : System.Buffers.StandardFormat
            public static Parse ($format: string) : System.Buffers.StandardFormat
            public Equals ($obj: any) : boolean
            public Equals ($other: System.Buffers.StandardFormat) : boolean
            public static op_Equality ($left: System.Buffers.StandardFormat, $right: System.Buffers.StandardFormat) : boolean
            public static op_Inequality ($left: System.Buffers.StandardFormat, $right: System.Buffers.StandardFormat) : boolean
            public constructor ($symbol: number, $precision?: number)
            public static Equals ($objA: any, $objB: any) : boolean
            public constructor ()
        }
        class ArrayBufferWriter$1<T> extends System.Object implements System.Buffers.IBufferWriter$1<T>
        {
            protected [__keep_incompatibility]: never;
            public get WrittenMemory(): System.ReadOnlyMemory$1<T>;
            public get WrittenCount(): number;
            public get Capacity(): number;
            public get FreeCapacity(): number;
            public Clear () : void
            public Advance ($count: number) : void
            public GetMemory ($sizeHint?: number) : System.Memory$1<T>
            public constructor ()
            public constructor ($initialCapacity: number)
        }
        class SequenceReaderExtensions extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static TryReadLittleEndian ($reader: $Ref<System.Buffers.SequenceReader$1<number>>, $value: $Ref<number>) : boolean
            public static TryReadBigEndian ($reader: $Ref<System.Buffers.SequenceReader$1<number>>, $value: $Ref<number>) : boolean
            public static TryReadLittleEndian ($reader: $Ref<System.Buffers.SequenceReader$1<number>>, $value: $Ref<bigint>) : boolean
            public static TryReadBigEndian ($reader: $Ref<System.Buffers.SequenceReader$1<number>>, $value: $Ref<bigint>) : boolean
        }
    }
    namespace System.Text {
        enum NormalizationForm
        { FormC = 1, FormD = 2, FormKC = 5, FormKD = 6 }
        class Encoding extends System.Object implements System.ICloneable
        {
            protected [__keep_incompatibility]: never;
            public get BodyName(): string;
            public get EncodingName(): string;
            public get HeaderName(): string;
            public get WebName(): string;
            public get WindowsCodePage(): number;
            public get IsBrowserDisplay(): boolean;
            public get IsBrowserSave(): boolean;
            public get IsMailNewsDisplay(): boolean;
            public get IsMailNewsSave(): boolean;
            public get IsSingleByte(): boolean;
            public get EncoderFallback(): System.Text.EncoderFallback;
            public set EncoderFallback(value: System.Text.EncoderFallback);
            public get DecoderFallback(): System.Text.DecoderFallback;
            public set DecoderFallback(value: System.Text.DecoderFallback);
            public get IsReadOnly(): boolean;
            public static get ASCII(): System.Text.Encoding;
            public get CodePage(): number;
            public static get Default(): System.Text.Encoding;
            public static get Unicode(): System.Text.Encoding;
            public static get BigEndianUnicode(): System.Text.Encoding;
            public static get UTF7(): System.Text.Encoding;
            public static get UTF8(): System.Text.Encoding;
            public static get UTF32(): System.Text.Encoding;
            public static Convert ($srcEncoding: System.Text.Encoding, $dstEncoding: System.Text.Encoding, $bytes: System.Array$1<number>) : System.Array$1<number>
            public static Convert ($srcEncoding: System.Text.Encoding, $dstEncoding: System.Text.Encoding, $bytes: System.Array$1<number>, $index: number, $count: number) : System.Array$1<number>
            public static RegisterProvider ($provider: System.Text.EncodingProvider) : void
            public static GetEncoding ($codepage: number) : System.Text.Encoding
            public static GetEncoding ($codepage: number, $encoderFallback: System.Text.EncoderFallback, $decoderFallback: System.Text.DecoderFallback) : System.Text.Encoding
            public static GetEncoding ($name: string) : System.Text.Encoding
            public static GetEncoding ($name: string, $encoderFallback: System.Text.EncoderFallback, $decoderFallback: System.Text.DecoderFallback) : System.Text.Encoding
            public static GetEncodings () : System.Array$1<System.Text.EncodingInfo>
            public GetPreamble () : System.Array$1<number>
            public Clone () : any
            public GetByteCount ($chars: System.Array$1<number>) : number
            public GetByteCount ($s: string) : number
            public GetByteCount ($chars: System.Array$1<number>, $index: number, $count: number) : number
            public GetByteCount ($str: string, $index: number, $count: number) : number
            public GetBytes ($chars: System.Array$1<number>) : System.Array$1<number>
            public GetBytes ($chars: System.Array$1<number>, $index: number, $count: number) : System.Array$1<number>
            public GetBytes ($chars: System.Array$1<number>, $charIndex: number, $charCount: number, $bytes: System.Array$1<number>, $byteIndex: number) : number
            public GetBytes ($s: string) : System.Array$1<number>
            public GetBytes ($s: string, $charIndex: number, $charCount: number, $bytes: System.Array$1<number>, $byteIndex: number) : number
            public GetCharCount ($bytes: System.Array$1<number>) : number
            public GetCharCount ($bytes: System.Array$1<number>, $index: number, $count: number) : number
            public GetChars ($bytes: System.Array$1<number>) : System.Array$1<number>
            public GetChars ($bytes: System.Array$1<number>, $index: number, $count: number) : System.Array$1<number>
            public GetChars ($bytes: System.Array$1<number>, $byteIndex: number, $byteCount: number, $chars: System.Array$1<number>, $charIndex: number) : number
            public IsAlwaysNormalized () : boolean
            public IsAlwaysNormalized ($form: System.Text.NormalizationForm) : boolean
            public GetDecoder () : System.Text.Decoder
            public GetEncoder () : System.Text.Encoder
            public GetMaxByteCount ($charCount: number) : number
            public GetMaxCharCount ($byteCount: number) : number
            public GetString ($bytes: System.Array$1<number>) : string
            public GetString ($bytes: System.Array$1<number>, $index: number, $count: number) : string
            public GetBytes ($s: string, $index: number, $count: number) : System.Array$1<number>
        }
        class ASCIIEncoding extends System.Text.Encoding implements System.ICloneable
        {
            protected [__keep_incompatibility]: never;
            public get IsSingleByte(): boolean;
            public constructor ()
        }
        class Decoder extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get Fallback(): System.Text.DecoderFallback;
            public set Fallback(value: System.Text.DecoderFallback);
            public get FallbackBuffer(): System.Text.DecoderFallbackBuffer;
            public Reset () : void
            public GetCharCount ($bytes: System.Array$1<number>, $index: number, $count: number) : number
            public GetCharCount ($bytes: System.Array$1<number>, $index: number, $count: number, $flush: boolean) : number
            public GetChars ($bytes: System.Array$1<number>, $byteIndex: number, $byteCount: number, $chars: System.Array$1<number>, $charIndex: number) : number
            public GetChars ($bytes: System.Array$1<number>, $byteIndex: number, $byteCount: number, $chars: System.Array$1<number>, $charIndex: number, $flush: boolean) : number
            public Convert ($bytes: System.Array$1<number>, $byteIndex: number, $byteCount: number, $chars: System.Array$1<number>, $charIndex: number, $charCount: number, $flush: boolean, $bytesUsed: $Ref<number>, $charsUsed: $Ref<number>, $completed: $Ref<boolean>) : void
        }
        class Encoder extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get Fallback(): System.Text.EncoderFallback;
            public set Fallback(value: System.Text.EncoderFallback);
            public get FallbackBuffer(): System.Text.EncoderFallbackBuffer;
            public Reset () : void
            public GetByteCount ($chars: System.Array$1<number>, $index: number, $count: number, $flush: boolean) : number
            public GetBytes ($chars: System.Array$1<number>, $charIndex: number, $charCount: number, $bytes: System.Array$1<number>, $byteIndex: number, $flush: boolean) : number
            public Convert ($chars: System.Array$1<number>, $charIndex: number, $charCount: number, $bytes: System.Array$1<number>, $byteIndex: number, $byteCount: number, $flush: boolean, $charsUsed: $Ref<number>, $bytesUsed: $Ref<number>, $completed: $Ref<boolean>) : void
        }
        class DecoderFallback extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get ReplacementFallback(): System.Text.DecoderFallback;
            public static get ExceptionFallback(): System.Text.DecoderFallback;
            public get MaxCharCount(): number;
            public CreateFallbackBuffer () : System.Text.DecoderFallbackBuffer
        }
        class DecoderFallbackBuffer extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get Remaining(): number;
            public Fallback ($bytesUnknown: System.Array$1<number>, $index: number) : boolean
            public GetNextChar () : number
            public MovePrevious () : boolean
            public Reset () : void
        }
        class DecoderExceptionFallback extends System.Text.DecoderFallback
        {
            protected [__keep_incompatibility]: never;
            public get MaxCharCount(): number;
            public constructor ()
        }
        class DecoderExceptionFallbackBuffer extends System.Text.DecoderFallbackBuffer
        {
            protected [__keep_incompatibility]: never;
            public get Remaining(): number;
            public constructor ()
        }
        class DecoderFallbackException extends System.ArgumentException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public get BytesUnknown(): System.Array$1<number>;
            public get Index(): number;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
            public constructor ($message: string, $bytesUnknown: System.Array$1<number>, $index: number)
            public constructor ($message: string, $paramName: string, $innerException: System.Exception)
            public constructor ($message: string, $paramName: string)
        }
        class DecoderReplacementFallback extends System.Text.DecoderFallback implements System.Runtime.Serialization.ISerializable
        {
            protected [__keep_incompatibility]: never;
            public get DefaultString(): string;
            public get MaxCharCount(): number;
            public constructor ()
            public constructor ($replacement: string)
        }
        class DecoderReplacementFallbackBuffer extends System.Text.DecoderFallbackBuffer
        {
            protected [__keep_incompatibility]: never;
            public get Remaining(): number;
            public constructor ($fallback: System.Text.DecoderReplacementFallback)
            public constructor ()
        }
        class EncoderFallback extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get ReplacementFallback(): System.Text.EncoderFallback;
            public static get ExceptionFallback(): System.Text.EncoderFallback;
            public get MaxCharCount(): number;
            public CreateFallbackBuffer () : System.Text.EncoderFallbackBuffer
        }
        class EncoderFallbackBuffer extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get Remaining(): number;
            public Fallback ($charUnknown: number, $index: number) : boolean
            public Fallback ($charUnknownHigh: number, $charUnknownLow: number, $index: number) : boolean
            public GetNextChar () : number
            public MovePrevious () : boolean
            public Reset () : void
        }
        class EncoderExceptionFallback extends System.Text.EncoderFallback
        {
            protected [__keep_incompatibility]: never;
            public get MaxCharCount(): number;
            public constructor ()
        }
        class EncoderExceptionFallbackBuffer extends System.Text.EncoderFallbackBuffer
        {
            protected [__keep_incompatibility]: never;
            public get Remaining(): number;
            public constructor ()
        }
        class EncoderFallbackException extends System.ArgumentException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public get CharUnknown(): number;
            public get CharUnknownHigh(): number;
            public get CharUnknownLow(): number;
            public get Index(): number;
            public IsUnknownSurrogate () : boolean
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class EncoderReplacementFallback extends System.Text.EncoderFallback implements System.Runtime.Serialization.ISerializable
        {
            protected [__keep_incompatibility]: never;
            public get DefaultString(): string;
            public get MaxCharCount(): number;
            public constructor ()
            public constructor ($replacement: string)
        }
        class EncoderReplacementFallbackBuffer extends System.Text.EncoderFallbackBuffer
        {
            protected [__keep_incompatibility]: never;
            public get Remaining(): number;
            public constructor ($fallback: System.Text.EncoderReplacementFallback)
            public constructor ()
        }
        class EncodingInfo extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get CodePage(): number;
            public get Name(): string;
            public get DisplayName(): string;
            public GetEncoding () : System.Text.Encoding
        }
        class EncodingProvider extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public GetEncoding ($name: string) : System.Text.Encoding
            public GetEncoding ($codepage: number) : System.Text.Encoding
            public GetEncoding ($name: string, $encoderFallback: System.Text.EncoderFallback, $decoderFallback: System.Text.DecoderFallback) : System.Text.Encoding
            public GetEncoding ($codepage: number, $encoderFallback: System.Text.EncoderFallback, $decoderFallback: System.Text.DecoderFallback) : System.Text.Encoding
        }
        class StringBuilder extends System.Object implements System.Runtime.Serialization.ISerializable
        {
            protected [__keep_incompatibility]: never;
            public get Capacity(): number;
            public set Capacity(value: number);
            public get MaxCapacity(): number;
            public get Length(): number;
            public set Length(value: number);
            public get Chars(): number;
            public set Chars(value: number);
            public EnsureCapacity ($capacity: number) : number
            public ToString () : string
            public ToString ($startIndex: number, $length: number) : string
            public Clear () : System.Text.StringBuilder
            public get_Chars ($index: number) : number
            public set_Chars ($index: number, $value: number) : void
            public Append ($value: number, $repeatCount: number) : System.Text.StringBuilder
            public Append ($value: System.Array$1<number>, $startIndex: number, $charCount: number) : System.Text.StringBuilder
            public Append ($value: string) : System.Text.StringBuilder
            public Append ($value: string, $startIndex: number, $count: number) : System.Text.StringBuilder
            public Append ($value: System.Text.StringBuilder) : System.Text.StringBuilder
            public Append ($value: System.Text.StringBuilder, $startIndex: number, $count: number) : System.Text.StringBuilder
            public AppendLine () : System.Text.StringBuilder
            public AppendLine ($value: string) : System.Text.StringBuilder
            public CopyTo ($sourceIndex: number, $destination: System.Array$1<number>, $destinationIndex: number, $count: number) : void
            public Insert ($index: number, $value: string, $count: number) : System.Text.StringBuilder
            public Remove ($startIndex: number, $length: number) : System.Text.StringBuilder
            public Append ($value: boolean) : System.Text.StringBuilder
            public Append ($value: number) : System.Text.StringBuilder
            public Append ($value: bigint) : System.Text.StringBuilder
            public Append ($value: System.Decimal) : System.Text.StringBuilder
            public Append ($value: any) : System.Text.StringBuilder
            public Append ($value: System.Array$1<number>) : System.Text.StringBuilder
            public AppendJoin ($separator: string, ...values: any[]) : System.Text.StringBuilder
            public AppendJoin ($separator: string, ...values: string[]) : System.Text.StringBuilder
            public AppendJoin ($separator: number, ...values: any[]) : System.Text.StringBuilder
            public AppendJoin ($separator: number, ...values: string[]) : System.Text.StringBuilder
            public Insert ($index: number, $value: string) : System.Text.StringBuilder
            public Insert ($index: number, $value: boolean) : System.Text.StringBuilder
            public Insert ($index: number, $value: number) : System.Text.StringBuilder
            public Insert ($index: number, $value: System.Array$1<number>) : System.Text.StringBuilder
            public Insert ($index: number, $value: System.Array$1<number>, $startIndex: number, $charCount: number) : System.Text.StringBuilder
            public Insert ($index: number, $value: bigint) : System.Text.StringBuilder
            public Insert ($index: number, $value: System.Decimal) : System.Text.StringBuilder
            public Insert ($index: number, $value: any) : System.Text.StringBuilder
            public AppendFormat ($format: string, $arg0: any) : System.Text.StringBuilder
            public AppendFormat ($format: string, $arg0: any, $arg1: any) : System.Text.StringBuilder
            public AppendFormat ($format: string, $arg0: any, $arg1: any, $arg2: any) : System.Text.StringBuilder
            public AppendFormat ($format: string, ...args: any[]) : System.Text.StringBuilder
            public AppendFormat ($provider: System.IFormatProvider, $format: string, $arg0: any) : System.Text.StringBuilder
            public AppendFormat ($provider: System.IFormatProvider, $format: string, $arg0: any, $arg1: any) : System.Text.StringBuilder
            public AppendFormat ($provider: System.IFormatProvider, $format: string, $arg0: any, $arg1: any, $arg2: any) : System.Text.StringBuilder
            public AppendFormat ($provider: System.IFormatProvider, $format: string, ...args: any[]) : System.Text.StringBuilder
            public Replace ($oldValue: string, $newValue: string) : System.Text.StringBuilder
            public Equals ($sb: System.Text.StringBuilder) : boolean
            public Replace ($oldValue: string, $newValue: string, $startIndex: number, $count: number) : System.Text.StringBuilder
            public Replace ($oldChar: number, $newChar: number) : System.Text.StringBuilder
            public Replace ($oldChar: number, $newChar: number, $startIndex: number, $count: number) : System.Text.StringBuilder
            public constructor ()
            public constructor ($capacity: number)
            public constructor ($value: string)
            public constructor ($value: string, $capacity: number)
            public constructor ($value: string, $startIndex: number, $length: number, $capacity: number)
            public constructor ($capacity: number, $maxCapacity: number)
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
        }
        class UTF32Encoding extends System.Text.Encoding implements System.ICloneable
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($bigEndian: boolean, $byteOrderMark: boolean)
            public constructor ($bigEndian: boolean, $byteOrderMark: boolean, $throwOnInvalidCharacters: boolean)
        }
        class UTF7Encoding extends System.Text.Encoding implements System.ICloneable
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($allowOptionals: boolean)
        }
        class UTF8Encoding extends System.Text.Encoding implements System.ICloneable
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($encoderShouldEmitUTF8Identifier: boolean)
            public constructor ($encoderShouldEmitUTF8Identifier: boolean, $throwOnInvalidBytes: boolean)
        }
        class UnicodeEncoding extends System.Text.Encoding implements System.ICloneable
        {
            protected [__keep_incompatibility]: never;
            public static CharSize : number
            public constructor ()
            public constructor ($bigEndian: boolean, $byteOrderMark: boolean)
            public constructor ($bigEndian: boolean, $byteOrderMark: boolean, $throwOnInvalidBytes: boolean)
        }
    }
    namespace System.TimeZoneInfo {
        class AdjustmentRule extends System.Object implements System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable, System.IEquatable$1<System.TimeZoneInfo.AdjustmentRule>
        {
            protected [__keep_incompatibility]: never;
            public get DateStart(): System.DateTime;
            public get DateEnd(): System.DateTime;
            public get DaylightDelta(): System.TimeSpan;
            public get DaylightTransitionStart(): System.TimeZoneInfo.TransitionTime;
            public get DaylightTransitionEnd(): System.TimeZoneInfo.TransitionTime;
            public Equals ($other: System.TimeZoneInfo.AdjustmentRule) : boolean
            public static CreateAdjustmentRule ($dateStart: System.DateTime, $dateEnd: System.DateTime, $daylightDelta: System.TimeSpan, $daylightTransitionStart: System.TimeZoneInfo.TransitionTime, $daylightTransitionEnd: System.TimeZoneInfo.TransitionTime) : System.TimeZoneInfo.AdjustmentRule
            public OnDeserialization ($sender: any) : void
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
        }
        class TransitionTime extends System.ValueType implements System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable, System.IEquatable$1<System.TimeZoneInfo.TransitionTime>
        {
            protected [__keep_incompatibility]: never;
            public get TimeOfDay(): System.DateTime;
            public get Month(): number;
            public get Week(): number;
            public get Day(): number;
            public get DayOfWeek(): System.DayOfWeek;
            public get IsFixedDateRule(): boolean;
            public Equals ($obj: any) : boolean
            public static op_Equality ($t1: System.TimeZoneInfo.TransitionTime, $t2: System.TimeZoneInfo.TransitionTime) : boolean
            public static op_Inequality ($t1: System.TimeZoneInfo.TransitionTime, $t2: System.TimeZoneInfo.TransitionTime) : boolean
            public Equals ($other: System.TimeZoneInfo.TransitionTime) : boolean
            public static CreateFixedDateRule ($timeOfDay: System.DateTime, $month: number, $day: number) : System.TimeZoneInfo.TransitionTime
            public static CreateFloatingDateRule ($timeOfDay: System.DateTime, $month: number, $week: number, $dayOfWeek: System.DayOfWeek) : System.TimeZoneInfo.TransitionTime
            public OnDeserialization ($sender: any) : void
            public static Equals ($objA: any, $objB: any) : boolean
        }
    }
    namespace System.Collections.ObjectModel {
        class ReadOnlyCollection$1<T> extends System.Object implements System.Collections.Generic.IReadOnlyList$1<T>, System.Collections.ICollection, System.Collections.Generic.IEnumerable$1<T>, System.Collections.IEnumerable, System.Collections.Generic.IList$1<T>, System.Collections.Generic.IReadOnlyCollection$1<T>, System.Collections.IList, System.Collections.Generic.ICollection$1<T>
        {
            protected [__keep_incompatibility]: never;
            public get Count(): number;
            public get SyncRoot(): any;
            public get IsSynchronized(): boolean;
            public get IsReadOnly(): boolean;
            public get IsFixedSize(): boolean;
            public GetEnumerator () : System.Collections.IEnumerator
            public CopyTo ($array: System.Array, $index: number) : void
            public get_Item ($index: number) : any
            public set_Item ($index: number, $value: any) : void
            public Add ($value: any) : number
            public Contains ($value: any) : boolean
            public Clear () : void
            public IndexOf ($value: any) : number
            public Insert ($index: number, $value: any) : void
            public Remove ($value: any) : void
            public RemoveAt ($index: number) : void
            public [Symbol.iterator]() : IterableIterator<T>
        }
        class Collection$1<T> extends System.Object implements System.Collections.Generic.IReadOnlyList$1<T>, System.Collections.ICollection, System.Collections.Generic.IEnumerable$1<T>, System.Collections.IEnumerable, System.Collections.Generic.IList$1<T>, System.Collections.Generic.IReadOnlyCollection$1<T>, System.Collections.IList, System.Collections.Generic.ICollection$1<T>
        {
            protected [__keep_incompatibility]: never;
            public get Count(): number;
            public get SyncRoot(): any;
            public get IsSynchronized(): boolean;
            public get IsReadOnly(): boolean;
            public get IsFixedSize(): boolean;
            public GetEnumerator () : System.Collections.IEnumerator
            public CopyTo ($array: System.Array, $index: number) : void
            public get_Item ($index: number) : any
            public set_Item ($index: number, $value: any) : void
            public Add ($value: any) : number
            public Contains ($value: any) : boolean
            public Clear () : void
            public IndexOf ($value: any) : number
            public Insert ($index: number, $value: any) : void
            public Remove ($value: any) : void
            public RemoveAt ($index: number) : void
            public [Symbol.iterator]() : IterableIterator<T>
        }
    }
    namespace System.ArraySegment$1 {
        class Enumerator<T> extends System.ValueType implements System.Collections.Generic.IEnumerator$1<T>, System.Collections.IEnumerator, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get Current(): T;
            public MoveNext () : boolean
            public Dispose () : void
        }
    }
    namespace System.Reflection {
        class Assembly extends System.Object implements System.Runtime.Serialization.ISerializable, System.Reflection.ICustomAttributeProvider, System.Security.IEvidenceFactory, System.Runtime.InteropServices._Assembly
        {
            protected [__keep_incompatibility]: never;
            public get CodeBase(): string;
            public get EscapedCodeBase(): string;
            public get FullName(): string;
            public get EntryPoint(): System.Reflection.MethodInfo;
            public get Evidence(): System.Security.Policy.Evidence;
            public get Location(): string;
            public get ImageRuntimeVersion(): string;
            public get HostContext(): bigint;
            public get ReflectionOnly(): boolean;
            public get PermissionSet(): System.Security.PermissionSet;
            public get SecurityRuleSet(): System.Security.SecurityRuleSet;
            public get IsFullyTrusted(): boolean;
            public get ManifestModule(): System.Reflection.Module;
            public get GlobalAssemblyCache(): boolean;
            public get IsDynamic(): boolean;
            public get DefinedTypes(): System.Collections.Generic.IEnumerable$1<System.Reflection.TypeInfo>;
            public get ExportedTypes(): System.Collections.Generic.IEnumerable$1<System.Type>;
            public get Modules(): System.Collections.Generic.IEnumerable$1<System.Reflection.Module>;
            public get CustomAttributes(): System.Collections.Generic.IEnumerable$1<System.Reflection.CustomAttributeData>;
            public add_ModuleResolve ($value: System.Reflection.ModuleResolveEventHandler) : void
            public remove_ModuleResolve ($value: System.Reflection.ModuleResolveEventHandler) : void
            public GetObjectData ($info: System.Runtime.Serialization.SerializationInfo, $context: System.Runtime.Serialization.StreamingContext) : void
            public IsDefined ($attributeType: System.Type, $inherit: boolean) : boolean
            public GetCustomAttributes ($inherit: boolean) : System.Array$1<any>
            public GetCustomAttributes ($attributeType: System.Type, $inherit: boolean) : System.Array$1<any>
            public GetFiles () : System.Array$1<System.IO.FileStream>
            public GetFiles ($getResourceModules: boolean) : System.Array$1<System.IO.FileStream>
            public GetFile ($name: string) : System.IO.FileStream
            public GetManifestResourceStream ($name: string) : System.IO.Stream
            public GetManifestResourceStream ($type: System.Type, $name: string) : System.IO.Stream
            public GetTypes () : System.Array$1<System.Type>
            public GetExportedTypes () : System.Array$1<System.Type>
            public GetType ($name: string, $throwOnError: boolean) : System.Type
            public GetType ($name: string) : System.Type
            public GetName ($copiedName: boolean) : System.Reflection.AssemblyName
            public GetName () : System.Reflection.AssemblyName
            public static CreateQualifiedName ($assemblyName: string, $typeName: string) : string
            public static GetAssembly ($type: System.Type) : System.Reflection.Assembly
            public static GetEntryAssembly () : System.Reflection.Assembly
            public static LoadFrom ($assemblyFile: string) : System.Reflection.Assembly
            public static LoadFrom ($assemblyFile: string, $hashValue: System.Array$1<number>, $hashAlgorithm: System.Configuration.Assemblies.AssemblyHashAlgorithm) : System.Reflection.Assembly
            public static UnsafeLoadFrom ($assemblyFile: string) : System.Reflection.Assembly
            public static LoadFile ($path: string) : System.Reflection.Assembly
            public static Load ($assemblyString: string) : System.Reflection.Assembly
            public static Load ($assemblyRef: System.Reflection.AssemblyName) : System.Reflection.Assembly
            public static Load ($rawAssembly: System.Array$1<number>) : System.Reflection.Assembly
            public static Load ($rawAssembly: System.Array$1<number>, $rawSymbolStore: System.Array$1<number>) : System.Reflection.Assembly
            public static Load ($rawAssembly: System.Array$1<number>, $rawSymbolStore: System.Array$1<number>, $securityContextSource: System.Security.SecurityContextSource) : System.Reflection.Assembly
            public static ReflectionOnlyLoad ($rawAssembly: System.Array$1<number>) : System.Reflection.Assembly
            public static ReflectionOnlyLoad ($assemblyString: string) : System.Reflection.Assembly
            public static ReflectionOnlyLoadFrom ($assemblyFile: string) : System.Reflection.Assembly
            public LoadModule ($moduleName: string, $rawModule: System.Array$1<number>) : System.Reflection.Module
            public LoadModule ($moduleName: string, $rawModule: System.Array$1<number>, $rawSymbolStore: System.Array$1<number>) : System.Reflection.Module
            public CreateInstance ($typeName: string) : any
            public CreateInstance ($typeName: string, $ignoreCase: boolean) : any
            public CreateInstance ($typeName: string, $ignoreCase: boolean, $bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $args: System.Array$1<any>, $culture: System.Globalization.CultureInfo, $activationAttributes: System.Array$1<any>) : any
            public GetLoadedModules () : System.Array$1<System.Reflection.Module>
            public GetModules () : System.Array$1<System.Reflection.Module>
            public static GetExecutingAssembly () : System.Reflection.Assembly
            public static GetCallingAssembly () : System.Reflection.Assembly
            public GetManifestResourceNames () : System.Array$1<string>
            public GetManifestResourceInfo ($resourceName: string) : System.Reflection.ManifestResourceInfo
            public GetCustomAttributesData () : System.Collections.Generic.IList$1<System.Reflection.CustomAttributeData>
            public GetType ($name: string, $throwOnError: boolean, $ignoreCase: boolean) : System.Type
            public GetModule ($name: string) : System.Reflection.Module
            public GetReferencedAssemblies () : System.Array$1<System.Reflection.AssemblyName>
            public GetModules ($getResourceModules: boolean) : System.Array$1<System.Reflection.Module>
            public GetLoadedModules ($getResourceModules: boolean) : System.Array$1<System.Reflection.Module>
            public GetSatelliteAssembly ($culture: System.Globalization.CultureInfo) : System.Reflection.Assembly
            public GetSatelliteAssembly ($culture: System.Globalization.CultureInfo, $version: System.Version) : System.Reflection.Assembly
            public static op_Equality ($left: System.Reflection.Assembly, $right: System.Reflection.Assembly) : boolean
            public static op_Inequality ($left: System.Reflection.Assembly, $right: System.Reflection.Assembly) : boolean
            public GetForwardedTypes () : System.Array$1<System.Type>
            public Equals ($other: any) : boolean
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
            public GetType () : System.Type
        }
        interface Assembly {
            GetCustomAttribute ($attributeType: System.Type) : System.Attribute;
            GetCustomAttributes () : System.Collections.Generic.IEnumerable$1<System.Attribute>;
            GetCustomAttributes ($attributeType: System.Type) : System.Collections.Generic.IEnumerable$1<System.Attribute>;
            IsDefined ($attributeType: System.Type) : boolean;
            TryGetRawMetadata ($blob: $Ref<System.Byte>, $length: $Ref<number>) : boolean;
        }
        interface ICustomAttributeProvider
        {
            GetCustomAttributes ($inherit: boolean) : System.Array$1<any>
            GetCustomAttributes ($attributeType: System.Type, $inherit: boolean) : System.Array$1<any>
            IsDefined ($attributeType: System.Type, $inherit: boolean) : boolean
        }
        class MemberInfo extends System.Object implements System.Runtime.InteropServices._MemberInfo, System.Reflection.ICustomAttributeProvider
        {
            protected [__keep_incompatibility]: never;
            public get MemberType(): System.Reflection.MemberTypes;
            public get Name(): string;
            public get DeclaringType(): System.Type;
            public get ReflectedType(): System.Type;
            public get Module(): System.Reflection.Module;
            public get CustomAttributes(): System.Collections.Generic.IEnumerable$1<System.Reflection.CustomAttributeData>;
            public get MetadataToken(): number;
            public HasSameMetadataDefinitionAs ($other: System.Reflection.MemberInfo) : boolean
            public IsDefined ($attributeType: System.Type, $inherit: boolean) : boolean
            public GetCustomAttributes ($inherit: boolean) : System.Array$1<any>
            public GetCustomAttributes ($attributeType: System.Type, $inherit: boolean) : System.Array$1<any>
            public GetCustomAttributesData () : System.Collections.Generic.IList$1<System.Reflection.CustomAttributeData>
            public static op_Equality ($left: System.Reflection.MemberInfo, $right: System.Reflection.MemberInfo) : boolean
            public static op_Inequality ($left: System.Reflection.MemberInfo, $right: System.Reflection.MemberInfo) : boolean
            public Equals ($other: any) : boolean
            public GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            public GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            public GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            public Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
        }
        interface MemberInfo {
            HasMetadataToken () : boolean;
            GetMetadataToken () : number;
            GetCustomAttribute ($attributeType: System.Type) : System.Attribute;
            GetCustomAttribute ($attributeType: System.Type, $inherit: boolean) : System.Attribute;
            GetCustomAttributes () : System.Collections.Generic.IEnumerable$1<System.Attribute>;
            GetCustomAttributes ($inherit: boolean) : System.Collections.Generic.IEnumerable$1<System.Attribute>;
            GetCustomAttributes ($attributeType: System.Type) : System.Collections.Generic.IEnumerable$1<System.Attribute>;
            GetCustomAttributes ($attributeType: System.Type, $inherit: boolean) : System.Collections.Generic.IEnumerable$1<System.Attribute>;
            IsDefined ($attributeType: System.Type) : boolean;
            IsDefined ($attributeType: System.Type, $inherit: boolean) : boolean;
        }
        interface IReflect
        {
            UnderlyingSystemType : System.Type
            GetMethod ($name: string, $bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>) : System.Reflection.MethodInfo
            GetMethod ($name: string, $bindingAttr: System.Reflection.BindingFlags) : System.Reflection.MethodInfo
            GetMethods ($bindingAttr: System.Reflection.BindingFlags) : System.Array$1<System.Reflection.MethodInfo>
            GetField ($name: string, $bindingAttr: System.Reflection.BindingFlags) : System.Reflection.FieldInfo
            GetFields ($bindingAttr: System.Reflection.BindingFlags) : System.Array$1<System.Reflection.FieldInfo>
            GetProperty ($name: string, $bindingAttr: System.Reflection.BindingFlags) : System.Reflection.PropertyInfo
            GetProperty ($name: string, $bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $returnType: System.Type, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>) : System.Reflection.PropertyInfo
            GetProperties ($bindingAttr: System.Reflection.BindingFlags) : System.Array$1<System.Reflection.PropertyInfo>
            GetMember ($name: string, $bindingAttr: System.Reflection.BindingFlags) : System.Array$1<System.Reflection.MemberInfo>
            GetMembers ($bindingAttr: System.Reflection.BindingFlags) : System.Array$1<System.Reflection.MemberInfo>
            InvokeMember ($name: string, $invokeAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $target: any, $args: System.Array$1<any>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>, $culture: System.Globalization.CultureInfo, $namedParameters: System.Array$1<string>) : any
        }
        interface MemberFilter
        { 
        (m: System.Reflection.MemberInfo, filterCriteria: any) : boolean; 
        Invoke?: (m: System.Reflection.MemberInfo, filterCriteria: any) => boolean;
        }
        var MemberFilter: { new (func: (m: System.Reflection.MemberInfo, filterCriteria: any) => boolean): MemberFilter; }
        interface TypeFilter
        { 
        (m: System.Type, filterCriteria: any) : boolean; 
        Invoke?: (m: System.Type, filterCriteria: any) => boolean;
        }
        var TypeFilter: { new (func: (m: System.Type, filterCriteria: any) => boolean): TypeFilter; }
        enum MemberTypes
        { Constructor = 1, Event = 2, Field = 4, Method = 8, Property = 16, TypeInfo = 32, Custom = 64, NestedType = 128, All = 191 }
        enum BindingFlags
        { Default = 0, IgnoreCase = 1, DeclaredOnly = 2, Instance = 4, Static = 8, Public = 16, NonPublic = 32, FlattenHierarchy = 64, InvokeMethod = 256, CreateInstance = 512, GetField = 1024, SetField = 2048, GetProperty = 4096, SetProperty = 8192, PutDispProperty = 16384, PutRefDispProperty = 32768, ExactBinding = 65536, SuppressChangeType = 131072, OptionalParamBinding = 262144, IgnoreReturn = 16777216, DoNotWrapExceptions = 33554432 }
        class Module extends System.Object implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Module, System.Reflection.ICustomAttributeProvider
        {
            protected [__keep_incompatibility]: never;
            public static FilterTypeName : System.Reflection.TypeFilter
            public static FilterTypeNameIgnoreCase : System.Reflection.TypeFilter
            public get Assembly(): System.Reflection.Assembly;
            public get FullyQualifiedName(): string;
            public get Name(): string;
            public get MDStreamVersion(): number;
            public get ModuleVersionId(): System.Guid;
            public get ScopeName(): string;
            public get ModuleHandle(): System.ModuleHandle;
            public get CustomAttributes(): System.Collections.Generic.IEnumerable$1<System.Reflection.CustomAttributeData>;
            public get MetadataToken(): number;
            public GetPEKind ($peKind: $Ref<System.Reflection.PortableExecutableKinds>, $machine: $Ref<System.Reflection.ImageFileMachine>) : void
            public IsResource () : boolean
            public IsDefined ($attributeType: System.Type, $inherit: boolean) : boolean
            public GetCustomAttributesData () : System.Collections.Generic.IList$1<System.Reflection.CustomAttributeData>
            public GetCustomAttributes ($inherit: boolean) : System.Array$1<any>
            public GetCustomAttributes ($attributeType: System.Type, $inherit: boolean) : System.Array$1<any>
            public GetMethod ($name: string) : System.Reflection.MethodInfo
            public GetMethod ($name: string, $types: System.Array$1<System.Type>) : System.Reflection.MethodInfo
            public GetMethod ($name: string, $bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $callConvention: System.Reflection.CallingConventions, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>) : System.Reflection.MethodInfo
            public GetMethods () : System.Array$1<System.Reflection.MethodInfo>
            public GetMethods ($bindingFlags: System.Reflection.BindingFlags) : System.Array$1<System.Reflection.MethodInfo>
            public GetField ($name: string) : System.Reflection.FieldInfo
            public GetField ($name: string, $bindingAttr: System.Reflection.BindingFlags) : System.Reflection.FieldInfo
            public GetFields () : System.Array$1<System.Reflection.FieldInfo>
            public GetFields ($bindingFlags: System.Reflection.BindingFlags) : System.Array$1<System.Reflection.FieldInfo>
            public GetTypes () : System.Array$1<System.Type>
            public GetType ($className: string) : System.Type
            public GetType ($className: string, $ignoreCase: boolean) : System.Type
            public GetType ($className: string, $throwOnError: boolean, $ignoreCase: boolean) : System.Type
            public FindTypes ($filter: System.Reflection.TypeFilter, $filterCriteria: any) : System.Array$1<System.Type>
            public ResolveField ($metadataToken: number) : System.Reflection.FieldInfo
            public ResolveField ($metadataToken: number, $genericTypeArguments: System.Array$1<System.Type>, $genericMethodArguments: System.Array$1<System.Type>) : System.Reflection.FieldInfo
            public ResolveMember ($metadataToken: number) : System.Reflection.MemberInfo
            public ResolveMember ($metadataToken: number, $genericTypeArguments: System.Array$1<System.Type>, $genericMethodArguments: System.Array$1<System.Type>) : System.Reflection.MemberInfo
            public ResolveMethod ($metadataToken: number) : System.Reflection.MethodBase
            public ResolveMethod ($metadataToken: number, $genericTypeArguments: System.Array$1<System.Type>, $genericMethodArguments: System.Array$1<System.Type>) : System.Reflection.MethodBase
            public ResolveSignature ($metadataToken: number) : System.Array$1<number>
            public ResolveString ($metadataToken: number) : string
            public ResolveType ($metadataToken: number) : System.Type
            public ResolveType ($metadataToken: number, $genericTypeArguments: System.Array$1<System.Type>, $genericMethodArguments: System.Array$1<System.Type>) : System.Type
            public GetObjectData ($info: System.Runtime.Serialization.SerializationInfo, $context: System.Runtime.Serialization.StreamingContext) : void
            public static op_Equality ($left: System.Reflection.Module, $right: System.Reflection.Module) : boolean
            public static op_Inequality ($left: System.Reflection.Module, $right: System.Reflection.Module) : boolean
            public GetSignerCertificate () : System.Security.Cryptography.X509Certificates.X509Certificate
            public GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            public GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            public GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            public Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
            public GetType () : System.Type
        }
        interface Module {
            HasModuleVersionId () : boolean;
            GetModuleVersionId () : System.Guid;
            GetCustomAttribute ($attributeType: System.Type) : System.Attribute;
            GetCustomAttributes () : System.Collections.Generic.IEnumerable$1<System.Attribute>;
            GetCustomAttributes ($attributeType: System.Type) : System.Collections.Generic.IEnumerable$1<System.Attribute>;
            IsDefined ($attributeType: System.Type) : boolean;
        }
        class MethodBase extends System.Reflection.MemberInfo implements System.Runtime.InteropServices._MemberInfo, System.Runtime.InteropServices._MethodBase, System.Reflection.ICustomAttributeProvider
        {
            protected [__keep_incompatibility]: never;
            public get Attributes(): System.Reflection.MethodAttributes;
            public get MethodImplementationFlags(): System.Reflection.MethodImplAttributes;
            public get CallingConvention(): System.Reflection.CallingConventions;
            public get IsAbstract(): boolean;
            public get IsConstructor(): boolean;
            public get IsFinal(): boolean;
            public get IsHideBySig(): boolean;
            public get IsSpecialName(): boolean;
            public get IsStatic(): boolean;
            public get IsVirtual(): boolean;
            public get IsAssembly(): boolean;
            public get IsFamily(): boolean;
            public get IsFamilyAndAssembly(): boolean;
            public get IsFamilyOrAssembly(): boolean;
            public get IsPrivate(): boolean;
            public get IsPublic(): boolean;
            public get IsConstructedGenericMethod(): boolean;
            public get IsGenericMethod(): boolean;
            public get IsGenericMethodDefinition(): boolean;
            public get ContainsGenericParameters(): boolean;
            public get MethodHandle(): System.RuntimeMethodHandle;
            public get IsSecurityCritical(): boolean;
            public get IsSecuritySafeCritical(): boolean;
            public get IsSecurityTransparent(): boolean;
            public GetParameters () : System.Array$1<System.Reflection.ParameterInfo>
            public GetMethodImplementationFlags () : System.Reflection.MethodImplAttributes
            public GetMethodBody () : System.Reflection.MethodBody
            public GetGenericArguments () : System.Array$1<System.Type>
            public Invoke ($obj: any, $parameters: System.Array$1<any>) : any
            public Invoke ($obj: any, $invokeAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $parameters: System.Array$1<any>, $culture: System.Globalization.CultureInfo) : any
            public static op_Equality ($left: System.Reflection.MethodBase, $right: System.Reflection.MethodBase) : boolean
            public static op_Inequality ($left: System.Reflection.MethodBase, $right: System.Reflection.MethodBase) : boolean
            public static GetMethodFromHandle ($handle: System.RuntimeMethodHandle) : System.Reflection.MethodBase
            public static GetMethodFromHandle ($handle: System.RuntimeMethodHandle, $declaringType: System.RuntimeTypeHandle) : System.Reflection.MethodBase
            public static GetCurrentMethod () : System.Reflection.MethodBase
            public static op_Equality ($left: System.Reflection.MemberInfo, $right: System.Reflection.MemberInfo) : boolean
            public static op_Inequality ($left: System.Reflection.MemberInfo, $right: System.Reflection.MemberInfo) : boolean
            public Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
        }
        enum GenericParameterAttributes
        { None = 0, VarianceMask = 3, Covariant = 1, Contravariant = 2, SpecialConstraintMask = 28, ReferenceTypeConstraint = 4, NotNullableValueTypeConstraint = 8, DefaultConstructorConstraint = 16 }
        enum TypeAttributes
        { VisibilityMask = 7, NotPublic = 0, Public = 1, NestedPublic = 2, NestedPrivate = 3, NestedFamily = 4, NestedAssembly = 5, NestedFamANDAssem = 6, NestedFamORAssem = 7, LayoutMask = 24, AutoLayout = 0, SequentialLayout = 8, ExplicitLayout = 16, ClassSemanticsMask = 32, Class = 0, Interface = 32, Abstract = 128, Sealed = 256, SpecialName = 1024, Import = 4096, Serializable = 8192, WindowsRuntime = 16384, StringFormatMask = 196608, AnsiClass = 0, UnicodeClass = 65536, AutoClass = 131072, CustomFormatClass = 196608, CustomFormatMask = 12582912, BeforeFieldInit = 1048576, RTSpecialName = 2048, HasSecurity = 262144, ReservedMask = 264192 }
        class ConstructorInfo extends System.Reflection.MethodBase implements System.Runtime.InteropServices._MemberInfo, System.Runtime.InteropServices._MethodBase, System.Runtime.InteropServices._ConstructorInfo, System.Reflection.ICustomAttributeProvider
        {
            protected [__keep_incompatibility]: never;
            public static ConstructorName : string
            public static TypeConstructorName : string
            public get MemberType(): System.Reflection.MemberTypes;
            public Invoke ($parameters: System.Array$1<any>) : any
            public Invoke ($invokeAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $parameters: System.Array$1<any>, $culture: System.Globalization.CultureInfo) : any
            public static op_Equality ($left: System.Reflection.ConstructorInfo, $right: System.Reflection.ConstructorInfo) : boolean
            public static op_Inequality ($left: System.Reflection.ConstructorInfo, $right: System.Reflection.ConstructorInfo) : boolean
            public Invoke_5 ($parameters: System.Array$1<any>) : any
            public Invoke_3 ($obj: any, $parameters: System.Array$1<any>) : any
            public Invoke_4 ($invokeAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $parameters: System.Array$1<any>, $culture: System.Globalization.CultureInfo) : any
            public Invoke_2 ($obj: any, $invokeAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $parameters: System.Array$1<any>, $culture: System.Globalization.CultureInfo) : any
            public Invoke ($obj: any, $parameters: System.Array$1<any>) : any
            public Invoke ($obj: any, $invokeAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $parameters: System.Array$1<any>, $culture: System.Globalization.CultureInfo) : any
            public Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
            public static op_Equality ($left: System.Reflection.MethodBase, $right: System.Reflection.MethodBase) : boolean
            public static op_Equality ($left: System.Reflection.MemberInfo, $right: System.Reflection.MemberInfo) : boolean
            public static op_Inequality ($left: System.Reflection.MethodBase, $right: System.Reflection.MethodBase) : boolean
            public static op_Inequality ($left: System.Reflection.MemberInfo, $right: System.Reflection.MemberInfo) : boolean
        }
        class Binder extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public BindToField ($bindingAttr: System.Reflection.BindingFlags, $match: System.Array$1<System.Reflection.FieldInfo>, $value: any, $culture: System.Globalization.CultureInfo) : System.Reflection.FieldInfo
            public BindToMethod ($bindingAttr: System.Reflection.BindingFlags, $match: System.Array$1<System.Reflection.MethodBase>, $args: $Ref<System.Array$1<any>>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>, $culture: System.Globalization.CultureInfo, $names: System.Array$1<string>, $state: $Ref<any>) : System.Reflection.MethodBase
            public ChangeType ($value: any, $type: System.Type, $culture: System.Globalization.CultureInfo) : any
            public ReorderArgumentArray ($args: $Ref<System.Array$1<any>>, $state: any) : void
            public SelectMethod ($bindingAttr: System.Reflection.BindingFlags, $match: System.Array$1<System.Reflection.MethodBase>, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>) : System.Reflection.MethodBase
            public SelectProperty ($bindingAttr: System.Reflection.BindingFlags, $match: System.Array$1<System.Reflection.PropertyInfo>, $returnType: System.Type, $indexes: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>) : System.Reflection.PropertyInfo
            public CanChangeType ($value: any, $type: System.Type, $culture: System.Globalization.CultureInfo) : boolean
        }
        class ParameterModifier extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get_Item ($index: number) : boolean
            public set_Item ($index: number, $value: boolean) : void
            public constructor ($parameterCount: number)
            public constructor ()
        }
        enum CallingConventions
        { Standard = 1, VarArgs = 2, Any = 3, HasThis = 32, ExplicitThis = 64 }
        class EventInfo extends System.Reflection.MemberInfo implements System.Runtime.InteropServices._MemberInfo, System.Runtime.InteropServices._EventInfo, System.Reflection.ICustomAttributeProvider
        {
            protected [__keep_incompatibility]: never;
            public get MemberType(): System.Reflection.MemberTypes;
            public get Attributes(): System.Reflection.EventAttributes;
            public get IsSpecialName(): boolean;
            public get AddMethod(): System.Reflection.MethodInfo;
            public get RemoveMethod(): System.Reflection.MethodInfo;
            public get RaiseMethod(): System.Reflection.MethodInfo;
            public get IsMulticast(): boolean;
            public get EventHandlerType(): System.Type;
            public GetOtherMethods () : System.Array$1<System.Reflection.MethodInfo>
            public GetOtherMethods ($nonPublic: boolean) : System.Array$1<System.Reflection.MethodInfo>
            public GetAddMethod () : System.Reflection.MethodInfo
            public GetRemoveMethod () : System.Reflection.MethodInfo
            public GetRaiseMethod () : System.Reflection.MethodInfo
            public GetAddMethod ($nonPublic: boolean) : System.Reflection.MethodInfo
            public GetRemoveMethod ($nonPublic: boolean) : System.Reflection.MethodInfo
            public GetRaiseMethod ($nonPublic: boolean) : System.Reflection.MethodInfo
            public RemoveEventHandler ($target: any, $handler: Function) : void
            public static op_Equality ($left: System.Reflection.EventInfo, $right: System.Reflection.EventInfo) : boolean
            public static op_Inequality ($left: System.Reflection.EventInfo, $right: System.Reflection.EventInfo) : boolean
            public AddEventHandler ($target: any, $handler: Function) : void
            public static op_Equality ($left: System.Reflection.MemberInfo, $right: System.Reflection.MemberInfo) : boolean
            public static op_Inequality ($left: System.Reflection.MemberInfo, $right: System.Reflection.MemberInfo) : boolean
        }
        class FieldInfo extends System.Reflection.MemberInfo implements System.Runtime.InteropServices._MemberInfo, System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._FieldInfo
        {
            protected [__keep_incompatibility]: never;
            public get MemberType(): System.Reflection.MemberTypes;
            public get Attributes(): System.Reflection.FieldAttributes;
            public get FieldType(): System.Type;
            public get IsInitOnly(): boolean;
            public get IsLiteral(): boolean;
            public get IsNotSerialized(): boolean;
            public get IsPinvokeImpl(): boolean;
            public get IsSpecialName(): boolean;
            public get IsStatic(): boolean;
            public get IsAssembly(): boolean;
            public get IsFamily(): boolean;
            public get IsFamilyAndAssembly(): boolean;
            public get IsFamilyOrAssembly(): boolean;
            public get IsPrivate(): boolean;
            public get IsPublic(): boolean;
            public get IsSecurityCritical(): boolean;
            public get IsSecuritySafeCritical(): boolean;
            public get IsSecurityTransparent(): boolean;
            public get FieldHandle(): System.RuntimeFieldHandle;
            public static op_Equality ($left: System.Reflection.FieldInfo, $right: System.Reflection.FieldInfo) : boolean
            public static op_Inequality ($left: System.Reflection.FieldInfo, $right: System.Reflection.FieldInfo) : boolean
            public GetValue ($obj: any) : any
            public SetValue ($obj: any, $value: any) : void
            public SetValue ($obj: any, $value: any, $invokeAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $culture: System.Globalization.CultureInfo) : void
            public GetRawConstantValue () : any
            public GetOptionalCustomModifiers () : System.Array$1<System.Type>
            public GetRequiredCustomModifiers () : System.Array$1<System.Type>
            public static GetFieldFromHandle ($handle: System.RuntimeFieldHandle) : System.Reflection.FieldInfo
            public static GetFieldFromHandle ($handle: System.RuntimeFieldHandle, $declaringType: System.RuntimeTypeHandle) : System.Reflection.FieldInfo
            public static op_Equality ($left: System.Reflection.MemberInfo, $right: System.Reflection.MemberInfo) : boolean
            public static op_Inequality ($left: System.Reflection.MemberInfo, $right: System.Reflection.MemberInfo) : boolean
        }
        class MethodInfo extends System.Reflection.MethodBase implements System.Runtime.InteropServices._MemberInfo, System.Runtime.InteropServices._MethodBase, System.Runtime.InteropServices._MethodInfo, System.Reflection.ICustomAttributeProvider
        {
            protected [__keep_incompatibility]: never;
            public get MemberType(): System.Reflection.MemberTypes;
            public get ReturnParameter(): System.Reflection.ParameterInfo;
            public get ReturnType(): System.Type;
            public get ReturnTypeCustomAttributes(): System.Reflection.ICustomAttributeProvider;
            public GetGenericMethodDefinition () : System.Reflection.MethodInfo
            public MakeGenericMethod (...typeArguments: System.Type[]) : System.Reflection.MethodInfo
            public GetBaseDefinition () : System.Reflection.MethodInfo
            public CreateDelegate ($delegateType: System.Type) : Function
            public CreateDelegate ($delegateType: System.Type, $target: any) : Function
            public static op_Equality ($left: System.Reflection.MethodInfo, $right: System.Reflection.MethodInfo) : boolean
            public static op_Inequality ($left: System.Reflection.MethodInfo, $right: System.Reflection.MethodInfo) : boolean
            public static op_Equality ($left: System.Reflection.MethodBase, $right: System.Reflection.MethodBase) : boolean
            public static op_Equality ($left: System.Reflection.MemberInfo, $right: System.Reflection.MemberInfo) : boolean
            public static op_Inequality ($left: System.Reflection.MethodBase, $right: System.Reflection.MethodBase) : boolean
            public static op_Inequality ($left: System.Reflection.MemberInfo, $right: System.Reflection.MemberInfo) : boolean
        }
        interface MethodInfo {
            GetRuntimeBaseDefinition () : System.Reflection.MethodInfo;
        }
        class PropertyInfo extends System.Reflection.MemberInfo implements System.Runtime.InteropServices._PropertyInfo, System.Runtime.InteropServices._MemberInfo, System.Reflection.ICustomAttributeProvider
        {
            protected [__keep_incompatibility]: never;
            public get MemberType(): System.Reflection.MemberTypes;
            public get PropertyType(): System.Type;
            public get Attributes(): System.Reflection.PropertyAttributes;
            public get IsSpecialName(): boolean;
            public get CanRead(): boolean;
            public get CanWrite(): boolean;
            public get GetMethod(): System.Reflection.MethodInfo;
            public get SetMethod(): System.Reflection.MethodInfo;
            public GetIndexParameters () : System.Array$1<System.Reflection.ParameterInfo>
            public GetAccessors () : System.Array$1<System.Reflection.MethodInfo>
            public GetAccessors ($nonPublic: boolean) : System.Array$1<System.Reflection.MethodInfo>
            public GetGetMethod () : System.Reflection.MethodInfo
            public GetGetMethod ($nonPublic: boolean) : System.Reflection.MethodInfo
            public GetSetMethod () : System.Reflection.MethodInfo
            public GetSetMethod ($nonPublic: boolean) : System.Reflection.MethodInfo
            public GetOptionalCustomModifiers () : System.Array$1<System.Type>
            public GetRequiredCustomModifiers () : System.Array$1<System.Type>
            public GetValue ($obj: any) : any
            public GetValue ($obj: any, $index: System.Array$1<any>) : any
            public GetValue ($obj: any, $invokeAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $index: System.Array$1<any>, $culture: System.Globalization.CultureInfo) : any
            public GetConstantValue () : any
            public GetRawConstantValue () : any
            public SetValue ($obj: any, $value: any) : void
            public SetValue ($obj: any, $value: any, $index: System.Array$1<any>) : void
            public SetValue ($obj: any, $value: any, $invokeAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $index: System.Array$1<any>, $culture: System.Globalization.CultureInfo) : void
            public static op_Equality ($left: System.Reflection.PropertyInfo, $right: System.Reflection.PropertyInfo) : boolean
            public static op_Inequality ($left: System.Reflection.PropertyInfo, $right: System.Reflection.PropertyInfo) : boolean
            public static op_Equality ($left: System.Reflection.MemberInfo, $right: System.Reflection.MemberInfo) : boolean
            public static op_Inequality ($left: System.Reflection.MemberInfo, $right: System.Reflection.MemberInfo) : boolean
        }
        class InterfaceMapping extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public TargetType : System.Type
            public InterfaceType : System.Type
            public TargetMethods : System.Array$1<System.Reflection.MethodInfo>
            public InterfaceMethods : System.Array$1<System.Reflection.MethodInfo>
        }
        class AssemblyName extends System.Object implements System.Runtime.InteropServices._AssemblyName, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable, System.ICloneable
        {
            protected [__keep_incompatibility]: never;
            public get ProcessorArchitecture(): System.Reflection.ProcessorArchitecture;
            public set ProcessorArchitecture(value: System.Reflection.ProcessorArchitecture);
            public get Name(): string;
            public set Name(value: string);
            public get CodeBase(): string;
            public set CodeBase(value: string);
            public get EscapedCodeBase(): string;
            public get CultureInfo(): System.Globalization.CultureInfo;
            public set CultureInfo(value: System.Globalization.CultureInfo);
            public get Flags(): System.Reflection.AssemblyNameFlags;
            public set Flags(value: System.Reflection.AssemblyNameFlags);
            public get FullName(): string;
            public get HashAlgorithm(): System.Configuration.Assemblies.AssemblyHashAlgorithm;
            public set HashAlgorithm(value: System.Configuration.Assemblies.AssemblyHashAlgorithm);
            public get KeyPair(): System.Reflection.StrongNameKeyPair;
            public set KeyPair(value: System.Reflection.StrongNameKeyPair);
            public get Version(): System.Version;
            public set Version(value: System.Version);
            public get VersionCompatibility(): System.Configuration.Assemblies.AssemblyVersionCompatibility;
            public set VersionCompatibility(value: System.Configuration.Assemblies.AssemblyVersionCompatibility);
            public get CultureName(): string;
            public set CultureName(value: string);
            public get ContentType(): System.Reflection.AssemblyContentType;
            public set ContentType(value: System.Reflection.AssemblyContentType);
            public GetPublicKey () : System.Array$1<number>
            public GetPublicKeyToken () : System.Array$1<number>
            public static ReferenceMatchesDefinition ($reference: System.Reflection.AssemblyName, $definition: System.Reflection.AssemblyName) : boolean
            public SetPublicKey ($publicKey: System.Array$1<number>) : void
            public SetPublicKeyToken ($publicKeyToken: System.Array$1<number>) : void
            public GetObjectData ($info: System.Runtime.Serialization.SerializationInfo, $context: System.Runtime.Serialization.StreamingContext) : void
            public Clone () : any
            public OnDeserialization ($sender: any) : void
            public static GetAssemblyName ($assemblyFile: string) : System.Reflection.AssemblyName
            public constructor ()
            public constructor ($assemblyName: string)
            public GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            public GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            public GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            public Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
        }
        class ParameterInfo extends System.Object implements System.Runtime.Serialization.IObjectReference, System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._ParameterInfo
        {
            protected [__keep_incompatibility]: never;
            public get Attributes(): System.Reflection.ParameterAttributes;
            public get Member(): System.Reflection.MemberInfo;
            public get Name(): string;
            public get ParameterType(): System.Type;
            public get Position(): number;
            public get IsIn(): boolean;
            public get IsLcid(): boolean;
            public get IsOptional(): boolean;
            public get IsOut(): boolean;
            public get IsRetval(): boolean;
            public get DefaultValue(): any;
            public get RawDefaultValue(): any;
            public get HasDefaultValue(): boolean;
            public get CustomAttributes(): System.Collections.Generic.IEnumerable$1<System.Reflection.CustomAttributeData>;
            public get MetadataToken(): number;
            public IsDefined ($attributeType: System.Type, $inherit: boolean) : boolean
            public GetCustomAttributesData () : System.Collections.Generic.IList$1<System.Reflection.CustomAttributeData>
            public GetCustomAttributes ($inherit: boolean) : System.Array$1<any>
            public GetCustomAttributes ($attributeType: System.Type, $inherit: boolean) : System.Array$1<any>
            public GetOptionalCustomModifiers () : System.Array$1<System.Type>
            public GetRequiredCustomModifiers () : System.Array$1<System.Type>
            public GetRealObject ($context: System.Runtime.Serialization.StreamingContext) : any
            public GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            public GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            public GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            public Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
        }
        interface ParameterInfo {
            GetCustomAttribute ($attributeType: System.Type) : System.Attribute;
            GetCustomAttribute ($attributeType: System.Type, $inherit: boolean) : System.Attribute;
            GetCustomAttributes () : System.Collections.Generic.IEnumerable$1<System.Attribute>;
            GetCustomAttributes ($inherit: boolean) : System.Collections.Generic.IEnumerable$1<System.Attribute>;
            GetCustomAttributes ($attributeType: System.Type) : System.Collections.Generic.IEnumerable$1<System.Attribute>;
            GetCustomAttributes ($attributeType: System.Type, $inherit: boolean) : System.Collections.Generic.IEnumerable$1<System.Attribute>;
            IsDefined ($attributeType: System.Type) : boolean;
            IsDefined ($attributeType: System.Type, $inherit: boolean) : boolean;
        }
        class StrongNameKeyPair extends System.Object implements System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable
        {
            protected [__keep_incompatibility]: never;
            public get PublicKey(): System.Array$1<number>;
            public constructor ($keyPairArray: System.Array$1<number>)
            public constructor ($keyPairFile: System.IO.FileStream)
            public constructor ($keyPairContainer: string)
            public OnDeserialization ($sender: any) : void
            public constructor ()
        }
        class ManifestResourceInfo extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get ReferencedAssembly(): System.Reflection.Assembly;
            public get FileName(): string;
            public get ResourceLocation(): System.Reflection.ResourceLocation;
            public constructor ($containingAssembly: System.Reflection.Assembly, $containingFileName: string, $resourceLocation: System.Reflection.ResourceLocation)
            public constructor ()
        }
        interface ModuleResolveEventHandler
        { 
        (sender: any, e: System.ResolveEventArgs) : System.Reflection.Module; 
        Invoke?: (sender: any, e: System.ResolveEventArgs) => System.Reflection.Module;
        }
        var ModuleResolveEventHandler: { new (func: (sender: any, e: System.ResolveEventArgs) => System.Reflection.Module): ModuleResolveEventHandler; }
        enum MethodImplAttributes
        { CodeTypeMask = 3, IL = 0, Native = 1, OPTIL = 2, Runtime = 3, ManagedMask = 4, Unmanaged = 4, Managed = 0, ForwardRef = 16, PreserveSig = 128, InternalCall = 4096, Synchronized = 32, NoInlining = 8, AggressiveInlining = 256, NoOptimization = 64, MaxMethodImplVal = 65535, SecurityMitigations = 1024 }
        enum MethodAttributes
        { MemberAccessMask = 7, PrivateScope = 0, Private = 1, FamANDAssem = 2, Assembly = 3, Family = 4, FamORAssem = 5, Public = 6, Static = 16, Final = 32, Virtual = 64, HideBySig = 128, CheckAccessOnOverride = 512, VtableLayoutMask = 256, ReuseSlot = 0, NewSlot = 256, Abstract = 1024, SpecialName = 2048, PinvokeImpl = 8192, UnmanagedExport = 8, RTSpecialName = 4096, HasSecurity = 16384, RequireSecObject = 32768, ReservedMask = 53248 }
        enum EventAttributes
        { None = 0, SpecialName = 512, RTSpecialName = 1024, ReservedMask = 1024 }
        enum FieldAttributes
        { FieldAccessMask = 7, PrivateScope = 0, Private = 1, FamANDAssem = 2, Assembly = 3, Family = 4, FamORAssem = 5, Public = 6, Static = 16, InitOnly = 32, Literal = 64, NotSerialized = 128, SpecialName = 512, PinvokeImpl = 8192, RTSpecialName = 1024, HasFieldMarshal = 4096, HasDefault = 32768, HasFieldRVA = 256, ReservedMask = 38144 }
        enum PropertyAttributes
        { None = 0, SpecialName = 512, RTSpecialName = 1024, HasDefault = 4096, Reserved2 = 8192, Reserved3 = 16384, Reserved4 = 32768, ReservedMask = 62464 }
        class AmbiguousMatchException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $inner: System.Exception)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class AssemblyAlgorithmIdAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get AlgorithmId(): number;
            public constructor ($algorithmId: System.Configuration.Assemblies.AssemblyHashAlgorithm)
            public constructor ($algorithmId: number)
            public constructor ()
        }
        class AssemblyCompanyAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Company(): string;
            public constructor ($company: string)
            public constructor ()
        }
        class AssemblyConfigurationAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Configuration(): string;
            public constructor ($configuration: string)
            public constructor ()
        }
        enum AssemblyContentType
        { Default = 0, WindowsRuntime = 1 }
        class AssemblyCopyrightAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Copyright(): string;
            public constructor ($copyright: string)
            public constructor ()
        }
        class AssemblyCultureAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Culture(): string;
            public constructor ($culture: string)
            public constructor ()
        }
        class AssemblyDefaultAliasAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get DefaultAlias(): string;
            public constructor ($defaultAlias: string)
            public constructor ()
        }
        class AssemblyDelaySignAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get DelaySign(): boolean;
            public constructor ($delaySign: boolean)
            public constructor ()
        }
        class AssemblyDescriptionAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Description(): string;
            public constructor ($description: string)
            public constructor ()
        }
        class AssemblyFileVersionAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Version(): string;
            public constructor ($version: string)
            public constructor ()
        }
        class AssemblyFlagsAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get AssemblyFlags(): number;
            public constructor ($assemblyFlags: System.Reflection.AssemblyNameFlags)
            public constructor ()
        }
        enum AssemblyNameFlags
        { None = 0, PublicKey = 1, EnableJITcompileOptimizer = 16384, EnableJITcompileTracking = 32768, Retargetable = 256 }
        class AssemblyInformationalVersionAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get InformationalVersion(): string;
            public constructor ($informationalVersion: string)
            public constructor ()
        }
        class AssemblyKeyFileAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get KeyFile(): string;
            public constructor ($keyFile: string)
            public constructor ()
        }
        class AssemblyKeyNameAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get KeyName(): string;
            public constructor ($keyName: string)
            public constructor ()
        }
        class AssemblyMetadataAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Key(): string;
            public get Value(): string;
            public constructor ($key: string, $value: string)
            public constructor ()
        }
        class AssemblyProductAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Product(): string;
            public constructor ($product: string)
            public constructor ()
        }
        class AssemblySignatureKeyAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get PublicKey(): string;
            public get Countersignature(): string;
            public constructor ($publicKey: string, $countersignature: string)
            public constructor ()
        }
        class AssemblyTitleAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Title(): string;
            public constructor ($title: string)
            public constructor ()
        }
        class AssemblyTrademarkAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Trademark(): string;
            public constructor ($trademark: string)
            public constructor ()
        }
        class AssemblyVersionAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Version(): string;
            public constructor ($version: string)
            public constructor ()
        }
        class CustomAttributeFormatException extends System.FormatException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $inner: System.Exception)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class DefaultMemberAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get MemberName(): string;
            public constructor ($memberName: string)
            public constructor ()
        }
        enum ExceptionHandlingClauseOptions
        { Clause = 0, Filter = 1, Finally = 2, Fault = 4 }
        interface IReflectableType
        {
            GetTypeInfo () : System.Reflection.TypeInfo
        }
        class TypeInfo extends System.Type implements System.Runtime.InteropServices._MemberInfo, System.Runtime.InteropServices._Type, System.Reflection.ICustomAttributeProvider, System.Reflection.IReflect, System.Reflection.IReflectableType
        {
            protected [__keep_incompatibility]: never;
            public get GenericTypeParameters(): System.Array$1<System.Type>;
            public get DeclaredConstructors(): System.Collections.Generic.IEnumerable$1<System.Reflection.ConstructorInfo>;
            public get DeclaredEvents(): System.Collections.Generic.IEnumerable$1<System.Reflection.EventInfo>;
            public get DeclaredFields(): System.Collections.Generic.IEnumerable$1<System.Reflection.FieldInfo>;
            public get DeclaredMembers(): System.Collections.Generic.IEnumerable$1<System.Reflection.MemberInfo>;
            public get DeclaredMethods(): System.Collections.Generic.IEnumerable$1<System.Reflection.MethodInfo>;
            public get DeclaredNestedTypes(): System.Collections.Generic.IEnumerable$1<System.Reflection.TypeInfo>;
            public get DeclaredProperties(): System.Collections.Generic.IEnumerable$1<System.Reflection.PropertyInfo>;
            public get ImplementedInterfaces(): System.Collections.Generic.IEnumerable$1<System.Type>;
            public AsType () : System.Type
            public GetDeclaredEvent ($name: string) : System.Reflection.EventInfo
            public GetDeclaredField ($name: string) : System.Reflection.FieldInfo
            public GetDeclaredMethod ($name: string) : System.Reflection.MethodInfo
            public GetDeclaredNestedType ($name: string) : System.Reflection.TypeInfo
            public GetDeclaredProperty ($name: string) : System.Reflection.PropertyInfo
            public GetDeclaredMethods ($name: string) : System.Collections.Generic.IEnumerable$1<System.Reflection.MethodInfo>
            public IsAssignableFrom ($typeInfo: System.Reflection.TypeInfo) : boolean
            public IsAssignableFrom ($c: System.Type) : boolean
        }
        interface TypeInfo {
            GetRuntimeInterfaceMap ($interfaceType: System.Type) : System.Reflection.InterfaceMapping;
        }
        enum ImageFileMachine
        { I386 = 332, IA64 = 512, AMD64 = 34404, ARM = 452 }
        class IntrospectionExtensions extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static GetTypeInfo ($type: System.Type) : System.Reflection.TypeInfo
        }
        class InvalidFilterCriteriaException extends System.ApplicationException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $inner: System.Exception)
            public constructor ($message: string, $innerException: System.Exception)
        }
        enum ResourceLocation
        { ContainedInAnotherAssembly = 2, ContainedInManifestFile = 4, Embedded = 1 }
        class CustomAttributeData extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get Constructor(): System.Reflection.ConstructorInfo;
            public get ConstructorArguments(): System.Collections.Generic.IList$1<System.Reflection.CustomAttributeTypedArgument>;
            public get NamedArguments(): System.Collections.Generic.IList$1<System.Reflection.CustomAttributeNamedArgument>;
            public get AttributeType(): System.Type;
            public static GetCustomAttributes ($target: System.Reflection.Assembly) : System.Collections.Generic.IList$1<System.Reflection.CustomAttributeData>
            public static GetCustomAttributes ($target: System.Reflection.MemberInfo) : System.Collections.Generic.IList$1<System.Reflection.CustomAttributeData>
            public static GetCustomAttributes ($target: System.Reflection.Module) : System.Collections.Generic.IList$1<System.Reflection.CustomAttributeData>
            public static GetCustomAttributes ($target: System.Reflection.ParameterInfo) : System.Collections.Generic.IList$1<System.Reflection.CustomAttributeData>
        }
        class MethodBody extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get ExceptionHandlingClauses(): System.Collections.Generic.IList$1<System.Reflection.ExceptionHandlingClause>;
            public get LocalVariables(): System.Collections.Generic.IList$1<System.Reflection.LocalVariableInfo>;
            public get InitLocals(): boolean;
            public get LocalSignatureMetadataToken(): number;
            public get MaxStackSize(): number;
            public GetILAsByteArray () : System.Array$1<number>
        }
        class Missing extends System.Object implements System.Runtime.Serialization.ISerializable
        {
            protected [__keep_incompatibility]: never;
            public static Value : System.Reflection.Missing
        }
        enum PortableExecutableKinds
        { NotAPortableExecutableImage = 0, ILOnly = 1, Required32Bit = 2, PE32Plus = 4, Unmanaged32Bit = 8, Preferred32Bit = 16 }
        class ObfuscateAssemblyAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get AssemblyIsPrivate(): boolean;
            public get StripAfterObfuscation(): boolean;
            public set StripAfterObfuscation(value: boolean);
            public constructor ($assemblyIsPrivate: boolean)
            public constructor ()
        }
        class ObfuscationAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get StripAfterObfuscation(): boolean;
            public set StripAfterObfuscation(value: boolean);
            public get Exclude(): boolean;
            public set Exclude(value: boolean);
            public get ApplyToMembers(): boolean;
            public set ApplyToMembers(value: boolean);
            public get Feature(): string;
            public set Feature(value: string);
            public constructor ()
        }
        enum ParameterAttributes
        { None = 0, In = 1, Out = 2, Lcid = 4, Retval = 8, Optional = 16, HasDefault = 4096, HasFieldMarshal = 8192, Reserved3 = 16384, Reserved4 = 32768, ReservedMask = 61440 }
        class Pointer extends System.Object implements System.Runtime.Serialization.ISerializable
        {
            protected [__keep_incompatibility]: never;
        }
        enum ProcessorArchitecture
        { None = 0, MSIL = 1, X86 = 2, IA64 = 3, Amd64 = 4, Arm = 5 }
        class ReflectionContext extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public MapAssembly ($assembly: System.Reflection.Assembly) : System.Reflection.Assembly
            public MapType ($type: System.Reflection.TypeInfo) : System.Reflection.TypeInfo
            public GetTypeForObject ($value: any) : System.Reflection.TypeInfo
        }
        class ReflectionTypeLoadException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public get Types(): System.Array$1<System.Type>;
            public get LoaderExceptions(): System.Array$1<System.Exception>;
            public get Message(): string;
            public constructor ($classes: System.Array$1<System.Type>, $exceptions: System.Array$1<System.Exception>)
            public constructor ($classes: System.Array$1<System.Type>, $exceptions: System.Array$1<System.Exception>, $message: string)
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        enum ResourceAttributes
        { Public = 1, Private = 2 }
        class TargetException extends System.ApplicationException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $inner: System.Exception)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class TargetInvocationException extends System.ApplicationException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ($inner: System.Exception)
            public constructor ($message: string, $inner: System.Exception)
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class TargetParameterCountException extends System.ApplicationException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $inner: System.Exception)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class TypeDelegator extends System.Reflection.TypeInfo implements System.Runtime.InteropServices._MemberInfo, System.Runtime.InteropServices._Type, System.Reflection.ICustomAttributeProvider, System.Reflection.IReflect, System.Reflection.IReflectableType
        {
            protected [__keep_incompatibility]: never;
            public get GUID(): System.Guid;
            public get MetadataToken(): number;
            public get Module(): System.Reflection.Module;
            public get Assembly(): System.Reflection.Assembly;
            public get TypeHandle(): System.RuntimeTypeHandle;
            public get Name(): string;
            public get FullName(): string;
            public get Namespace(): string;
            public get AssemblyQualifiedName(): string;
            public get BaseType(): System.Type;
            public get IsTypeDefinition(): boolean;
            public get IsSZArray(): boolean;
            public get IsGenericTypeParameter(): boolean;
            public get IsGenericMethodParameter(): boolean;
            public get IsByRefLike(): boolean;
            public get IsConstructedGenericType(): boolean;
            public get IsCollectible(): boolean;
            public get UnderlyingSystemType(): System.Type;
            public constructor ($delegatingType: System.Type)
            public constructor ()
        }
        class TypeExtensions extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static GetConstructor ($type: System.Type, $types: System.Array$1<System.Type>) : System.Reflection.ConstructorInfo
            public static GetConstructors ($type: System.Type) : System.Array$1<System.Reflection.ConstructorInfo>
            public static GetConstructors ($type: System.Type, $bindingAttr: System.Reflection.BindingFlags) : System.Array$1<System.Reflection.ConstructorInfo>
            public static GetDefaultMembers ($type: System.Type) : System.Array$1<System.Reflection.MemberInfo>
            public static GetEvent ($type: System.Type, $name: string) : System.Reflection.EventInfo
            public static GetEvent ($type: System.Type, $name: string, $bindingAttr: System.Reflection.BindingFlags) : System.Reflection.EventInfo
            public static GetEvents ($type: System.Type) : System.Array$1<System.Reflection.EventInfo>
            public static GetEvents ($type: System.Type, $bindingAttr: System.Reflection.BindingFlags) : System.Array$1<System.Reflection.EventInfo>
            public static GetField ($type: System.Type, $name: string) : System.Reflection.FieldInfo
            public static GetField ($type: System.Type, $name: string, $bindingAttr: System.Reflection.BindingFlags) : System.Reflection.FieldInfo
            public static GetFields ($type: System.Type) : System.Array$1<System.Reflection.FieldInfo>
            public static GetFields ($type: System.Type, $bindingAttr: System.Reflection.BindingFlags) : System.Array$1<System.Reflection.FieldInfo>
            public static GetGenericArguments ($type: System.Type) : System.Array$1<System.Type>
            public static GetInterfaces ($type: System.Type) : System.Array$1<System.Type>
            public static GetMember ($type: System.Type, $name: string) : System.Array$1<System.Reflection.MemberInfo>
            public static GetMember ($type: System.Type, $name: string, $bindingAttr: System.Reflection.BindingFlags) : System.Array$1<System.Reflection.MemberInfo>
            public static GetMembers ($type: System.Type) : System.Array$1<System.Reflection.MemberInfo>
            public static GetMembers ($type: System.Type, $bindingAttr: System.Reflection.BindingFlags) : System.Array$1<System.Reflection.MemberInfo>
            public static GetMethod ($type: System.Type, $name: string) : System.Reflection.MethodInfo
            public static GetMethod ($type: System.Type, $name: string, $bindingAttr: System.Reflection.BindingFlags) : System.Reflection.MethodInfo
            public static GetMethod ($type: System.Type, $name: string, $types: System.Array$1<System.Type>) : System.Reflection.MethodInfo
            public static GetMethods ($type: System.Type) : System.Array$1<System.Reflection.MethodInfo>
            public static GetMethods ($type: System.Type, $bindingAttr: System.Reflection.BindingFlags) : System.Array$1<System.Reflection.MethodInfo>
            public static GetNestedType ($type: System.Type, $name: string, $bindingAttr: System.Reflection.BindingFlags) : System.Type
            public static GetNestedTypes ($type: System.Type, $bindingAttr: System.Reflection.BindingFlags) : System.Array$1<System.Type>
            public static GetProperties ($type: System.Type) : System.Array$1<System.Reflection.PropertyInfo>
            public static GetProperties ($type: System.Type, $bindingAttr: System.Reflection.BindingFlags) : System.Array$1<System.Reflection.PropertyInfo>
            public static GetProperty ($type: System.Type, $name: string) : System.Reflection.PropertyInfo
            public static GetProperty ($type: System.Type, $name: string, $bindingAttr: System.Reflection.BindingFlags) : System.Reflection.PropertyInfo
            public static GetProperty ($type: System.Type, $name: string, $returnType: System.Type) : System.Reflection.PropertyInfo
            public static GetProperty ($type: System.Type, $name: string, $returnType: System.Type, $types: System.Array$1<System.Type>) : System.Reflection.PropertyInfo
            public static IsAssignableFrom ($type: System.Type, $c: System.Type) : boolean
            public static IsInstanceOfType ($type: System.Type, $o: any) : boolean
        }
        class AssemblyExtensions extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static GetExportedTypes ($assembly: System.Reflection.Assembly) : System.Array$1<System.Type>
            public static GetModules ($assembly: System.Reflection.Assembly) : System.Array$1<System.Reflection.Module>
            public static GetTypes ($assembly: System.Reflection.Assembly) : System.Array$1<System.Type>
        }
        class EventInfoExtensions extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static GetAddMethod ($eventInfo: System.Reflection.EventInfo) : System.Reflection.MethodInfo
            public static GetAddMethod ($eventInfo: System.Reflection.EventInfo, $nonPublic: boolean) : System.Reflection.MethodInfo
            public static GetRaiseMethod ($eventInfo: System.Reflection.EventInfo) : System.Reflection.MethodInfo
            public static GetRaiseMethod ($eventInfo: System.Reflection.EventInfo, $nonPublic: boolean) : System.Reflection.MethodInfo
            public static GetRemoveMethod ($eventInfo: System.Reflection.EventInfo) : System.Reflection.MethodInfo
            public static GetRemoveMethod ($eventInfo: System.Reflection.EventInfo, $nonPublic: boolean) : System.Reflection.MethodInfo
        }
        class MemberInfoExtensions extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static HasMetadataToken ($member: System.Reflection.MemberInfo) : boolean
            public static GetMetadataToken ($member: System.Reflection.MemberInfo) : number
        }
        class MethodInfoExtensions extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static GetBaseDefinition ($method: System.Reflection.MethodInfo) : System.Reflection.MethodInfo
        }
        class ModuleExtensions extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static HasModuleVersionId ($module: System.Reflection.Module) : boolean
            public static GetModuleVersionId ($module: System.Reflection.Module) : System.Guid
        }
        class PropertyInfoExtensions extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static GetAccessors ($property: System.Reflection.PropertyInfo) : System.Array$1<System.Reflection.MethodInfo>
            public static GetAccessors ($property: System.Reflection.PropertyInfo, $nonPublic: boolean) : System.Array$1<System.Reflection.MethodInfo>
            public static GetGetMethod ($property: System.Reflection.PropertyInfo) : System.Reflection.MethodInfo
            public static GetGetMethod ($property: System.Reflection.PropertyInfo, $nonPublic: boolean) : System.Reflection.MethodInfo
            public static GetSetMethod ($property: System.Reflection.PropertyInfo) : System.Reflection.MethodInfo
            public static GetSetMethod ($property: System.Reflection.PropertyInfo, $nonPublic: boolean) : System.Reflection.MethodInfo
        }
        class AssemblyNameProxy extends System.MarshalByRefObject
        {
            protected [__keep_incompatibility]: never;
            public GetAssemblyName ($assemblyFile: string) : System.Reflection.AssemblyName
            public constructor ()
        }
        class RuntimeReflectionExtensions extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static GetRuntimeFields ($type: System.Type) : System.Collections.Generic.IEnumerable$1<System.Reflection.FieldInfo>
            public static GetRuntimeMethods ($type: System.Type) : System.Collections.Generic.IEnumerable$1<System.Reflection.MethodInfo>
            public static GetRuntimeProperties ($type: System.Type) : System.Collections.Generic.IEnumerable$1<System.Reflection.PropertyInfo>
            public static GetRuntimeEvents ($type: System.Type) : System.Collections.Generic.IEnumerable$1<System.Reflection.EventInfo>
            public static GetRuntimeField ($type: System.Type, $name: string) : System.Reflection.FieldInfo
            public static GetRuntimeMethod ($type: System.Type, $name: string, $parameters: System.Array$1<System.Type>) : System.Reflection.MethodInfo
            public static GetRuntimeProperty ($type: System.Type, $name: string) : System.Reflection.PropertyInfo
            public static GetRuntimeEvent ($type: System.Type, $name: string) : System.Reflection.EventInfo
            public static GetRuntimeBaseDefinition ($method: System.Reflection.MethodInfo) : System.Reflection.MethodInfo
            public static GetRuntimeInterfaceMap ($typeInfo: System.Reflection.TypeInfo, $interfaceType: System.Type) : System.Reflection.InterfaceMapping
            public static GetMethodInfo ($del: Function) : System.Reflection.MethodInfo
        }
        class CustomAttributeNamedArgument extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get TypedValue(): System.Reflection.CustomAttributeTypedArgument;
            public get IsField(): boolean;
            public get MemberName(): string;
            public get MemberInfo(): System.Reflection.MemberInfo;
            public static op_Equality ($left: System.Reflection.CustomAttributeNamedArgument, $right: System.Reflection.CustomAttributeNamedArgument) : boolean
            public static op_Inequality ($left: System.Reflection.CustomAttributeNamedArgument, $right: System.Reflection.CustomAttributeNamedArgument) : boolean
            public constructor ($memberInfo: System.Reflection.MemberInfo, $value: any)
            public constructor ($memberInfo: System.Reflection.MemberInfo, $typedArgument: System.Reflection.CustomAttributeTypedArgument)
            public constructor ()
        }
        class CustomAttributeTypedArgument extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get ArgumentType(): System.Type;
            public get Value(): any;
            public static op_Equality ($left: System.Reflection.CustomAttributeTypedArgument, $right: System.Reflection.CustomAttributeTypedArgument) : boolean
            public static op_Inequality ($left: System.Reflection.CustomAttributeTypedArgument, $right: System.Reflection.CustomAttributeTypedArgument) : boolean
            public constructor ($value: any)
            public constructor ($argumentType: System.Type, $value: any)
            public constructor ()
        }
        class MissingMetadataException extends System.TypeAccessException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
        }
        class CustomAttributeExtensions extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static GetCustomAttribute ($element: System.Reflection.Assembly, $attributeType: System.Type) : System.Attribute
            public static GetCustomAttribute ($element: System.Reflection.Module, $attributeType: System.Type) : System.Attribute
            public static GetCustomAttribute ($element: System.Reflection.MemberInfo, $attributeType: System.Type) : System.Attribute
            public static GetCustomAttribute ($element: System.Reflection.ParameterInfo, $attributeType: System.Type) : System.Attribute
            public static GetCustomAttribute ($element: System.Reflection.MemberInfo, $attributeType: System.Type, $inherit: boolean) : System.Attribute
            public static GetCustomAttribute ($element: System.Reflection.ParameterInfo, $attributeType: System.Type, $inherit: boolean) : System.Attribute
            public static GetCustomAttributes ($element: System.Reflection.Assembly) : System.Collections.Generic.IEnumerable$1<System.Attribute>
            public static GetCustomAttributes ($element: System.Reflection.Module) : System.Collections.Generic.IEnumerable$1<System.Attribute>
            public static GetCustomAttributes ($element: System.Reflection.MemberInfo) : System.Collections.Generic.IEnumerable$1<System.Attribute>
            public static GetCustomAttributes ($element: System.Reflection.ParameterInfo) : System.Collections.Generic.IEnumerable$1<System.Attribute>
            public static GetCustomAttributes ($element: System.Reflection.MemberInfo, $inherit: boolean) : System.Collections.Generic.IEnumerable$1<System.Attribute>
            public static GetCustomAttributes ($element: System.Reflection.ParameterInfo, $inherit: boolean) : System.Collections.Generic.IEnumerable$1<System.Attribute>
            public static GetCustomAttributes ($element: System.Reflection.Assembly, $attributeType: System.Type) : System.Collections.Generic.IEnumerable$1<System.Attribute>
            public static GetCustomAttributes ($element: System.Reflection.Module, $attributeType: System.Type) : System.Collections.Generic.IEnumerable$1<System.Attribute>
            public static GetCustomAttributes ($element: System.Reflection.MemberInfo, $attributeType: System.Type) : System.Collections.Generic.IEnumerable$1<System.Attribute>
            public static GetCustomAttributes ($element: System.Reflection.ParameterInfo, $attributeType: System.Type) : System.Collections.Generic.IEnumerable$1<System.Attribute>
            public static GetCustomAttributes ($element: System.Reflection.MemberInfo, $attributeType: System.Type, $inherit: boolean) : System.Collections.Generic.IEnumerable$1<System.Attribute>
            public static GetCustomAttributes ($element: System.Reflection.ParameterInfo, $attributeType: System.Type, $inherit: boolean) : System.Collections.Generic.IEnumerable$1<System.Attribute>
            public static IsDefined ($element: System.Reflection.Assembly, $attributeType: System.Type) : boolean
            public static IsDefined ($element: System.Reflection.Module, $attributeType: System.Type) : boolean
            public static IsDefined ($element: System.Reflection.MemberInfo, $attributeType: System.Type) : boolean
            public static IsDefined ($element: System.Reflection.ParameterInfo, $attributeType: System.Type) : boolean
            public static IsDefined ($element: System.Reflection.MemberInfo, $attributeType: System.Type, $inherit: boolean) : boolean
            public static IsDefined ($element: System.Reflection.ParameterInfo, $attributeType: System.Type, $inherit: boolean) : boolean
        }
        class ExceptionHandlingClause extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get CatchType(): System.Type;
            public get FilterOffset(): number;
            public get Flags(): System.Reflection.ExceptionHandlingClauseOptions;
            public get HandlerLength(): number;
            public get HandlerOffset(): number;
            public get TryLength(): number;
            public get TryOffset(): number;
        }
        class LocalVariableInfo extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get IsPinned(): boolean;
            public get LocalIndex(): number;
            public get LocalType(): System.Type;
        }
    }
    namespace System.Security {
        interface IEvidenceFactory
        {
            Evidence : System.Security.Policy.Evidence
        }
        class PermissionSet extends System.Object implements System.Runtime.Serialization.IDeserializationCallback, System.Security.IStackWalk, System.Collections.ICollection, System.Collections.IEnumerable, System.Security.ISecurityEncodable
        {
            protected [__keep_incompatibility]: never;
            public get Count(): number;
            public get IsSynchronized(): boolean;
            public get IsReadOnly(): boolean;
            public get SyncRoot(): any;
            public AddPermission ($perm: System.Security.IPermission) : System.Security.IPermission
            public Assert () : void
            public Copy () : System.Security.PermissionSet
            public CopyTo ($array: System.Array, $index: number) : void
            public Demand () : void
            public FromXml ($et: System.Security.SecurityElement) : void
            public GetEnumerator () : System.Collections.IEnumerator
            public IsSubsetOf ($target: System.Security.PermissionSet) : boolean
            public PermitOnly () : void
            public ContainsNonCodeAccessPermissions () : boolean
            public static ConvertPermissionSet ($inFormat: string, $inData: System.Array$1<number>, $outFormat: string) : System.Array$1<number>
            public GetPermission ($permClass: System.Type) : System.Security.IPermission
            public Intersect ($other: System.Security.PermissionSet) : System.Security.PermissionSet
            public IsEmpty () : boolean
            public IsUnrestricted () : boolean
            public RemovePermission ($permClass: System.Type) : System.Security.IPermission
            public SetPermission ($perm: System.Security.IPermission) : System.Security.IPermission
            public ToXml () : System.Security.SecurityElement
            public Union ($other: System.Security.PermissionSet) : System.Security.PermissionSet
            public static RevertAssert () : void
            public constructor ($state: System.Security.Permissions.PermissionState)
            public constructor ($permSet: System.Security.PermissionSet)
            public OnDeserialization ($sender: any) : void
            public Deny () : void
            public FromXml ($e: System.Security.SecurityElement) : void
            public constructor ()
        }
        interface IStackWalk
        {
            Assert () : void
            Demand () : void
            Deny () : void
            PermitOnly () : void
        }
        interface ISecurityEncodable
        {
            FromXml ($e: System.Security.SecurityElement) : void
            ToXml () : System.Security.SecurityElement
        }
        enum SecurityContextSource
        { CurrentAppDomain = 0, CurrentAssembly = 1 }
        interface IPermission extends System.Security.ISecurityEncodable
        {
            Copy () : System.Security.IPermission
            Demand () : void
            Intersect ($target: System.Security.IPermission) : System.Security.IPermission
            IsSubsetOf ($target: System.Security.IPermission) : boolean
            Union ($target: System.Security.IPermission) : System.Security.IPermission
            FromXml ($e: System.Security.SecurityElement) : void
            ToXml () : System.Security.SecurityElement
        }
        class HostSecurityManager extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get DomainPolicy(): System.Security.Policy.PolicyLevel;
            public get Flags(): System.Security.HostSecurityManagerOptions;
            public DetermineApplicationTrust ($applicationEvidence: System.Security.Policy.Evidence, $activatorEvidence: System.Security.Policy.Evidence, $context: System.Security.Policy.TrustManagerContext) : System.Security.Policy.ApplicationTrust
            public ProvideAppDomainEvidence ($inputEvidence: System.Security.Policy.Evidence) : System.Security.Policy.Evidence
            public ProvideAssemblyEvidence ($loadedAssembly: System.Reflection.Assembly, $inputEvidence: System.Security.Policy.Evidence) : System.Security.Policy.Evidence
            public ResolvePolicy ($evidence: System.Security.Policy.Evidence) : System.Security.PermissionSet
            public GenerateAppDomainEvidence ($evidenceType: System.Type) : System.Security.Policy.EvidenceBase
            public GenerateAssemblyEvidence ($evidenceType: System.Type, $assembly: System.Reflection.Assembly) : System.Security.Policy.EvidenceBase
            public GetHostSuppliedAppDomainEvidenceTypes () : System.Array$1<System.Type>
            public GetHostSuppliedAssemblyEvidenceTypes ($assembly: System.Reflection.Assembly) : System.Array$1<System.Type>
            public constructor ()
        }
        class SecurityState extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public EnsureState () : void
            public IsStateAvailable () : boolean
        }
        class VerificationException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class SecurityElement extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get Attributes(): System.Collections.Hashtable;
            public set Attributes(value: System.Collections.Hashtable);
            public get Children(): System.Collections.ArrayList;
            public set Children(value: System.Collections.ArrayList);
            public get Tag(): string;
            public set Tag(value: string);
            public get Text(): string;
            public set Text(value: string);
            public AddAttribute ($name: string, $value: string) : void
            public AddChild ($child: System.Security.SecurityElement) : void
            public Attribute ($name: string) : string
            public Copy () : System.Security.SecurityElement
            public Equal ($other: System.Security.SecurityElement) : boolean
            public static Escape ($str: string) : string
            public static FromString ($xml: string) : System.Security.SecurityElement
            public static IsValidAttributeName ($name: string) : boolean
            public static IsValidAttributeValue ($value: string) : boolean
            public static IsValidTag ($tag: string) : boolean
            public static IsValidText ($text: string) : boolean
            public SearchForChildByTag ($tag: string) : System.Security.SecurityElement
            public SearchForTextOfTag ($tag: string) : string
            public constructor ($tag: string)
            public constructor ($tag: string, $text: string)
            public constructor ()
        }
        interface ISecurityPolicyEncodable
        {
            FromXml ($e: System.Security.SecurityElement, $level: System.Security.Policy.PolicyLevel) : void
            ToXml ($level: System.Security.Policy.PolicyLevel) : System.Security.SecurityElement
        }
        enum PolicyLevelType
        { AppDomain = 3, Enterprise = 2, Machine = 1, User = 0 }
        enum SecurityZone
        { Internet = 3, Intranet = 1, MyComputer = 0, NoZone = -1, Trusted = 2, Untrusted = 4 }
        class XmlSyntaxException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($lineNumber: number)
            public constructor ($lineNumber: number, $message: string)
            public constructor ($message: string)
            public constructor ($message: string, $inner: System.Exception)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class SuppressUnmanagedCodeSecurityAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class UnverifiableCodeAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class AllowPartiallyTrustedCallersAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get PartialTrustVisibilityLevel(): System.Security.PartialTrustVisibilityLevel;
            public set PartialTrustVisibilityLevel(value: System.Security.PartialTrustVisibilityLevel);
            public constructor ()
        }
        enum PartialTrustVisibilityLevel
        { VisibleToAllHosts = 0, NotVisibleByDefault = 1 }
        enum SecurityCriticalScope
        { Explicit = 0, Everything = 1 }
        class SecurityCriticalAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($scope: System.Security.SecurityCriticalScope)
        }
        class SecurityTreatAsSafeAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class SecuritySafeCriticalAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class SecurityTransparentAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        enum SecurityRuleSet
        { None = 0, Level1 = 1, Level2 = 2 }
        class SecurityRulesAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get SkipVerificationInFullTrust(): boolean;
            public set SkipVerificationInFullTrust(value: boolean);
            public get RuleSet(): System.Security.SecurityRuleSet;
            public constructor ($ruleSet: System.Security.SecurityRuleSet)
            public constructor ()
        }
        class SecurityContext extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public CreateCopy () : System.Security.SecurityContext
            public static Capture () : System.Security.SecurityContext
            public Dispose () : void
            public static IsFlowSuppressed () : boolean
            public static IsWindowsIdentityFlowSuppressed () : boolean
            public static RestoreFlow () : void
            public static Run ($securityContext: System.Security.SecurityContext, $callback: System.Threading.ContextCallback, $state: any) : void
            public static SuppressFlow () : System.Threading.AsyncFlowControl
            public static SuppressFlowWindowsIdentity () : System.Threading.AsyncFlowControl
        }
        class CodeAccessPermission extends System.Object implements System.Security.IStackWalk, System.Security.IPermission, System.Security.ISecurityEncodable
        {
            protected [__keep_incompatibility]: never;
            public Assert () : void
            public Copy () : System.Security.IPermission
            public Demand () : void
            public FromXml ($elem: System.Security.SecurityElement) : void
            public Intersect ($target: System.Security.IPermission) : System.Security.IPermission
            public IsSubsetOf ($target: System.Security.IPermission) : boolean
            public ToXml () : System.Security.SecurityElement
            public Union ($other: System.Security.IPermission) : System.Security.IPermission
            public PermitOnly () : void
            public static RevertAll () : void
            public static RevertAssert () : void
            public static RevertDeny () : void
            public static RevertPermitOnly () : void
            public Deny () : void
            public Union ($target: System.Security.IPermission) : System.Security.IPermission
            public FromXml ($e: System.Security.SecurityElement) : void
        }
        class HostProtectionException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public get DemandedResources(): System.Security.Permissions.HostProtectionResource;
            public get ProtectedResources(): System.Security.Permissions.HostProtectionResource;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $e: System.Exception)
            public constructor ($message: string, $protectedResources: System.Security.Permissions.HostProtectionResource, $demandedResources: System.Security.Permissions.HostProtectionResource)
            public constructor ($message: string, $innerException: System.Exception)
        }
        enum HostSecurityManagerOptions
        { None = 0, HostAppDomainEvidence = 1, HostPolicyLevel = 2, HostAssemblyEvidence = 4, HostDetermineApplicationTrust = 8, HostResolvePolicy = 16, AllFlags = 31 }
        class NamedPermissionSet extends System.Security.PermissionSet implements System.Runtime.Serialization.IDeserializationCallback, System.Security.IStackWalk, System.Collections.ICollection, System.Collections.IEnumerable, System.Security.ISecurityEncodable
        {
            protected [__keep_incompatibility]: never;
            public get Description(): string;
            public set Description(value: string);
            public get Name(): string;
            public set Name(value: string);
            public Copy () : System.Security.PermissionSet
            public Copy ($name: string) : System.Security.NamedPermissionSet
            public constructor ($name: string, $permSet: System.Security.PermissionSet)
            public constructor ($name: string, $state: System.Security.Permissions.PermissionState)
            public constructor ($permSet: System.Security.NamedPermissionSet)
            public constructor ($name: string)
            public constructor ($state: System.Security.Permissions.PermissionState)
            public constructor ($permSet: System.Security.PermissionSet)
            public constructor ()
        }
        class SecureString extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get Length(): number;
            public AppendChar ($c: number) : void
            public Clear () : void
            public Copy () : System.Security.SecureString
            public Dispose () : void
            public InsertAt ($index: number, $c: number) : void
            public IsReadOnly () : boolean
            public MakeReadOnly () : void
            public RemoveAt ($index: number) : void
            public SetAt ($index: number, $c: number) : void
            public constructor ()
        }
        class SecurityException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public get Action(): System.Security.Permissions.SecurityAction;
            public set Action(value: System.Security.Permissions.SecurityAction);
            public get DenySetInstance(): any;
            public set DenySetInstance(value: any);
            public get FailedAssemblyInfo(): System.Reflection.AssemblyName;
            public set FailedAssemblyInfo(value: System.Reflection.AssemblyName);
            public get Method(): System.Reflection.MethodInfo;
            public set Method(value: System.Reflection.MethodInfo);
            public get PermitOnlySetInstance(): any;
            public set PermitOnlySetInstance(value: any);
            public get Url(): string;
            public set Url(value: string);
            public get Zone(): System.Security.SecurityZone;
            public set Zone(value: System.Security.SecurityZone);
            public get Demanded(): any;
            public set Demanded(value: any);
            public get FirstPermissionThatFailed(): System.Security.IPermission;
            public set FirstPermissionThatFailed(value: System.Security.IPermission);
            public get PermissionState(): string;
            public set PermissionState(value: string);
            public get PermissionType(): System.Type;
            public set PermissionType(value: System.Type);
            public get GrantedSet(): string;
            public set GrantedSet(value: string);
            public get RefusedSet(): string;
            public set RefusedSet(value: string);
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $inner: System.Exception)
            public constructor ($message: string, $type: System.Type)
            public constructor ($message: string, $type: System.Type, $state: string)
            public constructor ($message: string, $deny: any, $permitOnly: any, $method: System.Reflection.MethodInfo, $demanded: any, $permThatFailed: System.Security.IPermission)
            public constructor ($message: string, $assemblyName: System.Reflection.AssemblyName, $grant: System.Security.PermissionSet, $refused: System.Security.PermissionSet, $method: System.Reflection.MethodInfo, $action: System.Security.Permissions.SecurityAction, $demanded: any, $permThatFailed: System.Security.IPermission, $evidence: System.Security.Policy.Evidence)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class SecurityManager extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static GetZoneAndOrigin ($zone: $Ref<System.Collections.ArrayList>, $origin: $Ref<System.Collections.ArrayList>) : void
            public static GetStandardSandbox ($evidence: System.Security.Policy.Evidence) : System.Security.PermissionSet
            public static CurrentThreadRequiresSecurityContextCapture () : boolean
        }
        class ReadOnlyPermissionSet extends System.Security.PermissionSet implements System.Runtime.Serialization.IDeserializationCallback, System.Security.IStackWalk, System.Collections.ICollection, System.Collections.IEnumerable, System.Security.ISecurityEncodable
        {
            protected [__keep_incompatibility]: never;
            public constructor ($permissionSetXml: System.Security.SecurityElement)
            public constructor ($state: System.Security.Permissions.PermissionState)
            public constructor ($permSet: System.Security.PermissionSet)
            public constructor ()
        }
    }
    namespace System.Threading.Tasks {
        class ValueTask extends System.ValueType implements System.IEquatable$1<System.Threading.Tasks.ValueTask>
        {
            protected [__keep_incompatibility]: never;
            public get IsCompleted(): boolean;
            public get IsCompletedSuccessfully(): boolean;
            public get IsFaulted(): boolean;
            public get IsCanceled(): boolean;
            public Equals ($obj: any) : boolean
            public Equals ($other: System.Threading.Tasks.ValueTask) : boolean
            public static op_Equality ($left: System.Threading.Tasks.ValueTask, $right: System.Threading.Tasks.ValueTask) : boolean
            public static op_Inequality ($left: System.Threading.Tasks.ValueTask, $right: System.Threading.Tasks.ValueTask) : boolean
            public AsTask () : $Task<any>
            public Preserve () : System.Threading.Tasks.ValueTask
            public GetAwaiter () : System.Runtime.CompilerServices.ValueTaskAwaiter
            public ConfigureAwait ($continueOnCapturedContext: boolean) : System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable
            public constructor ($task: $Task<any>)
            public constructor ($source: System.Threading.Tasks.Sources.IValueTaskSource, $token: number)
            public static Equals ($objA: any, $objB: any) : boolean
            public constructor ()
        }
        class Task extends System.Object implements System.IAsyncResult, System.Threading.IThreadPoolWorkItem, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get Id(): number;
            public static get CurrentId(): number | null;
            public get Exception(): System.AggregateException;
            public get Status(): System.Threading.Tasks.TaskStatus;
            public get IsCanceled(): boolean;
            public get IsCompleted(): boolean;
            public get IsCompletedSuccessfully(): boolean;
            public get CreationOptions(): System.Threading.Tasks.TaskCreationOptions;
            public get AsyncState(): any;
            public static get Factory(): System.Threading.Tasks.TaskFactory;
            public static get CompletedTask(): $Task<any>;
            public get IsFaulted(): boolean;
            public get AsyncWaitHandle(): System.Threading.WaitHandle;
            public get CompletedSynchronously(): boolean;
            public Start () : void
            public Start ($scheduler: System.Threading.Tasks.TaskScheduler) : void
            public RunSynchronously () : void
            public RunSynchronously ($scheduler: System.Threading.Tasks.TaskScheduler) : void
            public Dispose () : void
            public GetAwaiter () : System.Runtime.CompilerServices.TaskAwaiter
            public ConfigureAwait ($continueOnCapturedContext: boolean) : System.Runtime.CompilerServices.ConfiguredTaskAwaitable
            public static Yield () : System.Runtime.CompilerServices.YieldAwaitable
            public Wait () : void
            public Wait ($timeout: System.TimeSpan) : boolean
            public Wait ($cancellationToken: System.Threading.CancellationToken) : void
            public Wait ($millisecondsTimeout: number) : boolean
            public Wait ($millisecondsTimeout: number, $cancellationToken: System.Threading.CancellationToken) : boolean
            public ContinueWith ($continuationAction: System.Action$1<$Task<any>>) : $Task<any>
            public ContinueWith ($continuationAction: System.Action$1<$Task<any>>, $cancellationToken: System.Threading.CancellationToken) : $Task<any>
            public ContinueWith ($continuationAction: System.Action$1<$Task<any>>, $scheduler: System.Threading.Tasks.TaskScheduler) : $Task<any>
            public ContinueWith ($continuationAction: System.Action$1<$Task<any>>, $continuationOptions: System.Threading.Tasks.TaskContinuationOptions) : $Task<any>
            public ContinueWith ($continuationAction: System.Action$1<$Task<any>>, $cancellationToken: System.Threading.CancellationToken, $continuationOptions: System.Threading.Tasks.TaskContinuationOptions, $scheduler: System.Threading.Tasks.TaskScheduler) : $Task<any>
            public ContinueWith ($continuationAction: System.Action$2<$Task<any>, any>, $state: any) : $Task<any>
            public ContinueWith ($continuationAction: System.Action$2<$Task<any>, any>, $state: any, $cancellationToken: System.Threading.CancellationToken) : $Task<any>
            public ContinueWith ($continuationAction: System.Action$2<$Task<any>, any>, $state: any, $scheduler: System.Threading.Tasks.TaskScheduler) : $Task<any>
            public ContinueWith ($continuationAction: System.Action$2<$Task<any>, any>, $state: any, $continuationOptions: System.Threading.Tasks.TaskContinuationOptions) : $Task<any>
            public ContinueWith ($continuationAction: System.Action$2<$Task<any>, any>, $state: any, $cancellationToken: System.Threading.CancellationToken, $continuationOptions: System.Threading.Tasks.TaskContinuationOptions, $scheduler: System.Threading.Tasks.TaskScheduler) : $Task<any>
            public static WaitAll (...tasks: $Task<any>[]) : void
            public static WaitAll ($tasks: System.Array$1<$Task<any>>, $timeout: System.TimeSpan) : boolean
            public static WaitAll ($tasks: System.Array$1<$Task<any>>, $millisecondsTimeout: number) : boolean
            public static WaitAll ($tasks: System.Array$1<$Task<any>>, $cancellationToken: System.Threading.CancellationToken) : void
            public static WaitAll ($tasks: System.Array$1<$Task<any>>, $millisecondsTimeout: number, $cancellationToken: System.Threading.CancellationToken) : boolean
            public static WaitAny (...tasks: $Task<any>[]) : number
            public static WaitAny ($tasks: System.Array$1<$Task<any>>, $timeout: System.TimeSpan) : number
            public static WaitAny ($tasks: System.Array$1<$Task<any>>, $cancellationToken: System.Threading.CancellationToken) : number
            public static WaitAny ($tasks: System.Array$1<$Task<any>>, $millisecondsTimeout: number) : number
            public static WaitAny ($tasks: System.Array$1<$Task<any>>, $millisecondsTimeout: number, $cancellationToken: System.Threading.CancellationToken) : number
            public static FromException ($exception: System.Exception) : $Task<any>
            public static FromCanceled ($cancellationToken: System.Threading.CancellationToken) : $Task<any>
            public static Run ($action: System.Action) : $Task<any>
            public static Run ($action: System.Action, $cancellationToken: System.Threading.CancellationToken) : $Task<any>
            public static Run ($function: System.Func$1<$Task<any>>) : $Task<any>
            public static Run ($function: System.Func$1<$Task<any>>, $cancellationToken: System.Threading.CancellationToken) : $Task<any>
            public static Delay ($delay: System.TimeSpan) : $Task<any>
            public static Delay ($delay: System.TimeSpan, $cancellationToken: System.Threading.CancellationToken) : $Task<any>
            public static Delay ($millisecondsDelay: number) : $Task<any>
            public static Delay ($millisecondsDelay: number, $cancellationToken: System.Threading.CancellationToken) : $Task<any>
            public static WhenAll ($tasks: System.Collections.Generic.IEnumerable$1<$Task<any>>) : $Task<any>
            public static WhenAll (...tasks: $Task<any>[]) : $Task<any>
            public static WhenAny (...tasks: $Task<any>[]) : System.Threading.Tasks.Task$1<$Task<any>>
            public static WhenAny ($tasks: System.Collections.Generic.IEnumerable$1<$Task<any>>) : System.Threading.Tasks.Task$1<$Task<any>>
            public MarkAborted ($e: System.Threading.ThreadAbortException) : void
            public constructor ($action: System.Action)
            public constructor ($action: System.Action, $cancellationToken: System.Threading.CancellationToken)
            public constructor ($action: System.Action, $creationOptions: System.Threading.Tasks.TaskCreationOptions)
            public constructor ($action: System.Action, $cancellationToken: System.Threading.CancellationToken, $creationOptions: System.Threading.Tasks.TaskCreationOptions)
            public constructor ($action: System.Action$1<any>, $state: any)
            public constructor ($action: System.Action$1<any>, $state: any, $cancellationToken: System.Threading.CancellationToken)
            public constructor ($action: System.Action$1<any>, $state: any, $creationOptions: System.Threading.Tasks.TaskCreationOptions)
            public constructor ($action: System.Action$1<any>, $state: any, $cancellationToken: System.Threading.CancellationToken, $creationOptions: System.Threading.Tasks.TaskCreationOptions)
            public constructor ()
        }
        class Task$1<TResult> extends System.Threading.Tasks.Task implements System.IAsyncResult, System.Threading.IThreadPoolWorkItem, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get Result(): TResult;
            public static get Factory(): any;
            public GetAwaiter () : System.Runtime.CompilerServices.TaskAwaiter$1<TResult>
            public ConfigureAwait ($continueOnCapturedContext: boolean) : System.Runtime.CompilerServices.ConfiguredTaskAwaitable$1<TResult>
            public ContinueWith ($continuationAction: System.Action$1<System.Threading.Tasks.Task$1<TResult>>) : $Task<any>
            public ContinueWith ($continuationAction: System.Action$1<System.Threading.Tasks.Task$1<TResult>>, $cancellationToken: System.Threading.CancellationToken) : $Task<any>
            public ContinueWith ($continuationAction: System.Action$1<System.Threading.Tasks.Task$1<TResult>>, $scheduler: System.Threading.Tasks.TaskScheduler) : $Task<any>
            public ContinueWith ($continuationAction: System.Action$1<System.Threading.Tasks.Task$1<TResult>>, $continuationOptions: System.Threading.Tasks.TaskContinuationOptions) : $Task<any>
            public ContinueWith ($continuationAction: System.Action$1<System.Threading.Tasks.Task$1<TResult>>, $cancellationToken: System.Threading.CancellationToken, $continuationOptions: System.Threading.Tasks.TaskContinuationOptions, $scheduler: System.Threading.Tasks.TaskScheduler) : $Task<any>
            public ContinueWith ($continuationAction: System.Action$2<System.Threading.Tasks.Task$1<TResult>, any>, $state: any) : $Task<any>
            public ContinueWith ($continuationAction: System.Action$2<System.Threading.Tasks.Task$1<TResult>, any>, $state: any, $cancellationToken: System.Threading.CancellationToken) : $Task<any>
            public ContinueWith ($continuationAction: System.Action$2<System.Threading.Tasks.Task$1<TResult>, any>, $state: any, $scheduler: System.Threading.Tasks.TaskScheduler) : $Task<any>
            public ContinueWith ($continuationAction: System.Action$2<System.Threading.Tasks.Task$1<TResult>, any>, $state: any, $continuationOptions: System.Threading.Tasks.TaskContinuationOptions) : $Task<any>
            public ContinueWith ($continuationAction: System.Action$2<System.Threading.Tasks.Task$1<TResult>, any>, $state: any, $cancellationToken: System.Threading.CancellationToken, $continuationOptions: System.Threading.Tasks.TaskContinuationOptions, $scheduler: System.Threading.Tasks.TaskScheduler) : $Task<any>
            public constructor ($function: System.Func$1<TResult>)
            public constructor ($function: System.Func$1<TResult>, $cancellationToken: System.Threading.CancellationToken)
            public constructor ($function: System.Func$1<TResult>, $creationOptions: System.Threading.Tasks.TaskCreationOptions)
            public constructor ($function: System.Func$1<TResult>, $cancellationToken: System.Threading.CancellationToken, $creationOptions: System.Threading.Tasks.TaskCreationOptions)
            public constructor ($function: System.Func$2<any, TResult>, $state: any)
            public constructor ($function: System.Func$2<any, TResult>, $state: any, $cancellationToken: System.Threading.CancellationToken)
            public constructor ($function: System.Func$2<any, TResult>, $state: any, $creationOptions: System.Threading.Tasks.TaskCreationOptions)
            public constructor ($function: System.Func$2<any, TResult>, $state: any, $cancellationToken: System.Threading.CancellationToken, $creationOptions: System.Threading.Tasks.TaskCreationOptions)
            public GetAwaiter () : System.Runtime.CompilerServices.TaskAwaiter
            public ConfigureAwait ($continueOnCapturedContext: boolean) : System.Runtime.CompilerServices.ConfiguredTaskAwaitable
            public ContinueWith ($continuationAction: System.Action$1<$Task<any>>) : $Task<any>
            public ContinueWith ($continuationAction: System.Action$1<$Task<any>>, $cancellationToken: System.Threading.CancellationToken) : $Task<any>
            public ContinueWith ($continuationAction: System.Action$1<$Task<any>>, $scheduler: System.Threading.Tasks.TaskScheduler) : $Task<any>
            public ContinueWith ($continuationAction: System.Action$1<$Task<any>>, $continuationOptions: System.Threading.Tasks.TaskContinuationOptions) : $Task<any>
            public ContinueWith ($continuationAction: System.Action$1<$Task<any>>, $cancellationToken: System.Threading.CancellationToken, $continuationOptions: System.Threading.Tasks.TaskContinuationOptions, $scheduler: System.Threading.Tasks.TaskScheduler) : $Task<any>
            public ContinueWith ($continuationAction: System.Action$2<$Task<any>, any>, $state: any) : $Task<any>
            public ContinueWith ($continuationAction: System.Action$2<$Task<any>, any>, $state: any, $cancellationToken: System.Threading.CancellationToken) : $Task<any>
            public ContinueWith ($continuationAction: System.Action$2<$Task<any>, any>, $state: any, $scheduler: System.Threading.Tasks.TaskScheduler) : $Task<any>
            public ContinueWith ($continuationAction: System.Action$2<$Task<any>, any>, $state: any, $continuationOptions: System.Threading.Tasks.TaskContinuationOptions) : $Task<any>
            public ContinueWith ($continuationAction: System.Action$2<$Task<any>, any>, $state: any, $cancellationToken: System.Threading.CancellationToken, $continuationOptions: System.Threading.Tasks.TaskContinuationOptions, $scheduler: System.Threading.Tasks.TaskScheduler) : $Task<any>
            public constructor ($action: System.Action)
            public constructor ($action: System.Action, $cancellationToken: System.Threading.CancellationToken)
            public constructor ($action: System.Action, $creationOptions: System.Threading.Tasks.TaskCreationOptions)
            public constructor ($action: System.Action, $cancellationToken: System.Threading.CancellationToken, $creationOptions: System.Threading.Tasks.TaskCreationOptions)
            public constructor ($action: System.Action$1<any>, $state: any)
            public constructor ($action: System.Action$1<any>, $state: any, $cancellationToken: System.Threading.CancellationToken)
            public constructor ($action: System.Action$1<any>, $state: any, $creationOptions: System.Threading.Tasks.TaskCreationOptions)
            public constructor ($action: System.Action$1<any>, $state: any, $cancellationToken: System.Threading.CancellationToken, $creationOptions: System.Threading.Tasks.TaskCreationOptions)
            public constructor ()
        }
        class TaskCanceledException extends System.OperationCanceledException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public get Task(): $Task<any>;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
            public constructor ($message: string, $innerException: System.Exception, $token: System.Threading.CancellationToken)
            public constructor ($task: $Task<any>)
            public constructor ($token: System.Threading.CancellationToken)
            public constructor ($message: string, $token: System.Threading.CancellationToken)
        }
        class TaskCompletionSource$1<TResult> extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get Task(): System.Threading.Tasks.Task$1<TResult>;
            public TrySetException ($exception: System.Exception) : boolean
            public TrySetException ($exceptions: System.Collections.Generic.IEnumerable$1<System.Exception>) : boolean
            public SetException ($exception: System.Exception) : void
            public SetException ($exceptions: System.Collections.Generic.IEnumerable$1<System.Exception>) : void
            public TrySetResult ($result: TResult) : boolean
            public SetResult ($result: TResult) : void
            public TrySetCanceled () : boolean
            public TrySetCanceled ($cancellationToken: System.Threading.CancellationToken) : boolean
            public SetCanceled () : void
            public constructor ()
            public constructor ($creationOptions: System.Threading.Tasks.TaskCreationOptions)
            public constructor ($state: any)
            public constructor ($state: any, $creationOptions: System.Threading.Tasks.TaskCreationOptions)
        }
        enum TaskCreationOptions
        { None = 0, PreferFairness = 1, LongRunning = 2, AttachedToParent = 4, DenyChildAttach = 8, HideScheduler = 16, RunContinuationsAsynchronously = 64 }
        class TaskSchedulerException extends System.Exception implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($innerException: System.Exception)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class ValueTask$1<TResult> extends System.ValueType implements System.IEquatable$1<System.Threading.Tasks.ValueTask$1<TResult>>
        {
            protected [__keep_incompatibility]: never;
            public get IsCompleted(): boolean;
            public get IsCompletedSuccessfully(): boolean;
            public get IsFaulted(): boolean;
            public get IsCanceled(): boolean;
            public get Result(): TResult;
            public Equals ($obj: any) : boolean
            public Equals ($other: System.Threading.Tasks.ValueTask$1<TResult>) : boolean
            public static op_Equality ($left: any, $right: any) : any
            public static op_Inequality ($left: any, $right: any) : any
            public AsTask () : System.Threading.Tasks.Task$1<TResult>
            public Preserve () : System.Threading.Tasks.ValueTask$1<TResult>
            public GetAwaiter () : System.Runtime.CompilerServices.ValueTaskAwaiter$1<TResult>
            public ConfigureAwait ($continueOnCapturedContext: boolean) : System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable$1<TResult>
            public constructor ($result: TResult)
            public constructor ($task: System.Threading.Tasks.Task$1<TResult>)
            public constructor ($source: System.Threading.Tasks.Sources.IValueTaskSource$1<TResult>, $token: number)
            public static Equals ($objA: any, $objB: any) : any
            public constructor ()
        }
        class ParallelOptions extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get TaskScheduler(): System.Threading.Tasks.TaskScheduler;
            public set TaskScheduler(value: System.Threading.Tasks.TaskScheduler);
            public get MaxDegreeOfParallelism(): number;
            public set MaxDegreeOfParallelism(value: number);
            public get CancellationToken(): System.Threading.CancellationToken;
            public set CancellationToken(value: System.Threading.CancellationToken);
            public constructor ()
        }
        class TaskScheduler extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get MaximumConcurrencyLevel(): number;
            public static get Default(): System.Threading.Tasks.TaskScheduler;
            public static get Current(): System.Threading.Tasks.TaskScheduler;
            public get Id(): number;
            public static FromCurrentSynchronizationContext () : System.Threading.Tasks.TaskScheduler
            public static add_UnobservedTaskException ($value: System.EventHandler$1<System.Threading.Tasks.UnobservedTaskExceptionEventArgs>) : void
            public static remove_UnobservedTaskException ($value: System.EventHandler$1<System.Threading.Tasks.UnobservedTaskExceptionEventArgs>) : void
        }
        class Parallel extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static Invoke (...actions: System.Action[]) : void
            public static Invoke ($parallelOptions: System.Threading.Tasks.ParallelOptions, ...actions: System.Action[]) : void
            public static For ($fromInclusive: number, $toExclusive: number, $body: System.Action$1<number>) : System.Threading.Tasks.ParallelLoopResult
            public static For ($fromInclusive: bigint, $toExclusive: bigint, $body: System.Action$1<bigint>) : System.Threading.Tasks.ParallelLoopResult
            public static For ($fromInclusive: number, $toExclusive: number, $parallelOptions: System.Threading.Tasks.ParallelOptions, $body: System.Action$1<number>) : System.Threading.Tasks.ParallelLoopResult
            public static For ($fromInclusive: bigint, $toExclusive: bigint, $parallelOptions: System.Threading.Tasks.ParallelOptions, $body: System.Action$1<bigint>) : System.Threading.Tasks.ParallelLoopResult
            public static For ($fromInclusive: number, $toExclusive: number, $body: System.Action$2<number, System.Threading.Tasks.ParallelLoopState>) : System.Threading.Tasks.ParallelLoopResult
            public static For ($fromInclusive: bigint, $toExclusive: bigint, $body: System.Action$2<bigint, System.Threading.Tasks.ParallelLoopState>) : System.Threading.Tasks.ParallelLoopResult
            public static For ($fromInclusive: number, $toExclusive: number, $parallelOptions: System.Threading.Tasks.ParallelOptions, $body: System.Action$2<number, System.Threading.Tasks.ParallelLoopState>) : System.Threading.Tasks.ParallelLoopResult
            public static For ($fromInclusive: bigint, $toExclusive: bigint, $parallelOptions: System.Threading.Tasks.ParallelOptions, $body: System.Action$2<bigint, System.Threading.Tasks.ParallelLoopState>) : System.Threading.Tasks.ParallelLoopResult
        }
        class ParallelLoopResult extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get IsCompleted(): boolean;
            public get LowestBreakIteration(): bigint | null;
        }
        class ParallelLoopState extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get ShouldExitCurrentIteration(): boolean;
            public get IsStopped(): boolean;
            public get IsExceptional(): boolean;
            public get LowestBreakIteration(): bigint | null;
            public Stop () : void
            public Break () : void
        }
        class ConcurrentExclusiveSchedulerPair extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get Completion(): $Task<any>;
            public get ConcurrentScheduler(): System.Threading.Tasks.TaskScheduler;
            public get ExclusiveScheduler(): System.Threading.Tasks.TaskScheduler;
            public Complete () : void
            public constructor ()
            public constructor ($taskScheduler: System.Threading.Tasks.TaskScheduler)
            public constructor ($taskScheduler: System.Threading.Tasks.TaskScheduler, $maxConcurrencyLevel: number)
            public constructor ($taskScheduler: System.Threading.Tasks.TaskScheduler, $maxConcurrencyLevel: number, $maxItemsPerTask: number)
        }
        class TaskFactory$1<TResult> extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get CancellationToken(): System.Threading.CancellationToken;
            public get Scheduler(): System.Threading.Tasks.TaskScheduler;
            public get CreationOptions(): System.Threading.Tasks.TaskCreationOptions;
            public get ContinuationOptions(): System.Threading.Tasks.TaskContinuationOptions;
            public StartNew ($function: System.Func$1<TResult>) : System.Threading.Tasks.Task$1<TResult>
            public StartNew ($function: System.Func$1<TResult>, $cancellationToken: System.Threading.CancellationToken) : System.Threading.Tasks.Task$1<TResult>
            public StartNew ($function: System.Func$1<TResult>, $creationOptions: System.Threading.Tasks.TaskCreationOptions) : System.Threading.Tasks.Task$1<TResult>
            public StartNew ($function: System.Func$1<TResult>, $cancellationToken: System.Threading.CancellationToken, $creationOptions: System.Threading.Tasks.TaskCreationOptions, $scheduler: System.Threading.Tasks.TaskScheduler) : System.Threading.Tasks.Task$1<TResult>
            public StartNew ($function: System.Func$2<any, TResult>, $state: any) : System.Threading.Tasks.Task$1<TResult>
            public StartNew ($function: System.Func$2<any, TResult>, $state: any, $cancellationToken: System.Threading.CancellationToken) : System.Threading.Tasks.Task$1<TResult>
            public StartNew ($function: System.Func$2<any, TResult>, $state: any, $creationOptions: System.Threading.Tasks.TaskCreationOptions) : System.Threading.Tasks.Task$1<TResult>
            public StartNew ($function: System.Func$2<any, TResult>, $state: any, $cancellationToken: System.Threading.CancellationToken, $creationOptions: System.Threading.Tasks.TaskCreationOptions, $scheduler: System.Threading.Tasks.TaskScheduler) : System.Threading.Tasks.Task$1<TResult>
            public FromAsync ($asyncResult: System.IAsyncResult, $endMethod: System.Func$2<System.IAsyncResult, TResult>) : System.Threading.Tasks.Task$1<TResult>
            public FromAsync ($asyncResult: System.IAsyncResult, $endMethod: System.Func$2<System.IAsyncResult, TResult>, $creationOptions: System.Threading.Tasks.TaskCreationOptions) : System.Threading.Tasks.Task$1<TResult>
            public FromAsync ($asyncResult: System.IAsyncResult, $endMethod: System.Func$2<System.IAsyncResult, TResult>, $creationOptions: System.Threading.Tasks.TaskCreationOptions, $scheduler: System.Threading.Tasks.TaskScheduler) : System.Threading.Tasks.Task$1<TResult>
            public FromAsync ($beginMethod: System.Func$3<System.AsyncCallback, any, System.IAsyncResult>, $endMethod: System.Func$2<System.IAsyncResult, TResult>, $state: any) : System.Threading.Tasks.Task$1<TResult>
            public FromAsync ($beginMethod: System.Func$3<System.AsyncCallback, any, System.IAsyncResult>, $endMethod: System.Func$2<System.IAsyncResult, TResult>, $state: any, $creationOptions: System.Threading.Tasks.TaskCreationOptions) : System.Threading.Tasks.Task$1<TResult>
            public ContinueWhenAll ($tasks: System.Array$1<$Task<any>>, $continuationFunction: System.Func$2<System.Array$1<$Task<any>>, TResult>) : System.Threading.Tasks.Task$1<TResult>
            public ContinueWhenAll ($tasks: System.Array$1<$Task<any>>, $continuationFunction: System.Func$2<System.Array$1<$Task<any>>, TResult>, $cancellationToken: System.Threading.CancellationToken) : System.Threading.Tasks.Task$1<TResult>
            public ContinueWhenAll ($tasks: System.Array$1<$Task<any>>, $continuationFunction: System.Func$2<System.Array$1<$Task<any>>, TResult>, $continuationOptions: System.Threading.Tasks.TaskContinuationOptions) : System.Threading.Tasks.Task$1<TResult>
            public ContinueWhenAll ($tasks: System.Array$1<$Task<any>>, $continuationFunction: System.Func$2<System.Array$1<$Task<any>>, TResult>, $cancellationToken: System.Threading.CancellationToken, $continuationOptions: System.Threading.Tasks.TaskContinuationOptions, $scheduler: System.Threading.Tasks.TaskScheduler) : System.Threading.Tasks.Task$1<TResult>
            public ContinueWhenAny ($tasks: System.Array$1<$Task<any>>, $continuationFunction: System.Func$2<$Task<any>, TResult>) : System.Threading.Tasks.Task$1<TResult>
            public ContinueWhenAny ($tasks: System.Array$1<$Task<any>>, $continuationFunction: System.Func$2<$Task<any>, TResult>, $cancellationToken: System.Threading.CancellationToken) : System.Threading.Tasks.Task$1<TResult>
            public ContinueWhenAny ($tasks: System.Array$1<$Task<any>>, $continuationFunction: System.Func$2<$Task<any>, TResult>, $continuationOptions: System.Threading.Tasks.TaskContinuationOptions) : System.Threading.Tasks.Task$1<TResult>
            public ContinueWhenAny ($tasks: System.Array$1<$Task<any>>, $continuationFunction: System.Func$2<$Task<any>, TResult>, $cancellationToken: System.Threading.CancellationToken, $continuationOptions: System.Threading.Tasks.TaskContinuationOptions, $scheduler: System.Threading.Tasks.TaskScheduler) : System.Threading.Tasks.Task$1<TResult>
            public constructor ()
            public constructor ($cancellationToken: System.Threading.CancellationToken)
            public constructor ($scheduler: System.Threading.Tasks.TaskScheduler)
            public constructor ($creationOptions: System.Threading.Tasks.TaskCreationOptions, $continuationOptions: System.Threading.Tasks.TaskContinuationOptions)
            public constructor ($cancellationToken: System.Threading.CancellationToken, $creationOptions: System.Threading.Tasks.TaskCreationOptions, $continuationOptions: System.Threading.Tasks.TaskContinuationOptions, $scheduler: System.Threading.Tasks.TaskScheduler)
        }
        enum TaskContinuationOptions
        { None = 0, PreferFairness = 1, LongRunning = 2, AttachedToParent = 4, DenyChildAttach = 8, HideScheduler = 16, LazyCancellation = 32, RunContinuationsAsynchronously = 64, NotOnRanToCompletion = 65536, NotOnFaulted = 131072, NotOnCanceled = 262144, OnlyOnRanToCompletion = 393216, OnlyOnFaulted = 327680, OnlyOnCanceled = 196608, ExecuteSynchronously = 524288 }
        enum TaskStatus
        { Created = 0, WaitingForActivation = 1, WaitingToRun = 2, Running = 3, WaitingForChildrenToComplete = 4, RanToCompletion = 5, Canceled = 6, Faulted = 7 }
        class TaskFactory extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get CancellationToken(): System.Threading.CancellationToken;
            public get Scheduler(): System.Threading.Tasks.TaskScheduler;
            public get CreationOptions(): System.Threading.Tasks.TaskCreationOptions;
            public get ContinuationOptions(): System.Threading.Tasks.TaskContinuationOptions;
            public StartNew ($action: System.Action) : $Task<any>
            public StartNew ($action: System.Action, $cancellationToken: System.Threading.CancellationToken) : $Task<any>
            public StartNew ($action: System.Action, $creationOptions: System.Threading.Tasks.TaskCreationOptions) : $Task<any>
            public StartNew ($action: System.Action, $cancellationToken: System.Threading.CancellationToken, $creationOptions: System.Threading.Tasks.TaskCreationOptions, $scheduler: System.Threading.Tasks.TaskScheduler) : $Task<any>
            public StartNew ($action: System.Action$1<any>, $state: any) : $Task<any>
            public StartNew ($action: System.Action$1<any>, $state: any, $cancellationToken: System.Threading.CancellationToken) : $Task<any>
            public StartNew ($action: System.Action$1<any>, $state: any, $creationOptions: System.Threading.Tasks.TaskCreationOptions) : $Task<any>
            public StartNew ($action: System.Action$1<any>, $state: any, $cancellationToken: System.Threading.CancellationToken, $creationOptions: System.Threading.Tasks.TaskCreationOptions, $scheduler: System.Threading.Tasks.TaskScheduler) : $Task<any>
            public FromAsync ($asyncResult: System.IAsyncResult, $endMethod: System.Action$1<System.IAsyncResult>) : $Task<any>
            public FromAsync ($asyncResult: System.IAsyncResult, $endMethod: System.Action$1<System.IAsyncResult>, $creationOptions: System.Threading.Tasks.TaskCreationOptions) : $Task<any>
            public FromAsync ($asyncResult: System.IAsyncResult, $endMethod: System.Action$1<System.IAsyncResult>, $creationOptions: System.Threading.Tasks.TaskCreationOptions, $scheduler: System.Threading.Tasks.TaskScheduler) : $Task<any>
            public FromAsync ($beginMethod: System.Func$3<System.AsyncCallback, any, System.IAsyncResult>, $endMethod: System.Action$1<System.IAsyncResult>, $state: any) : $Task<any>
            public FromAsync ($beginMethod: System.Func$3<System.AsyncCallback, any, System.IAsyncResult>, $endMethod: System.Action$1<System.IAsyncResult>, $state: any, $creationOptions: System.Threading.Tasks.TaskCreationOptions) : $Task<any>
            public ContinueWhenAll ($tasks: System.Array$1<$Task<any>>, $continuationAction: System.Action$1<System.Array$1<$Task<any>>>) : $Task<any>
            public ContinueWhenAll ($tasks: System.Array$1<$Task<any>>, $continuationAction: System.Action$1<System.Array$1<$Task<any>>>, $cancellationToken: System.Threading.CancellationToken) : $Task<any>
            public ContinueWhenAll ($tasks: System.Array$1<$Task<any>>, $continuationAction: System.Action$1<System.Array$1<$Task<any>>>, $continuationOptions: System.Threading.Tasks.TaskContinuationOptions) : $Task<any>
            public ContinueWhenAll ($tasks: System.Array$1<$Task<any>>, $continuationAction: System.Action$1<System.Array$1<$Task<any>>>, $cancellationToken: System.Threading.CancellationToken, $continuationOptions: System.Threading.Tasks.TaskContinuationOptions, $scheduler: System.Threading.Tasks.TaskScheduler) : $Task<any>
            public ContinueWhenAny ($tasks: System.Array$1<$Task<any>>, $continuationAction: System.Action$1<$Task<any>>) : $Task<any>
            public ContinueWhenAny ($tasks: System.Array$1<$Task<any>>, $continuationAction: System.Action$1<$Task<any>>, $cancellationToken: System.Threading.CancellationToken) : $Task<any>
            public ContinueWhenAny ($tasks: System.Array$1<$Task<any>>, $continuationAction: System.Action$1<$Task<any>>, $continuationOptions: System.Threading.Tasks.TaskContinuationOptions) : $Task<any>
            public ContinueWhenAny ($tasks: System.Array$1<$Task<any>>, $continuationAction: System.Action$1<$Task<any>>, $cancellationToken: System.Threading.CancellationToken, $continuationOptions: System.Threading.Tasks.TaskContinuationOptions, $scheduler: System.Threading.Tasks.TaskScheduler) : $Task<any>
            public constructor ()
            public constructor ($cancellationToken: System.Threading.CancellationToken)
            public constructor ($scheduler: System.Threading.Tasks.TaskScheduler)
            public constructor ($creationOptions: System.Threading.Tasks.TaskCreationOptions, $continuationOptions: System.Threading.Tasks.TaskContinuationOptions)
            public constructor ($cancellationToken: System.Threading.CancellationToken, $creationOptions: System.Threading.Tasks.TaskCreationOptions, $continuationOptions: System.Threading.Tasks.TaskContinuationOptions, $scheduler: System.Threading.Tasks.TaskScheduler)
        }
        class UnobservedTaskExceptionEventArgs extends System.EventArgs
        {
            protected [__keep_incompatibility]: never;
            public get Observed(): boolean;
            public get Exception(): System.AggregateException;
            public SetObserved () : void
            public constructor ($exception: System.AggregateException)
            public constructor ()
        }
        class TaskAsyncEnumerableExtensions extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static ConfigureAwait ($source: System.IAsyncDisposable, $continueOnCapturedContext: boolean) : System.Runtime.CompilerServices.ConfiguredAsyncDisposable
        }
    }
    namespace System.Threading {
        class WaitHandle extends System.MarshalByRefObject implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public static WaitTimeout : number
            public get SafeWaitHandle(): Microsoft.Win32.SafeHandles.SafeWaitHandle;
            public set SafeWaitHandle(value: Microsoft.Win32.SafeHandles.SafeWaitHandle);
            public WaitOne ($millisecondsTimeout: number, $exitContext: boolean) : boolean
            public WaitOne ($timeout: System.TimeSpan, $exitContext: boolean) : boolean
            public WaitOne () : boolean
            public WaitOne ($millisecondsTimeout: number) : boolean
            public WaitOne ($timeout: System.TimeSpan) : boolean
            public static WaitAll ($waitHandles: System.Array$1<System.Threading.WaitHandle>, $millisecondsTimeout: number, $exitContext: boolean) : boolean
            public static WaitAll ($waitHandles: System.Array$1<System.Threading.WaitHandle>, $timeout: System.TimeSpan, $exitContext: boolean) : boolean
            public static WaitAll ($waitHandles: System.Array$1<System.Threading.WaitHandle>) : boolean
            public static WaitAll ($waitHandles: System.Array$1<System.Threading.WaitHandle>, $millisecondsTimeout: number) : boolean
            public static WaitAll ($waitHandles: System.Array$1<System.Threading.WaitHandle>, $timeout: System.TimeSpan) : boolean
            public static WaitAny ($waitHandles: System.Array$1<System.Threading.WaitHandle>, $millisecondsTimeout: number, $exitContext: boolean) : number
            public static WaitAny ($waitHandles: System.Array$1<System.Threading.WaitHandle>, $timeout: System.TimeSpan, $exitContext: boolean) : number
            public static WaitAny ($waitHandles: System.Array$1<System.Threading.WaitHandle>, $timeout: System.TimeSpan) : number
            public static WaitAny ($waitHandles: System.Array$1<System.Threading.WaitHandle>) : number
            public static WaitAny ($waitHandles: System.Array$1<System.Threading.WaitHandle>, $millisecondsTimeout: number) : number
            public static SignalAndWait ($toSignal: System.Threading.WaitHandle, $toWaitOn: System.Threading.WaitHandle) : boolean
            public static SignalAndWait ($toSignal: System.Threading.WaitHandle, $toWaitOn: System.Threading.WaitHandle, $timeout: System.TimeSpan, $exitContext: boolean) : boolean
            public static SignalAndWait ($toSignal: System.Threading.WaitHandle, $toWaitOn: System.Threading.WaitHandle, $millisecondsTimeout: number, $exitContext: boolean) : boolean
            public Close () : void
            public Dispose () : void
        }
        interface WaitHandle {
            GetSafeWaitHandle () : Microsoft.Win32.SafeHandles.SafeWaitHandle;
            SetSafeWaitHandle ($value: Microsoft.Win32.SafeHandles.SafeWaitHandle) : void;
        }
        enum LazyThreadSafetyMode
        { None = 0, PublicationOnly = 1, ExecutionAndPublication = 2 }
        class CancellationToken extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public static get None(): System.Threading.CancellationToken;
            public get IsCancellationRequested(): boolean;
            public get CanBeCanceled(): boolean;
            public get WaitHandle(): System.Threading.WaitHandle;
            public Register ($callback: System.Action) : System.Threading.CancellationTokenRegistration
            public Register ($callback: System.Action, $useSynchronizationContext: boolean) : System.Threading.CancellationTokenRegistration
            public Register ($callback: System.Action$1<any>, $state: any) : System.Threading.CancellationTokenRegistration
            public Register ($callback: System.Action$1<any>, $state: any, $useSynchronizationContext: boolean) : System.Threading.CancellationTokenRegistration
            public Register ($callback: System.Action$1<any>, $state: any, $useSynchronizationContext: boolean, $useExecutionContext: boolean) : System.Threading.CancellationTokenRegistration
            public Equals ($other: System.Threading.CancellationToken) : boolean
            public Equals ($other: any) : boolean
            public static op_Equality ($left: System.Threading.CancellationToken, $right: System.Threading.CancellationToken) : boolean
            public static op_Inequality ($left: System.Threading.CancellationToken, $right: System.Threading.CancellationToken) : boolean
            public ThrowIfCancellationRequested () : void
            public constructor ($canceled: boolean)
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
            public constructor ()
        }
        class HostExecutionContextManager extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public Capture () : System.Threading.HostExecutionContext
            public Revert ($previousState: any) : void
            public SetHostExecutionContext ($hostExecutionContext: System.Threading.HostExecutionContext) : any
            public constructor ()
        }
        class AbandonedMutexException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public get Mutex(): System.Threading.Mutex;
            public get MutexIndex(): number;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $inner: System.Exception)
            public constructor ($location: number, $handle: System.Threading.WaitHandle)
            public constructor ($message: string, $location: number, $handle: System.Threading.WaitHandle)
            public constructor ($message: string, $inner: System.Exception, $location: number, $handle: System.Threading.WaitHandle)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class Mutex extends System.Threading.WaitHandle implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public GetAccessControl () : System.Security.AccessControl.MutexSecurity
            public static OpenExisting ($name: string) : System.Threading.Mutex
            public static OpenExisting ($name: string, $rights: System.Security.AccessControl.MutexRights) : System.Threading.Mutex
            public static TryOpenExisting ($name: string, $result: $Ref<System.Threading.Mutex>) : boolean
            public static TryOpenExisting ($name: string, $rights: System.Security.AccessControl.MutexRights, $result: $Ref<System.Threading.Mutex>) : boolean
            public ReleaseMutex () : void
            public SetAccessControl ($mutexSecurity: System.Security.AccessControl.MutexSecurity) : void
            public constructor ()
            public constructor ($initiallyOwned: boolean)
            public constructor ($initiallyOwned: boolean, $name: string)
            public constructor ($initiallyOwned: boolean, $name: string, $createdNew: $Ref<boolean>)
            public constructor ($initiallyOwned: boolean, $name: string, $createdNew: $Ref<boolean>, $mutexSecurity: System.Security.AccessControl.MutexSecurity)
        }
        enum ApartmentState
        { STA = 0, MTA = 1, Unknown = 2 }
        class AsyncLocal$1<T> extends System.Object implements System.Threading.IAsyncLocal
        {
            protected [__keep_incompatibility]: never;
            public get Value(): T;
            public set Value(value: T);
            public constructor ()
            public constructor ($valueChangedHandler: System.Action$1<System.Threading.AsyncLocalValueChangedArgs$1<T>>)
        }
        interface IAsyncLocal
        {
        }
        class AsyncLocalValueChangedArgs$1<T> extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get PreviousValue(): T;
            public get CurrentValue(): T;
            public get ThreadContextChanged(): boolean;
        }
        class EventWaitHandle extends System.Threading.WaitHandle implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public static OpenExisting ($name: string) : System.Threading.EventWaitHandle
            public static OpenExisting ($name: string, $rights: System.Security.AccessControl.EventWaitHandleRights) : System.Threading.EventWaitHandle
            public static TryOpenExisting ($name: string, $result: $Ref<System.Threading.EventWaitHandle>) : boolean
            public static TryOpenExisting ($name: string, $rights: System.Security.AccessControl.EventWaitHandleRights, $result: $Ref<System.Threading.EventWaitHandle>) : boolean
            public Reset () : boolean
            public Set () : boolean
            public GetAccessControl () : System.Security.AccessControl.EventWaitHandleSecurity
            public SetAccessControl ($eventSecurity: System.Security.AccessControl.EventWaitHandleSecurity) : void
            public constructor ($initialState: boolean, $mode: System.Threading.EventResetMode)
            public constructor ($initialState: boolean, $mode: System.Threading.EventResetMode, $name: string)
            public constructor ($initialState: boolean, $mode: System.Threading.EventResetMode, $name: string, $createdNew: $Ref<boolean>)
            public constructor ($initialState: boolean, $mode: System.Threading.EventResetMode, $name: string, $createdNew: $Ref<boolean>, $eventSecurity: System.Security.AccessControl.EventWaitHandleSecurity)
            public constructor ()
        }
        class AutoResetEvent extends System.Threading.EventWaitHandle implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public constructor ($initialState: boolean)
            public constructor ($initialState: boolean, $mode: System.Threading.EventResetMode)
            public constructor ($initialState: boolean, $mode: System.Threading.EventResetMode, $name: string)
            public constructor ($initialState: boolean, $mode: System.Threading.EventResetMode, $name: string, $createdNew: $Ref<boolean>)
            public constructor ($initialState: boolean, $mode: System.Threading.EventResetMode, $name: string, $createdNew: $Ref<boolean>, $eventSecurity: System.Security.AccessControl.EventWaitHandleSecurity)
            public constructor ()
        }
        enum EventResetMode
        { AutoReset = 0, ManualReset = 1 }
        class LazyInitializer extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class LockRecursionException extends System.Exception implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class ManualResetEvent extends System.Threading.EventWaitHandle implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public constructor ($initialState: boolean)
            public constructor ($initialState: boolean, $mode: System.Threading.EventResetMode)
            public constructor ($initialState: boolean, $mode: System.Threading.EventResetMode, $name: string)
            public constructor ($initialState: boolean, $mode: System.Threading.EventResetMode, $name: string, $createdNew: $Ref<boolean>)
            public constructor ($initialState: boolean, $mode: System.Threading.EventResetMode, $name: string, $createdNew: $Ref<boolean>, $eventSecurity: System.Security.AccessControl.EventWaitHandleSecurity)
            public constructor ()
        }
        interface ParameterizedThreadStart
        { 
        (obj: any) : void; 
        Invoke?: (obj: any) => void;
        }
        var ParameterizedThreadStart: { new (func: (obj: any) => void): ParameterizedThreadStart; }
        class SemaphoreFullException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        interface SendOrPostCallback
        { 
        (state: any) : void; 
        Invoke?: (state: any) => void;
        }
        var SendOrPostCallback: { new (func: (state: any) => void): SendOrPostCallback; }
        class SynchronizationLockException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        enum ThreadPriority
        { Lowest = 0, BelowNormal = 1, Normal = 2, AboveNormal = 3, Highest = 4 }
        interface ThreadStart
        { 
        () : void; 
        Invoke?: () => void;
        }
        var ThreadStart: { new (func: () => void): ThreadStart; }
        class ThreadStartException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
        }
        enum ThreadState
        { Running = 0, StopRequested = 1, SuspendRequested = 2, Background = 4, Unstarted = 8, Stopped = 16, WaitSleepJoin = 32, Suspended = 64, AbortRequested = 128, Aborted = 256 }
        class ThreadStateException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class Timeout extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static InfiniteTimeSpan : System.TimeSpan
            public static Infinite : number
        }
        class WaitHandleCannotBeOpenedException extends System.ApplicationException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class CountdownEvent extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get CurrentCount(): number;
            public get InitialCount(): number;
            public get IsSet(): boolean;
            public get WaitHandle(): System.Threading.WaitHandle;
            public Dispose () : void
            public Signal () : boolean
            public Signal ($signalCount: number) : boolean
            public AddCount () : void
            public TryAddCount () : boolean
            public AddCount ($signalCount: number) : void
            public TryAddCount ($signalCount: number) : boolean
            public Reset () : void
            public Reset ($count: number) : void
            public Wait () : void
            public Wait ($cancellationToken: System.Threading.CancellationToken) : void
            public Wait ($timeout: System.TimeSpan) : boolean
            public Wait ($timeout: System.TimeSpan, $cancellationToken: System.Threading.CancellationToken) : boolean
            public Wait ($millisecondsTimeout: number) : boolean
            public Wait ($millisecondsTimeout: number, $cancellationToken: System.Threading.CancellationToken) : boolean
            public constructor ($initialCount: number)
            public constructor ()
        }
        class CancellationTokenRegistration extends System.ValueType implements System.IAsyncDisposable, System.IDisposable, System.IEquatable$1<System.Threading.CancellationTokenRegistration>
        {
            protected [__keep_incompatibility]: never;
            public get Token(): System.Threading.CancellationToken;
            public Unregister () : boolean
            public Dispose () : void
            public static op_Equality ($left: System.Threading.CancellationTokenRegistration, $right: System.Threading.CancellationTokenRegistration) : boolean
            public static op_Inequality ($left: System.Threading.CancellationTokenRegistration, $right: System.Threading.CancellationTokenRegistration) : boolean
            public Equals ($obj: any) : boolean
            public Equals ($other: System.Threading.CancellationTokenRegistration) : boolean
            public DisposeAsync () : System.Threading.Tasks.ValueTask
            public ConfigureAwait ($continueOnCapturedContext: boolean) : System.Runtime.CompilerServices.ConfiguredAsyncDisposable
            public static Equals ($objA: any, $objB: any) : boolean
        }
        class ManualResetEventSlim extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get WaitHandle(): System.Threading.WaitHandle;
            public get IsSet(): boolean;
            public get SpinCount(): number;
            public Set () : void
            public Reset () : void
            public Wait () : void
            public Wait ($cancellationToken: System.Threading.CancellationToken) : void
            public Wait ($timeout: System.TimeSpan) : boolean
            public Wait ($timeout: System.TimeSpan, $cancellationToken: System.Threading.CancellationToken) : boolean
            public Wait ($millisecondsTimeout: number) : boolean
            public Wait ($millisecondsTimeout: number, $cancellationToken: System.Threading.CancellationToken) : boolean
            public Dispose () : void
            public constructor ()
            public constructor ($initialState: boolean)
            public constructor ($initialState: boolean, $spinCount: number)
        }
        class NativeOverlapped extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public InternalLow : System.IntPtr
            public InternalHigh : System.IntPtr
            public OffsetLow : number
            public OffsetHigh : number
            public EventHandle : System.IntPtr
        }
        class SpinWait extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get Count(): number;
            public get NextSpinWillYield(): boolean;
            public SpinOnce () : void
            public SpinOnce ($sleep1Threshold: number) : void
            public Reset () : void
            public static SpinUntil ($condition: System.Func$1<boolean>) : void
            public static SpinUntil ($condition: System.Func$1<boolean>, $timeout: System.TimeSpan) : boolean
            public static SpinUntil ($condition: System.Func$1<boolean>, $millisecondsTimeout: number) : boolean
        }
        class CancellationTokenSource extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get IsCancellationRequested(): boolean;
            public get Token(): System.Threading.CancellationToken;
            public Cancel () : void
            public Cancel ($throwOnFirstException: boolean) : void
            public CancelAfter ($delay: System.TimeSpan) : void
            public CancelAfter ($millisecondsDelay: number) : void
            public Dispose () : void
            public static CreateLinkedTokenSource ($token1: System.Threading.CancellationToken, $token2: System.Threading.CancellationToken) : System.Threading.CancellationTokenSource
            public static CreateLinkedTokenSource (...tokens: System.Threading.CancellationToken[]) : System.Threading.CancellationTokenSource
            public constructor ()
            public constructor ($delay: System.TimeSpan)
            public constructor ($millisecondsDelay: number)
        }
        class LockHolder extends System.ValueType implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public static Hold ($l: System.Threading.Lock) : System.Threading.LockHolder
            public Dispose () : void
        }
        class Lock extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public Acquire () : void
            public Release () : void
            public constructor ()
        }
        class ThreadPoolBoundHandle extends System.Object implements System.Threading.IDeferredDisposable, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get Handle(): System.Runtime.InteropServices.SafeHandle;
            public static BindHandle ($handle: System.Runtime.InteropServices.SafeHandle) : System.Threading.ThreadPoolBoundHandle
            public Dispose () : void
        }
        interface IDeferredDisposable
        {
        }
        class IOCompletionCallback extends System.MulticastDelegate implements System.Runtime.Serialization.ISerializable, System.ICloneable
        {
            protected [__keep_incompatibility]: never;
            public EndInvoke ($result: System.IAsyncResult) : void
            public constructor ($object: any, $method: System.IntPtr)
        }
        class PreAllocatedOverlapped extends System.Object implements System.Threading.IDeferredDisposable, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public Dispose () : void
            public constructor ($callback: System.Threading.IOCompletionCallback, $state: any, $pinData: any)
            public constructor ()
        }
        class SemaphoreSlim extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get CurrentCount(): number;
            public get AvailableWaitHandle(): System.Threading.WaitHandle;
            public Wait () : void
            public Wait ($cancellationToken: System.Threading.CancellationToken) : void
            public Wait ($timeout: System.TimeSpan) : boolean
            public Wait ($timeout: System.TimeSpan, $cancellationToken: System.Threading.CancellationToken) : boolean
            public Wait ($millisecondsTimeout: number) : boolean
            public Wait ($millisecondsTimeout: number, $cancellationToken: System.Threading.CancellationToken) : boolean
            public WaitAsync () : $Task<any>
            public WaitAsync ($cancellationToken: System.Threading.CancellationToken) : $Task<any>
            public WaitAsync ($millisecondsTimeout: number) : System.Threading.Tasks.Task$1<boolean>
            public WaitAsync ($timeout: System.TimeSpan) : System.Threading.Tasks.Task$1<boolean>
            public WaitAsync ($timeout: System.TimeSpan, $cancellationToken: System.Threading.CancellationToken) : System.Threading.Tasks.Task$1<boolean>
            public WaitAsync ($millisecondsTimeout: number, $cancellationToken: System.Threading.CancellationToken) : System.Threading.Tasks.Task$1<boolean>
            public Release () : number
            public Release ($releaseCount: number) : number
            public Dispose () : void
            public constructor ($initialCount: number)
            public constructor ($initialCount: number, $maxCount: number)
            public constructor ()
        }
        interface IThreadPoolWorkItem
        {
        }
        class SpinLock extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get IsHeld(): boolean;
            public get IsHeldByCurrentThread(): boolean;
            public get IsThreadOwnerTrackingEnabled(): boolean;
            public Enter ($lockTaken: $Ref<boolean>) : void
            public TryEnter ($lockTaken: $Ref<boolean>) : void
            public TryEnter ($timeout: System.TimeSpan, $lockTaken: $Ref<boolean>) : void
            public TryEnter ($millisecondsTimeout: number, $lockTaken: $Ref<boolean>) : void
            public Exit () : void
            public Exit ($useMemoryBarrier: boolean) : void
            public constructor ($enableThreadOwnerTracking: boolean)
            public constructor ()
        }
        class ThreadLocal$1<T> extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get Value(): T;
            public set Value(value: T);
            public get Values(): System.Collections.Generic.IList$1<T>;
            public get IsValueCreated(): boolean;
            public Dispose () : void
            public constructor ()
            public constructor ($trackAllValues: boolean)
            public constructor ($valueFactory: System.Func$1<T>)
            public constructor ($valueFactory: System.Func$1<T>, $trackAllValues: boolean)
        }
        interface ContextCallback
        { 
        (state: any) : void; 
        Invoke?: (state: any) => void;
        }
        var ContextCallback: { new (func: (state: any) => void): ContextCallback; }
        class AsyncFlowControl extends System.ValueType implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public Dispose () : void
            public Undo () : void
            public Equals ($obj: any) : boolean
            public Equals ($obj: System.Threading.AsyncFlowControl) : boolean
            public static op_Equality ($a: System.Threading.AsyncFlowControl, $b: System.Threading.AsyncFlowControl) : boolean
            public static op_Inequality ($a: System.Threading.AsyncFlowControl, $b: System.Threading.AsyncFlowControl) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
        }
        class ExecutionContext extends System.Object implements System.Runtime.Serialization.ISerializable, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public Dispose () : void
            public static Run ($executionContext: System.Threading.ExecutionContext, $callback: System.Threading.ContextCallback, $state: any) : void
            public CreateCopy () : System.Threading.ExecutionContext
            public static SuppressFlow () : System.Threading.AsyncFlowControl
            public static RestoreFlow () : void
            public static IsFlowSuppressed () : boolean
            public static Capture () : System.Threading.ExecutionContext
            public GetObjectData ($info: System.Runtime.Serialization.SerializationInfo, $context: System.Runtime.Serialization.StreamingContext) : void
        }
        class Monitor extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static Enter ($obj: any) : void
            public static Enter ($obj: any, $lockTaken: $Ref<boolean>) : void
            public static Exit ($obj: any) : void
            public static TryEnter ($obj: any) : boolean
            public static TryEnter ($obj: any, $lockTaken: $Ref<boolean>) : void
            public static TryEnter ($obj: any, $millisecondsTimeout: number) : boolean
            public static TryEnter ($obj: any, $timeout: System.TimeSpan) : boolean
            public static TryEnter ($obj: any, $millisecondsTimeout: number, $lockTaken: $Ref<boolean>) : void
            public static TryEnter ($obj: any, $timeout: System.TimeSpan, $lockTaken: $Ref<boolean>) : void
            public static IsEntered ($obj: any) : boolean
            public static Wait ($obj: any, $millisecondsTimeout: number, $exitContext: boolean) : boolean
            public static Wait ($obj: any, $timeout: System.TimeSpan, $exitContext: boolean) : boolean
            public static Wait ($obj: any, $millisecondsTimeout: number) : boolean
            public static Wait ($obj: any, $timeout: System.TimeSpan) : boolean
            public static Wait ($obj: any) : boolean
            public static Pulse ($obj: any) : void
            public static PulseAll ($obj: any) : void
        }
        class SynchronizationContext extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get Current(): System.Threading.SynchronizationContext;
            public IsWaitNotificationRequired () : boolean
            public Send ($d: System.Threading.SendOrPostCallback, $state: any) : void
            public Post ($d: System.Threading.SendOrPostCallback, $state: any) : void
            public OperationStarted () : void
            public OperationCompleted () : void
            public Wait ($waitHandles: System.Array$1<System.IntPtr>, $waitAll: boolean, $millisecondsTimeout: number) : number
            public static SetSynchronizationContext ($syncContext: System.Threading.SynchronizationContext) : void
            public CreateCopy () : System.Threading.SynchronizationContext
            public constructor ()
        }
        class Thread extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements System.Runtime.InteropServices._Thread
        {
            protected [__keep_incompatibility]: never;
            public get ExecutionContext(): System.Threading.ExecutionContext;
            public get Priority(): System.Threading.ThreadPriority;
            public set Priority(value: System.Threading.ThreadPriority);
            public get CurrentUICulture(): System.Globalization.CultureInfo;
            public set CurrentUICulture(value: System.Globalization.CultureInfo);
            public get CurrentCulture(): System.Globalization.CultureInfo;
            public set CurrentCulture(value: System.Globalization.CultureInfo);
            public static get CurrentContext(): System.Runtime.Remoting.Contexts.Context;
            public static get CurrentPrincipal(): System.Security.Principal.IPrincipal;
            public static set CurrentPrincipal(value: System.Security.Principal.IPrincipal);
            public static get CurrentThread(): System.Threading.Thread;
            public get IsThreadPoolThread(): boolean;
            public get IsAlive(): boolean;
            public get IsBackground(): boolean;
            public set IsBackground(value: boolean);
            public get Name(): string;
            public set Name(value: string);
            public get ThreadState(): System.Threading.ThreadState;
            public get ManagedThreadId(): number;
            public Start () : void
            public Start ($parameter: any) : void
            public static ResetAbort () : void
            public Interrupt () : void
            public Join () : void
            public Join ($millisecondsTimeout: number) : boolean
            public Join ($timeout: System.TimeSpan) : boolean
            public static Sleep ($millisecondsTimeout: number) : void
            public static Sleep ($timeout: System.TimeSpan) : void
            public static Yield () : boolean
            public static AllocateDataSlot () : System.LocalDataStoreSlot
            public static AllocateNamedDataSlot ($name: string) : System.LocalDataStoreSlot
            public static GetNamedDataSlot ($name: string) : System.LocalDataStoreSlot
            public static FreeNamedDataSlot ($name: string) : void
            public static GetData ($slot: System.LocalDataStoreSlot) : any
            public static SetData ($slot: System.LocalDataStoreSlot, $data: any) : void
            public static MemoryBarrier () : void
            public static GetDomain () : System.AppDomain
            public static GetDomainID () : number
            public Abort () : void
            public Abort ($stateInfo: any) : void
            public static SpinWait ($iterations: number) : void
            public static VolatileRead ($address: $Ref<number>) : number
            public static VolatileRead ($address: $Ref<bigint>) : bigint
            public static VolatileRead ($address: $Ref<System.IntPtr>) : System.IntPtr
            public static VolatileRead ($address: $Ref<any>) : any
            public static VolatileRead ($address: $Ref<System.UIntPtr>) : System.UIntPtr
            public static VolatileWrite ($address: $Ref<number>, $value: number) : void
            public static VolatileWrite ($address: $Ref<bigint>, $value: bigint) : void
            public static VolatileWrite ($address: $Ref<System.IntPtr>, $value: System.IntPtr) : void
            public static VolatileWrite ($address: $Ref<any>, $value: any) : void
            public static VolatileWrite ($address: $Ref<System.UIntPtr>, $value: System.UIntPtr) : void
            public static BeginCriticalRegion () : void
            public static EndCriticalRegion () : void
            public static BeginThreadAffinity () : void
            public static EndThreadAffinity () : void
            public GetApartmentState () : System.Threading.ApartmentState
            public SetApartmentState ($state: System.Threading.ApartmentState) : void
            public TrySetApartmentState ($state: System.Threading.ApartmentState) : boolean
            public DisableComObjectEagerCleanup () : void
            public static GetCurrentProcessorId () : number
            public constructor ($start: System.Threading.ThreadStart)
            public constructor ($start: System.Threading.ThreadStart, $maxStackSize: number)
            public constructor ($start: System.Threading.ParameterizedThreadStart)
            public constructor ($start: System.Threading.ParameterizedThreadStart, $maxStackSize: number)
            public GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            public GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            public GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            public Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
            public constructor ()
        }
        class CompressedStack extends System.Object implements System.Runtime.Serialization.ISerializable
        {
            protected [__keep_incompatibility]: never;
            public CreateCopy () : System.Threading.CompressedStack
            public static Capture () : System.Threading.CompressedStack
            public static GetCompressedStack () : System.Threading.CompressedStack
            public GetObjectData ($info: System.Runtime.Serialization.SerializationInfo, $context: System.Runtime.Serialization.StreamingContext) : void
            public static Run ($compressedStack: System.Threading.CompressedStack, $callback: System.Threading.ContextCallback, $state: any) : void
        }
        class ThreadAbortException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public get ExceptionState(): any;
        }
        class ThreadInterruptedException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        interface WaitCallback
        { 
        (state: any) : void; 
        Invoke?: (state: any) => void;
        }
        var WaitCallback: { new (func: (state: any) => void): WaitCallback; }
        interface WaitOrTimerCallback
        { 
        (state: any, timedOut: boolean) : void; 
        Invoke?: (state: any, timedOut: boolean) => void;
        }
        var WaitOrTimerCallback: { new (func: (state: any, timedOut: boolean) => void): WaitOrTimerCallback; }
        class ThreadPool extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static SetMaxThreads ($workerThreads: number, $completionPortThreads: number) : boolean
            public static GetMaxThreads ($workerThreads: $Ref<number>, $completionPortThreads: $Ref<number>) : void
            public static SetMinThreads ($workerThreads: number, $completionPortThreads: number) : boolean
            public static GetMinThreads ($workerThreads: $Ref<number>, $completionPortThreads: $Ref<number>) : void
            public static GetAvailableThreads ($workerThreads: $Ref<number>, $completionPortThreads: $Ref<number>) : void
            public static RegisterWaitForSingleObject ($waitObject: System.Threading.WaitHandle, $callBack: System.Threading.WaitOrTimerCallback, $state: any, $millisecondsTimeOutInterval: number, $executeOnlyOnce: boolean) : System.Threading.RegisteredWaitHandle
            public static UnsafeRegisterWaitForSingleObject ($waitObject: System.Threading.WaitHandle, $callBack: System.Threading.WaitOrTimerCallback, $state: any, $millisecondsTimeOutInterval: number, $executeOnlyOnce: boolean) : System.Threading.RegisteredWaitHandle
            public static RegisterWaitForSingleObject ($waitObject: System.Threading.WaitHandle, $callBack: System.Threading.WaitOrTimerCallback, $state: any, $millisecondsTimeOutInterval: bigint, $executeOnlyOnce: boolean) : System.Threading.RegisteredWaitHandle
            public static UnsafeRegisterWaitForSingleObject ($waitObject: System.Threading.WaitHandle, $callBack: System.Threading.WaitOrTimerCallback, $state: any, $millisecondsTimeOutInterval: bigint, $executeOnlyOnce: boolean) : System.Threading.RegisteredWaitHandle
            public static RegisterWaitForSingleObject ($waitObject: System.Threading.WaitHandle, $callBack: System.Threading.WaitOrTimerCallback, $state: any, $timeout: System.TimeSpan, $executeOnlyOnce: boolean) : System.Threading.RegisteredWaitHandle
            public static UnsafeRegisterWaitForSingleObject ($waitObject: System.Threading.WaitHandle, $callBack: System.Threading.WaitOrTimerCallback, $state: any, $timeout: System.TimeSpan, $executeOnlyOnce: boolean) : System.Threading.RegisteredWaitHandle
            public static QueueUserWorkItem ($callBack: System.Threading.WaitCallback, $state: any) : boolean
            public static QueueUserWorkItem ($callBack: System.Threading.WaitCallback) : boolean
            public static UnsafeQueueUserWorkItem ($callBack: System.Threading.WaitCallback, $state: any) : boolean
            public static BindHandle ($osHandle: System.Runtime.InteropServices.SafeHandle) : boolean
        }
        class RegisteredWaitHandle extends System.MarshalByRefObject
        {
            protected [__keep_incompatibility]: never;
            public Unregister ($waitObject: System.Threading.WaitHandle) : boolean
        }
        class WaitHandleExtensions extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static GetSafeWaitHandle ($waitHandle: System.Threading.WaitHandle) : Microsoft.Win32.SafeHandles.SafeWaitHandle
            public static SetSafeWaitHandle ($waitHandle: System.Threading.WaitHandle, $value: Microsoft.Win32.SafeHandles.SafeWaitHandle) : void
        }
        class HostExecutionContext extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public CreateCopy () : System.Threading.HostExecutionContext
            public Dispose () : void
            public Dispose ($disposing: boolean) : void
            public constructor ()
            public constructor ($state: any)
        }
        class Interlocked extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static CompareExchange ($location1: $Ref<number>, $value: number, $comparand: number) : number
            public static CompareExchange ($location1: $Ref<any>, $value: any, $comparand: any) : any
            public static Decrement ($location: $Ref<number>) : number
            public static Decrement ($location: $Ref<bigint>) : bigint
            public static Increment ($location: $Ref<number>) : number
            public static Increment ($location: $Ref<bigint>) : bigint
            public static Exchange ($location1: $Ref<number>, $value: number) : number
            public static Exchange ($location1: $Ref<any>, $value: any) : any
            public static CompareExchange ($location1: $Ref<bigint>, $value: bigint, $comparand: bigint) : bigint
            public static CompareExchange ($location1: $Ref<System.IntPtr>, $value: System.IntPtr, $comparand: System.IntPtr) : System.IntPtr
            public static Exchange ($location1: $Ref<bigint>, $value: bigint) : bigint
            public static Exchange ($location1: $Ref<System.IntPtr>, $value: System.IntPtr) : System.IntPtr
            public static Read ($location: $Ref<bigint>) : bigint
            public static Add ($location1: $Ref<number>, $value: number) : number
            public static Add ($location1: $Ref<bigint>, $value: bigint) : bigint
            public static MemoryBarrier () : void
            public static MemoryBarrierProcessWide () : void
            public static SpeculationBarrier () : void
        }
        class LockCookie extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public Equals ($obj: System.Threading.LockCookie) : boolean
            public Equals ($obj: any) : boolean
            public static op_Equality ($a: System.Threading.LockCookie, $b: System.Threading.LockCookie) : boolean
            public static op_Inequality ($a: System.Threading.LockCookie, $b: System.Threading.LockCookie) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
        }
        class Overlapped extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get AsyncResult(): System.IAsyncResult;
            public set AsyncResult(value: System.IAsyncResult);
            public get EventHandleIntPtr(): System.IntPtr;
            public set EventHandleIntPtr(value: System.IntPtr);
            public get OffsetHigh(): number;
            public set OffsetHigh(value: number);
            public get OffsetLow(): number;
            public set OffsetLow(value: number);
            public constructor ()
            public constructor ($offsetLo: number, $offsetHi: number, $hEvent: System.IntPtr, $ar: System.IAsyncResult)
        }
        class ReaderWriterLock extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject
        {
            protected [__keep_incompatibility]: never;
            public get IsReaderLockHeld(): boolean;
            public get IsWriterLockHeld(): boolean;
            public get WriterSeqNum(): number;
            public AcquireReaderLock ($millisecondsTimeout: number) : void
            public AcquireReaderLock ($timeout: System.TimeSpan) : void
            public AcquireWriterLock ($millisecondsTimeout: number) : void
            public AcquireWriterLock ($timeout: System.TimeSpan) : void
            public AnyWritersSince ($seqNum: number) : boolean
            public DowngradeFromWriterLock ($lockCookie: $Ref<System.Threading.LockCookie>) : void
            public ReleaseLock () : System.Threading.LockCookie
            public ReleaseReaderLock () : void
            public ReleaseWriterLock () : void
            public RestoreLock ($lockCookie: $Ref<System.Threading.LockCookie>) : void
            public UpgradeToWriterLock ($millisecondsTimeout: number) : System.Threading.LockCookie
            public UpgradeToWriterLock ($timeout: System.TimeSpan) : System.Threading.LockCookie
            public constructor ()
        }
        class Timer extends System.MarshalByRefObject implements System.IAsyncDisposable, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public Change ($dueTime: number, $period: number) : boolean
            public Change ($dueTime: System.TimeSpan, $period: System.TimeSpan) : boolean
            public Dispose () : void
            public Change ($dueTime: bigint, $period: bigint) : boolean
            public Dispose ($notifyObject: System.Threading.WaitHandle) : boolean
            public DisposeAsync () : System.Threading.Tasks.ValueTask
            public constructor ($callback: System.Threading.TimerCallback, $state: any, $dueTime: number, $period: number)
            public constructor ($callback: System.Threading.TimerCallback, $state: any, $dueTime: bigint, $period: bigint)
            public constructor ($callback: System.Threading.TimerCallback, $state: any, $dueTime: System.TimeSpan, $period: System.TimeSpan)
            public constructor ($callback: System.Threading.TimerCallback)
            public ConfigureAwait ($continueOnCapturedContext: boolean) : System.Runtime.CompilerServices.ConfiguredAsyncDisposable
            public constructor ()
        }
        interface TimerCallback
        { 
        (state: any) : void; 
        Invoke?: (state: any) => void;
        }
        var TimerCallback: { new (func: (state: any) => void): TimerCallback; }
        class Volatile extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static Read ($location: $Ref<boolean>) : boolean
            public static Write ($location: $Ref<boolean>, $value: boolean) : void
            public static Read ($location: $Ref<number>) : number
            public static Write ($location: $Ref<number>, $value: number) : void
            public static Read ($location: $Ref<System.IntPtr>) : System.IntPtr
            public static Write ($location: $Ref<System.IntPtr>, $value: System.IntPtr) : void
            public static Read ($location: $Ref<System.UIntPtr>) : System.UIntPtr
            public static Write ($location: $Ref<System.UIntPtr>, $value: System.UIntPtr) : void
            public static Read ($location: $Ref<bigint>) : bigint
            public static Write ($location: $Ref<bigint>, $value: bigint) : void
        }
    }
    namespace System.Runtime.CompilerServices {
        interface ITuple
        {
            Length : number
            get_Item ($index: number) : any
        }
        class ValueTaskAwaiter extends System.ValueType implements System.Runtime.CompilerServices.INotifyCompletion, System.Runtime.CompilerServices.ICriticalNotifyCompletion
        {
            protected [__keep_incompatibility]: never;
            public get IsCompleted(): boolean;
            public GetResult () : void
            public OnCompleted ($continuation: System.Action) : void
            public UnsafeOnCompleted ($continuation: System.Action) : void
        }
        interface INotifyCompletion
        {
        }
        interface ICriticalNotifyCompletion extends System.Runtime.CompilerServices.INotifyCompletion
        {
            UnsafeOnCompleted ($continuation: System.Action) : void
        }
        class ConfiguredValueTaskAwaitable extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public GetAwaiter () : System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable.ConfiguredValueTaskAwaiter
        }
        class ValueTaskAwaiter$1<TResult> extends System.ValueType implements System.Runtime.CompilerServices.INotifyCompletion, System.Runtime.CompilerServices.ICriticalNotifyCompletion
        {
            protected [__keep_incompatibility]: never;
            public get IsCompleted(): boolean;
            public GetResult () : TResult
            public OnCompleted ($continuation: System.Action) : void
            public UnsafeOnCompleted ($continuation: System.Action) : void
        }
        class ConfiguredValueTaskAwaitable$1<TResult> extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public GetAwaiter () : System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable$1.ConfiguredValueTaskAwaiter<TResult>
        }
        class TaskAwaiter$1<TResult> extends System.ValueType implements System.Runtime.CompilerServices.INotifyCompletion, System.Runtime.CompilerServices.ICriticalNotifyCompletion, System.Runtime.CompilerServices.ITaskAwaiter
        {
            protected [__keep_incompatibility]: never;
            public get IsCompleted(): boolean;
            public OnCompleted ($continuation: System.Action) : void
            public UnsafeOnCompleted ($continuation: System.Action) : void
            public GetResult () : TResult
        }
        interface ITaskAwaiter
        {
        }
        class ConfiguredTaskAwaitable$1<TResult> extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public GetAwaiter () : System.Runtime.CompilerServices.ConfiguredTaskAwaitable$1.ConfiguredTaskAwaiter<TResult>
        }
        class TaskAwaiter extends System.ValueType implements System.Runtime.CompilerServices.INotifyCompletion, System.Runtime.CompilerServices.ICriticalNotifyCompletion, System.Runtime.CompilerServices.ITaskAwaiter
        {
            protected [__keep_incompatibility]: never;
            public get IsCompleted(): boolean;
            public OnCompleted ($continuation: System.Action) : void
            public UnsafeOnCompleted ($continuation: System.Action) : void
            public GetResult () : void
        }
        class ConfiguredTaskAwaitable extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public GetAwaiter () : System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter
        }
        class YieldAwaitable extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public GetAwaiter () : System.Runtime.CompilerServices.YieldAwaitable.YieldAwaiter
        }
        class ConfiguredAsyncDisposable extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public DisposeAsync () : System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable
        }
        class ConfiguredCancelableAsyncEnumerable$1<T> extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public ConfigureAwait ($continueOnCapturedContext: boolean) : System.Runtime.CompilerServices.ConfiguredCancelableAsyncEnumerable$1<T>
            public WithCancellation ($cancellationToken: System.Threading.CancellationToken) : System.Runtime.CompilerServices.ConfiguredCancelableAsyncEnumerable$1<T>
            public GetAsyncEnumerator () : System.Runtime.CompilerServices.ConfiguredCancelableAsyncEnumerable$1.Enumerator<T>
        }
        class AccessedThroughPropertyAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get PropertyName(): string;
            public constructor ($propertyName: string)
            public constructor ()
        }
        class AsyncIteratorMethodBuilder extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public static Create () : System.Runtime.CompilerServices.AsyncIteratorMethodBuilder
            public Complete () : void
        }
        interface IAsyncStateMachine
        {
            MoveNext () : void
            SetStateMachine ($stateMachine: System.Runtime.CompilerServices.IAsyncStateMachine) : void
        }
        class StateMachineAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get StateMachineType(): System.Type;
            public constructor ($stateMachineType: System.Type)
            public constructor ()
        }
        class AsyncIteratorStateMachineAttribute extends System.Runtime.CompilerServices.StateMachineAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ($stateMachineType: System.Type)
        }
        class AsyncMethodBuilderAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get BuilderType(): System.Type;
            public constructor ($builderType: System.Type)
            public constructor ()
        }
        class AsyncStateMachineAttribute extends System.Runtime.CompilerServices.StateMachineAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ($stateMachineType: System.Type)
        }
        class AsyncValueTaskMethodBuilder extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get Task(): System.Threading.Tasks.ValueTask;
            public static Create () : System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder
            public SetStateMachine ($stateMachine: System.Runtime.CompilerServices.IAsyncStateMachine) : void
            public SetResult () : void
            public SetException ($exception: System.Exception) : void
        }
        class AsyncValueTaskMethodBuilder$1<TResult> extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get Task(): System.Threading.Tasks.ValueTask$1<TResult>;
            public static Create () : any
            public SetStateMachine ($stateMachine: System.Runtime.CompilerServices.IAsyncStateMachine) : void
            public SetResult ($result: TResult) : void
            public SetException ($exception: System.Exception) : void
        }
        class CallerFilePathAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class CallerLineNumberAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class CallerMemberNameAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class CompilerGeneratedAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class CompilerGlobalScopeAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class CustomConstantAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Value(): any;
        }
        class DateTimeConstantAttribute extends System.Runtime.CompilerServices.CustomConstantAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Value(): any;
            public constructor ($ticks: bigint)
            public constructor ()
        }
        class DecimalConstantAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Value(): System.Decimal;
            public constructor ($scale: number, $sign: number, $hi: number, $mid: number, $low: number)
            public constructor ()
        }
        class DisablePrivateReflectionAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class DiscardableAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class ExtensionAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class FixedAddressValueTypeAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class FixedBufferAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get ElementType(): System.Type;
            public get Length(): number;
            public constructor ($elementType: System.Type, $length: number)
            public constructor ()
        }
        class FormattableStringFactory extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static Create ($format: string, ...arguments: any[]) : System.FormattableString
        }
        class IndexerNameAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ($indexerName: string)
            public constructor ()
        }
        class IsByRefLikeAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class IsConst extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class IsReadOnlyAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class IsVolatile extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class IteratorStateMachineAttribute extends System.Runtime.CompilerServices.StateMachineAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ($stateMachineType: System.Type)
        }
        class ReferenceAssemblyAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Description(): string;
            public constructor ()
            public constructor ($description: string)
        }
        class RuntimeCompatibilityAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get WrapNonExceptionThrows(): boolean;
            public set WrapNonExceptionThrows(value: boolean);
            public constructor ()
        }
        class RuntimeFeature extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static PortablePdb : string
            public static DefaultImplementationsOfInterfaces : string
            public static get IsDynamicCodeSupported(): boolean;
            public static get IsDynamicCodeCompiled(): boolean;
            public static IsSupported ($feature: string) : boolean
        }
        class RuntimeWrappedException extends System.Exception implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public get WrappedException(): any;
            public constructor ($thrownObject: any)
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class SpecialNameAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class StringFreezingAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class SuppressIldasmAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class TupleElementNamesAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get TransformNames(): System.Collections.Generic.IList$1<string>;
            public constructor ($transformNames: System.Array$1<string>)
            public constructor ()
        }
        class TypeForwardedFromAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get AssemblyFullName(): string;
            public constructor ($assemblyFullName: string)
            public constructor ()
        }
        class TypeForwardedToAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Destination(): System.Type;
            public constructor ($destination: System.Type)
            public constructor ()
        }
        class UnsafeValueTypeAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        interface IConfiguredTaskAwaiter
        {
        }
        class ContractHelper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static RaiseContractFailedEvent ($failureKind: System.Diagnostics.Contracts.ContractFailureKind, $userMessage: string, $conditionText: string, $innerException: System.Exception) : string
            public static TriggerFailure ($kind: System.Diagnostics.Contracts.ContractFailureKind, $displayMessage: string, $userMessage: string, $conditionText: string, $innerException: System.Exception) : void
        }
        class AsyncVoidMethodBuilder extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public static Create () : System.Runtime.CompilerServices.AsyncVoidMethodBuilder
            public SetStateMachine ($stateMachine: System.Runtime.CompilerServices.IAsyncStateMachine) : void
            public SetResult () : void
            public SetException ($exception: System.Exception) : void
        }
        class AsyncTaskMethodBuilder extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get Task(): $Task<any>;
            public static Create () : System.Runtime.CompilerServices.AsyncTaskMethodBuilder
            public SetStateMachine ($stateMachine: System.Runtime.CompilerServices.IAsyncStateMachine) : void
            public SetResult () : void
            public SetException ($exception: System.Exception) : void
        }
        class AsyncTaskMethodBuilder$1<TResult> extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get Task(): System.Threading.Tasks.Task$1<TResult>;
            public static Create () : any
            public SetStateMachine ($stateMachine: System.Runtime.CompilerServices.IAsyncStateMachine) : void
            public SetResult ($result: TResult) : void
            public SetException ($exception: System.Exception) : void
        }
        enum LoadHint
        { Default = 0, Always = 1, Sometimes = 2 }
        class DefaultDependencyAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get LoadHint(): System.Runtime.CompilerServices.LoadHint;
            public constructor ($loadHintArgument: System.Runtime.CompilerServices.LoadHint)
            public constructor ()
        }
        class DependencyAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get DependentAssembly(): string;
            public get LoadHint(): System.Runtime.CompilerServices.LoadHint;
            public constructor ($dependentAssemblyArgument: string, $loadHintArgument: System.Runtime.CompilerServices.LoadHint)
            public constructor ()
        }
        class CallConvCdecl extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class CallConvStdcall extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class CallConvThiscall extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class CallConvFastcall extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        enum CompilationRelaxations
        { NoStringInterning = 8 }
        class CompilationRelaxationsAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get CompilationRelaxations(): number;
            public constructor ($relaxations: number)
            public constructor ($relaxations: System.Runtime.CompilerServices.CompilationRelaxations)
            public constructor ()
        }
        class CompilerMarshalOverride extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class HasCopySemanticsAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class IDispatchConstantAttribute extends System.Runtime.CompilerServices.CustomConstantAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Value(): any;
            public constructor ()
        }
        class InternalsVisibleToAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get AssemblyName(): string;
            public get AllInternalsVisible(): boolean;
            public set AllInternalsVisible(value: boolean);
            public constructor ($assemblyName: string)
            public constructor ()
        }
        class IsBoxed extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class IsByValue extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class IsCopyConstructed extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class IsExplicitlyDereferenced extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class IsImplicitlyDereferenced extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class IsJitIntrinsic extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class IsLong extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class IsPinned extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class IsSignUnspecifiedByte extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class IsUdtReturn extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class IUnknownConstantAttribute extends System.Runtime.CompilerServices.CustomConstantAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Value(): any;
            public constructor ()
        }
        enum MethodImplOptions
        { Unmanaged = 4, ForwardRef = 16, PreserveSig = 128, InternalCall = 4096, Synchronized = 32, NoInlining = 8, AggressiveInlining = 256, NoOptimization = 64, SecurityMitigations = 1024 }
        enum MethodCodeType
        { IL = 0, Native = 1, OPTIL = 2, Runtime = 3 }
        class MethodImplAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public MethodCodeType : System.Runtime.CompilerServices.MethodCodeType
            public get Value(): System.Runtime.CompilerServices.MethodImplOptions;
            public constructor ($methodImplOptions: System.Runtime.CompilerServices.MethodImplOptions)
            public constructor ($value: number)
            public constructor ()
        }
        class NativeCppClassAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class RequiredAttributeAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get RequiredContract(): System.Type;
            public constructor ($requiredContract: System.Type)
            public constructor ()
        }
        class ScopelessEnumAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class ConditionalWeakTable$2<TKey, TValue> extends System.Object implements System.Collections.Generic.IEnumerable$1<System.Collections.Generic.KeyValuePair$2<TKey, TValue>>, System.Collections.IEnumerable
        {
            protected [__keep_incompatibility]: never;
            public AddOrUpdate ($key: TKey, $value: TValue) : void
            public Add ($key: TKey, $value: TValue) : void
            public Remove ($key: TKey) : boolean
            public TryGetValue ($key: TKey, $value: $Ref<TValue>) : boolean
            public GetOrCreateValue ($key: TKey) : TValue
            public GetValue ($key: TKey, $createValueCallback: System.Runtime.CompilerServices.ConditionalWeakTable$2.CreateValueCallback<TKey, TValue>) : TValue
            public Clear () : void
            public constructor ()
            public GetEnumerator () : System.Collections.IEnumerator
            public [Symbol.iterator]() : IterableIterator<System.Collections.Generic.KeyValuePair$2<TKey, TValue>>
        }
        class RuntimeHelpers extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get OffsetToStringData(): number;
            public static InitializeArray ($array: System.Array, $fldHandle: System.RuntimeFieldHandle) : void
            public static GetHashCode ($o: any) : number
            public static Equals ($o1: any, $o2: any) : boolean
            public static GetObjectValue ($obj: any) : any
            public static RunClassConstructor ($type: System.RuntimeTypeHandle) : void
            public static EnsureSufficientExecutionStack () : void
            public static TryEnsureSufficientExecutionStack () : boolean
            public static ExecuteCodeWithGuaranteedCleanup ($code: System.Runtime.CompilerServices.RuntimeHelpers.TryCode, $backoutCode: System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode, $userData: any) : void
            public static PrepareConstrainedRegions () : void
            public static PrepareConstrainedRegionsNoOP () : void
            public static ProbeForSufficientStack () : void
            public static PrepareDelegate ($d: Function) : void
            public static PrepareContractedDelegate ($d: Function) : void
            public static PrepareMethod ($method: System.RuntimeMethodHandle) : void
            public static PrepareMethod ($method: System.RuntimeMethodHandle, $instantiation: System.Array$1<System.RuntimeTypeHandle>) : void
            public static RunModuleConstructor ($module: System.ModuleHandle) : void
            public static GetUninitializedObject ($type: System.Type) : any
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
            public GetHashCode () : number
        }
        class EnumeratorCancellationAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class SwitchExpressionException extends System.InvalidOperationException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public get UnmatchedValue(): any;
            public get Message(): string;
            public constructor ()
            public constructor ($innerException: System.Exception)
            public constructor ($unmatchedValue: any)
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
    }
    namespace System.ReadOnlySpan$1 {
        class Enumerator<T> extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get Current(): $Ref<T>;
            public MoveNext () : boolean
        }
    }
    namespace System.Span$1 {
        class Enumerator<T> extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get Current(): $Ref<T>;
            public MoveNext () : boolean
        }
    }
    namespace System.Runtime.Remoting {
        class ObjectHandle extends System.MarshalByRefObject implements System.Runtime.Remoting.IObjectHandle
        {
            protected [__keep_incompatibility]: never;
            public Unwrap () : any
            public constructor ($o: any)
            public constructor ()
        }
        interface IObjectHandle
        {
            Unwrap () : any
        }
        class ObjRef extends System.Object implements System.Runtime.Serialization.IObjectReference, System.Runtime.Serialization.ISerializable
        {
            protected [__keep_incompatibility]: never;
            public get ChannelInfo(): System.Runtime.Remoting.IChannelInfo;
            public set ChannelInfo(value: System.Runtime.Remoting.IChannelInfo);
            public get EnvoyInfo(): System.Runtime.Remoting.IEnvoyInfo;
            public set EnvoyInfo(value: System.Runtime.Remoting.IEnvoyInfo);
            public get TypeInfo(): System.Runtime.Remoting.IRemotingTypeInfo;
            public set TypeInfo(value: System.Runtime.Remoting.IRemotingTypeInfo);
            public get URI(): string;
            public set URI(value: string);
            public GetObjectData ($info: System.Runtime.Serialization.SerializationInfo, $context: System.Runtime.Serialization.StreamingContext) : void
            public GetRealObject ($context: System.Runtime.Serialization.StreamingContext) : any
            public IsFromThisAppDomain () : boolean
            public IsFromThisProcess () : boolean
            public constructor ()
            public constructor ($o: System.MarshalByRefObject, $requestedType: System.Type)
        }
        class TypeEntry extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get AssemblyName(): string;
            public set AssemblyName(value: string);
            public get TypeName(): string;
            public set TypeName(value: string);
        }
        class ActivatedClientTypeEntry extends System.Runtime.Remoting.TypeEntry
        {
            protected [__keep_incompatibility]: never;
            public get ApplicationUrl(): string;
            public get ContextAttributes(): System.Array$1<System.Runtime.Remoting.Contexts.IContextAttribute>;
            public set ContextAttributes(value: System.Array$1<System.Runtime.Remoting.Contexts.IContextAttribute>);
            public get ObjectType(): System.Type;
            public constructor ($type: System.Type, $appUrl: string)
            public constructor ($typeName: string, $assemblyName: string, $appUrl: string)
            public constructor ()
        }
        class ActivatedServiceTypeEntry extends System.Runtime.Remoting.TypeEntry
        {
            protected [__keep_incompatibility]: never;
            public get ContextAttributes(): System.Array$1<System.Runtime.Remoting.Contexts.IContextAttribute>;
            public set ContextAttributes(value: System.Array$1<System.Runtime.Remoting.Contexts.IContextAttribute>);
            public get ObjectType(): System.Type;
            public constructor ($type: System.Type)
            public constructor ($typeName: string, $assemblyName: string)
            public constructor ()
        }
        enum CustomErrorsModes
        { On = 0, Off = 1, RemoteOnly = 2 }
        interface IChannelInfo
        {
            ChannelData : System.Array$1<any>
        }
        interface IEnvoyInfo
        {
            EnvoySinks : System.Runtime.Remoting.Messaging.IMessageSink
        }
        interface IRemotingTypeInfo
        {
            TypeName : string
            CanCastTo ($fromType: System.Type, $o: any) : boolean
        }
        class InternalRemotingServices extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static DebugOutChnl ($s: string) : void
            public static GetCachedSoapAttribute ($reflectionObject: any) : System.Runtime.Remoting.Metadata.SoapAttribute
            public static RemotingAssert ($condition: boolean, $message: string) : void
            public static RemotingTrace (...messages: any[]) : void
            public static SetServerIdentity ($m: System.Runtime.Remoting.Messaging.MethodCall, $srvID: any) : void
            public constructor ()
        }
        class RemotingConfiguration extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get ApplicationId(): string;
            public static get ApplicationName(): string;
            public static set ApplicationName(value: string);
            public static get CustomErrorsMode(): System.Runtime.Remoting.CustomErrorsModes;
            public static set CustomErrorsMode(value: System.Runtime.Remoting.CustomErrorsModes);
            public static get ProcessId(): string;
            public static Configure ($filename: string, $ensureSecurity: boolean) : void
            public static GetRegisteredActivatedClientTypes () : System.Array$1<System.Runtime.Remoting.ActivatedClientTypeEntry>
            public static GetRegisteredActivatedServiceTypes () : System.Array$1<System.Runtime.Remoting.ActivatedServiceTypeEntry>
            public static GetRegisteredWellKnownClientTypes () : System.Array$1<System.Runtime.Remoting.WellKnownClientTypeEntry>
            public static GetRegisteredWellKnownServiceTypes () : System.Array$1<System.Runtime.Remoting.WellKnownServiceTypeEntry>
            public static IsActivationAllowed ($svrType: System.Type) : boolean
            public static IsRemotelyActivatedClientType ($svrType: System.Type) : System.Runtime.Remoting.ActivatedClientTypeEntry
            public static IsRemotelyActivatedClientType ($typeName: string, $assemblyName: string) : System.Runtime.Remoting.ActivatedClientTypeEntry
            public static IsWellKnownClientType ($svrType: System.Type) : System.Runtime.Remoting.WellKnownClientTypeEntry
            public static IsWellKnownClientType ($typeName: string, $assemblyName: string) : System.Runtime.Remoting.WellKnownClientTypeEntry
            public static RegisterActivatedClientType ($entry: System.Runtime.Remoting.ActivatedClientTypeEntry) : void
            public static RegisterActivatedClientType ($type: System.Type, $appUrl: string) : void
            public static RegisterActivatedServiceType ($entry: System.Runtime.Remoting.ActivatedServiceTypeEntry) : void
            public static RegisterActivatedServiceType ($type: System.Type) : void
            public static RegisterWellKnownClientType ($type: System.Type, $objectUrl: string) : void
            public static RegisterWellKnownClientType ($entry: System.Runtime.Remoting.WellKnownClientTypeEntry) : void
            public static RegisterWellKnownServiceType ($type: System.Type, $objectUri: string, $mode: System.Runtime.Remoting.WellKnownObjectMode) : void
            public static RegisterWellKnownServiceType ($entry: System.Runtime.Remoting.WellKnownServiceTypeEntry) : void
            public static CustomErrorsEnabled ($isLocalRequest: boolean) : boolean
        }
        class WellKnownClientTypeEntry extends System.Runtime.Remoting.TypeEntry
        {
            protected [__keep_incompatibility]: never;
            public get ApplicationUrl(): string;
            public set ApplicationUrl(value: string);
            public get ObjectType(): System.Type;
            public get ObjectUrl(): string;
            public constructor ($type: System.Type, $objectUrl: string)
            public constructor ($typeName: string, $assemblyName: string, $objectUrl: string)
            public constructor ()
        }
        class WellKnownServiceTypeEntry extends System.Runtime.Remoting.TypeEntry
        {
            protected [__keep_incompatibility]: never;
            public get ContextAttributes(): System.Array$1<System.Runtime.Remoting.Contexts.IContextAttribute>;
            public set ContextAttributes(value: System.Array$1<System.Runtime.Remoting.Contexts.IContextAttribute>);
            public get Mode(): System.Runtime.Remoting.WellKnownObjectMode;
            public get ObjectType(): System.Type;
            public get ObjectUri(): string;
            public constructor ($type: System.Type, $objectUri: string, $mode: System.Runtime.Remoting.WellKnownObjectMode)
            public constructor ($typeName: string, $assemblyName: string, $objectUri: string, $mode: System.Runtime.Remoting.WellKnownObjectMode)
            public constructor ()
        }
        enum WellKnownObjectMode
        { Singleton = 1, SingleCall = 2 }
        class RemotingException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $InnerException: System.Exception)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class RemotingServices extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static IsTransparentProxy ($proxy: any) : boolean
            public static ExecuteMessage ($target: System.MarshalByRefObject, $reqMsg: System.Runtime.Remoting.Messaging.IMethodCallMessage) : System.Runtime.Remoting.Messaging.IMethodReturnMessage
            public static Connect ($classToProxy: System.Type, $url: string) : any
            public static Connect ($classToProxy: System.Type, $url: string, $data: any) : any
            public static Disconnect ($obj: System.MarshalByRefObject) : boolean
            public static GetServerTypeForUri ($URI: string) : System.Type
            public static GetObjectUri ($obj: System.MarshalByRefObject) : string
            public static Unmarshal ($objectRef: System.Runtime.Remoting.ObjRef) : any
            public static Unmarshal ($objectRef: System.Runtime.Remoting.ObjRef, $fRefine: boolean) : any
            public static Marshal ($Obj: System.MarshalByRefObject) : System.Runtime.Remoting.ObjRef
            public static Marshal ($Obj: System.MarshalByRefObject, $URI: string) : System.Runtime.Remoting.ObjRef
            public static Marshal ($Obj: System.MarshalByRefObject, $ObjURI: string, $RequestedType: System.Type) : System.Runtime.Remoting.ObjRef
            public static GetRealProxy ($proxy: any) : System.Runtime.Remoting.Proxies.RealProxy
            public static GetMethodBaseFromMethodMessage ($msg: System.Runtime.Remoting.Messaging.IMethodMessage) : System.Reflection.MethodBase
            public static GetObjectData ($obj: any, $info: System.Runtime.Serialization.SerializationInfo, $context: System.Runtime.Serialization.StreamingContext) : void
            public static GetObjRefForProxy ($obj: System.MarshalByRefObject) : System.Runtime.Remoting.ObjRef
            public static GetLifetimeService ($obj: System.MarshalByRefObject) : any
            public static GetEnvoyChainForProxy ($obj: System.MarshalByRefObject) : System.Runtime.Remoting.Messaging.IMessageSink
            public static GetSessionIdForMethodMessage ($msg: System.Runtime.Remoting.Messaging.IMethodMessage) : string
            public static IsMethodOverloaded ($msg: System.Runtime.Remoting.Messaging.IMethodMessage) : boolean
            public static IsObjectOutOfAppDomain ($tp: any) : boolean
            public static IsObjectOutOfContext ($tp: any) : boolean
            public static IsOneWay ($method: System.Reflection.MethodBase) : boolean
            public static SetObjectUriForMarshal ($obj: System.MarshalByRefObject, $uri: string) : void
        }
        class RemotingTimeoutException extends System.Runtime.Remoting.RemotingException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $InnerException: System.Exception)
        }
        class ServerException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $InnerException: System.Exception)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class SoapServices extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get XmlNsForClrType(): string;
            public static get XmlNsForClrTypeWithAssembly(): string;
            public static get XmlNsForClrTypeWithNs(): string;
            public static get XmlNsForClrTypeWithNsAndAssembly(): string;
            public static CodeXmlNamespaceForClrTypeNamespace ($typeNamespace: string, $assemblyName: string) : string
            public static DecodeXmlNamespaceForClrTypeNamespace ($inNamespace: string, $typeNamespace: $Ref<string>, $assemblyName: $Ref<string>) : boolean
            public static GetInteropFieldTypeAndNameFromXmlAttribute ($containingType: System.Type, $xmlAttribute: string, $xmlNamespace: string, $type: $Ref<System.Type>, $name: $Ref<string>) : void
            public static GetInteropFieldTypeAndNameFromXmlElement ($containingType: System.Type, $xmlElement: string, $xmlNamespace: string, $type: $Ref<System.Type>, $name: $Ref<string>) : void
            public static GetInteropTypeFromXmlElement ($xmlElement: string, $xmlNamespace: string) : System.Type
            public static GetInteropTypeFromXmlType ($xmlType: string, $xmlTypeNamespace: string) : System.Type
            public static GetSoapActionFromMethodBase ($mb: System.Reflection.MethodBase) : string
            public static GetTypeAndMethodNameFromSoapAction ($soapAction: string, $typeName: $Ref<string>, $methodName: $Ref<string>) : boolean
            public static GetXmlElementForInteropType ($type: System.Type, $xmlElement: $Ref<string>, $xmlNamespace: $Ref<string>) : boolean
            public static GetXmlNamespaceForMethodCall ($mb: System.Reflection.MethodBase) : string
            public static GetXmlNamespaceForMethodResponse ($mb: System.Reflection.MethodBase) : string
            public static GetXmlTypeForInteropType ($type: System.Type, $xmlType: $Ref<string>, $xmlTypeNamespace: $Ref<string>) : boolean
            public static IsClrTypeNamespace ($namespaceString: string) : boolean
            public static IsSoapActionValidForMethodBase ($soapAction: string, $mb: System.Reflection.MethodBase) : boolean
            public static PreLoad ($assembly: System.Reflection.Assembly) : void
            public static PreLoad ($type: System.Type) : void
            public static RegisterInteropXmlElement ($xmlElement: string, $xmlNamespace: string, $type: System.Type) : void
            public static RegisterInteropXmlType ($xmlType: string, $xmlTypeNamespace: string, $type: System.Type) : void
            public static RegisterSoapActionForMethodBase ($mb: System.Reflection.MethodBase) : void
            public static RegisterSoapActionForMethodBase ($mb: System.Reflection.MethodBase, $soapAction: string) : void
        }
    }
    namespace System.Security.Policy {
        class Evidence extends System.Object implements System.Collections.ICollection, System.Collections.IEnumerable
        {
            protected [__keep_incompatibility]: never;
            public get IsReadOnly(): boolean;
            public get IsSynchronized(): boolean;
            public get Locked(): boolean;
            public set Locked(value: boolean);
            public get SyncRoot(): any;
            public get Count(): number;
            public Clear () : void
            public Clone () : System.Security.Policy.Evidence
            public GetAssemblyEnumerator () : System.Collections.IEnumerator
            public GetHostEnumerator () : System.Collections.IEnumerator
            public Merge ($evidence: System.Security.Policy.Evidence) : void
            public RemoveType ($t: System.Type) : void
            public constructor ()
            public constructor ($evidence: System.Security.Policy.Evidence)
            public constructor ($hostEvidence: System.Array$1<System.Security.Policy.EvidenceBase>, $assemblyEvidence: System.Array$1<System.Security.Policy.EvidenceBase>)
            public CopyTo ($array: System.Array, $index: number) : void
            public GetEnumerator () : System.Collections.IEnumerator
        }
        class PolicyLevel extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get Label(): string;
            public get NamedPermissionSets(): System.Collections.IList;
            public get RootCodeGroup(): System.Security.Policy.CodeGroup;
            public set RootCodeGroup(value: System.Security.Policy.CodeGroup);
            public get StoreLocation(): string;
            public get Type(): System.Security.PolicyLevelType;
            public AddNamedPermissionSet ($permSet: System.Security.NamedPermissionSet) : void
            public ChangeNamedPermissionSet ($name: string, $pSet: System.Security.PermissionSet) : System.Security.NamedPermissionSet
            public static CreateAppDomainLevel () : System.Security.Policy.PolicyLevel
            public FromXml ($e: System.Security.SecurityElement) : void
            public GetNamedPermissionSet ($name: string) : System.Security.NamedPermissionSet
            public Recover () : void
            public RemoveNamedPermissionSet ($permSet: System.Security.NamedPermissionSet) : System.Security.NamedPermissionSet
            public RemoveNamedPermissionSet ($name: string) : System.Security.NamedPermissionSet
            public Reset () : void
            public Resolve ($evidence: System.Security.Policy.Evidence) : System.Security.Policy.PolicyStatement
            public ResolveMatchingCodeGroups ($evidence: System.Security.Policy.Evidence) : System.Security.Policy.CodeGroup
            public ToXml () : System.Security.SecurityElement
        }
        class EvidenceBase extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public Clone () : System.Security.Policy.EvidenceBase
        }
        class ApplicationTrust extends System.Security.Policy.EvidenceBase implements System.Security.ISecurityEncodable
        {
            protected [__keep_incompatibility]: never;
            public get ApplicationIdentity(): System.ApplicationIdentity;
            public set ApplicationIdentity(value: System.ApplicationIdentity);
            public get DefaultGrantSet(): System.Security.Policy.PolicyStatement;
            public set DefaultGrantSet(value: System.Security.Policy.PolicyStatement);
            public get ExtraInfo(): any;
            public set ExtraInfo(value: any);
            public get IsApplicationTrustedToRun(): boolean;
            public set IsApplicationTrustedToRun(value: boolean);
            public get Persist(): boolean;
            public set Persist(value: boolean);
            public get FullTrustAssemblies(): System.Collections.Generic.IList$1<System.Security.Policy.StrongName>;
            public FromXml ($element: System.Security.SecurityElement) : void
            public ToXml () : System.Security.SecurityElement
            public constructor ()
            public constructor ($applicationIdentity: System.ApplicationIdentity)
            public constructor ($defaultGrantSet: System.Security.PermissionSet, $fullTrustAssemblies: System.Collections.Generic.IEnumerable$1<System.Security.Policy.StrongName>)
            public FromXml ($e: System.Security.SecurityElement) : void
        }
        class StrongName extends System.Security.Policy.EvidenceBase implements System.Security.Policy.IIdentityPermissionFactory, System.Security.Policy.IBuiltInEvidence
        {
            protected [__keep_incompatibility]: never;
            public get Name(): string;
            public get PublicKey(): System.Security.Permissions.StrongNamePublicKeyBlob;
            public get Version(): System.Version;
            public Copy () : any
            public CreateIdentityPermission ($evidence: System.Security.Policy.Evidence) : System.Security.IPermission
            public constructor ($blob: System.Security.Permissions.StrongNamePublicKeyBlob, $name: string, $version: System.Version)
            public constructor ()
        }
        interface IIdentityPermissionFactory
        {
            CreateIdentityPermission ($evidence: System.Security.Policy.Evidence) : System.Security.IPermission
        }
        interface IBuiltInEvidence
        {
        }
        class TrustManagerContext extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get IgnorePersistedDecision(): boolean;
            public set IgnorePersistedDecision(value: boolean);
            public get KeepAlive(): boolean;
            public set KeepAlive(value: boolean);
            public get NoPrompt(): boolean;
            public set NoPrompt(value: boolean);
            public get Persist(): boolean;
            public set Persist(value: boolean);
            public get PreviousApplicationIdentity(): System.ApplicationIdentity;
            public set PreviousApplicationIdentity(value: System.ApplicationIdentity);
            public get UIContext(): System.Security.Policy.TrustManagerUIContext;
            public set UIContext(value: System.Security.Policy.TrustManagerUIContext);
            public constructor ()
            public constructor ($uiContext: System.Security.Policy.TrustManagerUIContext)
        }
        enum ApplicationVersionMatch
        { MatchAllVersions = 1, MatchExactVersion = 0 }
        interface IMembershipCondition extends System.Security.ISecurityEncodable, System.Security.ISecurityPolicyEncodable
        {
            Check ($evidence: System.Security.Policy.Evidence) : boolean
            Copy () : System.Security.Policy.IMembershipCondition
            Equals ($obj: any) : boolean
            ToString () : string
            FromXml ($e: System.Security.SecurityElement) : void
            ToXml () : System.Security.SecurityElement
            FromXml ($e: System.Security.SecurityElement, $level: System.Security.Policy.PolicyLevel) : void
            ToXml ($level: System.Security.Policy.PolicyLevel) : System.Security.SecurityElement
        }
        enum PolicyStatementAttribute
        { All = 3, Exclusive = 1, LevelFinal = 2, Nothing = 0 }
        class Publisher extends System.Security.Policy.EvidenceBase implements System.Security.Policy.IIdentityPermissionFactory
        {
            protected [__keep_incompatibility]: never;
            public get Certificate(): System.Security.Cryptography.X509Certificates.X509Certificate;
            public Copy () : any
            public CreateIdentityPermission ($evidence: System.Security.Policy.Evidence) : System.Security.IPermission
            public constructor ($cert: System.Security.Cryptography.X509Certificates.X509Certificate)
            public constructor ()
        }
        class PublisherMembershipCondition extends System.Object implements System.Security.Policy.IMembershipCondition, System.Security.ISecurityEncodable, System.Security.ISecurityPolicyEncodable
        {
            protected [__keep_incompatibility]: never;
            public get Certificate(): System.Security.Cryptography.X509Certificates.X509Certificate;
            public set Certificate(value: System.Security.Cryptography.X509Certificates.X509Certificate);
            public Check ($evidence: System.Security.Policy.Evidence) : boolean
            public Copy () : System.Security.Policy.IMembershipCondition
            public FromXml ($e: System.Security.SecurityElement) : void
            public FromXml ($e: System.Security.SecurityElement, $level: System.Security.Policy.PolicyLevel) : void
            public ToXml () : System.Security.SecurityElement
            public ToXml ($level: System.Security.Policy.PolicyLevel) : System.Security.SecurityElement
            public constructor ($certificate: System.Security.Cryptography.X509Certificates.X509Certificate)
            public constructor ()
        }
        class AllMembershipCondition extends System.Object implements System.Security.Policy.IConstantMembershipCondition, System.Security.Policy.IMembershipCondition, System.Security.ISecurityEncodable, System.Security.ISecurityPolicyEncodable
        {
            protected [__keep_incompatibility]: never;
            public Check ($evidence: System.Security.Policy.Evidence) : boolean
            public Copy () : System.Security.Policy.IMembershipCondition
            public FromXml ($e: System.Security.SecurityElement) : void
            public FromXml ($e: System.Security.SecurityElement, $level: System.Security.Policy.PolicyLevel) : void
            public ToXml () : System.Security.SecurityElement
            public ToXml ($level: System.Security.Policy.PolicyLevel) : System.Security.SecurityElement
            public constructor ()
        }
        interface IConstantMembershipCondition
        {
        }
        class ApplicationDirectory extends System.Security.Policy.EvidenceBase implements System.Security.Policy.IBuiltInEvidence
        {
            protected [__keep_incompatibility]: never;
            public get Directory(): string;
            public Copy () : any
            public constructor ($name: string)
            public constructor ()
        }
        class ApplicationDirectoryMembershipCondition extends System.Object implements System.Security.Policy.IConstantMembershipCondition, System.Security.Policy.IMembershipCondition, System.Security.ISecurityEncodable, System.Security.ISecurityPolicyEncodable
        {
            protected [__keep_incompatibility]: never;
            public Check ($evidence: System.Security.Policy.Evidence) : boolean
            public Copy () : System.Security.Policy.IMembershipCondition
            public FromXml ($e: System.Security.SecurityElement) : void
            public FromXml ($e: System.Security.SecurityElement, $level: System.Security.Policy.PolicyLevel) : void
            public ToXml () : System.Security.SecurityElement
            public ToXml ($level: System.Security.Policy.PolicyLevel) : System.Security.SecurityElement
            public constructor ()
        }
        class ApplicationSecurityInfo extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get ApplicationEvidence(): System.Security.Policy.Evidence;
            public set ApplicationEvidence(value: System.Security.Policy.Evidence);
            public get ApplicationId(): System.ApplicationId;
            public set ApplicationId(value: System.ApplicationId);
            public get DefaultRequestSet(): System.Security.PermissionSet;
            public set DefaultRequestSet(value: System.Security.PermissionSet);
            public get DeploymentId(): System.ApplicationId;
            public set DeploymentId(value: System.ApplicationId);
            public constructor ($activationContext: System.ActivationContext)
            public constructor ()
        }
        class ApplicationSecurityManager extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get ApplicationTrustManager(): System.Security.Policy.IApplicationTrustManager;
            public static get UserApplicationTrusts(): System.Security.Policy.ApplicationTrustCollection;
            public static DetermineApplicationTrust ($activationContext: System.ActivationContext, $context: System.Security.Policy.TrustManagerContext) : boolean
        }
        interface IApplicationTrustManager extends System.Security.ISecurityEncodable
        {
            DetermineApplicationTrust ($activationContext: System.ActivationContext, $context: System.Security.Policy.TrustManagerContext) : System.Security.Policy.ApplicationTrust
            FromXml ($e: System.Security.SecurityElement) : void
            ToXml () : System.Security.SecurityElement
        }
        class ApplicationTrustCollection extends System.Object implements System.Collections.ICollection, System.Collections.IEnumerable
        {
            protected [__keep_incompatibility]: never;
            public get Count(): number;
            public get IsSynchronized(): boolean;
            public get SyncRoot(): any;
            public get_Item ($index: number) : System.Security.Policy.ApplicationTrust
            public get_Item ($appFullName: string) : System.Security.Policy.ApplicationTrust
            public Add ($trust: System.Security.Policy.ApplicationTrust) : number
            public AddRange ($trusts: System.Array$1<System.Security.Policy.ApplicationTrust>) : void
            public AddRange ($trusts: System.Security.Policy.ApplicationTrustCollection) : void
            public Clear () : void
            public CopyTo ($array: System.Array$1<System.Security.Policy.ApplicationTrust>, $index: number) : void
            public Find ($applicationIdentity: System.ApplicationIdentity, $versionMatch: System.Security.Policy.ApplicationVersionMatch) : System.Security.Policy.ApplicationTrustCollection
            public GetEnumerator () : System.Security.Policy.ApplicationTrustEnumerator
            public Remove ($trust: System.Security.Policy.ApplicationTrust) : void
            public Remove ($applicationIdentity: System.ApplicationIdentity, $versionMatch: System.Security.Policy.ApplicationVersionMatch) : void
            public RemoveRange ($trusts: System.Array$1<System.Security.Policy.ApplicationTrust>) : void
            public RemoveRange ($trusts: System.Security.Policy.ApplicationTrustCollection) : void
            public CopyTo ($array: System.Array, $index: number) : void
            public GetEnumerator () : System.Collections.IEnumerator
        }
        class PolicyStatement extends System.Object implements System.Security.ISecurityEncodable, System.Security.ISecurityPolicyEncodable
        {
            protected [__keep_incompatibility]: never;
            public get PermissionSet(): System.Security.PermissionSet;
            public set PermissionSet(value: System.Security.PermissionSet);
            public get Attributes(): System.Security.Policy.PolicyStatementAttribute;
            public set Attributes(value: System.Security.Policy.PolicyStatementAttribute);
            public get AttributeString(): string;
            public Copy () : System.Security.Policy.PolicyStatement
            public FromXml ($et: System.Security.SecurityElement) : void
            public FromXml ($et: System.Security.SecurityElement, $level: System.Security.Policy.PolicyLevel) : void
            public ToXml () : System.Security.SecurityElement
            public ToXml ($level: System.Security.Policy.PolicyLevel) : System.Security.SecurityElement
            public constructor ($permSet: System.Security.PermissionSet)
            public constructor ($permSet: System.Security.PermissionSet, $attributes: System.Security.Policy.PolicyStatementAttribute)
            public FromXml ($e: System.Security.SecurityElement) : void
            public FromXml ($e: System.Security.SecurityElement, $level: System.Security.Policy.PolicyLevel) : void
            public constructor ()
        }
        class ApplicationTrustEnumerator extends System.Object implements System.Collections.IEnumerator
        {
            protected [__keep_incompatibility]: never;
            public get Current(): System.Security.Policy.ApplicationTrust;
            public Reset () : void
            public MoveNext () : boolean
        }
        class CodeConnectAccess extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static AnyScheme : string
            public static DefaultPort : number
            public static OriginPort : number
            public static OriginScheme : string
            public get Port(): number;
            public get Scheme(): string;
            public static CreateAnySchemeAccess ($allowPort: number) : System.Security.Policy.CodeConnectAccess
            public static CreateOriginSchemeAccess ($allowPort: number) : System.Security.Policy.CodeConnectAccess
            public constructor ($allowScheme: string, $allowPort: number)
            public constructor ()
        }
        class CodeGroup extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get MergeLogic(): string;
            public get PolicyStatement(): System.Security.Policy.PolicyStatement;
            public set PolicyStatement(value: System.Security.Policy.PolicyStatement);
            public get Description(): string;
            public set Description(value: string);
            public get MembershipCondition(): System.Security.Policy.IMembershipCondition;
            public set MembershipCondition(value: System.Security.Policy.IMembershipCondition);
            public get Name(): string;
            public set Name(value: string);
            public get Children(): System.Collections.IList;
            public set Children(value: System.Collections.IList);
            public get AttributeString(): string;
            public get PermissionSetName(): string;
            public Copy () : System.Security.Policy.CodeGroup
            public Resolve ($evidence: System.Security.Policy.Evidence) : System.Security.Policy.PolicyStatement
            public ResolveMatchingCodeGroups ($evidence: System.Security.Policy.Evidence) : System.Security.Policy.CodeGroup
            public AddChild ($group: System.Security.Policy.CodeGroup) : void
            public Equals ($o: any) : boolean
            public Equals ($cg: System.Security.Policy.CodeGroup, $compareChildren: boolean) : boolean
            public RemoveChild ($group: System.Security.Policy.CodeGroup) : void
            public FromXml ($e: System.Security.SecurityElement) : void
            public FromXml ($e: System.Security.SecurityElement, $level: System.Security.Policy.PolicyLevel) : void
            public ToXml () : System.Security.SecurityElement
            public ToXml ($level: System.Security.Policy.PolicyLevel) : System.Security.SecurityElement
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
        }
        class FileCodeGroup extends System.Security.Policy.CodeGroup
        {
            protected [__keep_incompatibility]: never;
            public get MergeLogic(): string;
            public get AttributeString(): string;
            public get PermissionSetName(): string;
            public constructor ($membershipCondition: System.Security.Policy.IMembershipCondition, $access: System.Security.Permissions.FileIOPermissionAccess)
            public constructor ()
        }
        class FirstMatchCodeGroup extends System.Security.Policy.CodeGroup
        {
            protected [__keep_incompatibility]: never;
            public get MergeLogic(): string;
            public constructor ($membershipCondition: System.Security.Policy.IMembershipCondition, $policy: System.Security.Policy.PolicyStatement)
            public constructor ()
        }
        class GacInstalled extends System.Security.Policy.EvidenceBase implements System.Security.Policy.IIdentityPermissionFactory, System.Security.Policy.IBuiltInEvidence
        {
            protected [__keep_incompatibility]: never;
            public Copy () : any
            public CreateIdentityPermission ($evidence: System.Security.Policy.Evidence) : System.Security.IPermission
            public constructor ()
        }
        class GacMembershipCondition extends System.Object implements System.Security.Policy.IConstantMembershipCondition, System.Security.Policy.IMembershipCondition, System.Security.ISecurityEncodable, System.Security.ISecurityPolicyEncodable
        {
            protected [__keep_incompatibility]: never;
            public Check ($evidence: System.Security.Policy.Evidence) : boolean
            public Copy () : System.Security.Policy.IMembershipCondition
            public FromXml ($e: System.Security.SecurityElement) : void
            public FromXml ($e: System.Security.SecurityElement, $level: System.Security.Policy.PolicyLevel) : void
            public ToXml () : System.Security.SecurityElement
            public ToXml ($level: System.Security.Policy.PolicyLevel) : System.Security.SecurityElement
            public constructor ()
        }
        class Hash extends System.Security.Policy.EvidenceBase implements System.Runtime.Serialization.ISerializable, System.Security.Policy.IBuiltInEvidence
        {
            protected [__keep_incompatibility]: never;
            public get MD5(): System.Array$1<number>;
            public get SHA1(): System.Array$1<number>;
            public get SHA256(): System.Array$1<number>;
            public GenerateHash ($hashAlg: System.Security.Cryptography.HashAlgorithm) : System.Array$1<number>
            public GetObjectData ($info: System.Runtime.Serialization.SerializationInfo, $context: System.Runtime.Serialization.StreamingContext) : void
            public static CreateMD5 ($md5: System.Array$1<number>) : System.Security.Policy.Hash
            public static CreateSHA1 ($sha1: System.Array$1<number>) : System.Security.Policy.Hash
            public static CreateSHA256 ($sha256: System.Array$1<number>) : System.Security.Policy.Hash
            public constructor ($assembly: System.Reflection.Assembly)
            public constructor ()
        }
        class HashMembershipCondition extends System.Object implements System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable, System.Security.Policy.IMembershipCondition, System.Security.ISecurityEncodable, System.Security.ISecurityPolicyEncodable
        {
            protected [__keep_incompatibility]: never;
            public get HashAlgorithm(): System.Security.Cryptography.HashAlgorithm;
            public set HashAlgorithm(value: System.Security.Cryptography.HashAlgorithm);
            public get HashValue(): System.Array$1<number>;
            public set HashValue(value: System.Array$1<number>);
            public Check ($evidence: System.Security.Policy.Evidence) : boolean
            public Copy () : System.Security.Policy.IMembershipCondition
            public ToXml () : System.Security.SecurityElement
            public ToXml ($level: System.Security.Policy.PolicyLevel) : System.Security.SecurityElement
            public FromXml ($e: System.Security.SecurityElement) : void
            public FromXml ($e: System.Security.SecurityElement, $level: System.Security.Policy.PolicyLevel) : void
            public constructor ($hashAlg: System.Security.Cryptography.HashAlgorithm, $value: System.Array$1<number>)
            public OnDeserialization ($sender: any) : void
            public constructor ()
        }
        class NetCodeGroup extends System.Security.Policy.CodeGroup
        {
            protected [__keep_incompatibility]: never;
            public static AbsentOriginScheme : string
            public static AnyOtherOriginScheme : string
            public get AttributeString(): string;
            public get MergeLogic(): string;
            public get PermissionSetName(): string;
            public AddConnectAccess ($originScheme: string, $connectAccess: System.Security.Policy.CodeConnectAccess) : void
            public GetConnectAccessRules () : System.Array$1<System.Collections.DictionaryEntry>
            public ResetConnectAccess () : void
            public constructor ($membershipCondition: System.Security.Policy.IMembershipCondition)
            public constructor ()
        }
        class PermissionRequestEvidence extends System.Security.Policy.EvidenceBase implements System.Security.Policy.IBuiltInEvidence
        {
            protected [__keep_incompatibility]: never;
            public get DeniedPermissions(): System.Security.PermissionSet;
            public get OptionalPermissions(): System.Security.PermissionSet;
            public get RequestedPermissions(): System.Security.PermissionSet;
            public Copy () : System.Security.Policy.PermissionRequestEvidence
            public constructor ($request: System.Security.PermissionSet, $optional: System.Security.PermissionSet, $denied: System.Security.PermissionSet)
            public constructor ()
        }
        class PolicyException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $exception: System.Exception)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class StrongNameMembershipCondition extends System.Object implements System.Security.Policy.IConstantMembershipCondition, System.Security.Policy.IMembershipCondition, System.Security.ISecurityEncodable, System.Security.ISecurityPolicyEncodable
        {
            protected [__keep_incompatibility]: never;
            public get Name(): string;
            public set Name(value: string);
            public get Version(): System.Version;
            public set Version(value: System.Version);
            public get PublicKey(): System.Security.Permissions.StrongNamePublicKeyBlob;
            public set PublicKey(value: System.Security.Permissions.StrongNamePublicKeyBlob);
            public Check ($evidence: System.Security.Policy.Evidence) : boolean
            public Copy () : System.Security.Policy.IMembershipCondition
            public FromXml ($e: System.Security.SecurityElement) : void
            public FromXml ($e: System.Security.SecurityElement, $level: System.Security.Policy.PolicyLevel) : void
            public ToXml () : System.Security.SecurityElement
            public ToXml ($level: System.Security.Policy.PolicyLevel) : System.Security.SecurityElement
            public constructor ($blob: System.Security.Permissions.StrongNamePublicKeyBlob, $name: string, $version: System.Version)
            public constructor ()
        }
        class Site extends System.Security.Policy.EvidenceBase implements System.Security.Policy.IIdentityPermissionFactory, System.Security.Policy.IBuiltInEvidence
        {
            protected [__keep_incompatibility]: never;
            public get Name(): string;
            public static CreateFromUrl ($url: string) : System.Security.Policy.Site
            public Copy () : any
            public CreateIdentityPermission ($evidence: System.Security.Policy.Evidence) : System.Security.IPermission
            public constructor ($name: string)
            public constructor ()
        }
        class SiteMembershipCondition extends System.Object implements System.Security.Policy.IConstantMembershipCondition, System.Security.Policy.IMembershipCondition, System.Security.ISecurityEncodable, System.Security.ISecurityPolicyEncodable
        {
            protected [__keep_incompatibility]: never;
            public get Site(): string;
            public set Site(value: string);
            public Check ($evidence: System.Security.Policy.Evidence) : boolean
            public Copy () : System.Security.Policy.IMembershipCondition
            public FromXml ($e: System.Security.SecurityElement) : void
            public FromXml ($e: System.Security.SecurityElement, $level: System.Security.Policy.PolicyLevel) : void
            public ToXml () : System.Security.SecurityElement
            public ToXml ($level: System.Security.Policy.PolicyLevel) : System.Security.SecurityElement
            public constructor ($site: string)
            public constructor ()
        }
        enum TrustManagerUIContext
        { Install = 0, Upgrade = 1, Run = 2 }
        class UnionCodeGroup extends System.Security.Policy.CodeGroup
        {
            protected [__keep_incompatibility]: never;
            public get MergeLogic(): string;
            public constructor ($membershipCondition: System.Security.Policy.IMembershipCondition, $policy: System.Security.Policy.PolicyStatement)
            public constructor ()
        }
        class Url extends System.Security.Policy.EvidenceBase implements System.Security.Policy.IIdentityPermissionFactory, System.Security.Policy.IBuiltInEvidence
        {
            protected [__keep_incompatibility]: never;
            public get Value(): string;
            public Copy () : any
            public CreateIdentityPermission ($evidence: System.Security.Policy.Evidence) : System.Security.IPermission
            public constructor ($name: string)
            public constructor ()
        }
        class UrlMembershipCondition extends System.Object implements System.Security.Policy.IConstantMembershipCondition, System.Security.Policy.IMembershipCondition, System.Security.ISecurityEncodable, System.Security.ISecurityPolicyEncodable
        {
            protected [__keep_incompatibility]: never;
            public get Url(): string;
            public set Url(value: string);
            public Check ($evidence: System.Security.Policy.Evidence) : boolean
            public Copy () : System.Security.Policy.IMembershipCondition
            public FromXml ($e: System.Security.SecurityElement) : void
            public FromXml ($e: System.Security.SecurityElement, $level: System.Security.Policy.PolicyLevel) : void
            public ToXml () : System.Security.SecurityElement
            public ToXml ($level: System.Security.Policy.PolicyLevel) : System.Security.SecurityElement
            public constructor ($url: string)
            public constructor ()
        }
        class Zone extends System.Security.Policy.EvidenceBase implements System.Security.Policy.IIdentityPermissionFactory, System.Security.Policy.IBuiltInEvidence
        {
            protected [__keep_incompatibility]: never;
            public get SecurityZone(): System.Security.SecurityZone;
            public Copy () : any
            public CreateIdentityPermission ($evidence: System.Security.Policy.Evidence) : System.Security.IPermission
            public static CreateFromUrl ($url: string) : System.Security.Policy.Zone
            public constructor ($zone: System.Security.SecurityZone)
            public constructor ()
        }
        class ZoneMembershipCondition extends System.Object implements System.Security.Policy.IConstantMembershipCondition, System.Security.Policy.IMembershipCondition, System.Security.ISecurityEncodable, System.Security.ISecurityPolicyEncodable
        {
            protected [__keep_incompatibility]: never;
            public get SecurityZone(): System.Security.SecurityZone;
            public set SecurityZone(value: System.Security.SecurityZone);
            public Check ($evidence: System.Security.Policy.Evidence) : boolean
            public Copy () : System.Security.Policy.IMembershipCondition
            public FromXml ($e: System.Security.SecurityElement) : void
            public FromXml ($e: System.Security.SecurityElement, $level: System.Security.Policy.PolicyLevel) : void
            public ToXml () : System.Security.SecurityElement
            public ToXml ($level: System.Security.Policy.PolicyLevel) : System.Security.SecurityElement
            public constructor ($zone: System.Security.SecurityZone)
            public constructor ()
        }
    }
    namespace System.Configuration.Assemblies {
        enum AssemblyHashAlgorithm
        { None = 0, MD5 = 32771, SHA1 = 32772, SHA256 = 32780, SHA384 = 32781, SHA512 = 32782 }
        enum AssemblyVersionCompatibility
        { SameMachine = 1, SameProcess = 2, SameDomain = 3 }
        class AssemblyHash extends System.ValueType implements System.ICloneable
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace System.Reflection.Emit {
        class AssemblyBuilder extends System.Reflection.Assembly implements System.Runtime.Serialization.ISerializable, System.Reflection.ICustomAttributeProvider, System.Security.IEvidenceFactory, System.Runtime.InteropServices._Assembly, System.Runtime.InteropServices._AssemblyBuilder
        {
            protected [__keep_incompatibility]: never;
            public get CodeBase(): string;
            public get EscapedCodeBase(): string;
            public get EntryPoint(): System.Reflection.MethodInfo;
            public get Location(): string;
            public get ImageRuntimeVersion(): string;
            public get ReflectionOnly(): boolean;
            public get ManifestModule(): System.Reflection.Module;
            public get GlobalAssemblyCache(): boolean;
            public get IsDynamic(): boolean;
            public get FullName(): string;
            public get Evidence(): System.Security.Policy.Evidence;
            public AddResourceFile ($name: string, $fileName: string) : void
            public AddResourceFile ($name: string, $fileName: string, $attribute: System.Reflection.ResourceAttributes) : void
            public static DefineDynamicAssembly ($name: System.Reflection.AssemblyName, $access: System.Reflection.Emit.AssemblyBuilderAccess) : System.Reflection.Emit.AssemblyBuilder
            public static DefineDynamicAssembly ($name: System.Reflection.AssemblyName, $access: System.Reflection.Emit.AssemblyBuilderAccess, $assemblyAttributes: System.Collections.Generic.IEnumerable$1<System.Reflection.Emit.CustomAttributeBuilder>) : System.Reflection.Emit.AssemblyBuilder
            public DefineDynamicModule ($name: string) : System.Reflection.Emit.ModuleBuilder
            public DefineDynamicModule ($name: string, $emitSymbolInfo: boolean) : System.Reflection.Emit.ModuleBuilder
            public DefineDynamicModule ($name: string, $fileName: string) : System.Reflection.Emit.ModuleBuilder
            public DefineDynamicModule ($name: string, $fileName: string, $emitSymbolInfo: boolean) : System.Reflection.Emit.ModuleBuilder
            public DefineResource ($name: string, $description: string, $fileName: string) : System.Resources.IResourceWriter
            public DefineResource ($name: string, $description: string, $fileName: string, $attribute: System.Reflection.ResourceAttributes) : System.Resources.IResourceWriter
            public DefineUnmanagedResource ($resource: System.Array$1<number>) : void
            public DefineUnmanagedResource ($resourceFileName: string) : void
            public DefineVersionInfoResource () : void
            public DefineVersionInfoResource ($product: string, $productVersion: string, $company: string, $copyright: string, $trademark: string) : void
            public GetDynamicModule ($name: string) : System.Reflection.Emit.ModuleBuilder
            public Save ($assemblyFileName: string, $portableExecutableKind: System.Reflection.PortableExecutableKinds, $imageFileMachine: System.Reflection.ImageFileMachine) : void
            public Save ($assemblyFileName: string) : void
            public SetEntryPoint ($entryMethod: System.Reflection.MethodInfo) : void
            public SetEntryPoint ($entryMethod: System.Reflection.MethodInfo, $fileKind: System.Reflection.Emit.PEFileKinds) : void
            public SetCustomAttribute ($customBuilder: System.Reflection.Emit.CustomAttributeBuilder) : void
            public SetCustomAttribute ($con: System.Reflection.ConstructorInfo, $binaryAttribute: System.Array$1<number>) : void
            public GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            public GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            public GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            public Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
        }
        enum AssemblyBuilderAccess
        { Run = 1, Save = 2, RunAndSave = 3, ReflectionOnly = 6, RunAndCollect = 9 }
        class CustomAttributeBuilder extends System.Object implements System.Runtime.InteropServices._CustomAttributeBuilder
        {
            protected [__keep_incompatibility]: never;
            public constructor ($con: System.Reflection.ConstructorInfo, $constructorArgs: System.Array$1<any>)
            public constructor ($con: System.Reflection.ConstructorInfo, $constructorArgs: System.Array$1<any>, $namedFields: System.Array$1<System.Reflection.FieldInfo>, $fieldValues: System.Array$1<any>)
            public constructor ($con: System.Reflection.ConstructorInfo, $constructorArgs: System.Array$1<any>, $namedProperties: System.Array$1<System.Reflection.PropertyInfo>, $propertyValues: System.Array$1<any>)
            public constructor ($con: System.Reflection.ConstructorInfo, $constructorArgs: System.Array$1<any>, $namedProperties: System.Array$1<System.Reflection.PropertyInfo>, $propertyValues: System.Array$1<any>, $namedFields: System.Array$1<System.Reflection.FieldInfo>, $fieldValues: System.Array$1<any>)
            public GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            public GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            public GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            public Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
            public constructor ()
        }
        enum OpCodeType
        { Annotation = 0, Macro = 1, Nternal = 2, Objmodel = 3, Prefix = 4, Primitive = 5 }
        enum OperandType
        { InlineBrTarget = 0, InlineField = 1, InlineI = 2, InlineI8 = 3, InlineMethod = 4, InlineNone = 5, InlinePhi = 6, InlineR = 7, InlineSig = 9, InlineString = 10, InlineSwitch = 11, InlineTok = 12, InlineType = 13, InlineVar = 14, ShortInlineBrTarget = 15, ShortInlineI = 16, ShortInlineR = 17, ShortInlineVar = 18 }
        enum PackingSize
        { Unspecified = 0, Size1 = 1, Size2 = 2, Size4 = 4, Size8 = 8, Size16 = 16, Size32 = 32, Size64 = 64, Size128 = 128 }
        enum StackBehaviour
        { Pop0 = 0, Pop1 = 1, Pop1_pop1 = 2, Popi = 3, Popi_pop1 = 4, Popi_popi = 5, Popi_popi8 = 6, Popi_popi_popi = 7, Popi_popr4 = 8, Popi_popr8 = 9, Popref = 10, Popref_pop1 = 11, Popref_popi = 12, Popref_popi_popi = 13, Popref_popi_popi8 = 14, Popref_popi_popr4 = 15, Popref_popi_popr8 = 16, Popref_popi_popref = 17, Push0 = 18, Push1 = 19, Push1_push1 = 20, Pushi = 21, Pushi8 = 22, Pushr4 = 23, Pushr8 = 24, Pushref = 25, Varpop = 26, Varpush = 27, Popref_popi_pop1 = 28 }
        class ExceptionHandler extends System.ValueType implements System.IEquatable$1<System.Reflection.Emit.ExceptionHandler>
        {
            protected [__keep_incompatibility]: never;
            public get ExceptionTypeToken(): number;
            public get TryOffset(): number;
            public get TryLength(): number;
            public get FilterOffset(): number;
            public get HandlerOffset(): number;
            public get HandlerLength(): number;
            public get Kind(): System.Reflection.ExceptionHandlingClauseOptions;
            public Equals ($obj: any) : boolean
            public Equals ($other: System.Reflection.Emit.ExceptionHandler) : boolean
            public static op_Equality ($left: System.Reflection.Emit.ExceptionHandler, $right: System.Reflection.Emit.ExceptionHandler) : boolean
            public static op_Inequality ($left: System.Reflection.Emit.ExceptionHandler, $right: System.Reflection.Emit.ExceptionHandler) : boolean
            public constructor ($tryOffset: number, $tryLength: number, $filterOffset: number, $handlerOffset: number, $handlerLength: number, $kind: System.Reflection.ExceptionHandlingClauseOptions, $exceptionTypeToken: number)
            public static Equals ($objA: any, $objB: any) : boolean
            public constructor ()
        }
        class ModuleBuilder extends System.Reflection.Module implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Module, System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._ModuleBuilder
        {
            protected [__keep_incompatibility]: never;
            public get FullyQualifiedName(): string;
            public get Assembly(): System.Reflection.Assembly;
            public get Name(): string;
            public get ScopeName(): string;
            public get ModuleVersionId(): System.Guid;
            public get MetadataToken(): number;
            public IsTransient () : boolean
            public CreateGlobalFunctions () : void
            public DefineInitializedData ($name: string, $data: System.Array$1<number>, $attributes: System.Reflection.FieldAttributes) : System.Reflection.Emit.FieldBuilder
            public DefineUninitializedData ($name: string, $size: number, $attributes: System.Reflection.FieldAttributes) : System.Reflection.Emit.FieldBuilder
            public DefineGlobalMethod ($name: string, $attributes: System.Reflection.MethodAttributes, $returnType: System.Type, $parameterTypes: System.Array$1<System.Type>) : System.Reflection.Emit.MethodBuilder
            public DefineGlobalMethod ($name: string, $attributes: System.Reflection.MethodAttributes, $callingConvention: System.Reflection.CallingConventions, $returnType: System.Type, $parameterTypes: System.Array$1<System.Type>) : System.Reflection.Emit.MethodBuilder
            public DefineGlobalMethod ($name: string, $attributes: System.Reflection.MethodAttributes, $callingConvention: System.Reflection.CallingConventions, $returnType: System.Type, $requiredReturnTypeCustomModifiers: System.Array$1<System.Type>, $optionalReturnTypeCustomModifiers: System.Array$1<System.Type>, $parameterTypes: System.Array$1<System.Type>, $requiredParameterTypeCustomModifiers: System.Array$1<System.Array$1<System.Type>>, $optionalParameterTypeCustomModifiers: System.Array$1<System.Array$1<System.Type>>) : System.Reflection.Emit.MethodBuilder
            public DefinePInvokeMethod ($name: string, $dllName: string, $attributes: System.Reflection.MethodAttributes, $callingConvention: System.Reflection.CallingConventions, $returnType: System.Type, $parameterTypes: System.Array$1<System.Type>, $nativeCallConv: System.Runtime.InteropServices.CallingConvention, $nativeCharSet: System.Runtime.InteropServices.CharSet) : System.Reflection.Emit.MethodBuilder
            public DefinePInvokeMethod ($name: string, $dllName: string, $entryName: string, $attributes: System.Reflection.MethodAttributes, $callingConvention: System.Reflection.CallingConventions, $returnType: System.Type, $parameterTypes: System.Array$1<System.Type>, $nativeCallConv: System.Runtime.InteropServices.CallingConvention, $nativeCharSet: System.Runtime.InteropServices.CharSet) : System.Reflection.Emit.MethodBuilder
            public DefineType ($name: string) : System.Reflection.Emit.TypeBuilder
            public DefineType ($name: string, $attr: System.Reflection.TypeAttributes) : System.Reflection.Emit.TypeBuilder
            public DefineType ($name: string, $attr: System.Reflection.TypeAttributes, $parent: System.Type) : System.Reflection.Emit.TypeBuilder
            public DefineType ($name: string, $attr: System.Reflection.TypeAttributes, $parent: System.Type, $interfaces: System.Array$1<System.Type>) : System.Reflection.Emit.TypeBuilder
            public DefineType ($name: string, $attr: System.Reflection.TypeAttributes, $parent: System.Type, $typesize: number) : System.Reflection.Emit.TypeBuilder
            public DefineType ($name: string, $attr: System.Reflection.TypeAttributes, $parent: System.Type, $packsize: System.Reflection.Emit.PackingSize) : System.Reflection.Emit.TypeBuilder
            public DefineType ($name: string, $attr: System.Reflection.TypeAttributes, $parent: System.Type, $packingSize: System.Reflection.Emit.PackingSize, $typesize: number) : System.Reflection.Emit.TypeBuilder
            public GetArrayMethod ($arrayClass: System.Type, $methodName: string, $callingConvention: System.Reflection.CallingConventions, $returnType: System.Type, $parameterTypes: System.Array$1<System.Type>) : System.Reflection.MethodInfo
            public DefineEnum ($name: string, $visibility: System.Reflection.TypeAttributes, $underlyingType: System.Type) : System.Reflection.Emit.EnumBuilder
            public SetCustomAttribute ($customBuilder: System.Reflection.Emit.CustomAttributeBuilder) : void
            public SetCustomAttribute ($con: System.Reflection.ConstructorInfo, $binaryAttribute: System.Array$1<number>) : void
            public GetSymWriter () : System.Diagnostics.SymbolStore.ISymbolWriter
            public DefineDocument ($url: string, $language: System.Guid, $languageVendor: System.Guid, $documentType: System.Guid) : System.Diagnostics.SymbolStore.ISymbolDocumentWriter
            public DefineResource ($name: string, $description: string, $attribute: System.Reflection.ResourceAttributes) : System.Resources.IResourceWriter
            public DefineResource ($name: string, $description: string) : System.Resources.IResourceWriter
            public DefineUnmanagedResource ($resource: System.Array$1<number>) : void
            public DefineUnmanagedResource ($resourceFileName: string) : void
            public DefineManifestResource ($name: string, $stream: System.IO.Stream, $attribute: System.Reflection.ResourceAttributes) : void
            public SetSymCustomAttribute ($name: string, $data: System.Array$1<number>) : void
            public SetUserEntryPoint ($entryPoint: System.Reflection.MethodInfo) : void
            public GetMethodToken ($method: System.Reflection.MethodInfo) : System.Reflection.Emit.MethodToken
            public GetMethodToken ($method: System.Reflection.MethodInfo, $optionalParameterTypes: System.Collections.Generic.IEnumerable$1<System.Type>) : System.Reflection.Emit.MethodToken
            public GetArrayMethodToken ($arrayClass: System.Type, $methodName: string, $callingConvention: System.Reflection.CallingConventions, $returnType: System.Type, $parameterTypes: System.Array$1<System.Type>) : System.Reflection.Emit.MethodToken
            public GetConstructorToken ($con: System.Reflection.ConstructorInfo) : System.Reflection.Emit.MethodToken
            public GetConstructorToken ($constructor: System.Reflection.ConstructorInfo, $optionalParameterTypes: System.Collections.Generic.IEnumerable$1<System.Type>) : System.Reflection.Emit.MethodToken
            public GetFieldToken ($field: System.Reflection.FieldInfo) : System.Reflection.Emit.FieldToken
            public GetSignatureToken ($sigBytes: System.Array$1<number>, $sigLength: number) : System.Reflection.Emit.SignatureToken
            public GetSignatureToken ($sigHelper: System.Reflection.Emit.SignatureHelper) : System.Reflection.Emit.SignatureToken
            public GetStringConstant ($str: string) : System.Reflection.Emit.StringToken
            public GetTypeToken ($type: System.Type) : System.Reflection.Emit.TypeToken
            public GetTypeToken ($name: string) : System.Reflection.Emit.TypeToken
        }
        enum PEFileKinds
        { Dll = 1, ConsoleApplication = 2, WindowApplication = 3 }
        class ConstructorBuilder extends System.Reflection.ConstructorInfo implements System.Runtime.InteropServices._MemberInfo, System.Runtime.InteropServices._ConstructorBuilder, System.Runtime.InteropServices._MethodBase, System.Runtime.InteropServices._ConstructorInfo, System.Reflection.ICustomAttributeProvider
        {
            protected [__keep_incompatibility]: never;
            public get CallingConvention(): System.Reflection.CallingConventions;
            public get InitLocals(): boolean;
            public set InitLocals(value: boolean);
            public get MethodHandle(): System.RuntimeMethodHandle;
            public get Attributes(): System.Reflection.MethodAttributes;
            public get ReflectedType(): System.Type;
            public get DeclaringType(): System.Type;
            public get Name(): string;
            public get Signature(): string;
            public get Module(): System.Reflection.Module;
            public AddDeclarativeSecurity ($action: System.Security.Permissions.SecurityAction, $pset: System.Security.PermissionSet) : void
            public DefineParameter ($iSequence: number, $attributes: System.Reflection.ParameterAttributes, $strParamName: string) : System.Reflection.Emit.ParameterBuilder
            public GetILGenerator () : System.Reflection.Emit.ILGenerator
            public GetILGenerator ($streamSize: number) : System.Reflection.Emit.ILGenerator
            public SetMethodBody ($il: System.Array$1<number>, $maxStack: number, $localSignature: System.Array$1<number>, $exceptionHandlers: System.Collections.Generic.IEnumerable$1<System.Reflection.Emit.ExceptionHandler>, $tokenFixups: System.Collections.Generic.IEnumerable$1<number>) : void
            public SetCustomAttribute ($customBuilder: System.Reflection.Emit.CustomAttributeBuilder) : void
            public SetCustomAttribute ($con: System.Reflection.ConstructorInfo, $binaryAttribute: System.Array$1<number>) : void
            public SetImplementationFlags ($attributes: System.Reflection.MethodImplAttributes) : void
            public GetModule () : System.Reflection.Module
            public GetToken () : System.Reflection.Emit.MethodToken
            public SetSymCustomAttribute ($name: string, $data: System.Array$1<number>) : void
        }
        class ParameterBuilder extends System.Object implements System.Runtime.InteropServices._ParameterBuilder
        {
            protected [__keep_incompatibility]: never;
            public get Attributes(): number;
            public get IsIn(): boolean;
            public get IsOut(): boolean;
            public get IsOptional(): boolean;
            public get Name(): string;
            public get Position(): number;
            public GetToken () : System.Reflection.Emit.ParameterToken
            public SetConstant ($defaultValue: any) : void
            public SetCustomAttribute ($customBuilder: System.Reflection.Emit.CustomAttributeBuilder) : void
            public SetCustomAttribute ($con: System.Reflection.ConstructorInfo, $binaryAttribute: System.Array$1<number>) : void
            public GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            public GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            public GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            public Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
        }
        class ILGenerator extends System.Object implements System.Runtime.InteropServices._ILGenerator
        {
            protected [__keep_incompatibility]: never;
            public get ILOffset(): number;
            public BeginCatchBlock ($exceptionType: System.Type) : void
            public BeginExceptFilterBlock () : void
            public BeginExceptionBlock () : System.Reflection.Emit.Label
            public BeginFaultBlock () : void
            public BeginFinallyBlock () : void
            public BeginScope () : void
            public DeclareLocal ($localType: System.Type) : System.Reflection.Emit.LocalBuilder
            public DeclareLocal ($localType: System.Type, $pinned: boolean) : System.Reflection.Emit.LocalBuilder
            public DefineLabel () : System.Reflection.Emit.Label
            public Emit ($opcode: System.Reflection.Emit.OpCode) : void
            public Emit ($opcode: System.Reflection.Emit.OpCode, $arg: number) : void
            public Emit ($opcode: System.Reflection.Emit.OpCode, $con: System.Reflection.ConstructorInfo) : void
            public Emit ($opcode: System.Reflection.Emit.OpCode, $field: System.Reflection.FieldInfo) : void
            public Emit ($opcode: System.Reflection.Emit.OpCode, $arg: bigint) : void
            public Emit ($opcode: System.Reflection.Emit.OpCode, $label: System.Reflection.Emit.Label) : void
            public Emit ($opcode: System.Reflection.Emit.OpCode, $labels: System.Array$1<System.Reflection.Emit.Label>) : void
            public Emit ($opcode: System.Reflection.Emit.OpCode, $local: System.Reflection.Emit.LocalBuilder) : void
            public Emit ($opcode: System.Reflection.Emit.OpCode, $meth: System.Reflection.MethodInfo) : void
            public Emit ($opcode: System.Reflection.Emit.OpCode, $signature: System.Reflection.Emit.SignatureHelper) : void
            public Emit ($opcode: System.Reflection.Emit.OpCode, $str: string) : void
            public Emit ($opcode: System.Reflection.Emit.OpCode, $cls: System.Type) : void
            public EmitCall ($opcode: System.Reflection.Emit.OpCode, $methodInfo: System.Reflection.MethodInfo, $optionalParameterTypes: System.Array$1<System.Type>) : void
            public EmitCalli ($opcode: System.Reflection.Emit.OpCode, $unmanagedCallConv: System.Runtime.InteropServices.CallingConvention, $returnType: System.Type, $parameterTypes: System.Array$1<System.Type>) : void
            public EmitCalli ($opcode: System.Reflection.Emit.OpCode, $callingConvention: System.Reflection.CallingConventions, $returnType: System.Type, $parameterTypes: System.Array$1<System.Type>, $optionalParameterTypes: System.Array$1<System.Type>) : void
            public EmitWriteLine ($fld: System.Reflection.FieldInfo) : void
            public EmitWriteLine ($localBuilder: System.Reflection.Emit.LocalBuilder) : void
            public EmitWriteLine ($value: string) : void
            public EndExceptionBlock () : void
            public EndScope () : void
            public MarkLabel ($loc: System.Reflection.Emit.Label) : void
            public MarkSequencePoint ($document: System.Diagnostics.SymbolStore.ISymbolDocumentWriter, $startLine: number, $startColumn: number, $endLine: number, $endColumn: number) : void
            public ThrowException ($excType: System.Type) : void
            public UsingNamespace ($usingNamespace: string) : void
            public GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            public GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            public GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            public Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
        }
        class MethodToken extends System.ValueType implements System.IEquatable$1<System.Reflection.Emit.MethodToken>
        {
            protected [__keep_incompatibility]: never;
            public static Empty : System.Reflection.Emit.MethodToken
            public get Token(): number;
            public Equals ($obj: any) : boolean
            public Equals ($obj: System.Reflection.Emit.MethodToken) : boolean
            public static op_Equality ($a: System.Reflection.Emit.MethodToken, $b: System.Reflection.Emit.MethodToken) : boolean
            public static op_Inequality ($a: System.Reflection.Emit.MethodToken, $b: System.Reflection.Emit.MethodToken) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
        }
        class DynamicILInfo extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get DynamicMethod(): System.Reflection.Emit.DynamicMethod;
            public GetTokenFor ($signature: System.Array$1<number>) : number
            public GetTokenFor ($method: System.Reflection.Emit.DynamicMethod) : number
            public GetTokenFor ($field: System.RuntimeFieldHandle) : number
            public GetTokenFor ($method: System.RuntimeMethodHandle) : number
            public GetTokenFor ($type: System.RuntimeTypeHandle) : number
            public GetTokenFor ($literal: string) : number
            public GetTokenFor ($method: System.RuntimeMethodHandle, $contextType: System.RuntimeTypeHandle) : number
            public GetTokenFor ($field: System.RuntimeFieldHandle, $contextType: System.RuntimeTypeHandle) : number
            public SetCode ($code: System.Array$1<number>, $maxStackSize: number) : void
            public SetExceptions ($exceptions: System.Array$1<number>) : void
            public SetLocalSignature ($localSignature: System.Array$1<number>) : void
        }
        class DynamicMethod extends System.Reflection.MethodInfo implements System.Runtime.InteropServices._MemberInfo, System.Runtime.InteropServices._MethodBase, System.Runtime.InteropServices._MethodInfo, System.Reflection.ICustomAttributeProvider
        {
            protected [__keep_incompatibility]: never;
            public get Attributes(): System.Reflection.MethodAttributes;
            public get CallingConvention(): System.Reflection.CallingConventions;
            public get DeclaringType(): System.Type;
            public get InitLocals(): boolean;
            public set InitLocals(value: boolean);
            public get MethodHandle(): System.RuntimeMethodHandle;
            public get Module(): System.Reflection.Module;
            public get Name(): string;
            public get ReflectedType(): System.Type;
            public get ReturnParameter(): System.Reflection.ParameterInfo;
            public get ReturnType(): System.Type;
            public get ReturnTypeCustomAttributes(): System.Reflection.ICustomAttributeProvider;
            public DefineParameter ($position: number, $attributes: System.Reflection.ParameterAttributes, $parameterName: string) : System.Reflection.Emit.ParameterBuilder
            public GetDynamicILInfo () : System.Reflection.Emit.DynamicILInfo
            public GetILGenerator () : System.Reflection.Emit.ILGenerator
            public GetILGenerator ($streamSize: number) : System.Reflection.Emit.ILGenerator
            public constructor ($name: string, $returnType: System.Type, $parameterTypes: System.Array$1<System.Type>, $m: System.Reflection.Module)
            public constructor ($name: string, $returnType: System.Type, $parameterTypes: System.Array$1<System.Type>, $owner: System.Type)
            public constructor ($name: string, $returnType: System.Type, $parameterTypes: System.Array$1<System.Type>, $m: System.Reflection.Module, $skipVisibility: boolean)
            public constructor ($name: string, $returnType: System.Type, $parameterTypes: System.Array$1<System.Type>, $owner: System.Type, $skipVisibility: boolean)
            public constructor ($name: string, $attributes: System.Reflection.MethodAttributes, $callingConvention: System.Reflection.CallingConventions, $returnType: System.Type, $parameterTypes: System.Array$1<System.Type>, $owner: System.Type, $skipVisibility: boolean)
            public constructor ($name: string, $attributes: System.Reflection.MethodAttributes, $callingConvention: System.Reflection.CallingConventions, $returnType: System.Type, $parameterTypes: System.Array$1<System.Type>, $m: System.Reflection.Module, $skipVisibility: boolean)
            public constructor ($name: string, $returnType: System.Type, $parameterTypes: System.Array$1<System.Type>)
            public constructor ($name: string, $returnType: System.Type, $parameterTypes: System.Array$1<System.Type>, $restrictedSkipVisibility: boolean)
            public constructor ()
        }
        class EnumBuilder extends System.Reflection.TypeInfo implements System.Runtime.InteropServices._MemberInfo, System.Runtime.InteropServices._Type, System.Runtime.InteropServices._EnumBuilder, System.Reflection.ICustomAttributeProvider, System.Reflection.IReflect, System.Reflection.IReflectableType
        {
            protected [__keep_incompatibility]: never;
            public get Assembly(): System.Reflection.Assembly;
            public get AssemblyQualifiedName(): string;
            public get BaseType(): System.Type;
            public get DeclaringType(): System.Type;
            public get FullName(): string;
            public get GUID(): System.Guid;
            public get Module(): System.Reflection.Module;
            public get Name(): string;
            public get Namespace(): string;
            public get ReflectedType(): System.Type;
            public get TypeHandle(): System.RuntimeTypeHandle;
            public get TypeToken(): System.Reflection.Emit.TypeToken;
            public get UnderlyingField(): System.Reflection.Emit.FieldBuilder;
            public get UnderlyingSystemType(): System.Type;
            public get IsConstructedGenericType(): boolean;
            public get IsTypeDefinition(): boolean;
            public CreateType () : System.Type
            public CreateTypeInfo () : System.Reflection.TypeInfo
            public DefineLiteral ($literalName: string, $literalValue: any) : System.Reflection.Emit.FieldBuilder
            public SetCustomAttribute ($customBuilder: System.Reflection.Emit.CustomAttributeBuilder) : void
            public SetCustomAttribute ($con: System.Reflection.ConstructorInfo, $binaryAttribute: System.Array$1<number>) : void
        }
        class TypeToken extends System.ValueType implements System.IEquatable$1<System.Reflection.Emit.TypeToken>
        {
            protected [__keep_incompatibility]: never;
            public static Empty : System.Reflection.Emit.TypeToken
            public get Token(): number;
            public Equals ($obj: any) : boolean
            public Equals ($obj: System.Reflection.Emit.TypeToken) : boolean
            public static op_Equality ($a: System.Reflection.Emit.TypeToken, $b: System.Reflection.Emit.TypeToken) : boolean
            public static op_Inequality ($a: System.Reflection.Emit.TypeToken, $b: System.Reflection.Emit.TypeToken) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
        }
        class FieldBuilder extends System.Reflection.FieldInfo implements System.Runtime.InteropServices._MemberInfo, System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._FieldBuilder, System.Runtime.InteropServices._FieldInfo
        {
            protected [__keep_incompatibility]: never;
            public get Attributes(): System.Reflection.FieldAttributes;
            public get DeclaringType(): System.Type;
            public get FieldHandle(): System.RuntimeFieldHandle;
            public get FieldType(): System.Type;
            public get Name(): string;
            public get ReflectedType(): System.Type;
            public get MetadataToken(): number;
            public get Module(): System.Reflection.Module;
            public GetToken () : System.Reflection.Emit.FieldToken
            public SetConstant ($defaultValue: any) : void
            public SetCustomAttribute ($customBuilder: System.Reflection.Emit.CustomAttributeBuilder) : void
            public SetCustomAttribute ($con: System.Reflection.ConstructorInfo, $binaryAttribute: System.Array$1<number>) : void
            public SetOffset ($iOffset: number) : void
        }
        class EventBuilder extends System.Object implements System.Runtime.InteropServices._EventBuilder
        {
            protected [__keep_incompatibility]: never;
            public AddOtherMethod ($mdBuilder: System.Reflection.Emit.MethodBuilder) : void
            public GetEventToken () : System.Reflection.Emit.EventToken
            public SetAddOnMethod ($mdBuilder: System.Reflection.Emit.MethodBuilder) : void
            public SetRaiseMethod ($mdBuilder: System.Reflection.Emit.MethodBuilder) : void
            public SetRemoveOnMethod ($mdBuilder: System.Reflection.Emit.MethodBuilder) : void
            public SetCustomAttribute ($customBuilder: System.Reflection.Emit.CustomAttributeBuilder) : void
            public SetCustomAttribute ($con: System.Reflection.ConstructorInfo, $binaryAttribute: System.Array$1<number>) : void
            public GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            public GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            public GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            public Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
        }
        class MethodBuilder extends System.Reflection.MethodInfo implements System.Runtime.InteropServices._MemberInfo, System.Runtime.InteropServices._MethodBase, System.Runtime.InteropServices._MethodBuilder, System.Runtime.InteropServices._MethodInfo, System.Reflection.ICustomAttributeProvider
        {
            protected [__keep_incompatibility]: never;
            public get ContainsGenericParameters(): boolean;
            public get InitLocals(): boolean;
            public set InitLocals(value: boolean);
            public get MethodHandle(): System.RuntimeMethodHandle;
            public get ReturnType(): System.Type;
            public get ReflectedType(): System.Type;
            public get DeclaringType(): System.Type;
            public get Name(): string;
            public get Attributes(): System.Reflection.MethodAttributes;
            public get ReturnTypeCustomAttributes(): System.Reflection.ICustomAttributeProvider;
            public get CallingConvention(): System.Reflection.CallingConventions;
            public get Signature(): string;
            public get IsGenericMethodDefinition(): boolean;
            public get IsGenericMethod(): boolean;
            public get Module(): System.Reflection.Module;
            public get ReturnParameter(): System.Reflection.ParameterInfo;
            public GetToken () : System.Reflection.Emit.MethodToken
            public GetModule () : System.Reflection.Module
            public CreateMethodBody ($il: System.Array$1<number>, $count: number) : void
            public SetMethodBody ($il: System.Array$1<number>, $maxStack: number, $localSignature: System.Array$1<number>, $exceptionHandlers: System.Collections.Generic.IEnumerable$1<System.Reflection.Emit.ExceptionHandler>, $tokenFixups: System.Collections.Generic.IEnumerable$1<number>) : void
            public GetILGenerator () : System.Reflection.Emit.ILGenerator
            public GetILGenerator ($size: number) : System.Reflection.Emit.ILGenerator
            public DefineParameter ($position: number, $attributes: System.Reflection.ParameterAttributes, $strParamName: string) : System.Reflection.Emit.ParameterBuilder
            public SetCustomAttribute ($customBuilder: System.Reflection.Emit.CustomAttributeBuilder) : void
            public SetCustomAttribute ($con: System.Reflection.ConstructorInfo, $binaryAttribute: System.Array$1<number>) : void
            public SetImplementationFlags ($attributes: System.Reflection.MethodImplAttributes) : void
            public AddDeclarativeSecurity ($action: System.Security.Permissions.SecurityAction, $pset: System.Security.PermissionSet) : void
            public SetSymCustomAttribute ($name: string, $data: System.Array$1<number>) : void
            public DefineGenericParameters (...names: string[]) : System.Array$1<System.Reflection.Emit.GenericTypeParameterBuilder>
            public SetReturnType ($returnType: System.Type) : void
            public SetParameters (...parameterTypes: System.Type[]) : void
            public SetSignature ($returnType: System.Type, $returnTypeRequiredCustomModifiers: System.Array$1<System.Type>, $returnTypeOptionalCustomModifiers: System.Array$1<System.Type>, $parameterTypes: System.Array$1<System.Type>, $parameterTypeRequiredCustomModifiers: System.Array$1<System.Array$1<System.Type>>, $parameterTypeOptionalCustomModifiers: System.Array$1<System.Array$1<System.Type>>) : void
        }
        class EventToken extends System.ValueType implements System.IEquatable$1<System.Reflection.Emit.EventToken>
        {
            protected [__keep_incompatibility]: never;
            public static Empty : System.Reflection.Emit.EventToken
            public get Token(): number;
            public Equals ($obj: any) : boolean
            public Equals ($obj: System.Reflection.Emit.EventToken) : boolean
            public static op_Equality ($a: System.Reflection.Emit.EventToken, $b: System.Reflection.Emit.EventToken) : boolean
            public static op_Inequality ($a: System.Reflection.Emit.EventToken, $b: System.Reflection.Emit.EventToken) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
        }
        class FieldToken extends System.ValueType implements System.IEquatable$1<System.Reflection.Emit.FieldToken>
        {
            protected [__keep_incompatibility]: never;
            public static Empty : System.Reflection.Emit.FieldToken
            public get Token(): number;
            public Equals ($obj: any) : boolean
            public Equals ($obj: System.Reflection.Emit.FieldToken) : boolean
            public static op_Equality ($a: System.Reflection.Emit.FieldToken, $b: System.Reflection.Emit.FieldToken) : boolean
            public static op_Inequality ($a: System.Reflection.Emit.FieldToken, $b: System.Reflection.Emit.FieldToken) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
        }
        class UnmanagedMarshal extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get BaseType(): System.Runtime.InteropServices.UnmanagedType;
            public get ElementCount(): number;
            public get GetUnmanagedType(): System.Runtime.InteropServices.UnmanagedType;
            public get IIDGuid(): System.Guid;
            public static DefineByValArray ($elemCount: number) : System.Reflection.Emit.UnmanagedMarshal
            public static DefineByValTStr ($elemCount: number) : System.Reflection.Emit.UnmanagedMarshal
            public static DefineLPArray ($elemType: System.Runtime.InteropServices.UnmanagedType) : System.Reflection.Emit.UnmanagedMarshal
            public static DefineSafeArray ($elemType: System.Runtime.InteropServices.UnmanagedType) : System.Reflection.Emit.UnmanagedMarshal
            public static DefineUnmanagedMarshal ($unmanagedType: System.Runtime.InteropServices.UnmanagedType) : System.Reflection.Emit.UnmanagedMarshal
        }
        enum FlowControl
        { Branch = 0, Break = 1, Call = 2, Cond_Branch = 3, Meta = 4, Next = 5, Phi = 6, Return = 7, Throw = 8 }
        class GenericTypeParameterBuilder extends System.Reflection.TypeInfo implements System.Runtime.InteropServices._MemberInfo, System.Runtime.InteropServices._Type, System.Reflection.ICustomAttributeProvider, System.Reflection.IReflect, System.Reflection.IReflectableType
        {
            protected [__keep_incompatibility]: never;
            public get UnderlyingSystemType(): System.Type;
            public get Assembly(): System.Reflection.Assembly;
            public get AssemblyQualifiedName(): string;
            public get BaseType(): System.Type;
            public get FullName(): string;
            public get GUID(): System.Guid;
            public get Name(): string;
            public get Namespace(): string;
            public get Module(): System.Reflection.Module;
            public get DeclaringType(): System.Type;
            public get ReflectedType(): System.Type;
            public get TypeHandle(): System.RuntimeTypeHandle;
            public get ContainsGenericParameters(): boolean;
            public get IsGenericParameter(): boolean;
            public get IsGenericType(): boolean;
            public get IsGenericTypeDefinition(): boolean;
            public get GenericParameterAttributes(): System.Reflection.GenericParameterAttributes;
            public get GenericParameterPosition(): number;
            public get DeclaringMethod(): System.Reflection.MethodBase;
            public SetBaseTypeConstraint ($baseTypeConstraint: System.Type) : void
            public SetInterfaceConstraints (...interfaceConstraints: System.Type[]) : void
            public SetGenericParameterAttributes ($genericParameterAttributes: System.Reflection.GenericParameterAttributes) : void
            public SetCustomAttribute ($customBuilder: System.Reflection.Emit.CustomAttributeBuilder) : void
            public SetCustomAttribute ($con: System.Reflection.ConstructorInfo, $binaryAttribute: System.Array$1<number>) : void
        }
        class Label extends System.ValueType implements System.IEquatable$1<System.Reflection.Emit.Label>
        {
            protected [__keep_incompatibility]: never;
            public Equals ($obj: any) : boolean
            public Equals ($obj: System.Reflection.Emit.Label) : boolean
            public static op_Equality ($a: System.Reflection.Emit.Label, $b: System.Reflection.Emit.Label) : boolean
            public static op_Inequality ($a: System.Reflection.Emit.Label, $b: System.Reflection.Emit.Label) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
        }
        class LocalBuilder extends System.Reflection.LocalVariableInfo implements System.Runtime.InteropServices._LocalBuilder
        {
            protected [__keep_incompatibility]: never;
            public get LocalType(): System.Type;
            public get IsPinned(): boolean;
            public get LocalIndex(): number;
            public SetLocalSymInfo ($name: string, $startOffset: number, $endOffset: number) : void
            public SetLocalSymInfo ($name: string) : void
            public GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            public GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            public GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            public Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
        }
        class OpCode extends System.ValueType implements System.IEquatable$1<System.Reflection.Emit.OpCode>
        {
            protected [__keep_incompatibility]: never;
            public get Name(): string;
            public get Size(): number;
            public get OpCodeType(): System.Reflection.Emit.OpCodeType;
            public get OperandType(): System.Reflection.Emit.OperandType;
            public get FlowControl(): System.Reflection.Emit.FlowControl;
            public get StackBehaviourPop(): System.Reflection.Emit.StackBehaviour;
            public get StackBehaviourPush(): System.Reflection.Emit.StackBehaviour;
            public get Value(): number;
            public Equals ($obj: any) : boolean
            public Equals ($obj: System.Reflection.Emit.OpCode) : boolean
            public static op_Equality ($a: System.Reflection.Emit.OpCode, $b: System.Reflection.Emit.OpCode) : boolean
            public static op_Inequality ($a: System.Reflection.Emit.OpCode, $b: System.Reflection.Emit.OpCode) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
        }
        class SignatureHelper extends System.Object implements System.Runtime.InteropServices._SignatureHelper
        {
            protected [__keep_incompatibility]: never;
            public static GetFieldSigHelper ($mod: System.Reflection.Module) : System.Reflection.Emit.SignatureHelper
            public static GetLocalVarSigHelper ($mod: System.Reflection.Module) : System.Reflection.Emit.SignatureHelper
            public static GetLocalVarSigHelper () : System.Reflection.Emit.SignatureHelper
            public static GetMethodSigHelper ($callingConvention: System.Reflection.CallingConventions, $returnType: System.Type) : System.Reflection.Emit.SignatureHelper
            public static GetMethodSigHelper ($unmanagedCallingConvention: System.Runtime.InteropServices.CallingConvention, $returnType: System.Type) : System.Reflection.Emit.SignatureHelper
            public static GetMethodSigHelper ($mod: System.Reflection.Module, $callingConvention: System.Reflection.CallingConventions, $returnType: System.Type) : System.Reflection.Emit.SignatureHelper
            public static GetMethodSigHelper ($mod: System.Reflection.Module, $unmanagedCallConv: System.Runtime.InteropServices.CallingConvention, $returnType: System.Type) : System.Reflection.Emit.SignatureHelper
            public static GetMethodSigHelper ($mod: System.Reflection.Module, $returnType: System.Type, $parameterTypes: System.Array$1<System.Type>) : System.Reflection.Emit.SignatureHelper
            public static GetPropertySigHelper ($mod: System.Reflection.Module, $returnType: System.Type, $parameterTypes: System.Array$1<System.Type>) : System.Reflection.Emit.SignatureHelper
            public static GetPropertySigHelper ($mod: System.Reflection.Module, $returnType: System.Type, $requiredReturnTypeCustomModifiers: System.Array$1<System.Type>, $optionalReturnTypeCustomModifiers: System.Array$1<System.Type>, $parameterTypes: System.Array$1<System.Type>, $requiredParameterTypeCustomModifiers: System.Array$1<System.Array$1<System.Type>>, $optionalParameterTypeCustomModifiers: System.Array$1<System.Array$1<System.Type>>) : System.Reflection.Emit.SignatureHelper
            public static GetPropertySigHelper ($mod: System.Reflection.Module, $callingConvention: System.Reflection.CallingConventions, $returnType: System.Type, $requiredReturnTypeCustomModifiers: System.Array$1<System.Type>, $optionalReturnTypeCustomModifiers: System.Array$1<System.Type>, $parameterTypes: System.Array$1<System.Type>, $requiredParameterTypeCustomModifiers: System.Array$1<System.Array$1<System.Type>>, $optionalParameterTypeCustomModifiers: System.Array$1<System.Array$1<System.Type>>) : System.Reflection.Emit.SignatureHelper
            public AddArguments ($arguments: System.Array$1<System.Type>, $requiredCustomModifiers: System.Array$1<System.Array$1<System.Type>>, $optionalCustomModifiers: System.Array$1<System.Array$1<System.Type>>) : void
            public AddArgument ($argument: System.Type, $pinned: boolean) : void
            public AddArgument ($argument: System.Type, $requiredCustomModifiers: System.Array$1<System.Type>, $optionalCustomModifiers: System.Array$1<System.Type>) : void
            public AddArgument ($clsArgument: System.Type) : void
            public AddSentinel () : void
            public GetSignature () : System.Array$1<number>
            public GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            public GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            public GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            public Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
        }
        class MethodRental extends System.Object implements System.Runtime.InteropServices._MethodRental
        {
            protected [__keep_incompatibility]: never;
            public static JitImmediate : number
            public static JitOnDemand : number
            public static SwapMethodBody ($cls: System.Type, $methodtoken: number, $rgIL: System.IntPtr, $methodSize: number, $flags: number) : void
            public GetIDsOfNames ($riid: $Ref<System.Guid>, $rgszNames: System.IntPtr, $cNames: number, $lcid: number, $rgDispId: System.IntPtr) : void
            public GetTypeInfo ($iTInfo: number, $lcid: number, $ppTInfo: System.IntPtr) : void
            public GetTypeInfoCount ($pcTInfo: $Ref<number>) : void
            public Invoke ($dispIdMember: number, $riid: $Ref<System.Guid>, $lcid: number, $wFlags: number, $pDispParams: System.IntPtr, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: System.IntPtr) : void
        }
        class TypeBuilder extends System.Reflection.TypeInfo implements System.Runtime.InteropServices._MemberInfo, System.Runtime.InteropServices._Type, System.Runtime.InteropServices._TypeBuilder, System.Reflection.ICustomAttributeProvider, System.Reflection.IReflect, System.Reflection.IReflectableType
        {
            protected [__keep_incompatibility]: never;
            public static UnspecifiedTypeSize : number
            public get Assembly(): System.Reflection.Assembly;
            public get AssemblyQualifiedName(): string;
            public get BaseType(): System.Type;
            public get DeclaringType(): System.Type;
            public get UnderlyingSystemType(): System.Type;
            public get FullName(): string;
            public get GUID(): System.Guid;
            public get Module(): System.Reflection.Module;
            public get Name(): string;
            public get Namespace(): string;
            public get PackingSize(): System.Reflection.Emit.PackingSize;
            public get Size(): number;
            public get ReflectedType(): System.Type;
            public get TypeHandle(): System.RuntimeTypeHandle;
            public get TypeToken(): System.Reflection.Emit.TypeToken;
            public get ContainsGenericParameters(): boolean;
            public get IsGenericParameter(): boolean;
            public get GenericParameterAttributes(): System.Reflection.GenericParameterAttributes;
            public get IsGenericTypeDefinition(): boolean;
            public get IsGenericType(): boolean;
            public get GenericParameterPosition(): number;
            public get DeclaringMethod(): System.Reflection.MethodBase;
            public get IsConstructedGenericType(): boolean;
            public get IsTypeDefinition(): boolean;
            public AddDeclarativeSecurity ($action: System.Security.Permissions.SecurityAction, $pset: System.Security.PermissionSet) : void
            public AddInterfaceImplementation ($interfaceType: System.Type) : void
            public DefineNestedType ($name: string) : System.Reflection.Emit.TypeBuilder
            public DefineNestedType ($name: string, $attr: System.Reflection.TypeAttributes) : System.Reflection.Emit.TypeBuilder
            public DefineNestedType ($name: string, $attr: System.Reflection.TypeAttributes, $parent: System.Type) : System.Reflection.Emit.TypeBuilder
            public DefineNestedType ($name: string, $attr: System.Reflection.TypeAttributes, $parent: System.Type, $interfaces: System.Array$1<System.Type>) : System.Reflection.Emit.TypeBuilder
            public DefineNestedType ($name: string, $attr: System.Reflection.TypeAttributes, $parent: System.Type, $typeSize: number) : System.Reflection.Emit.TypeBuilder
            public DefineNestedType ($name: string, $attr: System.Reflection.TypeAttributes, $parent: System.Type, $packSize: System.Reflection.Emit.PackingSize) : System.Reflection.Emit.TypeBuilder
            public DefineNestedType ($name: string, $attr: System.Reflection.TypeAttributes, $parent: System.Type, $packSize: System.Reflection.Emit.PackingSize, $typeSize: number) : System.Reflection.Emit.TypeBuilder
            public DefineConstructor ($attributes: System.Reflection.MethodAttributes, $callingConvention: System.Reflection.CallingConventions, $parameterTypes: System.Array$1<System.Type>) : System.Reflection.Emit.ConstructorBuilder
            public DefineConstructor ($attributes: System.Reflection.MethodAttributes, $callingConvention: System.Reflection.CallingConventions, $parameterTypes: System.Array$1<System.Type>, $requiredCustomModifiers: System.Array$1<System.Array$1<System.Type>>, $optionalCustomModifiers: System.Array$1<System.Array$1<System.Type>>) : System.Reflection.Emit.ConstructorBuilder
            public DefineDefaultConstructor ($attributes: System.Reflection.MethodAttributes) : System.Reflection.Emit.ConstructorBuilder
            public DefineMethod ($name: string, $attributes: System.Reflection.MethodAttributes, $returnType: System.Type, $parameterTypes: System.Array$1<System.Type>) : System.Reflection.Emit.MethodBuilder
            public DefineMethod ($name: string, $attributes: System.Reflection.MethodAttributes, $callingConvention: System.Reflection.CallingConventions, $returnType: System.Type, $parameterTypes: System.Array$1<System.Type>) : System.Reflection.Emit.MethodBuilder
            public DefineMethod ($name: string, $attributes: System.Reflection.MethodAttributes, $callingConvention: System.Reflection.CallingConventions, $returnType: System.Type, $returnTypeRequiredCustomModifiers: System.Array$1<System.Type>, $returnTypeOptionalCustomModifiers: System.Array$1<System.Type>, $parameterTypes: System.Array$1<System.Type>, $parameterTypeRequiredCustomModifiers: System.Array$1<System.Array$1<System.Type>>, $parameterTypeOptionalCustomModifiers: System.Array$1<System.Array$1<System.Type>>) : System.Reflection.Emit.MethodBuilder
            public DefinePInvokeMethod ($name: string, $dllName: string, $entryName: string, $attributes: System.Reflection.MethodAttributes, $callingConvention: System.Reflection.CallingConventions, $returnType: System.Type, $parameterTypes: System.Array$1<System.Type>, $nativeCallConv: System.Runtime.InteropServices.CallingConvention, $nativeCharSet: System.Runtime.InteropServices.CharSet) : System.Reflection.Emit.MethodBuilder
            public DefinePInvokeMethod ($name: string, $dllName: string, $entryName: string, $attributes: System.Reflection.MethodAttributes, $callingConvention: System.Reflection.CallingConventions, $returnType: System.Type, $returnTypeRequiredCustomModifiers: System.Array$1<System.Type>, $returnTypeOptionalCustomModifiers: System.Array$1<System.Type>, $parameterTypes: System.Array$1<System.Type>, $parameterTypeRequiredCustomModifiers: System.Array$1<System.Array$1<System.Type>>, $parameterTypeOptionalCustomModifiers: System.Array$1<System.Array$1<System.Type>>, $nativeCallConv: System.Runtime.InteropServices.CallingConvention, $nativeCharSet: System.Runtime.InteropServices.CharSet) : System.Reflection.Emit.MethodBuilder
            public DefinePInvokeMethod ($name: string, $dllName: string, $attributes: System.Reflection.MethodAttributes, $callingConvention: System.Reflection.CallingConventions, $returnType: System.Type, $parameterTypes: System.Array$1<System.Type>, $nativeCallConv: System.Runtime.InteropServices.CallingConvention, $nativeCharSet: System.Runtime.InteropServices.CharSet) : System.Reflection.Emit.MethodBuilder
            public DefineMethod ($name: string, $attributes: System.Reflection.MethodAttributes) : System.Reflection.Emit.MethodBuilder
            public DefineMethod ($name: string, $attributes: System.Reflection.MethodAttributes, $callingConvention: System.Reflection.CallingConventions) : System.Reflection.Emit.MethodBuilder
            public DefineMethodOverride ($methodInfoBody: System.Reflection.MethodInfo, $methodInfoDeclaration: System.Reflection.MethodInfo) : void
            public DefineField ($fieldName: string, $type: System.Type, $attributes: System.Reflection.FieldAttributes) : System.Reflection.Emit.FieldBuilder
            public DefineField ($fieldName: string, $type: System.Type, $requiredCustomModifiers: System.Array$1<System.Type>, $optionalCustomModifiers: System.Array$1<System.Type>, $attributes: System.Reflection.FieldAttributes) : System.Reflection.Emit.FieldBuilder
            public DefineProperty ($name: string, $attributes: System.Reflection.PropertyAttributes, $returnType: System.Type, $parameterTypes: System.Array$1<System.Type>) : System.Reflection.Emit.PropertyBuilder
            public DefineProperty ($name: string, $attributes: System.Reflection.PropertyAttributes, $callingConvention: System.Reflection.CallingConventions, $returnType: System.Type, $parameterTypes: System.Array$1<System.Type>) : System.Reflection.Emit.PropertyBuilder
            public DefineProperty ($name: string, $attributes: System.Reflection.PropertyAttributes, $returnType: System.Type, $returnTypeRequiredCustomModifiers: System.Array$1<System.Type>, $returnTypeOptionalCustomModifiers: System.Array$1<System.Type>, $parameterTypes: System.Array$1<System.Type>, $parameterTypeRequiredCustomModifiers: System.Array$1<System.Array$1<System.Type>>, $parameterTypeOptionalCustomModifiers: System.Array$1<System.Array$1<System.Type>>) : System.Reflection.Emit.PropertyBuilder
            public DefineProperty ($name: string, $attributes: System.Reflection.PropertyAttributes, $callingConvention: System.Reflection.CallingConventions, $returnType: System.Type, $returnTypeRequiredCustomModifiers: System.Array$1<System.Type>, $returnTypeOptionalCustomModifiers: System.Array$1<System.Type>, $parameterTypes: System.Array$1<System.Type>, $parameterTypeRequiredCustomModifiers: System.Array$1<System.Array$1<System.Type>>, $parameterTypeOptionalCustomModifiers: System.Array$1<System.Array$1<System.Type>>) : System.Reflection.Emit.PropertyBuilder
            public DefineTypeInitializer () : System.Reflection.Emit.ConstructorBuilder
            public CreateType () : System.Type
            public CreateTypeInfo () : System.Reflection.TypeInfo
            public GetField ($name: string, $bindingAttr: System.Reflection.BindingFlags) : System.Reflection.FieldInfo
            public SetCustomAttribute ($customBuilder: System.Reflection.Emit.CustomAttributeBuilder) : void
            public SetCustomAttribute ($con: System.Reflection.ConstructorInfo, $binaryAttribute: System.Array$1<number>) : void
            public DefineEvent ($name: string, $attributes: System.Reflection.EventAttributes, $eventtype: System.Type) : System.Reflection.Emit.EventBuilder
            public DefineInitializedData ($name: string, $data: System.Array$1<number>, $attributes: System.Reflection.FieldAttributes) : System.Reflection.Emit.FieldBuilder
            public DefineUninitializedData ($name: string, $size: number, $attributes: System.Reflection.FieldAttributes) : System.Reflection.Emit.FieldBuilder
            public SetParent ($parent: System.Type) : void
            public IsCreated () : boolean
            public DefineGenericParameters (...names: string[]) : System.Array$1<System.Reflection.Emit.GenericTypeParameterBuilder>
            public static GetConstructor ($type: System.Type, $constructor: System.Reflection.ConstructorInfo) : System.Reflection.ConstructorInfo
            public static GetMethod ($type: System.Type, $method: System.Reflection.MethodInfo) : System.Reflection.MethodInfo
            public static GetField ($type: System.Type, $field: System.Reflection.FieldInfo) : System.Reflection.FieldInfo
            public GetConstructor ($types: System.Array$1<System.Type>) : System.Reflection.ConstructorInfo
            public GetConstructor ($bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>) : System.Reflection.ConstructorInfo
            public GetConstructor ($bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $callConvention: System.Reflection.CallingConventions, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>) : System.Reflection.ConstructorInfo
            public GetField ($name: string) : System.Reflection.FieldInfo
            public GetMethod ($name: string) : System.Reflection.MethodInfo
            public GetMethod ($name: string, $bindingAttr: System.Reflection.BindingFlags) : System.Reflection.MethodInfo
            public GetMethod ($name: string, $types: System.Array$1<System.Type>) : System.Reflection.MethodInfo
            public GetMethod ($name: string, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>) : System.Reflection.MethodInfo
            public GetMethod ($name: string, $bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>) : System.Reflection.MethodInfo
            public GetMethod ($name: string, $bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $callConvention: System.Reflection.CallingConventions, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>) : System.Reflection.MethodInfo
            public GetMethod ($name: string, $genericParameterCount: number, $types: System.Array$1<System.Type>) : System.Reflection.MethodInfo
            public GetMethod ($name: string, $genericParameterCount: number, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>) : System.Reflection.MethodInfo
            public GetMethod ($name: string, $genericParameterCount: number, $bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>) : System.Reflection.MethodInfo
            public GetMethod ($name: string, $genericParameterCount: number, $bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $callConvention: System.Reflection.CallingConventions, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>) : System.Reflection.MethodInfo
        }
        class SignatureToken extends System.ValueType implements System.IEquatable$1<System.Reflection.Emit.SignatureToken>
        {
            protected [__keep_incompatibility]: never;
            public static Empty : System.Reflection.Emit.SignatureToken
            public get Token(): number;
            public Equals ($obj: any) : boolean
            public Equals ($obj: System.Reflection.Emit.SignatureToken) : boolean
            public static op_Equality ($a: System.Reflection.Emit.SignatureToken, $b: System.Reflection.Emit.SignatureToken) : boolean
            public static op_Inequality ($a: System.Reflection.Emit.SignatureToken, $b: System.Reflection.Emit.SignatureToken) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
        }
        class StringToken extends System.ValueType implements System.IEquatable$1<System.Reflection.Emit.StringToken>
        {
            protected [__keep_incompatibility]: never;
            public get Token(): number;
            public Equals ($obj: any) : boolean
            public Equals ($obj: System.Reflection.Emit.StringToken) : boolean
            public static op_Equality ($a: System.Reflection.Emit.StringToken, $b: System.Reflection.Emit.StringToken) : boolean
            public static op_Inequality ($a: System.Reflection.Emit.StringToken, $b: System.Reflection.Emit.StringToken) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
        }
        class OpCodes extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static Nop : System.Reflection.Emit.OpCode
            public static Break : System.Reflection.Emit.OpCode
            public static Ldarg_0 : System.Reflection.Emit.OpCode
            public static Ldarg_1 : System.Reflection.Emit.OpCode
            public static Ldarg_2 : System.Reflection.Emit.OpCode
            public static Ldarg_3 : System.Reflection.Emit.OpCode
            public static Ldloc_0 : System.Reflection.Emit.OpCode
            public static Ldloc_1 : System.Reflection.Emit.OpCode
            public static Ldloc_2 : System.Reflection.Emit.OpCode
            public static Ldloc_3 : System.Reflection.Emit.OpCode
            public static Stloc_0 : System.Reflection.Emit.OpCode
            public static Stloc_1 : System.Reflection.Emit.OpCode
            public static Stloc_2 : System.Reflection.Emit.OpCode
            public static Stloc_3 : System.Reflection.Emit.OpCode
            public static Ldarg_S : System.Reflection.Emit.OpCode
            public static Ldarga_S : System.Reflection.Emit.OpCode
            public static Starg_S : System.Reflection.Emit.OpCode
            public static Ldloc_S : System.Reflection.Emit.OpCode
            public static Ldloca_S : System.Reflection.Emit.OpCode
            public static Stloc_S : System.Reflection.Emit.OpCode
            public static Ldnull : System.Reflection.Emit.OpCode
            public static Ldc_I4_M1 : System.Reflection.Emit.OpCode
            public static Ldc_I4_0 : System.Reflection.Emit.OpCode
            public static Ldc_I4_1 : System.Reflection.Emit.OpCode
            public static Ldc_I4_2 : System.Reflection.Emit.OpCode
            public static Ldc_I4_3 : System.Reflection.Emit.OpCode
            public static Ldc_I4_4 : System.Reflection.Emit.OpCode
            public static Ldc_I4_5 : System.Reflection.Emit.OpCode
            public static Ldc_I4_6 : System.Reflection.Emit.OpCode
            public static Ldc_I4_7 : System.Reflection.Emit.OpCode
            public static Ldc_I4_8 : System.Reflection.Emit.OpCode
            public static Ldc_I4_S : System.Reflection.Emit.OpCode
            public static Ldc_I4 : System.Reflection.Emit.OpCode
            public static Ldc_I8 : System.Reflection.Emit.OpCode
            public static Ldc_R4 : System.Reflection.Emit.OpCode
            public static Ldc_R8 : System.Reflection.Emit.OpCode
            public static Dup : System.Reflection.Emit.OpCode
            public static Pop : System.Reflection.Emit.OpCode
            public static Jmp : System.Reflection.Emit.OpCode
            public static Call : System.Reflection.Emit.OpCode
            public static Calli : System.Reflection.Emit.OpCode
            public static Ret : System.Reflection.Emit.OpCode
            public static Br_S : System.Reflection.Emit.OpCode
            public static Brfalse_S : System.Reflection.Emit.OpCode
            public static Brtrue_S : System.Reflection.Emit.OpCode
            public static Beq_S : System.Reflection.Emit.OpCode
            public static Bge_S : System.Reflection.Emit.OpCode
            public static Bgt_S : System.Reflection.Emit.OpCode
            public static Ble_S : System.Reflection.Emit.OpCode
            public static Blt_S : System.Reflection.Emit.OpCode
            public static Bne_Un_S : System.Reflection.Emit.OpCode
            public static Bge_Un_S : System.Reflection.Emit.OpCode
            public static Bgt_Un_S : System.Reflection.Emit.OpCode
            public static Ble_Un_S : System.Reflection.Emit.OpCode
            public static Blt_Un_S : System.Reflection.Emit.OpCode
            public static Br : System.Reflection.Emit.OpCode
            public static Brfalse : System.Reflection.Emit.OpCode
            public static Brtrue : System.Reflection.Emit.OpCode
            public static Beq : System.Reflection.Emit.OpCode
            public static Bge : System.Reflection.Emit.OpCode
            public static Bgt : System.Reflection.Emit.OpCode
            public static Ble : System.Reflection.Emit.OpCode
            public static Blt : System.Reflection.Emit.OpCode
            public static Bne_Un : System.Reflection.Emit.OpCode
            public static Bge_Un : System.Reflection.Emit.OpCode
            public static Bgt_Un : System.Reflection.Emit.OpCode
            public static Ble_Un : System.Reflection.Emit.OpCode
            public static Blt_Un : System.Reflection.Emit.OpCode
            public static Switch : System.Reflection.Emit.OpCode
            public static Ldind_I1 : System.Reflection.Emit.OpCode
            public static Ldind_U1 : System.Reflection.Emit.OpCode
            public static Ldind_I2 : System.Reflection.Emit.OpCode
            public static Ldind_U2 : System.Reflection.Emit.OpCode
            public static Ldind_I4 : System.Reflection.Emit.OpCode
            public static Ldind_U4 : System.Reflection.Emit.OpCode
            public static Ldind_I8 : System.Reflection.Emit.OpCode
            public static Ldind_I : System.Reflection.Emit.OpCode
            public static Ldind_R4 : System.Reflection.Emit.OpCode
            public static Ldind_R8 : System.Reflection.Emit.OpCode
            public static Ldind_Ref : System.Reflection.Emit.OpCode
            public static Stind_Ref : System.Reflection.Emit.OpCode
            public static Stind_I1 : System.Reflection.Emit.OpCode
            public static Stind_I2 : System.Reflection.Emit.OpCode
            public static Stind_I4 : System.Reflection.Emit.OpCode
            public static Stind_I8 : System.Reflection.Emit.OpCode
            public static Stind_R4 : System.Reflection.Emit.OpCode
            public static Stind_R8 : System.Reflection.Emit.OpCode
            public static Add : System.Reflection.Emit.OpCode
            public static Sub : System.Reflection.Emit.OpCode
            public static Mul : System.Reflection.Emit.OpCode
            public static Div : System.Reflection.Emit.OpCode
            public static Div_Un : System.Reflection.Emit.OpCode
            public static Rem : System.Reflection.Emit.OpCode
            public static Rem_Un : System.Reflection.Emit.OpCode
            public static And : System.Reflection.Emit.OpCode
            public static Or : System.Reflection.Emit.OpCode
            public static Xor : System.Reflection.Emit.OpCode
            public static Shl : System.Reflection.Emit.OpCode
            public static Shr : System.Reflection.Emit.OpCode
            public static Shr_Un : System.Reflection.Emit.OpCode
            public static Neg : System.Reflection.Emit.OpCode
            public static Not : System.Reflection.Emit.OpCode
            public static Conv_I1 : System.Reflection.Emit.OpCode
            public static Conv_I2 : System.Reflection.Emit.OpCode
            public static Conv_I4 : System.Reflection.Emit.OpCode
            public static Conv_I8 : System.Reflection.Emit.OpCode
            public static Conv_R4 : System.Reflection.Emit.OpCode
            public static Conv_R8 : System.Reflection.Emit.OpCode
            public static Conv_U4 : System.Reflection.Emit.OpCode
            public static Conv_U8 : System.Reflection.Emit.OpCode
            public static Callvirt : System.Reflection.Emit.OpCode
            public static Cpobj : System.Reflection.Emit.OpCode
            public static Ldobj : System.Reflection.Emit.OpCode
            public static Ldstr : System.Reflection.Emit.OpCode
            public static Newobj : System.Reflection.Emit.OpCode
            public static Castclass : System.Reflection.Emit.OpCode
            public static Isinst : System.Reflection.Emit.OpCode
            public static Conv_R_Un : System.Reflection.Emit.OpCode
            public static Unbox : System.Reflection.Emit.OpCode
            public static Throw : System.Reflection.Emit.OpCode
            public static Ldfld : System.Reflection.Emit.OpCode
            public static Ldflda : System.Reflection.Emit.OpCode
            public static Stfld : System.Reflection.Emit.OpCode
            public static Ldsfld : System.Reflection.Emit.OpCode
            public static Ldsflda : System.Reflection.Emit.OpCode
            public static Stsfld : System.Reflection.Emit.OpCode
            public static Stobj : System.Reflection.Emit.OpCode
            public static Conv_Ovf_I1_Un : System.Reflection.Emit.OpCode
            public static Conv_Ovf_I2_Un : System.Reflection.Emit.OpCode
            public static Conv_Ovf_I4_Un : System.Reflection.Emit.OpCode
            public static Conv_Ovf_I8_Un : System.Reflection.Emit.OpCode
            public static Conv_Ovf_U1_Un : System.Reflection.Emit.OpCode
            public static Conv_Ovf_U2_Un : System.Reflection.Emit.OpCode
            public static Conv_Ovf_U4_Un : System.Reflection.Emit.OpCode
            public static Conv_Ovf_U8_Un : System.Reflection.Emit.OpCode
            public static Conv_Ovf_I_Un : System.Reflection.Emit.OpCode
            public static Conv_Ovf_U_Un : System.Reflection.Emit.OpCode
            public static Box : System.Reflection.Emit.OpCode
            public static Newarr : System.Reflection.Emit.OpCode
            public static Ldlen : System.Reflection.Emit.OpCode
            public static Ldelema : System.Reflection.Emit.OpCode
            public static Ldelem_I1 : System.Reflection.Emit.OpCode
            public static Ldelem_U1 : System.Reflection.Emit.OpCode
            public static Ldelem_I2 : System.Reflection.Emit.OpCode
            public static Ldelem_U2 : System.Reflection.Emit.OpCode
            public static Ldelem_I4 : System.Reflection.Emit.OpCode
            public static Ldelem_U4 : System.Reflection.Emit.OpCode
            public static Ldelem_I8 : System.Reflection.Emit.OpCode
            public static Ldelem_I : System.Reflection.Emit.OpCode
            public static Ldelem_R4 : System.Reflection.Emit.OpCode
            public static Ldelem_R8 : System.Reflection.Emit.OpCode
            public static Ldelem_Ref : System.Reflection.Emit.OpCode
            public static Stelem_I : System.Reflection.Emit.OpCode
            public static Stelem_I1 : System.Reflection.Emit.OpCode
            public static Stelem_I2 : System.Reflection.Emit.OpCode
            public static Stelem_I4 : System.Reflection.Emit.OpCode
            public static Stelem_I8 : System.Reflection.Emit.OpCode
            public static Stelem_R4 : System.Reflection.Emit.OpCode
            public static Stelem_R8 : System.Reflection.Emit.OpCode
            public static Stelem_Ref : System.Reflection.Emit.OpCode
            public static Ldelem : System.Reflection.Emit.OpCode
            public static Stelem : System.Reflection.Emit.OpCode
            public static Unbox_Any : System.Reflection.Emit.OpCode
            public static Conv_Ovf_I1 : System.Reflection.Emit.OpCode
            public static Conv_Ovf_U1 : System.Reflection.Emit.OpCode
            public static Conv_Ovf_I2 : System.Reflection.Emit.OpCode
            public static Conv_Ovf_U2 : System.Reflection.Emit.OpCode
            public static Conv_Ovf_I4 : System.Reflection.Emit.OpCode
            public static Conv_Ovf_U4 : System.Reflection.Emit.OpCode
            public static Conv_Ovf_I8 : System.Reflection.Emit.OpCode
            public static Conv_Ovf_U8 : System.Reflection.Emit.OpCode
            public static Refanyval : System.Reflection.Emit.OpCode
            public static Ckfinite : System.Reflection.Emit.OpCode
            public static Mkrefany : System.Reflection.Emit.OpCode
            public static Ldtoken : System.Reflection.Emit.OpCode
            public static Conv_U2 : System.Reflection.Emit.OpCode
            public static Conv_U1 : System.Reflection.Emit.OpCode
            public static Conv_I : System.Reflection.Emit.OpCode
            public static Conv_Ovf_I : System.Reflection.Emit.OpCode
            public static Conv_Ovf_U : System.Reflection.Emit.OpCode
            public static Add_Ovf : System.Reflection.Emit.OpCode
            public static Add_Ovf_Un : System.Reflection.Emit.OpCode
            public static Mul_Ovf : System.Reflection.Emit.OpCode
            public static Mul_Ovf_Un : System.Reflection.Emit.OpCode
            public static Sub_Ovf : System.Reflection.Emit.OpCode
            public static Sub_Ovf_Un : System.Reflection.Emit.OpCode
            public static Endfinally : System.Reflection.Emit.OpCode
            public static Leave : System.Reflection.Emit.OpCode
            public static Leave_S : System.Reflection.Emit.OpCode
            public static Stind_I : System.Reflection.Emit.OpCode
            public static Conv_U : System.Reflection.Emit.OpCode
            public static Prefix7 : System.Reflection.Emit.OpCode
            public static Prefix6 : System.Reflection.Emit.OpCode
            public static Prefix5 : System.Reflection.Emit.OpCode
            public static Prefix4 : System.Reflection.Emit.OpCode
            public static Prefix3 : System.Reflection.Emit.OpCode
            public static Prefix2 : System.Reflection.Emit.OpCode
            public static Prefix1 : System.Reflection.Emit.OpCode
            public static Prefixref : System.Reflection.Emit.OpCode
            public static Arglist : System.Reflection.Emit.OpCode
            public static Ceq : System.Reflection.Emit.OpCode
            public static Cgt : System.Reflection.Emit.OpCode
            public static Cgt_Un : System.Reflection.Emit.OpCode
            public static Clt : System.Reflection.Emit.OpCode
            public static Clt_Un : System.Reflection.Emit.OpCode
            public static Ldftn : System.Reflection.Emit.OpCode
            public static Ldvirtftn : System.Reflection.Emit.OpCode
            public static Ldarg : System.Reflection.Emit.OpCode
            public static Ldarga : System.Reflection.Emit.OpCode
            public static Starg : System.Reflection.Emit.OpCode
            public static Ldloc : System.Reflection.Emit.OpCode
            public static Ldloca : System.Reflection.Emit.OpCode
            public static Stloc : System.Reflection.Emit.OpCode
            public static Localloc : System.Reflection.Emit.OpCode
            public static Endfilter : System.Reflection.Emit.OpCode
            public static Unaligned : System.Reflection.Emit.OpCode
            public static Volatile : System.Reflection.Emit.OpCode
            public static Tailcall : System.Reflection.Emit.OpCode
            public static Initobj : System.Reflection.Emit.OpCode
            public static Constrained : System.Reflection.Emit.OpCode
            public static Cpblk : System.Reflection.Emit.OpCode
            public static Initblk : System.Reflection.Emit.OpCode
            public static Rethrow : System.Reflection.Emit.OpCode
            public static Sizeof : System.Reflection.Emit.OpCode
            public static Refanytype : System.Reflection.Emit.OpCode
            public static Readonly : System.Reflection.Emit.OpCode
            public static TakesSingleByteArgument ($inst: System.Reflection.Emit.OpCode) : boolean
        }
        class ParameterToken extends System.ValueType implements System.IEquatable$1<System.Reflection.Emit.ParameterToken>
        {
            protected [__keep_incompatibility]: never;
            public static Empty : System.Reflection.Emit.ParameterToken
            public get Token(): number;
            public Equals ($obj: any) : boolean
            public Equals ($obj: System.Reflection.Emit.ParameterToken) : boolean
            public static op_Equality ($a: System.Reflection.Emit.ParameterToken, $b: System.Reflection.Emit.ParameterToken) : boolean
            public static op_Inequality ($a: System.Reflection.Emit.ParameterToken, $b: System.Reflection.Emit.ParameterToken) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
        }
        class PropertyBuilder extends System.Reflection.PropertyInfo implements System.Runtime.InteropServices._PropertyBuilder, System.Runtime.InteropServices._PropertyInfo, System.Runtime.InteropServices._MemberInfo, System.Reflection.ICustomAttributeProvider
        {
            protected [__keep_incompatibility]: never;
            public get Attributes(): System.Reflection.PropertyAttributes;
            public get CanRead(): boolean;
            public get CanWrite(): boolean;
            public get DeclaringType(): System.Type;
            public get Name(): string;
            public get PropertyToken(): System.Reflection.Emit.PropertyToken;
            public get PropertyType(): System.Type;
            public get ReflectedType(): System.Type;
            public get Module(): System.Reflection.Module;
            public AddOtherMethod ($mdBuilder: System.Reflection.Emit.MethodBuilder) : void
            public SetConstant ($defaultValue: any) : void
            public SetCustomAttribute ($customBuilder: System.Reflection.Emit.CustomAttributeBuilder) : void
            public SetCustomAttribute ($con: System.Reflection.ConstructorInfo, $binaryAttribute: System.Array$1<number>) : void
            public SetGetMethod ($mdBuilder: System.Reflection.Emit.MethodBuilder) : void
            public SetSetMethod ($mdBuilder: System.Reflection.Emit.MethodBuilder) : void
        }
        class PropertyToken extends System.ValueType implements System.IEquatable$1<System.Reflection.Emit.PropertyToken>
        {
            protected [__keep_incompatibility]: never;
            public static Empty : System.Reflection.Emit.PropertyToken
            public get Token(): number;
            public Equals ($obj: any) : boolean
            public Equals ($obj: System.Reflection.Emit.PropertyToken) : boolean
            public static op_Equality ($a: System.Reflection.Emit.PropertyToken, $b: System.Reflection.Emit.PropertyToken) : boolean
            public static op_Inequality ($a: System.Reflection.Emit.PropertyToken, $b: System.Reflection.Emit.PropertyToken) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
        }
    }
    namespace System.Security.Principal {
        enum PrincipalPolicy
        { UnauthenticatedPrincipal = 0, NoPrincipal = 1, WindowsPrincipal = 2 }
        interface IPrincipal
        {
            Identity : System.Security.Principal.IIdentity
            IsInRole ($role: string) : boolean
        }
        interface IIdentity
        {
            Name : string
            AuthenticationType : string
            IsAuthenticated : boolean
        }
        class GenericIdentity extends System.Security.Claims.ClaimsIdentity implements System.Security.Principal.IIdentity
        {
            protected [__keep_incompatibility]: never;
            public get Claims(): System.Collections.Generic.IEnumerable$1<System.Security.Claims.Claim>;
            public get Name(): string;
            public get AuthenticationType(): string;
            public get IsAuthenticated(): boolean;
            public constructor ($name: string)
            public constructor ($name: string, $type: string)
            public constructor ()
            public constructor ($identity: System.Security.Principal.IIdentity)
            public constructor ($claims: System.Collections.Generic.IEnumerable$1<System.Security.Claims.Claim>)
            public constructor ($authenticationType: string)
            public constructor ($claims: System.Collections.Generic.IEnumerable$1<System.Security.Claims.Claim>, $authenticationType: string)
            public constructor ($identity: System.Security.Principal.IIdentity, $claims: System.Collections.Generic.IEnumerable$1<System.Security.Claims.Claim>)
            public constructor ($authenticationType: string, $nameType: string, $roleType: string)
            public constructor ($claims: System.Collections.Generic.IEnumerable$1<System.Security.Claims.Claim>, $authenticationType: string, $nameType: string, $roleType: string)
            public constructor ($identity: System.Security.Principal.IIdentity, $claims: System.Collections.Generic.IEnumerable$1<System.Security.Claims.Claim>, $authenticationType: string, $nameType: string, $roleType: string)
            public constructor ($reader: System.IO.BinaryReader)
        }
        enum TokenAccessLevels
        { AssignPrimary = 1, Duplicate = 2, Impersonate = 4, Query = 8, QuerySource = 16, AdjustPrivileges = 32, AdjustGroups = 64, AdjustDefault = 128, AdjustSessionId = 256, Read = 131080, Write = 131296, AllAccess = 983551, MaximumAllowed = 33554432 }
        enum TokenImpersonationLevel
        { None = 0, Anonymous = 1, Identification = 2, Impersonation = 3, Delegation = 4 }
        class GenericPrincipal extends System.Security.Claims.ClaimsPrincipal implements System.Security.Principal.IPrincipal
        {
            protected [__keep_incompatibility]: never;
            public get Identity(): System.Security.Principal.IIdentity;
            public constructor ($identity: System.Security.Principal.IIdentity, $roles: System.Array$1<string>)
            public constructor ()
            public constructor ($identities: System.Collections.Generic.IEnumerable$1<System.Security.Claims.ClaimsIdentity>)
            public constructor ($identity: System.Security.Principal.IIdentity)
            public constructor ($principal: System.Security.Principal.IPrincipal)
            public constructor ($reader: System.IO.BinaryReader)
        }
        class IdentityNotMappedException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public get UnmappedIdentities(): System.Security.Principal.IdentityReferenceCollection;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $inner: System.Exception)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class IdentityReferenceCollection extends System.Object implements System.Collections.Generic.IEnumerable$1<System.Security.Principal.IdentityReference>, System.Collections.IEnumerable, System.Collections.Generic.ICollection$1<System.Security.Principal.IdentityReference>
        {
            protected [__keep_incompatibility]: never;
            public get Count(): number;
            public get IsReadOnly(): boolean;
            public get_Item ($index: number) : System.Security.Principal.IdentityReference
            public set_Item ($index: number, $value: System.Security.Principal.IdentityReference) : void
            public Add ($identity: System.Security.Principal.IdentityReference) : void
            public Clear () : void
            public Contains ($identity: System.Security.Principal.IdentityReference) : boolean
            public CopyTo ($array: System.Array$1<System.Security.Principal.IdentityReference>, $offset: number) : void
            public GetEnumerator () : System.Collections.Generic.IEnumerator$1<System.Security.Principal.IdentityReference>
            public Remove ($identity: System.Security.Principal.IdentityReference) : boolean
            public Translate ($targetType: System.Type) : System.Security.Principal.IdentityReferenceCollection
            public Translate ($targetType: System.Type, $forceSuccess: boolean) : System.Security.Principal.IdentityReferenceCollection
            public constructor ()
            public constructor ($capacity: number)
            public GetEnumerator () : System.Collections.IEnumerator
        }
        class IdentityReference extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get Value(): string;
            public IsValidTargetType ($targetType: System.Type) : boolean
            public Translate ($targetType: System.Type) : System.Security.Principal.IdentityReference
            public static op_Equality ($left: System.Security.Principal.IdentityReference, $right: System.Security.Principal.IdentityReference) : boolean
            public static op_Inequality ($left: System.Security.Principal.IdentityReference, $right: System.Security.Principal.IdentityReference) : boolean
        }
        class NTAccount extends System.Security.Principal.IdentityReference
        {
            protected [__keep_incompatibility]: never;
            public get Value(): string;
            public static op_Equality ($left: System.Security.Principal.NTAccount, $right: System.Security.Principal.NTAccount) : boolean
            public static op_Inequality ($left: System.Security.Principal.NTAccount, $right: System.Security.Principal.NTAccount) : boolean
            public constructor ($name: string)
            public constructor ($domainName: string, $accountName: string)
            public static op_Equality ($left: System.Security.Principal.IdentityReference, $right: System.Security.Principal.IdentityReference) : boolean
            public static op_Inequality ($left: System.Security.Principal.IdentityReference, $right: System.Security.Principal.IdentityReference) : boolean
            public constructor ()
        }
        class SecurityIdentifier extends System.Security.Principal.IdentityReference implements System.IComparable$1<System.Security.Principal.SecurityIdentifier>
        {
            protected [__keep_incompatibility]: never;
            public static MaxBinaryLength : number
            public static MinBinaryLength : number
            public get AccountDomainSid(): System.Security.Principal.SecurityIdentifier;
            public get BinaryLength(): number;
            public get Value(): string;
            public CompareTo ($sid: System.Security.Principal.SecurityIdentifier) : number
            public Equals ($o: any) : boolean
            public Equals ($sid: System.Security.Principal.SecurityIdentifier) : boolean
            public GetBinaryForm ($binaryForm: System.Array$1<number>, $offset: number) : void
            public IsAccountSid () : boolean
            public IsEqualDomainSid ($sid: System.Security.Principal.SecurityIdentifier) : boolean
            public IsWellKnown ($type: System.Security.Principal.WellKnownSidType) : boolean
            public static op_Equality ($left: System.Security.Principal.SecurityIdentifier, $right: System.Security.Principal.SecurityIdentifier) : boolean
            public static op_Inequality ($left: System.Security.Principal.SecurityIdentifier, $right: System.Security.Principal.SecurityIdentifier) : boolean
            public constructor ($sddlForm: string)
            public constructor ($binaryForm: System.Array$1<number>, $offset: number)
            public constructor ($binaryForm: System.IntPtr)
            public constructor ($sidType: System.Security.Principal.WellKnownSidType, $domainSid: System.Security.Principal.SecurityIdentifier)
            public static op_Equality ($left: System.Security.Principal.IdentityReference, $right: System.Security.Principal.IdentityReference) : boolean
            public static op_Inequality ($left: System.Security.Principal.IdentityReference, $right: System.Security.Principal.IdentityReference) : boolean
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
            public constructor ()
        }
        enum WellKnownSidType
        { NullSid = 0, WorldSid = 1, LocalSid = 2, CreatorOwnerSid = 3, CreatorGroupSid = 4, CreatorOwnerServerSid = 5, CreatorGroupServerSid = 6, NTAuthoritySid = 7, DialupSid = 8, NetworkSid = 9, BatchSid = 10, InteractiveSid = 11, ServiceSid = 12, AnonymousSid = 13, ProxySid = 14, EnterpriseControllersSid = 15, SelfSid = 16, AuthenticatedUserSid = 17, RestrictedCodeSid = 18, TerminalServerSid = 19, RemoteLogonIdSid = 20, LogonIdsSid = 21, LocalSystemSid = 22, LocalServiceSid = 23, NetworkServiceSid = 24, BuiltinDomainSid = 25, BuiltinAdministratorsSid = 26, BuiltinUsersSid = 27, BuiltinGuestsSid = 28, BuiltinPowerUsersSid = 29, BuiltinAccountOperatorsSid = 30, BuiltinSystemOperatorsSid = 31, BuiltinPrintOperatorsSid = 32, BuiltinBackupOperatorsSid = 33, BuiltinReplicatorSid = 34, BuiltinPreWindows2000CompatibleAccessSid = 35, BuiltinRemoteDesktopUsersSid = 36, BuiltinNetworkConfigurationOperatorsSid = 37, AccountAdministratorSid = 38, AccountGuestSid = 39, AccountKrbtgtSid = 40, AccountDomainAdminsSid = 41, AccountDomainUsersSid = 42, AccountDomainGuestsSid = 43, AccountComputersSid = 44, AccountControllersSid = 45, AccountCertAdminsSid = 46, AccountSchemaAdminsSid = 47, AccountEnterpriseAdminsSid = 48, AccountPolicyAdminsSid = 49, AccountRasAndIasServersSid = 50, NtlmAuthenticationSid = 51, DigestAuthenticationSid = 52, SChannelAuthenticationSid = 53, ThisOrganizationSid = 54, OtherOrganizationSid = 55, BuiltinIncomingForestTrustBuildersSid = 56, BuiltinPerformanceMonitoringUsersSid = 57, BuiltinPerformanceLoggingUsersSid = 58, BuiltinAuthorizationAccessSid = 59, WinBuiltinTerminalServerLicenseServersSid = 60, MaxDefined = 60, WinBuiltinDCOMUsersSid = 61, WinBuiltinIUsersSid = 62, WinIUserSid = 63, WinBuiltinCryptoOperatorsSid = 64, WinUntrustedLabelSid = 65, WinLowLabelSid = 66, WinMediumLabelSid = 67, WinHighLabelSid = 68, WinSystemLabelSid = 69, WinWriteRestrictedCodeSid = 70, WinCreatorOwnerRightsSid = 71, WinCacheablePrincipalsGroupSid = 72, WinNonCacheablePrincipalsGroupSid = 73, WinEnterpriseReadonlyControllersSid = 74, WinAccountReadonlyControllersSid = 75, WinBuiltinEventLogReadersGroup = 76, WinNewEnterpriseReadonlyControllersSid = 77, WinBuiltinCertSvcDComAccessGroup = 78, WinMediumPlusLabelSid = 79, WinLocalLogonSid = 80, WinConsoleLogonSid = 81, WinThisOrganizationCertificateSid = 82, WinApplicationPackageAuthoritySid = 83, WinBuiltinAnyPackageSid = 84, WinCapabilityInternetClientSid = 85, WinCapabilityInternetClientServerSid = 86, WinCapabilityPrivateNetworkClientServerSid = 87, WinCapabilityPicturesLibrarySid = 88, WinCapabilityVideosLibrarySid = 89, WinCapabilityMusicLibrarySid = 90, WinCapabilityDocumentsLibrarySid = 91, WinCapabilitySharedUserCertificatesSid = 92, WinCapabilityEnterpriseAuthenticationSid = 93, WinCapabilityRemovableStorageSid = 94 }
        enum WindowsAccountType
        { Normal = 0, Guest = 1, System = 2, Anonymous = 3 }
        enum WindowsBuiltInRole
        { Administrator = 544, User = 545, Guest = 546, PowerUser = 547, AccountOperator = 548, SystemOperator = 549, PrintOperator = 550, BackupOperator = 551, Replicator = 552 }
        class WindowsIdentity extends System.Security.Claims.ClaimsIdentity implements System.Runtime.Serialization.IDeserializationCallback, System.Security.Principal.IIdentity, System.Runtime.Serialization.ISerializable, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public static DefaultIssuer : string
            public get AuthenticationType(): string;
            public get IsAnonymous(): boolean;
            public get IsAuthenticated(): boolean;
            public get IsGuest(): boolean;
            public get IsSystem(): boolean;
            public get Name(): string;
            public get Token(): System.IntPtr;
            public get Groups(): System.Security.Principal.IdentityReferenceCollection;
            public get ImpersonationLevel(): System.Security.Principal.TokenImpersonationLevel;
            public get Owner(): System.Security.Principal.SecurityIdentifier;
            public get User(): System.Security.Principal.SecurityIdentifier;
            public get AccessToken(): Microsoft.Win32.SafeHandles.SafeAccessTokenHandle;
            public get DeviceClaims(): System.Collections.Generic.IEnumerable$1<System.Security.Claims.Claim>;
            public get UserClaims(): System.Collections.Generic.IEnumerable$1<System.Security.Claims.Claim>;
            public Dispose () : void
            public static GetAnonymous () : System.Security.Principal.WindowsIdentity
            public static GetCurrent () : System.Security.Principal.WindowsIdentity
            public static GetCurrent ($ifImpersonating: boolean) : System.Security.Principal.WindowsIdentity
            public static GetCurrent ($desiredAccess: System.Security.Principal.TokenAccessLevels) : System.Security.Principal.WindowsIdentity
            public Impersonate () : System.Security.Principal.WindowsImpersonationContext
            public static Impersonate ($userToken: System.IntPtr) : System.Security.Principal.WindowsImpersonationContext
            public static RunImpersonated ($safeAccessTokenHandle: Microsoft.Win32.SafeHandles.SafeAccessTokenHandle, $action: System.Action) : void
            public constructor ($userToken: System.IntPtr)
            public constructor ($userToken: System.IntPtr, $type: string)
            public constructor ($userToken: System.IntPtr, $type: string, $acctType: System.Security.Principal.WindowsAccountType)
            public constructor ($userToken: System.IntPtr, $type: string, $acctType: System.Security.Principal.WindowsAccountType, $isAuthenticated: boolean)
            public constructor ($sUserPrincipalName: string)
            public constructor ($sUserPrincipalName: string, $type: string)
            public constructor ($info: System.Runtime.Serialization.SerializationInfo, $context: System.Runtime.Serialization.StreamingContext)
            public OnDeserialization ($sender: any) : void
            public constructor ()
            public constructor ($identity: System.Security.Principal.IIdentity)
            public constructor ($claims: System.Collections.Generic.IEnumerable$1<System.Security.Claims.Claim>)
            public constructor ($authenticationType: string)
            public constructor ($claims: System.Collections.Generic.IEnumerable$1<System.Security.Claims.Claim>, $authenticationType: string)
            public constructor ($identity: System.Security.Principal.IIdentity, $claims: System.Collections.Generic.IEnumerable$1<System.Security.Claims.Claim>)
            public constructor ($authenticationType: string, $nameType: string, $roleType: string)
            public constructor ($claims: System.Collections.Generic.IEnumerable$1<System.Security.Claims.Claim>, $authenticationType: string, $nameType: string, $roleType: string)
            public constructor ($identity: System.Security.Principal.IIdentity, $claims: System.Collections.Generic.IEnumerable$1<System.Security.Claims.Claim>, $authenticationType: string, $nameType: string, $roleType: string)
            public constructor ($reader: System.IO.BinaryReader)
        }
        class WindowsImpersonationContext extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public Dispose () : void
            public Undo () : void
        }
        class WindowsPrincipal extends System.Security.Claims.ClaimsPrincipal implements System.Security.Principal.IPrincipal
        {
            protected [__keep_incompatibility]: never;
            public get Identity(): System.Security.Principal.IIdentity;
            public get DeviceClaims(): System.Collections.Generic.IEnumerable$1<System.Security.Claims.Claim>;
            public get UserClaims(): System.Collections.Generic.IEnumerable$1<System.Security.Claims.Claim>;
            public IsInRole ($rid: number) : boolean
            public IsInRole ($role: string) : boolean
            public IsInRole ($role: System.Security.Principal.WindowsBuiltInRole) : boolean
            public IsInRole ($sid: System.Security.Principal.SecurityIdentifier) : boolean
            public constructor ($ntIdentity: System.Security.Principal.WindowsIdentity)
            public constructor ()
            public constructor ($identities: System.Collections.Generic.IEnumerable$1<System.Security.Claims.ClaimsIdentity>)
            public constructor ($identity: System.Security.Principal.IIdentity)
            public constructor ($principal: System.Security.Principal.IPrincipal)
            public constructor ($reader: System.IO.BinaryReader)
        }
    }
    namespace System.Runtime.ExceptionServices {
        class FirstChanceExceptionEventArgs extends System.EventArgs
        {
            protected [__keep_incompatibility]: never;
            public get Exception(): System.Exception;
            public constructor ($exception: System.Exception)
            public constructor ()
        }
        class HandleProcessCorruptedStateExceptionsAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class ExceptionDispatchInfo extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get SourceException(): System.Exception;
            public static Capture ($source: System.Exception) : System.Runtime.ExceptionServices.ExceptionDispatchInfo
            public Throw () : void
            public static Throw ($source: System.Exception) : void
        }
    }
    namespace System.Environment {
        enum SpecialFolder
        { MyDocuments = 5, Desktop = 0, MyComputer = 17, Programs = 2, Personal = 5, Favorites = 6, Startup = 7, Recent = 8, SendTo = 9, StartMenu = 11, MyMusic = 13, DesktopDirectory = 16, Templates = 21, ApplicationData = 26, LocalApplicationData = 28, InternetCache = 32, Cookies = 33, History = 34, CommonApplicationData = 35, System = 37, ProgramFiles = 38, MyPictures = 39, CommonProgramFiles = 43, MyVideos = 14, NetworkShortcuts = 19, Fonts = 20, CommonStartMenu = 22, CommonPrograms = 23, CommonStartup = 24, CommonDesktopDirectory = 25, PrinterShortcuts = 27, Windows = 36, UserProfile = 40, SystemX86 = 41, ProgramFilesX86 = 42, CommonProgramFilesX86 = 44, CommonTemplates = 45, CommonDocuments = 46, CommonAdminTools = 47, AdminTools = 48, CommonMusic = 53, CommonPictures = 54, CommonVideos = 55, Resources = 56, LocalizedResources = 57, CommonOemLinks = 58, CDBurning = 59 }
        enum SpecialFolderOption
        { None = 0, DoNotVerify = 16384, Create = 32768 }
    }
    namespace System.ActivationContext {
        enum ContextForm
        { Loose = 0, StoreBounded = 1 }
    }
    namespace System.Runtime.Hosting {
        class ApplicationActivator extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public CreateInstance ($activationContext: System.ActivationContext) : System.Runtime.Remoting.ObjectHandle
            public CreateInstance ($activationContext: System.ActivationContext, $activationCustomData: System.Array$1<string>) : System.Runtime.Remoting.ObjectHandle
            public constructor ()
        }
        class ActivationArguments extends System.Security.Policy.EvidenceBase
        {
            protected [__keep_incompatibility]: never;
            public get ActivationContext(): System.ActivationContext;
            public get ActivationData(): System.Array$1<string>;
            public get ApplicationIdentity(): System.ApplicationIdentity;
            public constructor ($activationData: System.ActivationContext)
            public constructor ($applicationIdentity: System.ApplicationIdentity)
            public constructor ($activationContext: System.ActivationContext, $activationData: System.Array$1<string>)
            public constructor ($applicationIdentity: System.ApplicationIdentity, $activationData: System.Array$1<string>)
            public constructor ()
        }
    }
    namespace System.IO {
        class TextWriter extends System.MarshalByRefObject implements System.IAsyncDisposable, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public static Null : System.IO.TextWriter
            public get FormatProvider(): System.IFormatProvider;
            public get Encoding(): System.Text.Encoding;
            public get NewLine(): string;
            public set NewLine(value: string);
            public Close () : void
            public Dispose () : void
            public DisposeAsync () : System.Threading.Tasks.ValueTask
            public Flush () : void
            public Write ($value: number) : void
            public Write ($buffer: System.Array$1<number>) : void
            public Write ($buffer: System.Array$1<number>, $index: number, $count: number) : void
            public Write ($value: boolean) : void
            public Write ($value: bigint) : void
            public Write ($value: System.Decimal) : void
            public Write ($value: string) : void
            public Write ($value: any) : void
            public Write ($format: string, $arg0: any) : void
            public Write ($format: string, $arg0: any, $arg1: any) : void
            public Write ($format: string, $arg0: any, $arg1: any, $arg2: any) : void
            public Write ($format: string, ...arg: any[]) : void
            public WriteLine () : void
            public WriteLine ($value: number) : void
            public WriteLine ($buffer: System.Array$1<number>) : void
            public WriteLine ($buffer: System.Array$1<number>, $index: number, $count: number) : void
            public WriteLine ($value: boolean) : void
            public WriteLine ($value: bigint) : void
            public WriteLine ($value: System.Decimal) : void
            public WriteLine ($value: string) : void
            public WriteLine ($value: any) : void
            public WriteLine ($format: string, $arg0: any) : void
            public WriteLine ($format: string, $arg0: any, $arg1: any) : void
            public WriteLine ($format: string, $arg0: any, $arg1: any, $arg2: any) : void
            public WriteLine ($format: string, ...arg: any[]) : void
            public WriteAsync ($value: number) : $Task<any>
            public WriteAsync ($value: string) : $Task<any>
            public WriteAsync ($buffer: System.Array$1<number>) : $Task<any>
            public WriteAsync ($buffer: System.Array$1<number>, $index: number, $count: number) : $Task<any>
            public WriteAsync ($buffer: System.ReadOnlyMemory$1<number>, $cancellationToken?: System.Threading.CancellationToken) : $Task<any>
            public WriteLineAsync ($value: number) : $Task<any>
            public WriteLineAsync ($value: string) : $Task<any>
            public WriteLineAsync ($buffer: System.Array$1<number>) : $Task<any>
            public WriteLineAsync ($buffer: System.Array$1<number>, $index: number, $count: number) : $Task<any>
            public WriteLineAsync ($buffer: System.ReadOnlyMemory$1<number>, $cancellationToken?: System.Threading.CancellationToken) : $Task<any>
            public WriteLineAsync () : $Task<any>
            public FlushAsync () : $Task<any>
            public static Synchronized ($writer: System.IO.TextWriter) : System.IO.TextWriter
            public ConfigureAwait ($continueOnCapturedContext: boolean) : System.Runtime.CompilerServices.ConfiguredAsyncDisposable
        }
        class TextReader extends System.MarshalByRefObject implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public static Null : System.IO.TextReader
            public Close () : void
            public Dispose () : void
            public Peek () : number
            public Read () : number
            public Read ($buffer: System.Array$1<number>, $index: number, $count: number) : number
            public ReadToEnd () : string
            public ReadBlock ($buffer: System.Array$1<number>, $index: number, $count: number) : number
            public ReadLine () : string
            public ReadLineAsync () : System.Threading.Tasks.Task$1<string>
            public ReadToEndAsync () : System.Threading.Tasks.Task$1<string>
            public ReadAsync ($buffer: System.Array$1<number>, $index: number, $count: number) : System.Threading.Tasks.Task$1<number>
            public ReadAsync ($buffer: System.Memory$1<number>, $cancellationToken?: System.Threading.CancellationToken) : System.Threading.Tasks.ValueTask$1<number>
            public ReadBlockAsync ($buffer: System.Array$1<number>, $index: number, $count: number) : System.Threading.Tasks.Task$1<number>
            public ReadBlockAsync ($buffer: System.Memory$1<number>, $cancellationToken?: System.Threading.CancellationToken) : System.Threading.Tasks.ValueTask$1<number>
            public static Synchronized ($reader: System.IO.TextReader) : System.IO.TextReader
        }
        class Stream extends System.MarshalByRefObject implements System.IAsyncDisposable, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public static Null : System.IO.Stream
            public get CanRead(): boolean;
            public get CanSeek(): boolean;
            public get CanTimeout(): boolean;
            public get CanWrite(): boolean;
            public get Length(): bigint;
            public get Position(): bigint;
            public set Position(value: bigint);
            public get ReadTimeout(): number;
            public set ReadTimeout(value: number);
            public get WriteTimeout(): number;
            public set WriteTimeout(value: number);
            public CopyToAsync ($destination: System.IO.Stream) : $Task<any>
            public CopyToAsync ($destination: System.IO.Stream, $bufferSize: number) : $Task<any>
            public CopyToAsync ($destination: System.IO.Stream, $cancellationToken: System.Threading.CancellationToken) : $Task<any>
            public CopyToAsync ($destination: System.IO.Stream, $bufferSize: number, $cancellationToken: System.Threading.CancellationToken) : $Task<any>
            public CopyTo ($destination: System.IO.Stream) : void
            public CopyTo ($destination: System.IO.Stream, $bufferSize: number) : void
            public Close () : void
            public Dispose () : void
            public Flush () : void
            public FlushAsync () : $Task<any>
            public FlushAsync ($cancellationToken: System.Threading.CancellationToken) : $Task<any>
            public BeginRead ($buffer: System.Array$1<number>, $offset: number, $count: number, $callback: System.AsyncCallback, $state: any) : System.IAsyncResult
            public EndRead ($asyncResult: System.IAsyncResult) : number
            public ReadAsync ($buffer: System.Array$1<number>, $offset: number, $count: number) : System.Threading.Tasks.Task$1<number>
            public ReadAsync ($buffer: System.Array$1<number>, $offset: number, $count: number, $cancellationToken: System.Threading.CancellationToken) : System.Threading.Tasks.Task$1<number>
            public ReadAsync ($buffer: System.Memory$1<number>, $cancellationToken?: System.Threading.CancellationToken) : System.Threading.Tasks.ValueTask$1<number>
            public BeginWrite ($buffer: System.Array$1<number>, $offset: number, $count: number, $callback: System.AsyncCallback, $state: any) : System.IAsyncResult
            public EndWrite ($asyncResult: System.IAsyncResult) : void
            public WriteAsync ($buffer: System.Array$1<number>, $offset: number, $count: number) : $Task<any>
            public WriteAsync ($buffer: System.Array$1<number>, $offset: number, $count: number, $cancellationToken: System.Threading.CancellationToken) : $Task<any>
            public WriteAsync ($buffer: System.ReadOnlyMemory$1<number>, $cancellationToken?: System.Threading.CancellationToken) : System.Threading.Tasks.ValueTask
            public Seek ($offset: bigint, $origin: System.IO.SeekOrigin) : bigint
            public SetLength ($value: bigint) : void
            public Read ($buffer: System.Array$1<number>, $offset: number, $count: number) : number
            public ReadByte () : number
            public Write ($buffer: System.Array$1<number>, $offset: number, $count: number) : void
            public WriteByte ($value: number) : void
            public static Synchronized ($stream: System.IO.Stream) : System.IO.Stream
            public DisposeAsync () : System.Threading.Tasks.ValueTask
            public ConfigureAwait ($continueOnCapturedContext: boolean) : System.Runtime.CompilerServices.ConfiguredAsyncDisposable
        }
        enum SeekOrigin
        { Begin = 0, Current = 1, End = 2 }
        class BinaryWriter extends System.Object implements System.IAsyncDisposable, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public static Null : System.IO.BinaryWriter
            public get BaseStream(): System.IO.Stream;
            public Close () : void
            public Dispose () : void
            public Flush () : void
            public Seek ($offset: number, $origin: System.IO.SeekOrigin) : bigint
            public DisposeAsync () : System.Threading.Tasks.ValueTask
            public Write ($value: boolean) : void
            public Write ($value: number) : void
            public Write ($buffer: System.Array$1<number>) : void
            public Write ($buffer: System.Array$1<number>, $index: number, $count: number) : void
            public Write ($ch: number) : void
            public Write ($chars: System.Array$1<number>) : void
            public Write ($chars: System.Array$1<number>, $index: number, $count: number) : void
            public Write ($value: System.Decimal) : void
            public Write ($value: bigint) : void
            public Write ($value: string) : void
            public constructor ($output: System.IO.Stream)
            public constructor ($output: System.IO.Stream, $encoding: System.Text.Encoding)
            public constructor ($output: System.IO.Stream, $encoding: System.Text.Encoding, $leaveOpen: boolean)
            public ConfigureAwait ($continueOnCapturedContext: boolean) : System.Runtime.CompilerServices.ConfiguredAsyncDisposable
            public constructor ()
        }
        class BinaryReader extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get BaseStream(): System.IO.Stream;
            public Close () : void
            public Dispose () : void
            public PeekChar () : number
            public Read () : number
            public ReadBoolean () : boolean
            public ReadByte () : number
            public ReadSByte () : number
            public ReadChar () : number
            public ReadInt16 () : number
            public ReadUInt16 () : number
            public ReadInt32 () : number
            public ReadUInt32 () : number
            public ReadInt64 () : bigint
            public ReadUInt64 () : bigint
            public ReadSingle () : number
            public ReadDouble () : number
            public ReadDecimal () : System.Decimal
            public ReadString () : string
            public Read ($buffer: System.Array$1<number>, $index: number, $count: number) : number
            public ReadChars ($count: number) : System.Array$1<number>
            public ReadBytes ($count: number) : System.Array$1<number>
            public constructor ($input: System.IO.Stream)
            public constructor ($input: System.IO.Stream, $encoding: System.Text.Encoding)
            public constructor ($input: System.IO.Stream, $encoding: System.Text.Encoding, $leaveOpen: boolean)
            public constructor ()
        }
        class FileStream extends System.IO.Stream implements System.IAsyncDisposable, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get CanRead(): boolean;
            public get CanWrite(): boolean;
            public get CanSeek(): boolean;
            public get IsAsync(): boolean;
            public get Name(): string;
            public get Length(): bigint;
            public get Position(): bigint;
            public set Position(value: bigint);
            public get SafeFileHandle(): Microsoft.Win32.SafeHandles.SafeFileHandle;
            public Flush () : void
            public Flush ($flushToDisk: boolean) : void
            public Lock ($position: bigint, $length: bigint) : void
            public Unlock ($position: bigint, $length: bigint) : void
            public GetAccessControl () : System.Security.AccessControl.FileSecurity
            public SetAccessControl ($fileSecurity: System.Security.AccessControl.FileSecurity) : void
            public constructor ($path: string, $mode: System.IO.FileMode)
            public constructor ($path: string, $mode: System.IO.FileMode, $access: System.IO.FileAccess)
            public constructor ($path: string, $mode: System.IO.FileMode, $access: System.IO.FileAccess, $share: System.IO.FileShare)
            public constructor ($path: string, $mode: System.IO.FileMode, $access: System.IO.FileAccess, $share: System.IO.FileShare, $bufferSize: number)
            public constructor ($path: string, $mode: System.IO.FileMode, $access: System.IO.FileAccess, $share: System.IO.FileShare, $bufferSize: number, $useAsync: boolean)
            public constructor ($path: string, $mode: System.IO.FileMode, $access: System.IO.FileAccess, $share: System.IO.FileShare, $bufferSize: number, $options: System.IO.FileOptions)
            public constructor ($handle: Microsoft.Win32.SafeHandles.SafeFileHandle, $access: System.IO.FileAccess)
            public constructor ($handle: Microsoft.Win32.SafeHandles.SafeFileHandle, $access: System.IO.FileAccess, $bufferSize: number)
            public constructor ($handle: Microsoft.Win32.SafeHandles.SafeFileHandle, $access: System.IO.FileAccess, $bufferSize: number, $isAsync: boolean)
            public constructor ($path: string, $mode: System.IO.FileMode, $rights: System.Security.AccessControl.FileSystemRights, $share: System.IO.FileShare, $bufferSize: number, $options: System.IO.FileOptions)
            public constructor ($path: string, $mode: System.IO.FileMode, $rights: System.Security.AccessControl.FileSystemRights, $share: System.IO.FileShare, $bufferSize: number, $options: System.IO.FileOptions, $fileSecurity: System.Security.AccessControl.FileSecurity)
            public constructor ()
        }
        class UnmanagedMemoryStream extends System.IO.Stream implements System.IAsyncDisposable, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get CanRead(): boolean;
            public get CanSeek(): boolean;
            public get CanWrite(): boolean;
            public get Length(): bigint;
            public get Capacity(): bigint;
            public get Position(): bigint;
            public set Position(value: bigint);
            public constructor ($buffer: System.Runtime.InteropServices.SafeBuffer, $offset: bigint, $length: bigint)
            public constructor ($buffer: System.Runtime.InteropServices.SafeBuffer, $offset: bigint, $length: bigint, $access: System.IO.FileAccess)
            public constructor ()
        }
        class IOException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $hresult: number)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class DirectoryNotFoundException extends System.IO.IOException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class EndOfStreamException extends System.IO.IOException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        enum FileAccess
        { Read = 1, Write = 2, ReadWrite = 3 }
        class FileLoadException extends System.IO.IOException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public get Message(): string;
            public get FileName(): string;
            public get FusionLog(): string;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $inner: System.Exception)
            public constructor ($message: string, $fileName: string)
            public constructor ($message: string, $fileName: string, $inner: System.Exception)
            public constructor ($message: string, $hresult: number)
            public constructor ($message: string, $innerException: System.Exception)
        }
        enum FileMode
        { CreateNew = 1, Create = 2, Open = 3, OpenOrCreate = 4, Truncate = 5, Append = 6 }
        class FileNotFoundException extends System.IO.IOException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public get Message(): string;
            public get FileName(): string;
            public get FusionLog(): string;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
            public constructor ($message: string, $fileName: string)
            public constructor ($message: string, $fileName: string, $innerException: System.Exception)
            public constructor ($message: string, $hresult: number)
        }
        enum FileOptions
        { None = 0, WriteThrough = -2147483648, Asynchronous = 1073741824, RandomAccess = 268435456, DeleteOnClose = 67108864, SequentialScan = 134217728, Encrypted = 16384 }
        enum FileShare
        { None = 0, Read = 1, Write = 2, ReadWrite = 3, Delete = 4, Inheritable = 16 }
        class MemoryStream extends System.IO.Stream implements System.IAsyncDisposable, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get CanRead(): boolean;
            public get CanSeek(): boolean;
            public get CanWrite(): boolean;
            public get Capacity(): number;
            public set Capacity(value: number);
            public get Length(): bigint;
            public get Position(): bigint;
            public set Position(value: bigint);
            public GetBuffer () : System.Array$1<number>
            public TryGetBuffer ($buffer: $Ref<System.ArraySegment$1<number>>) : boolean
            public ToArray () : System.Array$1<number>
            public WriteTo ($stream: System.IO.Stream) : void
            public constructor ()
            public constructor ($capacity: number)
            public constructor ($buffer: System.Array$1<number>)
            public constructor ($buffer: System.Array$1<number>, $writable: boolean)
            public constructor ($buffer: System.Array$1<number>, $index: number, $count: number)
            public constructor ($buffer: System.Array$1<number>, $index: number, $count: number, $writable: boolean)
            public constructor ($buffer: System.Array$1<number>, $index: number, $count: number, $writable: boolean, $publiclyVisible: boolean)
        }
        class PathTooLongException extends System.IO.IOException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class StreamReader extends System.IO.TextReader implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public static Null : System.IO.StreamReader
            public get CurrentEncoding(): System.Text.Encoding;
            public get BaseStream(): System.IO.Stream;
            public get EndOfStream(): boolean;
            public DiscardBufferedData () : void
            public constructor ($stream: System.IO.Stream)
            public constructor ($stream: System.IO.Stream, $detectEncodingFromByteOrderMarks: boolean)
            public constructor ($stream: System.IO.Stream, $encoding: System.Text.Encoding)
            public constructor ($stream: System.IO.Stream, $encoding: System.Text.Encoding, $detectEncodingFromByteOrderMarks: boolean)
            public constructor ($stream: System.IO.Stream, $encoding: System.Text.Encoding, $detectEncodingFromByteOrderMarks: boolean, $bufferSize: number)
            public constructor ($stream: System.IO.Stream, $encoding: System.Text.Encoding, $detectEncodingFromByteOrderMarks: boolean, $bufferSize: number, $leaveOpen: boolean)
            public constructor ($path: string)
            public constructor ($path: string, $detectEncodingFromByteOrderMarks: boolean)
            public constructor ($path: string, $encoding: System.Text.Encoding)
            public constructor ($path: string, $encoding: System.Text.Encoding, $detectEncodingFromByteOrderMarks: boolean)
            public constructor ($path: string, $encoding: System.Text.Encoding, $detectEncodingFromByteOrderMarks: boolean, $bufferSize: number)
            public constructor ()
        }
        class StreamWriter extends System.IO.TextWriter implements System.IAsyncDisposable, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public static Null : System.IO.StreamWriter
            public get AutoFlush(): boolean;
            public set AutoFlush(value: boolean);
            public get BaseStream(): System.IO.Stream;
            public get Encoding(): System.Text.Encoding;
            public constructor ($stream: System.IO.Stream)
            public constructor ($stream: System.IO.Stream, $encoding: System.Text.Encoding)
            public constructor ($stream: System.IO.Stream, $encoding: System.Text.Encoding, $bufferSize: number)
            public constructor ($stream: System.IO.Stream, $encoding: System.Text.Encoding, $bufferSize: number, $leaveOpen: boolean)
            public constructor ($path: string)
            public constructor ($path: string, $append: boolean)
            public constructor ($path: string, $append: boolean, $encoding: System.Text.Encoding)
            public constructor ($path: string, $append: boolean, $encoding: System.Text.Encoding, $bufferSize: number)
            public constructor ()
        }
        class UnmanagedMemoryAccessor extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get Capacity(): bigint;
            public get CanRead(): boolean;
            public get CanWrite(): boolean;
            public Dispose () : void
            public ReadBoolean ($position: bigint) : boolean
            public ReadByte ($position: bigint) : number
            public ReadChar ($position: bigint) : number
            public ReadInt16 ($position: bigint) : number
            public ReadInt32 ($position: bigint) : number
            public ReadInt64 ($position: bigint) : bigint
            public ReadDecimal ($position: bigint) : System.Decimal
            public ReadSingle ($position: bigint) : number
            public ReadDouble ($position: bigint) : number
            public ReadSByte ($position: bigint) : number
            public ReadUInt16 ($position: bigint) : number
            public ReadUInt32 ($position: bigint) : number
            public ReadUInt64 ($position: bigint) : bigint
            public Write ($position: bigint, $value: boolean) : void
            public Write ($position: bigint, $value: number) : void
            public Write ($position: bigint, $value: bigint) : void
            public Write ($position: bigint, $value: System.Decimal) : void
            public constructor ($buffer: System.Runtime.InteropServices.SafeBuffer, $offset: bigint, $capacity: bigint)
            public constructor ($buffer: System.Runtime.InteropServices.SafeBuffer, $offset: bigint, $capacity: bigint, $access: System.IO.FileAccess)
            public constructor ()
        }
        class DriveNotFoundException extends System.IO.IOException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        enum DriveType
        { Unknown = 0, NoRootDirectory = 1, Removable = 2, Fixed = 3, Network = 4, CDRom = 5, Ram = 6 }
        class Directory extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static GetParent ($path: string) : System.IO.DirectoryInfo
            public static CreateDirectory ($path: string) : System.IO.DirectoryInfo
            public static Exists ($path: string) : boolean
            public static SetCreationTime ($path: string, $creationTime: System.DateTime) : void
            public static SetCreationTimeUtc ($path: string, $creationTimeUtc: System.DateTime) : void
            public static GetCreationTime ($path: string) : System.DateTime
            public static GetCreationTimeUtc ($path: string) : System.DateTime
            public static SetLastWriteTime ($path: string, $lastWriteTime: System.DateTime) : void
            public static SetLastWriteTimeUtc ($path: string, $lastWriteTimeUtc: System.DateTime) : void
            public static GetLastWriteTime ($path: string) : System.DateTime
            public static GetLastWriteTimeUtc ($path: string) : System.DateTime
            public static SetLastAccessTime ($path: string, $lastAccessTime: System.DateTime) : void
            public static SetLastAccessTimeUtc ($path: string, $lastAccessTimeUtc: System.DateTime) : void
            public static GetLastAccessTime ($path: string) : System.DateTime
            public static GetLastAccessTimeUtc ($path: string) : System.DateTime
            public static GetFiles ($path: string) : System.Array$1<string>
            public static GetFiles ($path: string, $searchPattern: string) : System.Array$1<string>
            public static GetFiles ($path: string, $searchPattern: string, $searchOption: System.IO.SearchOption) : System.Array$1<string>
            public static GetFiles ($path: string, $searchPattern: string, $enumerationOptions: System.IO.EnumerationOptions) : System.Array$1<string>
            public static GetDirectories ($path: string) : System.Array$1<string>
            public static GetDirectories ($path: string, $searchPattern: string) : System.Array$1<string>
            public static GetDirectories ($path: string, $searchPattern: string, $searchOption: System.IO.SearchOption) : System.Array$1<string>
            public static GetDirectories ($path: string, $searchPattern: string, $enumerationOptions: System.IO.EnumerationOptions) : System.Array$1<string>
            public static GetFileSystemEntries ($path: string) : System.Array$1<string>
            public static GetFileSystemEntries ($path: string, $searchPattern: string) : System.Array$1<string>
            public static GetFileSystemEntries ($path: string, $searchPattern: string, $searchOption: System.IO.SearchOption) : System.Array$1<string>
            public static GetFileSystemEntries ($path: string, $searchPattern: string, $enumerationOptions: System.IO.EnumerationOptions) : System.Array$1<string>
            public static EnumerateDirectories ($path: string) : System.Collections.Generic.IEnumerable$1<string>
            public static EnumerateDirectories ($path: string, $searchPattern: string) : System.Collections.Generic.IEnumerable$1<string>
            public static EnumerateDirectories ($path: string, $searchPattern: string, $searchOption: System.IO.SearchOption) : System.Collections.Generic.IEnumerable$1<string>
            public static EnumerateDirectories ($path: string, $searchPattern: string, $enumerationOptions: System.IO.EnumerationOptions) : System.Collections.Generic.IEnumerable$1<string>
            public static EnumerateFiles ($path: string) : System.Collections.Generic.IEnumerable$1<string>
            public static EnumerateFiles ($path: string, $searchPattern: string) : System.Collections.Generic.IEnumerable$1<string>
            public static EnumerateFiles ($path: string, $searchPattern: string, $searchOption: System.IO.SearchOption) : System.Collections.Generic.IEnumerable$1<string>
            public static EnumerateFiles ($path: string, $searchPattern: string, $enumerationOptions: System.IO.EnumerationOptions) : System.Collections.Generic.IEnumerable$1<string>
            public static EnumerateFileSystemEntries ($path: string) : System.Collections.Generic.IEnumerable$1<string>
            public static EnumerateFileSystemEntries ($path: string, $searchPattern: string) : System.Collections.Generic.IEnumerable$1<string>
            public static EnumerateFileSystemEntries ($path: string, $searchPattern: string, $searchOption: System.IO.SearchOption) : System.Collections.Generic.IEnumerable$1<string>
            public static EnumerateFileSystemEntries ($path: string, $searchPattern: string, $enumerationOptions: System.IO.EnumerationOptions) : System.Collections.Generic.IEnumerable$1<string>
            public static GetDirectoryRoot ($path: string) : string
            public static GetCurrentDirectory () : string
            public static SetCurrentDirectory ($path: string) : void
            public static Move ($sourceDirName: string, $destDirName: string) : void
            public static Delete ($path: string) : void
            public static Delete ($path: string, $recursive: boolean) : void
            public static GetLogicalDrives () : System.Array$1<string>
            public static CreateDirectory ($path: string, $directorySecurity: System.Security.AccessControl.DirectorySecurity) : System.IO.DirectoryInfo
            public static GetAccessControl ($path: string, $includeSections: System.Security.AccessControl.AccessControlSections) : System.Security.AccessControl.DirectorySecurity
            public static GetAccessControl ($path: string) : System.Security.AccessControl.DirectorySecurity
            public static SetAccessControl ($path: string, $directorySecurity: System.Security.AccessControl.DirectorySecurity) : void
        }
        class FileSystemInfo extends System.MarshalByRefObject implements System.Runtime.Serialization.ISerializable
        {
            protected [__keep_incompatibility]: never;
            public get Attributes(): System.IO.FileAttributes;
            public set Attributes(value: System.IO.FileAttributes);
            public get FullName(): string;
            public get Extension(): string;
            public get Name(): string;
            public get Exists(): boolean;
            public get CreationTime(): System.DateTime;
            public set CreationTime(value: System.DateTime);
            public get CreationTimeUtc(): System.DateTime;
            public set CreationTimeUtc(value: System.DateTime);
            public get LastAccessTime(): System.DateTime;
            public set LastAccessTime(value: System.DateTime);
            public get LastAccessTimeUtc(): System.DateTime;
            public set LastAccessTimeUtc(value: System.DateTime);
            public get LastWriteTime(): System.DateTime;
            public set LastWriteTime(value: System.DateTime);
            public get LastWriteTimeUtc(): System.DateTime;
            public set LastWriteTimeUtc(value: System.DateTime);
            public Refresh () : void
            public GetObjectData ($info: System.Runtime.Serialization.SerializationInfo, $context: System.Runtime.Serialization.StreamingContext) : void
            public Delete () : void
        }
        class DirectoryInfo extends System.IO.FileSystemInfo implements System.Runtime.Serialization.ISerializable
        {
            protected [__keep_incompatibility]: never;
            public get Parent(): System.IO.DirectoryInfo;
            public get Root(): System.IO.DirectoryInfo;
            public CreateSubdirectory ($path: string) : System.IO.DirectoryInfo
            public Create () : void
            public GetFiles () : System.Array$1<System.IO.FileInfo>
            public GetFiles ($searchPattern: string) : System.Array$1<System.IO.FileInfo>
            public GetFiles ($searchPattern: string, $searchOption: System.IO.SearchOption) : System.Array$1<System.IO.FileInfo>
            public GetFiles ($searchPattern: string, $enumerationOptions: System.IO.EnumerationOptions) : System.Array$1<System.IO.FileInfo>
            public GetFileSystemInfos () : System.Array$1<System.IO.FileSystemInfo>
            public GetFileSystemInfos ($searchPattern: string) : System.Array$1<System.IO.FileSystemInfo>
            public GetFileSystemInfos ($searchPattern: string, $searchOption: System.IO.SearchOption) : System.Array$1<System.IO.FileSystemInfo>
            public GetFileSystemInfos ($searchPattern: string, $enumerationOptions: System.IO.EnumerationOptions) : System.Array$1<System.IO.FileSystemInfo>
            public GetDirectories () : System.Array$1<System.IO.DirectoryInfo>
            public GetDirectories ($searchPattern: string) : System.Array$1<System.IO.DirectoryInfo>
            public GetDirectories ($searchPattern: string, $searchOption: System.IO.SearchOption) : System.Array$1<System.IO.DirectoryInfo>
            public GetDirectories ($searchPattern: string, $enumerationOptions: System.IO.EnumerationOptions) : System.Array$1<System.IO.DirectoryInfo>
            public EnumerateDirectories () : System.Collections.Generic.IEnumerable$1<System.IO.DirectoryInfo>
            public EnumerateDirectories ($searchPattern: string) : System.Collections.Generic.IEnumerable$1<System.IO.DirectoryInfo>
            public EnumerateDirectories ($searchPattern: string, $searchOption: System.IO.SearchOption) : System.Collections.Generic.IEnumerable$1<System.IO.DirectoryInfo>
            public EnumerateDirectories ($searchPattern: string, $enumerationOptions: System.IO.EnumerationOptions) : System.Collections.Generic.IEnumerable$1<System.IO.DirectoryInfo>
            public EnumerateFiles () : System.Collections.Generic.IEnumerable$1<System.IO.FileInfo>
            public EnumerateFiles ($searchPattern: string) : System.Collections.Generic.IEnumerable$1<System.IO.FileInfo>
            public EnumerateFiles ($searchPattern: string, $searchOption: System.IO.SearchOption) : System.Collections.Generic.IEnumerable$1<System.IO.FileInfo>
            public EnumerateFiles ($searchPattern: string, $enumerationOptions: System.IO.EnumerationOptions) : System.Collections.Generic.IEnumerable$1<System.IO.FileInfo>
            public EnumerateFileSystemInfos () : System.Collections.Generic.IEnumerable$1<System.IO.FileSystemInfo>
            public EnumerateFileSystemInfos ($searchPattern: string) : System.Collections.Generic.IEnumerable$1<System.IO.FileSystemInfo>
            public EnumerateFileSystemInfos ($searchPattern: string, $searchOption: System.IO.SearchOption) : System.Collections.Generic.IEnumerable$1<System.IO.FileSystemInfo>
            public EnumerateFileSystemInfos ($searchPattern: string, $enumerationOptions: System.IO.EnumerationOptions) : System.Collections.Generic.IEnumerable$1<System.IO.FileSystemInfo>
            public MoveTo ($destDirName: string) : void
            public Delete () : void
            public Delete ($recursive: boolean) : void
            public Create ($directorySecurity: System.Security.AccessControl.DirectorySecurity) : void
            public CreateSubdirectory ($path: string, $directorySecurity: System.Security.AccessControl.DirectorySecurity) : System.IO.DirectoryInfo
            public GetAccessControl () : System.Security.AccessControl.DirectorySecurity
            public GetAccessControl ($includeSections: System.Security.AccessControl.AccessControlSections) : System.Security.AccessControl.DirectorySecurity
            public SetAccessControl ($directorySecurity: System.Security.AccessControl.DirectorySecurity) : void
            public constructor ($path: string)
            public constructor ()
        }
        enum SearchOption
        { TopDirectoryOnly = 0, AllDirectories = 1 }
        class EnumerationOptions extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get RecurseSubdirectories(): boolean;
            public set RecurseSubdirectories(value: boolean);
            public get IgnoreInaccessible(): boolean;
            public set IgnoreInaccessible(value: boolean);
            public get BufferSize(): number;
            public set BufferSize(value: number);
            public get AttributesToSkip(): System.IO.FileAttributes;
            public set AttributesToSkip(value: System.IO.FileAttributes);
            public get MatchType(): System.IO.MatchType;
            public set MatchType(value: System.IO.MatchType);
            public get MatchCasing(): System.IO.MatchCasing;
            public set MatchCasing(value: System.IO.MatchCasing);
            public get ReturnSpecialDirectories(): boolean;
            public set ReturnSpecialDirectories(value: boolean);
            public constructor ()
        }
        class FileInfo extends System.IO.FileSystemInfo implements System.Runtime.Serialization.ISerializable
        {
            protected [__keep_incompatibility]: never;
            public get Length(): bigint;
            public get DirectoryName(): string;
            public get Directory(): System.IO.DirectoryInfo;
            public get IsReadOnly(): boolean;
            public set IsReadOnly(value: boolean);
            public get Name(): string;
            public OpenText () : System.IO.StreamReader
            public CreateText () : System.IO.StreamWriter
            public AppendText () : System.IO.StreamWriter
            public CopyTo ($destFileName: string) : System.IO.FileInfo
            public CopyTo ($destFileName: string, $overwrite: boolean) : System.IO.FileInfo
            public Create () : System.IO.FileStream
            public Open ($mode: System.IO.FileMode) : System.IO.FileStream
            public Open ($mode: System.IO.FileMode, $access: System.IO.FileAccess) : System.IO.FileStream
            public Open ($mode: System.IO.FileMode, $access: System.IO.FileAccess, $share: System.IO.FileShare) : System.IO.FileStream
            public OpenRead () : System.IO.FileStream
            public OpenWrite () : System.IO.FileStream
            public MoveTo ($destFileName: string) : void
            public Replace ($destinationFileName: string, $destinationBackupFileName: string) : System.IO.FileInfo
            public Replace ($destinationFileName: string, $destinationBackupFileName: string, $ignoreMetadataErrors: boolean) : System.IO.FileInfo
            public Decrypt () : void
            public Encrypt () : void
            public GetAccessControl () : System.Security.AccessControl.FileSecurity
            public GetAccessControl ($includeSections: System.Security.AccessControl.AccessControlSections) : System.Security.AccessControl.FileSecurity
            public SetAccessControl ($fileSecurity: System.Security.AccessControl.FileSecurity) : void
            public constructor ($fileName: string)
            public constructor ()
        }
        enum FileAttributes
        { ReadOnly = 1, Hidden = 2, System = 4, Directory = 16, Archive = 32, Device = 64, Normal = 128, Temporary = 256, SparseFile = 512, ReparsePoint = 1024, Compressed = 2048, Offline = 4096, NotContentIndexed = 8192, Encrypted = 16384, IntegrityStream = 32768, NoScrubData = 131072 }
        enum MatchType
        { Simple = 0, Win32 = 1 }
        enum MatchCasing
        { PlatformDefault = 0, CaseSensitive = 1, CaseInsensitive = 2 }
        class File extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static OpenText ($path: string) : System.IO.StreamReader
            public static CreateText ($path: string) : System.IO.StreamWriter
            public static AppendText ($path: string) : System.IO.StreamWriter
            public static Copy ($sourceFileName: string, $destFileName: string) : void
            public static Copy ($sourceFileName: string, $destFileName: string, $overwrite: boolean) : void
            public static Create ($path: string) : System.IO.FileStream
            public static Create ($path: string, $bufferSize: number) : System.IO.FileStream
            public static Create ($path: string, $bufferSize: number, $options: System.IO.FileOptions) : System.IO.FileStream
            public static Delete ($path: string) : void
            public static Exists ($path: string) : boolean
            public static Open ($path: string, $mode: System.IO.FileMode) : System.IO.FileStream
            public static Open ($path: string, $mode: System.IO.FileMode, $access: System.IO.FileAccess) : System.IO.FileStream
            public static Open ($path: string, $mode: System.IO.FileMode, $access: System.IO.FileAccess, $share: System.IO.FileShare) : System.IO.FileStream
            public static SetCreationTime ($path: string, $creationTime: System.DateTime) : void
            public static SetCreationTimeUtc ($path: string, $creationTimeUtc: System.DateTime) : void
            public static GetCreationTime ($path: string) : System.DateTime
            public static GetCreationTimeUtc ($path: string) : System.DateTime
            public static SetLastAccessTime ($path: string, $lastAccessTime: System.DateTime) : void
            public static SetLastAccessTimeUtc ($path: string, $lastAccessTimeUtc: System.DateTime) : void
            public static GetLastAccessTime ($path: string) : System.DateTime
            public static GetLastAccessTimeUtc ($path: string) : System.DateTime
            public static SetLastWriteTime ($path: string, $lastWriteTime: System.DateTime) : void
            public static SetLastWriteTimeUtc ($path: string, $lastWriteTimeUtc: System.DateTime) : void
            public static GetLastWriteTime ($path: string) : System.DateTime
            public static GetLastWriteTimeUtc ($path: string) : System.DateTime
            public static GetAttributes ($path: string) : System.IO.FileAttributes
            public static SetAttributes ($path: string, $fileAttributes: System.IO.FileAttributes) : void
            public static OpenRead ($path: string) : System.IO.FileStream
            public static OpenWrite ($path: string) : System.IO.FileStream
            public static ReadAllText ($path: string) : string
            public static ReadAllText ($path: string, $encoding: System.Text.Encoding) : string
            public static WriteAllText ($path: string, $contents: string) : void
            public static WriteAllText ($path: string, $contents: string, $encoding: System.Text.Encoding) : void
            public static ReadAllBytes ($path: string) : System.Array$1<number>
            public static WriteAllBytes ($path: string, $bytes: System.Array$1<number>) : void
            public static ReadAllLines ($path: string) : System.Array$1<string>
            public static ReadAllLines ($path: string, $encoding: System.Text.Encoding) : System.Array$1<string>
            public static ReadLines ($path: string) : System.Collections.Generic.IEnumerable$1<string>
            public static ReadLines ($path: string, $encoding: System.Text.Encoding) : System.Collections.Generic.IEnumerable$1<string>
            public static WriteAllLines ($path: string, $contents: System.Array$1<string>) : void
            public static WriteAllLines ($path: string, $contents: System.Collections.Generic.IEnumerable$1<string>) : void
            public static WriteAllLines ($path: string, $contents: System.Array$1<string>, $encoding: System.Text.Encoding) : void
            public static WriteAllLines ($path: string, $contents: System.Collections.Generic.IEnumerable$1<string>, $encoding: System.Text.Encoding) : void
            public static AppendAllText ($path: string, $contents: string) : void
            public static AppendAllText ($path: string, $contents: string, $encoding: System.Text.Encoding) : void
            public static AppendAllLines ($path: string, $contents: System.Collections.Generic.IEnumerable$1<string>) : void
            public static AppendAllLines ($path: string, $contents: System.Collections.Generic.IEnumerable$1<string>, $encoding: System.Text.Encoding) : void
            public static Replace ($sourceFileName: string, $destinationFileName: string, $destinationBackupFileName: string) : void
            public static Replace ($sourceFileName: string, $destinationFileName: string, $destinationBackupFileName: string, $ignoreMetadataErrors: boolean) : void
            public static Move ($sourceFileName: string, $destFileName: string) : void
            public static Encrypt ($path: string) : void
            public static Decrypt ($path: string) : void
            public static ReadAllTextAsync ($path: string, $cancellationToken?: System.Threading.CancellationToken) : System.Threading.Tasks.Task$1<string>
            public static ReadAllTextAsync ($path: string, $encoding: System.Text.Encoding, $cancellationToken?: System.Threading.CancellationToken) : System.Threading.Tasks.Task$1<string>
            public static WriteAllTextAsync ($path: string, $contents: string, $cancellationToken?: System.Threading.CancellationToken) : $Task<any>
            public static WriteAllTextAsync ($path: string, $contents: string, $encoding: System.Text.Encoding, $cancellationToken?: System.Threading.CancellationToken) : $Task<any>
            public static ReadAllBytesAsync ($path: string, $cancellationToken?: System.Threading.CancellationToken) : System.Threading.Tasks.Task$1<System.Array$1<number>>
            public static WriteAllBytesAsync ($path: string, $bytes: System.Array$1<number>, $cancellationToken?: System.Threading.CancellationToken) : $Task<any>
            public static ReadAllLinesAsync ($path: string, $cancellationToken?: System.Threading.CancellationToken) : System.Threading.Tasks.Task$1<System.Array$1<string>>
            public static ReadAllLinesAsync ($path: string, $encoding: System.Text.Encoding, $cancellationToken?: System.Threading.CancellationToken) : System.Threading.Tasks.Task$1<System.Array$1<string>>
            public static WriteAllLinesAsync ($path: string, $contents: System.Collections.Generic.IEnumerable$1<string>, $cancellationToken?: System.Threading.CancellationToken) : $Task<any>
            public static WriteAllLinesAsync ($path: string, $contents: System.Collections.Generic.IEnumerable$1<string>, $encoding: System.Text.Encoding, $cancellationToken?: System.Threading.CancellationToken) : $Task<any>
            public static AppendAllTextAsync ($path: string, $contents: string, $cancellationToken?: System.Threading.CancellationToken) : $Task<any>
            public static AppendAllTextAsync ($path: string, $contents: string, $encoding: System.Text.Encoding, $cancellationToken?: System.Threading.CancellationToken) : $Task<any>
            public static AppendAllLinesAsync ($path: string, $contents: System.Collections.Generic.IEnumerable$1<string>, $cancellationToken?: System.Threading.CancellationToken) : $Task<any>
            public static AppendAllLinesAsync ($path: string, $contents: System.Collections.Generic.IEnumerable$1<string>, $encoding: System.Text.Encoding, $cancellationToken?: System.Threading.CancellationToken) : $Task<any>
            public static Create ($path: string, $bufferSize: number, $options: System.IO.FileOptions, $fileSecurity: System.Security.AccessControl.FileSecurity) : System.IO.FileStream
            public static GetAccessControl ($path: string) : System.Security.AccessControl.FileSecurity
            public static GetAccessControl ($path: string, $includeSections: System.Security.AccessControl.AccessControlSections) : System.Security.AccessControl.FileSecurity
            public static SetAccessControl ($path: string, $fileSecurity: System.Security.AccessControl.FileSecurity) : void
        }
        class BufferedStream extends System.IO.Stream implements System.IAsyncDisposable, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get UnderlyingStream(): System.IO.Stream;
            public get BufferSize(): number;
            public get CanRead(): boolean;
            public get CanWrite(): boolean;
            public get CanSeek(): boolean;
            public get Length(): bigint;
            public get Position(): bigint;
            public set Position(value: bigint);
            public constructor ($stream: System.IO.Stream)
            public constructor ($stream: System.IO.Stream, $bufferSize: number)
            public constructor ()
        }
        class StringReader extends System.IO.TextReader implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public constructor ($s: string)
            public constructor ()
        }
        class StringWriter extends System.IO.TextWriter implements System.IAsyncDisposable, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get Encoding(): System.Text.Encoding;
            public GetStringBuilder () : System.Text.StringBuilder
            public constructor ()
            public constructor ($formatProvider: System.IFormatProvider)
            public constructor ($sb: System.Text.StringBuilder)
            public constructor ($sb: System.Text.StringBuilder, $formatProvider: System.IFormatProvider)
        }
        class DriveInfo extends System.Object implements System.Runtime.Serialization.ISerializable
        {
            protected [__keep_incompatibility]: never;
            public get AvailableFreeSpace(): bigint;
            public get TotalFreeSpace(): bigint;
            public get TotalSize(): bigint;
            public get VolumeLabel(): string;
            public set VolumeLabel(value: string);
            public get DriveFormat(): string;
            public get DriveType(): System.IO.DriveType;
            public get Name(): string;
            public get RootDirectory(): System.IO.DirectoryInfo;
            public get IsReady(): boolean;
            public static GetDrives () : System.Array$1<System.IO.DriveInfo>
            public constructor ($driveName: string)
            public constructor ()
        }
        class Path extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static AltDirectorySeparatorChar : number
            public static DirectorySeparatorChar : number
            public static PathSeparator : number
            public static VolumeSeparatorChar : number
            public static ChangeExtension ($path: string, $extension: string) : string
            public static Combine ($path1: string, $path2: string) : string
            public static GetDirectoryName ($path: string) : string
            public static GetExtension ($path: string) : string
            public static GetFileName ($path: string) : string
            public static GetFileNameWithoutExtension ($path: string) : string
            public static GetFullPath ($path: string) : string
            public static GetPathRoot ($path: string) : string
            public static GetTempFileName () : string
            public static GetTempPath () : string
            public static HasExtension ($path: string) : boolean
            public static IsPathRooted ($path: string) : boolean
            public static GetInvalidFileNameChars () : System.Array$1<number>
            public static GetInvalidPathChars () : System.Array$1<number>
            public static GetRandomFileName () : string
            public static Combine (...paths: string[]) : string
            public static Combine ($path1: string, $path2: string, $path3: string) : string
            public static Combine ($path1: string, $path2: string, $path3: string, $path4: string) : string
            public static GetRelativePath ($relativeTo: string, $path: string) : string
            public static IsPathFullyQualified ($path: string) : boolean
            public static GetFullPath ($path: string, $basePath: string) : string
        }
    }
    namespace System.Deployment.Internal {
        class InternalActivationContextHelper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static GetActivationContextData ($appInfo: System.ActivationContext) : any
            public static GetApplicationComponentManifest ($appInfo: System.ActivationContext) : any
            public static GetApplicationManifestBytes ($appInfo: System.ActivationContext) : System.Array$1<number>
            public static GetDeploymentComponentManifest ($appInfo: System.ActivationContext) : any
            public static GetDeploymentManifestBytes ($appInfo: System.ActivationContext) : System.Array$1<number>
            public static IsFirstRun ($appInfo: System.ActivationContext) : boolean
            public static PrepareForExecution ($appInfo: System.ActivationContext) : void
        }
        class InternalApplicationIdentityHelper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static GetInternalAppId ($id: System.ApplicationIdentity) : any
        }
    }
    namespace System.Runtime.Remoting.Contexts {
        class Context extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get DefaultContext(): System.Runtime.Remoting.Contexts.Context;
            public get ContextID(): number;
            public get ContextProperties(): System.Array$1<System.Runtime.Remoting.Contexts.IContextProperty>;
            public static RegisterDynamicProperty ($prop: System.Runtime.Remoting.Contexts.IDynamicProperty, $obj: System.ContextBoundObject, $ctx: System.Runtime.Remoting.Contexts.Context) : boolean
            public static UnregisterDynamicProperty ($name: string, $obj: System.ContextBoundObject, $ctx: System.Runtime.Remoting.Contexts.Context) : boolean
            public GetProperty ($name: string) : System.Runtime.Remoting.Contexts.IContextProperty
            public SetProperty ($prop: System.Runtime.Remoting.Contexts.IContextProperty) : void
            public Freeze () : void
            public DoCallBack ($deleg: System.Runtime.Remoting.Contexts.CrossContextDelegate) : void
            public static AllocateDataSlot () : System.LocalDataStoreSlot
            public static AllocateNamedDataSlot ($name: string) : System.LocalDataStoreSlot
            public static FreeNamedDataSlot ($name: string) : void
            public static GetNamedDataSlot ($name: string) : System.LocalDataStoreSlot
            public static GetData ($slot: System.LocalDataStoreSlot) : any
            public static SetData ($slot: System.LocalDataStoreSlot, $data: any) : void
            public constructor ()
        }
        interface IContextAttribute
        {
            GetPropertiesForNewContext ($msg: System.Runtime.Remoting.Activation.IConstructionCallMessage) : void
            IsContextOK ($ctx: System.Runtime.Remoting.Contexts.Context, $msg: System.Runtime.Remoting.Activation.IConstructionCallMessage) : boolean
        }
        interface IContextProperty
        {
            Name : string
            Freeze ($newContext: System.Runtime.Remoting.Contexts.Context) : void
            IsNewContextOK ($newCtx: System.Runtime.Remoting.Contexts.Context) : boolean
        }
        interface IDynamicProperty
        {
            Name : string
        }
        interface CrossContextDelegate
        { 
        () : void; 
        Invoke?: () => void;
        }
        var CrossContextDelegate: { new (func: () => void): CrossContextDelegate; }
        class ContextAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute, System.Runtime.Remoting.Contexts.IContextAttribute, System.Runtime.Remoting.Contexts.IContextProperty
        {
            protected [__keep_incompatibility]: never;
            public get Name(): string;
            public Freeze ($newContext: System.Runtime.Remoting.Contexts.Context) : void
            public GetPropertiesForNewContext ($ctorMsg: System.Runtime.Remoting.Activation.IConstructionCallMessage) : void
            public IsContextOK ($ctx: System.Runtime.Remoting.Contexts.Context, $ctorMsg: System.Runtime.Remoting.Activation.IConstructionCallMessage) : boolean
            public IsNewContextOK ($newCtx: System.Runtime.Remoting.Contexts.Context) : boolean
            public constructor ($name: string)
            public GetPropertiesForNewContext ($msg: System.Runtime.Remoting.Activation.IConstructionCallMessage) : void
            public IsContextOK ($ctx: System.Runtime.Remoting.Contexts.Context, $msg: System.Runtime.Remoting.Activation.IConstructionCallMessage) : boolean
            public constructor ()
        }
        class ContextProperty extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get Name(): string;
            public get Property(): any;
        }
        interface IContextPropertyActivator
        {
            CollectFromClientContext ($msg: System.Runtime.Remoting.Activation.IConstructionCallMessage) : void
            CollectFromServerContext ($msg: System.Runtime.Remoting.Activation.IConstructionReturnMessage) : void
            DeliverClientContextToServerContext ($msg: System.Runtime.Remoting.Activation.IConstructionCallMessage) : boolean
            DeliverServerContextToClientContext ($msg: System.Runtime.Remoting.Activation.IConstructionReturnMessage) : boolean
            IsOKToActivate ($msg: System.Runtime.Remoting.Activation.IConstructionCallMessage) : boolean
        }
        interface IContributeClientContextSink
        {
            GetClientContextSink ($nextSink: System.Runtime.Remoting.Messaging.IMessageSink) : System.Runtime.Remoting.Messaging.IMessageSink
        }
        interface IContributeDynamicSink
        {
            GetDynamicSink () : System.Runtime.Remoting.Contexts.IDynamicMessageSink
        }
        interface IDynamicMessageSink
        {
            ProcessMessageFinish ($replyMsg: System.Runtime.Remoting.Messaging.IMessage, $bCliSide: boolean, $bAsync: boolean) : void
            ProcessMessageStart ($reqMsg: System.Runtime.Remoting.Messaging.IMessage, $bCliSide: boolean, $bAsync: boolean) : void
        }
        interface IContributeEnvoySink
        {
            GetEnvoySink ($obj: System.MarshalByRefObject, $nextSink: System.Runtime.Remoting.Messaging.IMessageSink) : System.Runtime.Remoting.Messaging.IMessageSink
        }
        interface IContributeObjectSink
        {
            GetObjectSink ($obj: System.MarshalByRefObject, $nextSink: System.Runtime.Remoting.Messaging.IMessageSink) : System.Runtime.Remoting.Messaging.IMessageSink
        }
        interface IContributeServerContextSink
        {
            GetServerContextSink ($nextSink: System.Runtime.Remoting.Messaging.IMessageSink) : System.Runtime.Remoting.Messaging.IMessageSink
        }
        class SynchronizationAttribute extends System.Runtime.Remoting.Contexts.ContextAttribute implements System.Runtime.Remoting.Contexts.IContributeClientContextSink, System.Runtime.InteropServices._Attribute, System.Runtime.Remoting.Contexts.IContributeServerContextSink, System.Runtime.Remoting.Contexts.IContextAttribute, System.Runtime.Remoting.Contexts.IContextProperty
        {
            protected [__keep_incompatibility]: never;
            public static NOT_SUPPORTED : number
            public static SUPPORTED : number
            public static REQUIRED : number
            public static REQUIRES_NEW : number
            public get IsReEntrant(): boolean;
            public get Locked(): boolean;
            public set Locked(value: boolean);
            public GetClientContextSink ($nextSink: System.Runtime.Remoting.Messaging.IMessageSink) : System.Runtime.Remoting.Messaging.IMessageSink
            public GetServerContextSink ($nextSink: System.Runtime.Remoting.Messaging.IMessageSink) : System.Runtime.Remoting.Messaging.IMessageSink
            public constructor ()
            public constructor ($reEntrant: boolean)
            public constructor ($flag: number)
            public constructor ($flag: number, $reEntrant: boolean)
            public constructor ($name: string)
        }
    }
    namespace System.Threading.Tasks.Sources {
        interface IValueTaskSource
        {
            GetStatus ($token: number) : System.Threading.Tasks.Sources.ValueTaskSourceStatus
            OnCompleted ($continuation: System.Action$1<any>, $state: any, $token: number, $flags: System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags) : void
            GetResult ($token: number) : void
        }
        interface IValueTaskSource$1<TResult>
        {
            GetStatus ($token: number) : System.Threading.Tasks.Sources.ValueTaskSourceStatus
            OnCompleted ($continuation: System.Action$1<any>, $state: any, $token: number, $flags: System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags) : void
            GetResult ($token: number) : TResult
        }
        enum ValueTaskSourceOnCompletedFlags
        { None = 0, UseSchedulingContext = 1, FlowExecutionContext = 2 }
        enum ValueTaskSourceStatus
        { Pending = 0, Succeeded = 1, Faulted = 2, Canceled = 3 }
        class ManualResetValueTaskSourceCore$1<TResult> extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get RunContinuationsAsynchronously(): boolean;
            public set RunContinuationsAsynchronously(value: boolean);
            public get Version(): number;
            public Reset () : void
            public SetResult ($result: TResult) : void
            public SetException ($error: System.Exception) : void
            public GetStatus ($token: number) : System.Threading.Tasks.Sources.ValueTaskSourceStatus
            public GetResult ($token: number) : TResult
            public OnCompleted ($continuation: System.Action$1<any>, $state: any, $token: number, $flags: System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags) : void
        }
    }
    namespace System.Collections.Concurrent {
        class Partitioner$1<TSource> extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class OrderablePartitioner$1<TSource> extends System.Collections.Concurrent.Partitioner$1<TSource>
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace System.Security.Permissions {
        enum HostProtectionResource
        { All = 511, ExternalProcessMgmt = 4, ExternalThreading = 16, MayLeakOnAbort = 256, None = 0, SecurityInfrastructure = 64, SelfAffectingProcessMgmt = 8, SelfAffectingThreading = 32, SharedState = 2, Synchronization = 1, UI = 128 }
        enum PermissionState
        { None = 0, Unrestricted = 1 }
        enum SecurityAction
        { Demand = 2, Assert = 3, Deny = 4, PermitOnly = 5, LinkDemand = 6, InheritanceDemand = 7, RequestMinimum = 8, RequestOptional = 9, RequestRefuse = 10 }
        enum FileIOPermissionAccess
        { NoAccess = 0, Read = 1, Write = 2, Append = 4, PathDiscovery = 8, AllAccess = 15 }
        class StrongNamePublicKeyBlob extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public constructor ($publicKey: System.Array$1<number>)
            public constructor ()
        }
        enum FileDialogPermissionAccess
        { None = 0, Open = 1, OpenSave = 3, Save = 2 }
        interface IUnrestrictedPermission
        {
            IsUnrestricted () : boolean
        }
        enum IsolatedStorageContainment
        { None = 0, DomainIsolationByUser = 16, ApplicationIsolationByUser = 21, AssemblyIsolationByUser = 32, DomainIsolationByMachine = 48, AssemblyIsolationByMachine = 64, ApplicationIsolationByMachine = 69, DomainIsolationByRoamingUser = 80, AssemblyIsolationByRoamingUser = 96, ApplicationIsolationByRoamingUser = 101, AdministerIsolatedStorageByUser = 112, UnrestrictedIsolatedStorage = 240 }
        enum ReflectionPermissionFlag
        { AllFlags = 7, MemberAccess = 2, NoFlags = 0, ReflectionEmit = 4, RestrictedMemberAccess = 8, TypeInformation = 1 }
        enum RegistryPermissionAccess
        { AllAccess = 7, Create = 4, NoAccess = 0, Read = 1, Write = 2 }
        enum UIPermissionClipboard
        { AllClipboard = 2, NoClipboard = 0, OwnClipboard = 1 }
        enum UIPermissionWindow
        { AllWindows = 3, NoWindows = 0, SafeSubWindows = 1, SafeTopLevelWindows = 2 }
        class SecurityAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Unrestricted(): boolean;
            public set Unrestricted(value: boolean);
            public get Action(): System.Security.Permissions.SecurityAction;
            public set Action(value: System.Security.Permissions.SecurityAction);
            public CreatePermission () : System.Security.IPermission
        }
        class CodeAccessSecurityAttribute extends System.Security.Permissions.SecurityAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
        }
        class EnvironmentPermission extends System.Security.CodeAccessPermission implements System.Security.IStackWalk, System.Security.IPermission, System.Security.ISecurityEncodable, System.Security.Permissions.IBuiltInPermission, System.Security.Permissions.IUnrestrictedPermission
        {
            protected [__keep_incompatibility]: never;
            public AddPathList ($flag: System.Security.Permissions.EnvironmentPermissionAccess, $pathList: string) : void
            public GetPathList ($flag: System.Security.Permissions.EnvironmentPermissionAccess) : string
            public IsUnrestricted () : boolean
            public SetPathList ($flag: System.Security.Permissions.EnvironmentPermissionAccess, $pathList: string) : void
            public constructor ($state: System.Security.Permissions.PermissionState)
            public constructor ($flag: System.Security.Permissions.EnvironmentPermissionAccess, $pathList: string)
            public constructor ()
        }
        interface IBuiltInPermission
        {
        }
        enum EnvironmentPermissionAccess
        { NoAccess = 0, Read = 1, Write = 2, AllAccess = 3 }
        class EnvironmentPermissionAttribute extends System.Security.Permissions.CodeAccessSecurityAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get All(): string;
            public set All(value: string);
            public get Read(): string;
            public set Read(value: string);
            public get Write(): string;
            public set Write(value: string);
            public constructor ($action: System.Security.Permissions.SecurityAction)
            public constructor ()
        }
        class FileDialogPermission extends System.Security.CodeAccessPermission implements System.Security.IStackWalk, System.Security.IPermission, System.Security.ISecurityEncodable, System.Security.Permissions.IBuiltInPermission, System.Security.Permissions.IUnrestrictedPermission
        {
            protected [__keep_incompatibility]: never;
            public get Access(): System.Security.Permissions.FileDialogPermissionAccess;
            public set Access(value: System.Security.Permissions.FileDialogPermissionAccess);
            public IsUnrestricted () : boolean
            public constructor ($state: System.Security.Permissions.PermissionState)
            public constructor ($access: System.Security.Permissions.FileDialogPermissionAccess)
            public constructor ()
        }
        class FileDialogPermissionAttribute extends System.Security.Permissions.CodeAccessSecurityAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Open(): boolean;
            public set Open(value: boolean);
            public get Save(): boolean;
            public set Save(value: boolean);
            public constructor ($action: System.Security.Permissions.SecurityAction)
            public constructor ()
        }
        class FileIOPermission extends System.Security.CodeAccessPermission implements System.Security.IStackWalk, System.Security.IPermission, System.Security.ISecurityEncodable, System.Security.Permissions.IBuiltInPermission, System.Security.Permissions.IUnrestrictedPermission
        {
            protected [__keep_incompatibility]: never;
            public get AllFiles(): System.Security.Permissions.FileIOPermissionAccess;
            public set AllFiles(value: System.Security.Permissions.FileIOPermissionAccess);
            public get AllLocalFiles(): System.Security.Permissions.FileIOPermissionAccess;
            public set AllLocalFiles(value: System.Security.Permissions.FileIOPermissionAccess);
            public AddPathList ($access: System.Security.Permissions.FileIOPermissionAccess, $path: string) : void
            public AddPathList ($access: System.Security.Permissions.FileIOPermissionAccess, $pathList: System.Array$1<string>) : void
            public GetPathList ($access: System.Security.Permissions.FileIOPermissionAccess) : System.Array$1<string>
            public IsUnrestricted () : boolean
            public SetPathList ($access: System.Security.Permissions.FileIOPermissionAccess, $path: string) : void
            public SetPathList ($access: System.Security.Permissions.FileIOPermissionAccess, $pathList: System.Array$1<string>) : void
            public constructor ($state: System.Security.Permissions.PermissionState)
            public constructor ($access: System.Security.Permissions.FileIOPermissionAccess, $path: string)
            public constructor ($access: System.Security.Permissions.FileIOPermissionAccess, $pathList: System.Array$1<string>)
            public constructor ($access: System.Security.Permissions.FileIOPermissionAccess, $control: System.Security.AccessControl.AccessControlActions, $path: string)
            public constructor ($access: System.Security.Permissions.FileIOPermissionAccess, $control: System.Security.AccessControl.AccessControlActions, $pathList: System.Array$1<string>)
            public constructor ()
        }
        class FileIOPermissionAttribute extends System.Security.Permissions.CodeAccessSecurityAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Append(): string;
            public set Append(value: string);
            public get PathDiscovery(): string;
            public set PathDiscovery(value: string);
            public get Read(): string;
            public set Read(value: string);
            public get Write(): string;
            public set Write(value: string);
            public get AllFiles(): System.Security.Permissions.FileIOPermissionAccess;
            public set AllFiles(value: System.Security.Permissions.FileIOPermissionAccess);
            public get AllLocalFiles(): System.Security.Permissions.FileIOPermissionAccess;
            public set AllLocalFiles(value: System.Security.Permissions.FileIOPermissionAccess);
            public get ChangeAccessControl(): string;
            public set ChangeAccessControl(value: string);
            public get ViewAccessControl(): string;
            public set ViewAccessControl(value: string);
            public get ViewAndModify(): string;
            public set ViewAndModify(value: string);
            public constructor ($action: System.Security.Permissions.SecurityAction)
            public constructor ()
        }
        class GacIdentityPermission extends System.Security.CodeAccessPermission implements System.Security.IStackWalk, System.Security.IPermission, System.Security.ISecurityEncodable, System.Security.Permissions.IBuiltInPermission
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($state: System.Security.Permissions.PermissionState)
        }
        class GacIdentityPermissionAttribute extends System.Security.Permissions.CodeAccessSecurityAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ($action: System.Security.Permissions.SecurityAction)
            public constructor ()
        }
        class HostProtectionAttribute extends System.Security.Permissions.CodeAccessSecurityAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get ExternalProcessMgmt(): boolean;
            public set ExternalProcessMgmt(value: boolean);
            public get ExternalThreading(): boolean;
            public set ExternalThreading(value: boolean);
            public get MayLeakOnAbort(): boolean;
            public set MayLeakOnAbort(value: boolean);
            public get SecurityInfrastructure(): boolean;
            public set SecurityInfrastructure(value: boolean);
            public get SelfAffectingProcessMgmt(): boolean;
            public set SelfAffectingProcessMgmt(value: boolean);
            public get SelfAffectingThreading(): boolean;
            public set SelfAffectingThreading(value: boolean);
            public get SharedState(): boolean;
            public set SharedState(value: boolean);
            public get Synchronization(): boolean;
            public set Synchronization(value: boolean);
            public get UI(): boolean;
            public set UI(value: boolean);
            public get Resources(): System.Security.Permissions.HostProtectionResource;
            public set Resources(value: System.Security.Permissions.HostProtectionResource);
            public constructor ()
            public constructor ($action: System.Security.Permissions.SecurityAction)
        }
        class IsolatedStoragePermission extends System.Security.CodeAccessPermission implements System.Security.IStackWalk, System.Security.IPermission, System.Security.ISecurityEncodable, System.Security.Permissions.IUnrestrictedPermission
        {
            protected [__keep_incompatibility]: never;
            public get UserQuota(): bigint;
            public set UserQuota(value: bigint);
            public get UsageAllowed(): System.Security.Permissions.IsolatedStorageContainment;
            public set UsageAllowed(value: System.Security.Permissions.IsolatedStorageContainment);
            public IsUnrestricted () : boolean
        }
        class IsolatedStorageFilePermission extends System.Security.Permissions.IsolatedStoragePermission implements System.Security.IStackWalk, System.Security.IPermission, System.Security.ISecurityEncodable, System.Security.Permissions.IBuiltInPermission, System.Security.Permissions.IUnrestrictedPermission
        {
            protected [__keep_incompatibility]: never;
            public constructor ($state: System.Security.Permissions.PermissionState)
            public constructor ()
        }
        class IsolatedStoragePermissionAttribute extends System.Security.Permissions.CodeAccessSecurityAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get UsageAllowed(): System.Security.Permissions.IsolatedStorageContainment;
            public set UsageAllowed(value: System.Security.Permissions.IsolatedStorageContainment);
            public get UserQuota(): bigint;
            public set UserQuota(value: bigint);
        }
        class IsolatedStorageFilePermissionAttribute extends System.Security.Permissions.IsolatedStoragePermissionAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ($action: System.Security.Permissions.SecurityAction)
            public constructor ()
        }
        class KeyContainerPermission extends System.Security.CodeAccessPermission implements System.Security.IStackWalk, System.Security.IPermission, System.Security.ISecurityEncodable, System.Security.Permissions.IBuiltInPermission, System.Security.Permissions.IUnrestrictedPermission
        {
            protected [__keep_incompatibility]: never;
            public get AccessEntries(): System.Security.Permissions.KeyContainerPermissionAccessEntryCollection;
            public get Flags(): System.Security.Permissions.KeyContainerPermissionFlags;
            public IsUnrestricted () : boolean
            public constructor ($state: System.Security.Permissions.PermissionState)
            public constructor ($flags: System.Security.Permissions.KeyContainerPermissionFlags)
            public constructor ($flags: System.Security.Permissions.KeyContainerPermissionFlags, $accessList: System.Array$1<System.Security.Permissions.KeyContainerPermissionAccessEntry>)
            public constructor ()
        }
        class KeyContainerPermissionAccessEntryCollection extends System.Object implements System.Collections.ICollection, System.Collections.IEnumerable
        {
            protected [__keep_incompatibility]: never;
            public get Count(): number;
            public get IsSynchronized(): boolean;
            public get SyncRoot(): any;
            public get_Item ($index: number) : System.Security.Permissions.KeyContainerPermissionAccessEntry
            public Add ($accessEntry: System.Security.Permissions.KeyContainerPermissionAccessEntry) : number
            public Clear () : void
            public CopyTo ($array: System.Array$1<System.Security.Permissions.KeyContainerPermissionAccessEntry>, $index: number) : void
            public GetEnumerator () : System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator
            public IndexOf ($accessEntry: System.Security.Permissions.KeyContainerPermissionAccessEntry) : number
            public Remove ($accessEntry: System.Security.Permissions.KeyContainerPermissionAccessEntry) : void
            public CopyTo ($array: System.Array, $index: number) : void
            public GetEnumerator () : System.Collections.IEnumerator
        }
        enum KeyContainerPermissionFlags
        { NoFlags = 0, Create = 1, Open = 2, Delete = 4, Import = 16, Export = 32, Sign = 256, Decrypt = 512, ViewAcl = 4096, ChangeAcl = 8192, AllFlags = 13111 }
        class KeyContainerPermissionAccessEntry extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get Flags(): System.Security.Permissions.KeyContainerPermissionFlags;
            public set Flags(value: System.Security.Permissions.KeyContainerPermissionFlags);
            public get KeyContainerName(): string;
            public set KeyContainerName(value: string);
            public get KeySpec(): number;
            public set KeySpec(value: number);
            public get KeyStore(): string;
            public set KeyStore(value: string);
            public get ProviderName(): string;
            public set ProviderName(value: string);
            public get ProviderType(): number;
            public set ProviderType(value: number);
            public constructor ($parameters: System.Security.Cryptography.CspParameters, $flags: System.Security.Permissions.KeyContainerPermissionFlags)
            public constructor ($keyContainerName: string, $flags: System.Security.Permissions.KeyContainerPermissionFlags)
            public constructor ($keyStore: string, $providerName: string, $providerType: number, $keyContainerName: string, $keySpec: number, $flags: System.Security.Permissions.KeyContainerPermissionFlags)
            public constructor ()
        }
        class KeyContainerPermissionAccessEntryEnumerator extends System.Object implements System.Collections.IEnumerator
        {
            protected [__keep_incompatibility]: never;
            public get Current(): System.Security.Permissions.KeyContainerPermissionAccessEntry;
            public MoveNext () : boolean
            public Reset () : void
        }
        class KeyContainerPermissionAttribute extends System.Security.Permissions.CodeAccessSecurityAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Flags(): System.Security.Permissions.KeyContainerPermissionFlags;
            public set Flags(value: System.Security.Permissions.KeyContainerPermissionFlags);
            public get KeyContainerName(): string;
            public set KeyContainerName(value: string);
            public get KeySpec(): number;
            public set KeySpec(value: number);
            public get KeyStore(): string;
            public set KeyStore(value: string);
            public get ProviderName(): string;
            public set ProviderName(value: string);
            public get ProviderType(): number;
            public set ProviderType(value: number);
            public constructor ($action: System.Security.Permissions.SecurityAction)
            public constructor ()
        }
        class PermissionSetAttribute extends System.Security.Permissions.CodeAccessSecurityAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get File(): string;
            public set File(value: string);
            public get Hex(): string;
            public set Hex(value: string);
            public get Name(): string;
            public set Name(value: string);
            public get UnicodeEncoded(): boolean;
            public set UnicodeEncoded(value: boolean);
            public get XML(): string;
            public set XML(value: string);
            public CreatePermissionSet () : System.Security.PermissionSet
            public constructor ($action: System.Security.Permissions.SecurityAction)
            public constructor ()
        }
        class PrincipalPermission extends System.Object implements System.Security.IPermission, System.Security.Permissions.IBuiltInPermission, System.Security.ISecurityEncodable, System.Security.Permissions.IUnrestrictedPermission
        {
            protected [__keep_incompatibility]: never;
            public Copy () : System.Security.IPermission
            public Demand () : void
            public FromXml ($elem: System.Security.SecurityElement) : void
            public Intersect ($target: System.Security.IPermission) : System.Security.IPermission
            public IsSubsetOf ($target: System.Security.IPermission) : boolean
            public IsUnrestricted () : boolean
            public ToXml () : System.Security.SecurityElement
            public Union ($other: System.Security.IPermission) : System.Security.IPermission
            public constructor ($state: System.Security.Permissions.PermissionState)
            public constructor ($name: string, $role: string)
            public constructor ($name: string, $role: string, $isAuthenticated: boolean)
            public Union ($target: System.Security.IPermission) : System.Security.IPermission
            public FromXml ($e: System.Security.SecurityElement) : void
            public constructor ()
        }
        class PrincipalPermissionAttribute extends System.Security.Permissions.CodeAccessSecurityAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Authenticated(): boolean;
            public set Authenticated(value: boolean);
            public get Name(): string;
            public set Name(value: string);
            public get Role(): string;
            public set Role(value: string);
            public constructor ($action: System.Security.Permissions.SecurityAction)
            public constructor ()
        }
        class PublisherIdentityPermission extends System.Security.CodeAccessPermission implements System.Security.IStackWalk, System.Security.IPermission, System.Security.ISecurityEncodable, System.Security.Permissions.IBuiltInPermission
        {
            protected [__keep_incompatibility]: never;
            public get Certificate(): System.Security.Cryptography.X509Certificates.X509Certificate;
            public set Certificate(value: System.Security.Cryptography.X509Certificates.X509Certificate);
            public constructor ($state: System.Security.Permissions.PermissionState)
            public constructor ($certificate: System.Security.Cryptography.X509Certificates.X509Certificate)
            public constructor ()
        }
        class PublisherIdentityPermissionAttribute extends System.Security.Permissions.CodeAccessSecurityAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get CertFile(): string;
            public set CertFile(value: string);
            public get SignedFile(): string;
            public set SignedFile(value: string);
            public get X509Certificate(): string;
            public set X509Certificate(value: string);
            public constructor ($action: System.Security.Permissions.SecurityAction)
            public constructor ()
        }
        class ReflectionPermission extends System.Security.CodeAccessPermission implements System.Security.IStackWalk, System.Security.IPermission, System.Security.ISecurityEncodable, System.Security.Permissions.IBuiltInPermission, System.Security.Permissions.IUnrestrictedPermission
        {
            protected [__keep_incompatibility]: never;
            public get Flags(): System.Security.Permissions.ReflectionPermissionFlag;
            public set Flags(value: System.Security.Permissions.ReflectionPermissionFlag);
            public IsUnrestricted () : boolean
            public constructor ($state: System.Security.Permissions.PermissionState)
            public constructor ($flag: System.Security.Permissions.ReflectionPermissionFlag)
            public constructor ()
        }
        class ReflectionPermissionAttribute extends System.Security.Permissions.CodeAccessSecurityAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Flags(): System.Security.Permissions.ReflectionPermissionFlag;
            public set Flags(value: System.Security.Permissions.ReflectionPermissionFlag);
            public get MemberAccess(): boolean;
            public set MemberAccess(value: boolean);
            public get RestrictedMemberAccess(): boolean;
            public set RestrictedMemberAccess(value: boolean);
            public constructor ($action: System.Security.Permissions.SecurityAction)
            public constructor ()
        }
        class RegistryPermission extends System.Security.CodeAccessPermission implements System.Security.IStackWalk, System.Security.IPermission, System.Security.ISecurityEncodable, System.Security.Permissions.IBuiltInPermission, System.Security.Permissions.IUnrestrictedPermission
        {
            protected [__keep_incompatibility]: never;
            public AddPathList ($access: System.Security.Permissions.RegistryPermissionAccess, $pathList: string) : void
            public AddPathList ($access: System.Security.Permissions.RegistryPermissionAccess, $control: System.Security.AccessControl.AccessControlActions, $pathList: string) : void
            public GetPathList ($access: System.Security.Permissions.RegistryPermissionAccess) : string
            public SetPathList ($access: System.Security.Permissions.RegistryPermissionAccess, $pathList: string) : void
            public IsUnrestricted () : boolean
            public constructor ($state: System.Security.Permissions.PermissionState)
            public constructor ($access: System.Security.Permissions.RegistryPermissionAccess, $pathList: string)
            public constructor ($access: System.Security.Permissions.RegistryPermissionAccess, $control: System.Security.AccessControl.AccessControlActions, $pathList: string)
            public constructor ()
        }
        class RegistryPermissionAttribute extends System.Security.Permissions.CodeAccessSecurityAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Create(): string;
            public set Create(value: string);
            public get Read(): string;
            public set Read(value: string);
            public get Write(): string;
            public set Write(value: string);
            public get ChangeAccessControl(): string;
            public set ChangeAccessControl(value: string);
            public get ViewAccessControl(): string;
            public set ViewAccessControl(value: string);
            public get ViewAndModify(): string;
            public set ViewAndModify(value: string);
            public constructor ($action: System.Security.Permissions.SecurityAction)
            public constructor ()
        }
        class SecurityPermission extends System.Security.CodeAccessPermission implements System.Security.IStackWalk, System.Security.IPermission, System.Security.ISecurityEncodable, System.Security.Permissions.IBuiltInPermission, System.Security.Permissions.IUnrestrictedPermission
        {
            protected [__keep_incompatibility]: never;
            public get Flags(): System.Security.Permissions.SecurityPermissionFlag;
            public set Flags(value: System.Security.Permissions.SecurityPermissionFlag);
            public IsUnrestricted () : boolean
            public constructor ($state: System.Security.Permissions.PermissionState)
            public constructor ($flag: System.Security.Permissions.SecurityPermissionFlag)
            public constructor ()
        }
        enum SecurityPermissionFlag
        { NoFlags = 0, Assertion = 1, UnmanagedCode = 2, SkipVerification = 4, Execution = 8, ControlThread = 16, ControlEvidence = 32, ControlPolicy = 64, SerializationFormatter = 128, ControlDomainPolicy = 256, ControlPrincipal = 512, ControlAppDomain = 1024, RemotingConfiguration = 2048, Infrastructure = 4096, BindingRedirects = 8192, AllFlags = 16383 }
        class SecurityPermissionAttribute extends System.Security.Permissions.CodeAccessSecurityAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Assertion(): boolean;
            public set Assertion(value: boolean);
            public get BindingRedirects(): boolean;
            public set BindingRedirects(value: boolean);
            public get ControlAppDomain(): boolean;
            public set ControlAppDomain(value: boolean);
            public get ControlDomainPolicy(): boolean;
            public set ControlDomainPolicy(value: boolean);
            public get ControlEvidence(): boolean;
            public set ControlEvidence(value: boolean);
            public get ControlPolicy(): boolean;
            public set ControlPolicy(value: boolean);
            public get ControlPrincipal(): boolean;
            public set ControlPrincipal(value: boolean);
            public get ControlThread(): boolean;
            public set ControlThread(value: boolean);
            public get Execution(): boolean;
            public set Execution(value: boolean);
            public get Infrastructure(): boolean;
            public set Infrastructure(value: boolean);
            public get RemotingConfiguration(): boolean;
            public set RemotingConfiguration(value: boolean);
            public get SerializationFormatter(): boolean;
            public set SerializationFormatter(value: boolean);
            public get SkipVerification(): boolean;
            public set SkipVerification(value: boolean);
            public get UnmanagedCode(): boolean;
            public set UnmanagedCode(value: boolean);
            public get Flags(): System.Security.Permissions.SecurityPermissionFlag;
            public set Flags(value: System.Security.Permissions.SecurityPermissionFlag);
            public constructor ($action: System.Security.Permissions.SecurityAction)
            public constructor ()
        }
        class SiteIdentityPermission extends System.Security.CodeAccessPermission implements System.Security.IStackWalk, System.Security.IPermission, System.Security.ISecurityEncodable, System.Security.Permissions.IBuiltInPermission
        {
            protected [__keep_incompatibility]: never;
            public get Site(): string;
            public set Site(value: string);
            public constructor ($state: System.Security.Permissions.PermissionState)
            public constructor ($site: string)
            public constructor ()
        }
        class SiteIdentityPermissionAttribute extends System.Security.Permissions.CodeAccessSecurityAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Site(): string;
            public set Site(value: string);
            public constructor ($action: System.Security.Permissions.SecurityAction)
            public constructor ()
        }
        class StrongNameIdentityPermission extends System.Security.CodeAccessPermission implements System.Security.IStackWalk, System.Security.IPermission, System.Security.ISecurityEncodable, System.Security.Permissions.IBuiltInPermission
        {
            protected [__keep_incompatibility]: never;
            public get Name(): string;
            public set Name(value: string);
            public get PublicKey(): System.Security.Permissions.StrongNamePublicKeyBlob;
            public set PublicKey(value: System.Security.Permissions.StrongNamePublicKeyBlob);
            public get Version(): System.Version;
            public set Version(value: System.Version);
            public constructor ($state: System.Security.Permissions.PermissionState)
            public constructor ($blob: System.Security.Permissions.StrongNamePublicKeyBlob, $name: string, $version: System.Version)
            public constructor ()
        }
        class StrongNameIdentityPermissionAttribute extends System.Security.Permissions.CodeAccessSecurityAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Name(): string;
            public set Name(value: string);
            public get PublicKey(): string;
            public set PublicKey(value: string);
            public get Version(): string;
            public set Version(value: string);
            public constructor ($action: System.Security.Permissions.SecurityAction)
            public constructor ()
        }
        class UIPermission extends System.Security.CodeAccessPermission implements System.Security.IStackWalk, System.Security.IPermission, System.Security.ISecurityEncodable, System.Security.Permissions.IBuiltInPermission, System.Security.Permissions.IUnrestrictedPermission
        {
            protected [__keep_incompatibility]: never;
            public get Clipboard(): System.Security.Permissions.UIPermissionClipboard;
            public set Clipboard(value: System.Security.Permissions.UIPermissionClipboard);
            public get Window(): System.Security.Permissions.UIPermissionWindow;
            public set Window(value: System.Security.Permissions.UIPermissionWindow);
            public IsUnrestricted () : boolean
            public constructor ($state: System.Security.Permissions.PermissionState)
            public constructor ($clipboardFlag: System.Security.Permissions.UIPermissionClipboard)
            public constructor ($windowFlag: System.Security.Permissions.UIPermissionWindow)
            public constructor ($windowFlag: System.Security.Permissions.UIPermissionWindow, $clipboardFlag: System.Security.Permissions.UIPermissionClipboard)
            public constructor ()
        }
        class UIPermissionAttribute extends System.Security.Permissions.CodeAccessSecurityAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Clipboard(): System.Security.Permissions.UIPermissionClipboard;
            public set Clipboard(value: System.Security.Permissions.UIPermissionClipboard);
            public get Window(): System.Security.Permissions.UIPermissionWindow;
            public set Window(value: System.Security.Permissions.UIPermissionWindow);
            public constructor ($action: System.Security.Permissions.SecurityAction)
            public constructor ()
        }
        class UrlIdentityPermission extends System.Security.CodeAccessPermission implements System.Security.IStackWalk, System.Security.IPermission, System.Security.ISecurityEncodable, System.Security.Permissions.IBuiltInPermission
        {
            protected [__keep_incompatibility]: never;
            public get Url(): string;
            public set Url(value: string);
            public constructor ($state: System.Security.Permissions.PermissionState)
            public constructor ($site: string)
            public constructor ()
        }
        class UrlIdentityPermissionAttribute extends System.Security.Permissions.CodeAccessSecurityAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Url(): string;
            public set Url(value: string);
            public constructor ($action: System.Security.Permissions.SecurityAction)
            public constructor ()
        }
        class ZoneIdentityPermission extends System.Security.CodeAccessPermission implements System.Security.IStackWalk, System.Security.IPermission, System.Security.ISecurityEncodable, System.Security.Permissions.IBuiltInPermission
        {
            protected [__keep_incompatibility]: never;
            public get SecurityZone(): System.Security.SecurityZone;
            public set SecurityZone(value: System.Security.SecurityZone);
            public constructor ($state: System.Security.Permissions.PermissionState)
            public constructor ($zone: System.Security.SecurityZone)
            public constructor ()
        }
        class ZoneIdentityPermissionAttribute extends System.Security.Permissions.CodeAccessSecurityAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Zone(): System.Security.SecurityZone;
            public set Zone(value: System.Security.SecurityZone);
            public constructor ($action: System.Security.Permissions.SecurityAction)
            public constructor ()
        }
    }
    namespace System.Security.Cryptography.X509Certificates {
        class X509Certificate extends System.Object implements System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get Handle(): System.IntPtr;
            public get Issuer(): string;
            public get Subject(): string;
            public Reset () : void
            public static CreateFromCertFile ($filename: string) : System.Security.Cryptography.X509Certificates.X509Certificate
            public static CreateFromSignedFile ($filename: string) : System.Security.Cryptography.X509Certificates.X509Certificate
            public Dispose () : void
            public Equals ($obj: any) : boolean
            public Equals ($other: System.Security.Cryptography.X509Certificates.X509Certificate) : boolean
            public Export ($contentType: System.Security.Cryptography.X509Certificates.X509ContentType) : System.Array$1<number>
            public Export ($contentType: System.Security.Cryptography.X509Certificates.X509ContentType, $password: string) : System.Array$1<number>
            public Export ($contentType: System.Security.Cryptography.X509Certificates.X509ContentType, $password: System.Security.SecureString) : System.Array$1<number>
            public GetRawCertDataString () : string
            public GetCertHash () : System.Array$1<number>
            public GetCertHash ($hashAlgorithm: System.Security.Cryptography.HashAlgorithmName) : System.Array$1<number>
            public GetCertHashString () : string
            public GetCertHashString ($hashAlgorithm: System.Security.Cryptography.HashAlgorithmName) : string
            public GetEffectiveDateString () : string
            public GetExpirationDateString () : string
            public GetFormat () : string
            public GetPublicKeyString () : string
            public GetRawCertData () : System.Array$1<number>
            public GetKeyAlgorithm () : string
            public GetKeyAlgorithmParameters () : System.Array$1<number>
            public GetKeyAlgorithmParametersString () : string
            public GetPublicKey () : System.Array$1<number>
            public GetSerialNumber () : System.Array$1<number>
            public GetSerialNumberString () : string
            public ToString () : string
            public ToString ($fVerbose: boolean) : string
            public Import ($rawData: System.Array$1<number>) : void
            public Import ($rawData: System.Array$1<number>, $password: string, $keyStorageFlags: System.Security.Cryptography.X509Certificates.X509KeyStorageFlags) : void
            public Import ($rawData: System.Array$1<number>, $password: System.Security.SecureString, $keyStorageFlags: System.Security.Cryptography.X509Certificates.X509KeyStorageFlags) : void
            public Import ($fileName: string) : void
            public Import ($fileName: string, $password: string, $keyStorageFlags: System.Security.Cryptography.X509Certificates.X509KeyStorageFlags) : void
            public Import ($fileName: string, $password: System.Security.SecureString, $keyStorageFlags: System.Security.Cryptography.X509Certificates.X509KeyStorageFlags) : void
            public constructor ()
            public constructor ($data: System.Array$1<number>)
            public constructor ($rawData: System.Array$1<number>, $password: string)
            public constructor ($rawData: System.Array$1<number>, $password: System.Security.SecureString)
            public constructor ($rawData: System.Array$1<number>, $password: string, $keyStorageFlags: System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)
            public constructor ($rawData: System.Array$1<number>, $password: System.Security.SecureString, $keyStorageFlags: System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)
            public constructor ($handle: System.IntPtr)
            public constructor ($fileName: string)
            public constructor ($fileName: string, $password: string)
            public constructor ($fileName: string, $password: System.Security.SecureString)
            public constructor ($fileName: string, $password: string, $keyStorageFlags: System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)
            public constructor ($fileName: string, $password: System.Security.SecureString, $keyStorageFlags: System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)
            public constructor ($cert: System.Security.Cryptography.X509Certificates.X509Certificate)
            public constructor ($info: System.Runtime.Serialization.SerializationInfo, $context: System.Runtime.Serialization.StreamingContext)
            public OnDeserialization ($sender: any) : void
            public static Equals ($objA: any, $objB: any) : boolean
        }
        enum X509ContentType
        { Unknown = 0, Cert = 1, SerializedCert = 2, Pfx = 3, Pkcs12 = 3, SerializedStore = 4, Pkcs7 = 5, Authenticode = 6 }
        enum X509KeyStorageFlags
        { DefaultKeySet = 0, UserKeySet = 1, MachineKeySet = 2, Exportable = 4, UserProtected = 8, PersistKeySet = 16, EphemeralKeySet = 32 }
    }
    namespace System.Security.Cryptography {
        class HashAlgorithm extends System.Object implements System.IDisposable, System.Security.Cryptography.ICryptoTransform
        {
            protected [__keep_incompatibility]: never;
            public get HashSize(): number;
            public get Hash(): System.Array$1<number>;
            public get InputBlockSize(): number;
            public get OutputBlockSize(): number;
            public get CanTransformMultipleBlocks(): boolean;
            public get CanReuseTransform(): boolean;
            public static Create () : System.Security.Cryptography.HashAlgorithm
            public static Create ($hashName: string) : System.Security.Cryptography.HashAlgorithm
            public ComputeHash ($buffer: System.Array$1<number>) : System.Array$1<number>
            public ComputeHash ($buffer: System.Array$1<number>, $offset: number, $count: number) : System.Array$1<number>
            public ComputeHash ($inputStream: System.IO.Stream) : System.Array$1<number>
            public Dispose () : void
            public Clear () : void
            public TransformBlock ($inputBuffer: System.Array$1<number>, $inputOffset: number, $inputCount: number, $outputBuffer: System.Array$1<number>, $outputOffset: number) : number
            public TransformFinalBlock ($inputBuffer: System.Array$1<number>, $inputOffset: number, $inputCount: number) : System.Array$1<number>
            public Initialize () : void
        }
        interface ICryptoTransform extends System.IDisposable
        {
            InputBlockSize : number
            OutputBlockSize : number
            CanTransformMultipleBlocks : boolean
            CanReuseTransform : boolean
            TransformBlock ($inputBuffer: System.Array$1<number>, $inputOffset: number, $inputCount: number, $outputBuffer: System.Array$1<number>, $outputOffset: number) : number
            TransformFinalBlock ($inputBuffer: System.Array$1<number>, $inputOffset: number, $inputCount: number) : System.Array$1<number>
        }
        class CspParameters extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public ProviderType : number
            public ProviderName : string
            public KeyContainerName : string
            public KeyNumber : number
            public get Flags(): System.Security.Cryptography.CspProviderFlags;
            public set Flags(value: System.Security.Cryptography.CspProviderFlags);
            public get CryptoKeySecurity(): System.Security.AccessControl.CryptoKeySecurity;
            public set CryptoKeySecurity(value: System.Security.AccessControl.CryptoKeySecurity);
            public get KeyPassword(): System.Security.SecureString;
            public set KeyPassword(value: System.Security.SecureString);
            public get ParentWindowHandle(): System.IntPtr;
            public set ParentWindowHandle(value: System.IntPtr);
            public constructor ()
            public constructor ($dwTypeIn: number)
            public constructor ($dwTypeIn: number, $strProviderNameIn: string)
            public constructor ($dwTypeIn: number, $strProviderNameIn: string, $strContainerNameIn: string)
            public constructor ($providerType: number, $providerName: string, $keyContainerName: string, $cryptoKeySecurity: System.Security.AccessControl.CryptoKeySecurity, $keyPassword: System.Security.SecureString)
            public constructor ($providerType: number, $providerName: string, $keyContainerName: string, $cryptoKeySecurity: System.Security.AccessControl.CryptoKeySecurity, $parentWindowHandle: System.IntPtr)
        }
        class DeriveBytes extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public GetBytes ($cb: number) : System.Array$1<number>
            public Reset () : void
            public Dispose () : void
        }
        class Rfc2898DeriveBytes extends System.Security.Cryptography.DeriveBytes implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get HashAlgorithm(): System.Security.Cryptography.HashAlgorithmName;
            public get IterationCount(): number;
            public set IterationCount(value: number);
            public get Salt(): System.Array$1<number>;
            public set Salt(value: System.Array$1<number>);
            public CryptDeriveKey ($algname: string, $alghashname: string, $keySize: number, $rgbIV: System.Array$1<number>) : System.Array$1<number>
            public constructor ($password: System.Array$1<number>, $salt: System.Array$1<number>, $iterations: number)
            public constructor ($password: System.Array$1<number>, $salt: System.Array$1<number>, $iterations: number, $hashAlgorithm: System.Security.Cryptography.HashAlgorithmName)
            public constructor ($password: string, $salt: System.Array$1<number>)
            public constructor ($password: string, $salt: System.Array$1<number>, $iterations: number)
            public constructor ($password: string, $salt: System.Array$1<number>, $iterations: number, $hashAlgorithm: System.Security.Cryptography.HashAlgorithmName)
            public constructor ($password: string, $saltSize: number)
            public constructor ($password: string, $saltSize: number, $iterations: number)
            public constructor ($password: string, $saltSize: number, $iterations: number, $hashAlgorithm: System.Security.Cryptography.HashAlgorithmName)
            public constructor ()
        }
        class HashAlgorithmName extends System.ValueType implements System.IEquatable$1<System.Security.Cryptography.HashAlgorithmName>
        {
            protected [__keep_incompatibility]: never;
            public static get MD5(): System.Security.Cryptography.HashAlgorithmName;
            public static get SHA1(): System.Security.Cryptography.HashAlgorithmName;
            public static get SHA256(): System.Security.Cryptography.HashAlgorithmName;
            public static get SHA384(): System.Security.Cryptography.HashAlgorithmName;
            public static get SHA512(): System.Security.Cryptography.HashAlgorithmName;
            public get Name(): string;
            public Equals ($obj: any) : boolean
            public Equals ($other: System.Security.Cryptography.HashAlgorithmName) : boolean
            public static op_Equality ($left: System.Security.Cryptography.HashAlgorithmName, $right: System.Security.Cryptography.HashAlgorithmName) : boolean
            public static op_Inequality ($left: System.Security.Cryptography.HashAlgorithmName, $right: System.Security.Cryptography.HashAlgorithmName) : boolean
            public constructor ($name: string)
            public static Equals ($objA: any, $objB: any) : boolean
            public constructor ()
        }
        interface ICspAsymmetricAlgorithm
        {
            CspKeyContainerInfo : System.Security.Cryptography.CspKeyContainerInfo
            ExportCspBlob ($includePrivateParameters: boolean) : System.Array$1<number>
            ImportCspBlob ($rawData: System.Array$1<number>) : void
        }
        class CspKeyContainerInfo extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get Accessible(): boolean;
            public get CryptoKeySecurity(): System.Security.AccessControl.CryptoKeySecurity;
            public get Exportable(): boolean;
            public get HardwareDevice(): boolean;
            public get KeyContainerName(): string;
            public get KeyNumber(): System.Security.Cryptography.KeyNumber;
            public get MachineKeyStore(): boolean;
            public get Protected(): boolean;
            public get ProviderName(): string;
            public get ProviderType(): number;
            public get RandomlyGenerated(): boolean;
            public get Removable(): boolean;
            public get UniqueKeyContainerName(): string;
            public constructor ($parameters: System.Security.Cryptography.CspParameters)
            public constructor ()
        }
        enum KeyNumber
        { Exchange = 1, Signature = 2 }
        class CryptoStream extends System.IO.Stream implements System.IAsyncDisposable, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get CanRead(): boolean;
            public get CanSeek(): boolean;
            public get CanWrite(): boolean;
            public get Length(): bigint;
            public get Position(): bigint;
            public set Position(value: bigint);
            public get HasFlushedFinalBlock(): boolean;
            public FlushFinalBlock () : void
            public Clear () : void
            public constructor ($stream: System.IO.Stream, $transform: System.Security.Cryptography.ICryptoTransform, $mode: System.Security.Cryptography.CryptoStreamMode)
            public constructor ($stream: System.IO.Stream, $transform: System.Security.Cryptography.ICryptoTransform, $mode: System.Security.Cryptography.CryptoStreamMode, $leaveOpen: boolean)
            public constructor ()
        }
        enum CryptoStreamMode
        { Read = 0, Write = 1 }
        class CryptographicOperations extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class RSAEncryptionPadding extends System.Object implements System.IEquatable$1<System.Security.Cryptography.RSAEncryptionPadding>
        {
            protected [__keep_incompatibility]: never;
            public static get Pkcs1(): System.Security.Cryptography.RSAEncryptionPadding;
            public static get OaepSHA1(): System.Security.Cryptography.RSAEncryptionPadding;
            public static get OaepSHA256(): System.Security.Cryptography.RSAEncryptionPadding;
            public static get OaepSHA384(): System.Security.Cryptography.RSAEncryptionPadding;
            public static get OaepSHA512(): System.Security.Cryptography.RSAEncryptionPadding;
            public get Mode(): System.Security.Cryptography.RSAEncryptionPaddingMode;
            public get OaepHashAlgorithm(): System.Security.Cryptography.HashAlgorithmName;
            public static CreateOaep ($hashAlgorithm: System.Security.Cryptography.HashAlgorithmName) : System.Security.Cryptography.RSAEncryptionPadding
            public Equals ($obj: any) : boolean
            public Equals ($other: System.Security.Cryptography.RSAEncryptionPadding) : boolean
            public static op_Equality ($left: System.Security.Cryptography.RSAEncryptionPadding, $right: System.Security.Cryptography.RSAEncryptionPadding) : boolean
            public static op_Inequality ($left: System.Security.Cryptography.RSAEncryptionPadding, $right: System.Security.Cryptography.RSAEncryptionPadding) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
        }
        enum RSAEncryptionPaddingMode
        { Pkcs1 = 0, Oaep = 1 }
        class RSASignaturePadding extends System.Object implements System.IEquatable$1<System.Security.Cryptography.RSASignaturePadding>
        {
            protected [__keep_incompatibility]: never;
            public static get Pkcs1(): System.Security.Cryptography.RSASignaturePadding;
            public static get Pss(): System.Security.Cryptography.RSASignaturePadding;
            public get Mode(): System.Security.Cryptography.RSASignaturePaddingMode;
            public Equals ($obj: any) : boolean
            public Equals ($other: System.Security.Cryptography.RSASignaturePadding) : boolean
            public static op_Equality ($left: System.Security.Cryptography.RSASignaturePadding, $right: System.Security.Cryptography.RSASignaturePadding) : boolean
            public static op_Inequality ($left: System.Security.Cryptography.RSASignaturePadding, $right: System.Security.Cryptography.RSASignaturePadding) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
        }
        enum RSASignaturePaddingMode
        { Pkcs1 = 0, Pss = 1 }
        class SymmetricAlgorithm extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get BlockSize(): number;
            public set BlockSize(value: number);
            public get FeedbackSize(): number;
            public set FeedbackSize(value: number);
            public get IV(): System.Array$1<number>;
            public set IV(value: System.Array$1<number>);
            public get Key(): System.Array$1<number>;
            public set Key(value: System.Array$1<number>);
            public get LegalBlockSizes(): System.Array$1<System.Security.Cryptography.KeySizes>;
            public get LegalKeySizes(): System.Array$1<System.Security.Cryptography.KeySizes>;
            public get KeySize(): number;
            public set KeySize(value: number);
            public get Mode(): System.Security.Cryptography.CipherMode;
            public set Mode(value: System.Security.Cryptography.CipherMode);
            public get Padding(): System.Security.Cryptography.PaddingMode;
            public set Padding(value: System.Security.Cryptography.PaddingMode);
            public Dispose () : void
            public Clear () : void
            public ValidKeySize ($bitLength: number) : boolean
            public static Create () : System.Security.Cryptography.SymmetricAlgorithm
            public static Create ($algName: string) : System.Security.Cryptography.SymmetricAlgorithm
            public CreateEncryptor () : System.Security.Cryptography.ICryptoTransform
            public CreateEncryptor ($rgbKey: System.Array$1<number>, $rgbIV: System.Array$1<number>) : System.Security.Cryptography.ICryptoTransform
            public CreateDecryptor () : System.Security.Cryptography.ICryptoTransform
            public CreateDecryptor ($rgbKey: System.Array$1<number>, $rgbIV: System.Array$1<number>) : System.Security.Cryptography.ICryptoTransform
            public GenerateKey () : void
            public GenerateIV () : void
        }
        class Aes extends System.Security.Cryptography.SymmetricAlgorithm implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public static Create () : System.Security.Cryptography.Aes
            public static Create ($algorithmName: string) : System.Security.Cryptography.Aes
            public static Create () : System.Security.Cryptography.SymmetricAlgorithm
            public static Create ($algName: string) : System.Security.Cryptography.SymmetricAlgorithm
        }
        class AsymmetricAlgorithm extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get KeySize(): number;
            public set KeySize(value: number);
            public get LegalKeySizes(): System.Array$1<System.Security.Cryptography.KeySizes>;
            public get SignatureAlgorithm(): string;
            public get KeyExchangeAlgorithm(): string;
            public Dispose () : void
            public Clear () : void
            public static Create () : System.Security.Cryptography.AsymmetricAlgorithm
            public static Create ($algName: string) : System.Security.Cryptography.AsymmetricAlgorithm
            public FromXmlString ($xmlString: string) : void
            public ToXmlString ($includePrivateParameters: boolean) : string
            public ExportPkcs8PrivateKey () : System.Array$1<number>
            public ExportSubjectPublicKeyInfo () : System.Array$1<number>
        }
        class KeySizes extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get MinSize(): number;
            public get MaxSize(): number;
            public get SkipSize(): number;
            public constructor ($minSize: number, $maxSize: number, $skipSize: number)
            public constructor ()
        }
        class PbeParameters extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get EncryptionAlgorithm(): System.Security.Cryptography.PbeEncryptionAlgorithm;
            public get HashAlgorithm(): System.Security.Cryptography.HashAlgorithmName;
            public get IterationCount(): number;
            public constructor ($encryptionAlgorithm: System.Security.Cryptography.PbeEncryptionAlgorithm, $hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, $iterationCount: number)
            public constructor ()
        }
        class AsymmetricKeyExchangeDeformatter extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get Parameters(): string;
            public set Parameters(value: string);
            public SetKey ($key: System.Security.Cryptography.AsymmetricAlgorithm) : void
            public DecryptKeyExchange ($rgb: System.Array$1<number>) : System.Array$1<number>
        }
        class AsymmetricKeyExchangeFormatter extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get Parameters(): string;
            public SetKey ($key: System.Security.Cryptography.AsymmetricAlgorithm) : void
            public CreateKeyExchange ($data: System.Array$1<number>) : System.Array$1<number>
            public CreateKeyExchange ($data: System.Array$1<number>, $symAlgType: System.Type) : System.Array$1<number>
        }
        class AsymmetricSignatureDeformatter extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public SetKey ($key: System.Security.Cryptography.AsymmetricAlgorithm) : void
            public SetHashAlgorithm ($strName: string) : void
            public VerifySignature ($hash: System.Security.Cryptography.HashAlgorithm, $rgbSignature: System.Array$1<number>) : boolean
            public VerifySignature ($rgbHash: System.Array$1<number>, $rgbSignature: System.Array$1<number>) : boolean
        }
        class AsymmetricSignatureFormatter extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public SetKey ($key: System.Security.Cryptography.AsymmetricAlgorithm) : void
            public SetHashAlgorithm ($strName: string) : void
            public CreateSignature ($hash: System.Security.Cryptography.HashAlgorithm) : System.Array$1<number>
            public CreateSignature ($rgbHash: System.Array$1<number>) : System.Array$1<number>
        }
        enum FromBase64TransformMode
        { IgnoreWhiteSpaces = 0, DoNotIgnoreWhiteSpaces = 1 }
        class ToBase64Transform extends System.Object implements System.IDisposable, System.Security.Cryptography.ICryptoTransform
        {
            protected [__keep_incompatibility]: never;
            public get InputBlockSize(): number;
            public get OutputBlockSize(): number;
            public get CanTransformMultipleBlocks(): boolean;
            public get CanReuseTransform(): boolean;
            public TransformBlock ($inputBuffer: System.Array$1<number>, $inputOffset: number, $inputCount: number, $outputBuffer: System.Array$1<number>, $outputOffset: number) : number
            public TransformFinalBlock ($inputBuffer: System.Array$1<number>, $inputOffset: number, $inputCount: number) : System.Array$1<number>
            public Dispose () : void
            public Clear () : void
            public constructor ()
        }
        class FromBase64Transform extends System.Object implements System.IDisposable, System.Security.Cryptography.ICryptoTransform
        {
            protected [__keep_incompatibility]: never;
            public get InputBlockSize(): number;
            public get OutputBlockSize(): number;
            public get CanTransformMultipleBlocks(): boolean;
            public get CanReuseTransform(): boolean;
            public TransformBlock ($inputBuffer: System.Array$1<number>, $inputOffset: number, $inputCount: number, $outputBuffer: System.Array$1<number>, $outputOffset: number) : number
            public TransformFinalBlock ($inputBuffer: System.Array$1<number>, $inputOffset: number, $inputCount: number) : System.Array$1<number>
            public Dispose () : void
            public Clear () : void
            public constructor ()
            public constructor ($whitespaces: System.Security.Cryptography.FromBase64TransformMode)
        }
        enum CipherMode
        { CBC = 1, ECB = 2, OFB = 3, CFB = 4, CTS = 5 }
        enum PaddingMode
        { None = 1, PKCS7 = 2, Zeros = 3, ANSIX923 = 4, ISO10126 = 5 }
        class CryptographicException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($format: string, $insert: string)
            public constructor ($message: string, $inner: System.Exception)
            public constructor ($hr: number)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class CryptographicUnexpectedOperationException extends System.Security.Cryptography.CryptographicException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($format: string, $insert: string)
            public constructor ($message: string, $inner: System.Exception)
        }
        enum CspProviderFlags
        { NoFlags = 0, UseMachineKeyStore = 1, UseDefaultKeyContainer = 2, UseNonExportableKey = 4, UseExistingKey = 8, UseArchivableKey = 16, UseUserProtectedKey = 32, NoPrompt = 64, CreateEphemeralKey = 128 }
        class DES extends System.Security.Cryptography.SymmetricAlgorithm implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get Key(): System.Array$1<number>;
            public set Key(value: System.Array$1<number>);
            public static Create () : System.Security.Cryptography.DES
            public static Create ($algName: string) : System.Security.Cryptography.DES
            public static IsWeakKey ($rgbKey: System.Array$1<number>) : boolean
            public static IsSemiWeakKey ($rgbKey: System.Array$1<number>) : boolean
            public static Create () : System.Security.Cryptography.SymmetricAlgorithm
            public static Create ($algName: string) : System.Security.Cryptography.SymmetricAlgorithm
        }
        class DESCryptoServiceProvider extends System.Security.Cryptography.DES implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class DSAParameters extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public P : System.Array$1<number>
            public Q : System.Array$1<number>
            public G : System.Array$1<number>
            public Y : System.Array$1<number>
            public J : System.Array$1<number>
            public X : System.Array$1<number>
            public Seed : System.Array$1<number>
            public Counter : number
        }
        class DSA extends System.Security.Cryptography.AsymmetricAlgorithm implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public static Create () : System.Security.Cryptography.DSA
            public static Create ($algName: string) : System.Security.Cryptography.DSA
            public CreateSignature ($rgbHash: System.Array$1<number>) : System.Array$1<number>
            public VerifySignature ($rgbHash: System.Array$1<number>, $rgbSignature: System.Array$1<number>) : boolean
            public SignData ($data: System.Array$1<number>, $hashAlgorithm: System.Security.Cryptography.HashAlgorithmName) : System.Array$1<number>
            public SignData ($data: System.Array$1<number>, $offset: number, $count: number, $hashAlgorithm: System.Security.Cryptography.HashAlgorithmName) : System.Array$1<number>
            public SignData ($data: System.IO.Stream, $hashAlgorithm: System.Security.Cryptography.HashAlgorithmName) : System.Array$1<number>
            public VerifyData ($data: System.Array$1<number>, $signature: System.Array$1<number>, $hashAlgorithm: System.Security.Cryptography.HashAlgorithmName) : boolean
            public VerifyData ($data: System.Array$1<number>, $offset: number, $count: number, $signature: System.Array$1<number>, $hashAlgorithm: System.Security.Cryptography.HashAlgorithmName) : boolean
            public VerifyData ($data: System.IO.Stream, $signature: System.Array$1<number>, $hashAlgorithm: System.Security.Cryptography.HashAlgorithmName) : boolean
            public ExportParameters ($includePrivateParameters: boolean) : System.Security.Cryptography.DSAParameters
            public ImportParameters ($parameters: System.Security.Cryptography.DSAParameters) : void
            public static Create ($keySizeInBits: number) : System.Security.Cryptography.DSA
            public static Create ($parameters: System.Security.Cryptography.DSAParameters) : System.Security.Cryptography.DSA
            public static Create () : System.Security.Cryptography.AsymmetricAlgorithm
            public static Create ($algName: string) : System.Security.Cryptography.AsymmetricAlgorithm
        }
        class DSASignatureDeformatter extends System.Security.Cryptography.AsymmetricSignatureDeformatter
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($key: System.Security.Cryptography.AsymmetricAlgorithm)
        }
        class DSASignatureFormatter extends System.Security.Cryptography.AsymmetricSignatureFormatter
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($key: System.Security.Cryptography.AsymmetricAlgorithm)
        }
        class KeyedHashAlgorithm extends System.Security.Cryptography.HashAlgorithm implements System.IDisposable, System.Security.Cryptography.ICryptoTransform
        {
            protected [__keep_incompatibility]: never;
            public get Key(): System.Array$1<number>;
            public set Key(value: System.Array$1<number>);
            public static Create () : System.Security.Cryptography.KeyedHashAlgorithm
            public static Create ($algName: string) : System.Security.Cryptography.KeyedHashAlgorithm
            public static Create () : System.Security.Cryptography.HashAlgorithm
            public static Create ($hashName: string) : System.Security.Cryptography.HashAlgorithm
        }
        class HMAC extends System.Security.Cryptography.KeyedHashAlgorithm implements System.IDisposable, System.Security.Cryptography.ICryptoTransform
        {
            protected [__keep_incompatibility]: never;
            public get Key(): System.Array$1<number>;
            public set Key(value: System.Array$1<number>);
            public get HashName(): string;
            public set HashName(value: string);
            public static Create () : System.Security.Cryptography.HMAC
            public static Create ($algorithmName: string) : System.Security.Cryptography.HMAC
            public static Create () : System.Security.Cryptography.KeyedHashAlgorithm
            public static Create ($algName: string) : System.Security.Cryptography.KeyedHashAlgorithm
            public static Create () : System.Security.Cryptography.HashAlgorithm
            public static Create ($hashName: string) : System.Security.Cryptography.HashAlgorithm
        }
        class HMACMD5 extends System.Security.Cryptography.HMAC implements System.IDisposable, System.Security.Cryptography.ICryptoTransform
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($key: System.Array$1<number>)
        }
        class HMACRIPEMD160 extends System.Security.Cryptography.HMAC implements System.IDisposable, System.Security.Cryptography.ICryptoTransform
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($key: System.Array$1<number>)
        }
        class HMACSHA1 extends System.Security.Cryptography.HMAC implements System.IDisposable, System.Security.Cryptography.ICryptoTransform
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($key: System.Array$1<number>)
            public constructor ($key: System.Array$1<number>, $useManagedSha1: boolean)
        }
        class HMACSHA256 extends System.Security.Cryptography.HMAC implements System.IDisposable, System.Security.Cryptography.ICryptoTransform
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($key: System.Array$1<number>)
        }
        class HMACSHA384 extends System.Security.Cryptography.HMAC implements System.IDisposable, System.Security.Cryptography.ICryptoTransform
        {
            protected [__keep_incompatibility]: never;
            public get ProduceLegacyHmacValues(): boolean;
            public set ProduceLegacyHmacValues(value: boolean);
            public constructor ()
            public constructor ($key: System.Array$1<number>)
        }
        class HMACSHA512 extends System.Security.Cryptography.HMAC implements System.IDisposable, System.Security.Cryptography.ICryptoTransform
        {
            protected [__keep_incompatibility]: never;
            public get ProduceLegacyHmacValues(): boolean;
            public set ProduceLegacyHmacValues(value: boolean);
            public constructor ()
            public constructor ($key: System.Array$1<number>)
        }
        class MACTripleDES extends System.Security.Cryptography.KeyedHashAlgorithm implements System.IDisposable, System.Security.Cryptography.ICryptoTransform
        {
            protected [__keep_incompatibility]: never;
            public get Padding(): System.Security.Cryptography.PaddingMode;
            public set Padding(value: System.Security.Cryptography.PaddingMode);
            public constructor ()
            public constructor ($rgbKey: System.Array$1<number>)
            public constructor ($strTripleDES: string, $rgbKey: System.Array$1<number>)
        }
        class MaskGenerationMethod extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public GenerateMask ($rgbSeed: System.Array$1<number>, $cbReturn: number) : System.Array$1<number>
        }
        class MD5 extends System.Security.Cryptography.HashAlgorithm implements System.IDisposable, System.Security.Cryptography.ICryptoTransform
        {
            protected [__keep_incompatibility]: never;
            public static Create () : System.Security.Cryptography.MD5
            public static Create ($algName: string) : System.Security.Cryptography.MD5
            public static Create () : System.Security.Cryptography.HashAlgorithm
            public static Create ($hashName: string) : System.Security.Cryptography.HashAlgorithm
        }
        class PasswordDeriveBytes extends System.Security.Cryptography.DeriveBytes implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get HashName(): string;
            public set HashName(value: string);
            public get IterationCount(): number;
            public set IterationCount(value: number);
            public get Salt(): System.Array$1<number>;
            public set Salt(value: System.Array$1<number>);
            public CryptDeriveKey ($algname: string, $alghashname: string, $keySize: number, $rgbIV: System.Array$1<number>) : System.Array$1<number>
            public constructor ($strPassword: string, $rgbSalt: System.Array$1<number>)
            public constructor ($password: System.Array$1<number>, $salt: System.Array$1<number>)
            public constructor ($strPassword: string, $rgbSalt: System.Array$1<number>, $strHashName: string, $iterations: number)
            public constructor ($password: System.Array$1<number>, $salt: System.Array$1<number>, $hashName: string, $iterations: number)
            public constructor ($strPassword: string, $rgbSalt: System.Array$1<number>, $cspParams: System.Security.Cryptography.CspParameters)
            public constructor ($password: System.Array$1<number>, $salt: System.Array$1<number>, $cspParams: System.Security.Cryptography.CspParameters)
            public constructor ($strPassword: string, $rgbSalt: System.Array$1<number>, $strHashName: string, $iterations: number, $cspParams: System.Security.Cryptography.CspParameters)
            public constructor ($password: System.Array$1<number>, $salt: System.Array$1<number>, $hashName: string, $iterations: number, $cspParams: System.Security.Cryptography.CspParameters)
            public constructor ()
        }
        class PKCS1MaskGenerationMethod extends System.Security.Cryptography.MaskGenerationMethod
        {
            protected [__keep_incompatibility]: never;
            public get HashName(): string;
            public set HashName(value: string);
            public constructor ()
        }
        class RandomNumberGenerator extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public static Create () : System.Security.Cryptography.RandomNumberGenerator
            public static Create ($rngName: string) : System.Security.Cryptography.RandomNumberGenerator
            public Dispose () : void
            public GetBytes ($data: System.Array$1<number>) : void
            public GetBytes ($data: System.Array$1<number>, $offset: number, $count: number) : void
            public GetNonZeroBytes ($data: System.Array$1<number>) : void
            public static GetInt32 ($fromInclusive: number, $toExclusive: number) : number
            public static GetInt32 ($toExclusive: number) : number
        }
        class RC2 extends System.Security.Cryptography.SymmetricAlgorithm implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get EffectiveKeySize(): number;
            public set EffectiveKeySize(value: number);
            public get KeySize(): number;
            public set KeySize(value: number);
            public static Create () : System.Security.Cryptography.RC2
            public static Create ($AlgName: string) : System.Security.Cryptography.RC2
            public static Create () : System.Security.Cryptography.SymmetricAlgorithm
            public static Create ($algName: string) : System.Security.Cryptography.SymmetricAlgorithm
        }
        class RC2CryptoServiceProvider extends System.Security.Cryptography.RC2 implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get EffectiveKeySize(): number;
            public set EffectiveKeySize(value: number);
            public get UseSalt(): boolean;
            public set UseSalt(value: boolean);
            public constructor ()
        }
        class Rijndael extends System.Security.Cryptography.SymmetricAlgorithm implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public static Create () : System.Security.Cryptography.Rijndael
            public static Create ($algName: string) : System.Security.Cryptography.Rijndael
            public static Create () : System.Security.Cryptography.SymmetricAlgorithm
            public static Create ($algName: string) : System.Security.Cryptography.SymmetricAlgorithm
        }
        class RijndaelManaged extends System.Security.Cryptography.Rijndael implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class RijndaelManagedTransform extends System.Object implements System.IDisposable, System.Security.Cryptography.ICryptoTransform
        {
            protected [__keep_incompatibility]: never;
            public get BlockSizeValue(): number;
            public get InputBlockSize(): number;
            public get OutputBlockSize(): number;
            public get CanTransformMultipleBlocks(): boolean;
            public get CanReuseTransform(): boolean;
            public Dispose () : void
            public Clear () : void
            public TransformBlock ($inputBuffer: System.Array$1<number>, $inputOffset: number, $inputCount: number, $outputBuffer: System.Array$1<number>, $outputOffset: number) : number
            public TransformFinalBlock ($inputBuffer: System.Array$1<number>, $inputOffset: number, $inputCount: number) : System.Array$1<number>
            public Reset () : void
        }
        class RIPEMD160 extends System.Security.Cryptography.HashAlgorithm implements System.IDisposable, System.Security.Cryptography.ICryptoTransform
        {
            protected [__keep_incompatibility]: never;
            public static Create () : System.Security.Cryptography.RIPEMD160
            public static Create ($hashName: string) : System.Security.Cryptography.RIPEMD160
            public static Create () : System.Security.Cryptography.HashAlgorithm
            public static Create ($hashName: string) : System.Security.Cryptography.HashAlgorithm
        }
        class RIPEMD160Managed extends System.Security.Cryptography.RIPEMD160 implements System.IDisposable, System.Security.Cryptography.ICryptoTransform
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class RSAParameters extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public Exponent : System.Array$1<number>
            public Modulus : System.Array$1<number>
            public P : System.Array$1<number>
            public Q : System.Array$1<number>
            public DP : System.Array$1<number>
            public DQ : System.Array$1<number>
            public InverseQ : System.Array$1<number>
            public D : System.Array$1<number>
        }
        class RSA extends System.Security.Cryptography.AsymmetricAlgorithm implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get KeyExchangeAlgorithm(): string;
            public get SignatureAlgorithm(): string;
            public static Create () : System.Security.Cryptography.RSA
            public static Create ($algName: string) : System.Security.Cryptography.RSA
            public Encrypt ($data: System.Array$1<number>, $padding: System.Security.Cryptography.RSAEncryptionPadding) : System.Array$1<number>
            public Decrypt ($data: System.Array$1<number>, $padding: System.Security.Cryptography.RSAEncryptionPadding) : System.Array$1<number>
            public SignHash ($hash: System.Array$1<number>, $hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, $padding: System.Security.Cryptography.RSASignaturePadding) : System.Array$1<number>
            public VerifyHash ($hash: System.Array$1<number>, $signature: System.Array$1<number>, $hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, $padding: System.Security.Cryptography.RSASignaturePadding) : boolean
            public SignData ($data: System.Array$1<number>, $hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, $padding: System.Security.Cryptography.RSASignaturePadding) : System.Array$1<number>
            public SignData ($data: System.Array$1<number>, $offset: number, $count: number, $hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, $padding: System.Security.Cryptography.RSASignaturePadding) : System.Array$1<number>
            public SignData ($data: System.IO.Stream, $hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, $padding: System.Security.Cryptography.RSASignaturePadding) : System.Array$1<number>
            public VerifyData ($data: System.Array$1<number>, $signature: System.Array$1<number>, $hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, $padding: System.Security.Cryptography.RSASignaturePadding) : boolean
            public VerifyData ($data: System.Array$1<number>, $offset: number, $count: number, $signature: System.Array$1<number>, $hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, $padding: System.Security.Cryptography.RSASignaturePadding) : boolean
            public VerifyData ($data: System.IO.Stream, $signature: System.Array$1<number>, $hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, $padding: System.Security.Cryptography.RSASignaturePadding) : boolean
            public DecryptValue ($rgb: System.Array$1<number>) : System.Array$1<number>
            public EncryptValue ($rgb: System.Array$1<number>) : System.Array$1<number>
            public ExportParameters ($includePrivateParameters: boolean) : System.Security.Cryptography.RSAParameters
            public ImportParameters ($parameters: System.Security.Cryptography.RSAParameters) : void
            public static Create ($keySizeInBits: number) : System.Security.Cryptography.RSA
            public static Create ($parameters: System.Security.Cryptography.RSAParameters) : System.Security.Cryptography.RSA
            public ExportRSAPrivateKey () : System.Array$1<number>
            public ExportRSAPublicKey () : System.Array$1<number>
            public static Create () : System.Security.Cryptography.AsymmetricAlgorithm
            public static Create ($algName: string) : System.Security.Cryptography.AsymmetricAlgorithm
        }
        class RSACryptoServiceProvider extends System.Security.Cryptography.RSA implements System.Security.Cryptography.ICspAsymmetricAlgorithm, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get SignatureAlgorithm(): string;
            public static get UseMachineKeyStore(): boolean;
            public static set UseMachineKeyStore(value: boolean);
            public get KeyExchangeAlgorithm(): string;
            public get KeySize(): number;
            public get PersistKeyInCsp(): boolean;
            public set PersistKeyInCsp(value: boolean);
            public get PublicOnly(): boolean;
            public get CspKeyContainerInfo(): System.Security.Cryptography.CspKeyContainerInfo;
            public Encrypt ($data: System.Array$1<number>, $padding: System.Security.Cryptography.RSAEncryptionPadding) : System.Array$1<number>
            public Decrypt ($data: System.Array$1<number>, $padding: System.Security.Cryptography.RSAEncryptionPadding) : System.Array$1<number>
            public SignHash ($hash: System.Array$1<number>, $hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, $padding: System.Security.Cryptography.RSASignaturePadding) : System.Array$1<number>
            public VerifyHash ($hash: System.Array$1<number>, $signature: System.Array$1<number>, $hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, $padding: System.Security.Cryptography.RSASignaturePadding) : boolean
            public Decrypt ($rgb: System.Array$1<number>, $fOAEP: boolean) : System.Array$1<number>
            public Encrypt ($rgb: System.Array$1<number>, $fOAEP: boolean) : System.Array$1<number>
            public SignData ($buffer: System.Array$1<number>, $halg: any) : System.Array$1<number>
            public SignData ($inputStream: System.IO.Stream, $halg: any) : System.Array$1<number>
            public SignData ($buffer: System.Array$1<number>, $offset: number, $count: number, $halg: any) : System.Array$1<number>
            public SignHash ($rgbHash: System.Array$1<number>, $str: string) : System.Array$1<number>
            public VerifyData ($buffer: System.Array$1<number>, $halg: any, $signature: System.Array$1<number>) : boolean
            public VerifyHash ($rgbHash: System.Array$1<number>, $str: string, $rgbSignature: System.Array$1<number>) : boolean
            public ExportCspBlob ($includePrivateParameters: boolean) : System.Array$1<number>
            public ImportCspBlob ($keyBlob: System.Array$1<number>) : void
            public constructor ()
            public constructor ($parameters: System.Security.Cryptography.CspParameters)
            public constructor ($dwKeySize: number)
            public constructor ($dwKeySize: number, $parameters: System.Security.Cryptography.CspParameters)
            public ImportCspBlob ($rawData: System.Array$1<number>) : void
            public SignData ($data: System.Array$1<number>, $hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, $padding: System.Security.Cryptography.RSASignaturePadding) : System.Array$1<number>
            public SignData ($data: System.Array$1<number>, $offset: number, $count: number, $hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, $padding: System.Security.Cryptography.RSASignaturePadding) : System.Array$1<number>
            public SignData ($data: System.IO.Stream, $hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, $padding: System.Security.Cryptography.RSASignaturePadding) : System.Array$1<number>
            public VerifyData ($data: System.Array$1<number>, $signature: System.Array$1<number>, $hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, $padding: System.Security.Cryptography.RSASignaturePadding) : boolean
            public VerifyData ($data: System.Array$1<number>, $offset: number, $count: number, $signature: System.Array$1<number>, $hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, $padding: System.Security.Cryptography.RSASignaturePadding) : boolean
            public VerifyData ($data: System.IO.Stream, $signature: System.Array$1<number>, $hashAlgorithm: System.Security.Cryptography.HashAlgorithmName, $padding: System.Security.Cryptography.RSASignaturePadding) : boolean
        }
        class RSAOAEPKeyExchangeDeformatter extends System.Security.Cryptography.AsymmetricKeyExchangeDeformatter
        {
            protected [__keep_incompatibility]: never;
            public get Parameters(): string;
            public set Parameters(value: string);
            public constructor ()
            public constructor ($key: System.Security.Cryptography.AsymmetricAlgorithm)
        }
        class RSAOAEPKeyExchangeFormatter extends System.Security.Cryptography.AsymmetricKeyExchangeFormatter
        {
            protected [__keep_incompatibility]: never;
            public get Parameter(): System.Array$1<number>;
            public set Parameter(value: System.Array$1<number>);
            public get Parameters(): string;
            public get Rng(): System.Security.Cryptography.RandomNumberGenerator;
            public set Rng(value: System.Security.Cryptography.RandomNumberGenerator);
            public constructor ()
            public constructor ($key: System.Security.Cryptography.AsymmetricAlgorithm)
        }
        class RSAPKCS1KeyExchangeDeformatter extends System.Security.Cryptography.AsymmetricKeyExchangeDeformatter
        {
            protected [__keep_incompatibility]: never;
            public get RNG(): System.Security.Cryptography.RandomNumberGenerator;
            public set RNG(value: System.Security.Cryptography.RandomNumberGenerator);
            public get Parameters(): string;
            public set Parameters(value: string);
            public constructor ()
            public constructor ($key: System.Security.Cryptography.AsymmetricAlgorithm)
        }
        class RSAPKCS1KeyExchangeFormatter extends System.Security.Cryptography.AsymmetricKeyExchangeFormatter
        {
            protected [__keep_incompatibility]: never;
            public get Parameters(): string;
            public get Rng(): System.Security.Cryptography.RandomNumberGenerator;
            public set Rng(value: System.Security.Cryptography.RandomNumberGenerator);
            public constructor ()
            public constructor ($key: System.Security.Cryptography.AsymmetricAlgorithm)
        }
        class SHA1 extends System.Security.Cryptography.HashAlgorithm implements System.IDisposable, System.Security.Cryptography.ICryptoTransform
        {
            protected [__keep_incompatibility]: never;
            public static Create () : System.Security.Cryptography.SHA1
            public static Create ($hashName: string) : System.Security.Cryptography.SHA1
            public static Create () : System.Security.Cryptography.HashAlgorithm
            public static Create ($hashName: string) : System.Security.Cryptography.HashAlgorithm
        }
        class SHA1Managed extends System.Security.Cryptography.SHA1 implements System.IDisposable, System.Security.Cryptography.ICryptoTransform
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class SHA256 extends System.Security.Cryptography.HashAlgorithm implements System.IDisposable, System.Security.Cryptography.ICryptoTransform
        {
            protected [__keep_incompatibility]: never;
            public static Create () : System.Security.Cryptography.SHA256
            public static Create ($hashName: string) : System.Security.Cryptography.SHA256
            public static Create () : System.Security.Cryptography.HashAlgorithm
            public static Create ($hashName: string) : System.Security.Cryptography.HashAlgorithm
        }
        class SHA256Managed extends System.Security.Cryptography.SHA256 implements System.IDisposable, System.Security.Cryptography.ICryptoTransform
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class SHA384 extends System.Security.Cryptography.HashAlgorithm implements System.IDisposable, System.Security.Cryptography.ICryptoTransform
        {
            protected [__keep_incompatibility]: never;
            public static Create () : System.Security.Cryptography.SHA384
            public static Create ($hashName: string) : System.Security.Cryptography.SHA384
            public static Create () : System.Security.Cryptography.HashAlgorithm
            public static Create ($hashName: string) : System.Security.Cryptography.HashAlgorithm
        }
        class SHA384Managed extends System.Security.Cryptography.SHA384 implements System.IDisposable, System.Security.Cryptography.ICryptoTransform
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class SHA512 extends System.Security.Cryptography.HashAlgorithm implements System.IDisposable, System.Security.Cryptography.ICryptoTransform
        {
            protected [__keep_incompatibility]: never;
            public static Create () : System.Security.Cryptography.SHA512
            public static Create ($hashName: string) : System.Security.Cryptography.SHA512
            public static Create () : System.Security.Cryptography.HashAlgorithm
            public static Create ($hashName: string) : System.Security.Cryptography.HashAlgorithm
        }
        class SHA512Managed extends System.Security.Cryptography.SHA512 implements System.IDisposable, System.Security.Cryptography.ICryptoTransform
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class SignatureDescription extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get KeyAlgorithm(): string;
            public set KeyAlgorithm(value: string);
            public get DigestAlgorithm(): string;
            public set DigestAlgorithm(value: string);
            public get FormatterAlgorithm(): string;
            public set FormatterAlgorithm(value: string);
            public get DeformatterAlgorithm(): string;
            public set DeformatterAlgorithm(value: string);
            public CreateDeformatter ($key: System.Security.Cryptography.AsymmetricAlgorithm) : System.Security.Cryptography.AsymmetricSignatureDeformatter
            public CreateFormatter ($key: System.Security.Cryptography.AsymmetricAlgorithm) : System.Security.Cryptography.AsymmetricSignatureFormatter
            public CreateDigest () : System.Security.Cryptography.HashAlgorithm
            public constructor ()
            public constructor ($el: System.Security.SecurityElement)
        }
        class TripleDES extends System.Security.Cryptography.SymmetricAlgorithm implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get Key(): System.Array$1<number>;
            public set Key(value: System.Array$1<number>);
            public static Create () : System.Security.Cryptography.TripleDES
            public static Create ($str: string) : System.Security.Cryptography.TripleDES
            public static IsWeakKey ($rgbKey: System.Array$1<number>) : boolean
            public static Create () : System.Security.Cryptography.SymmetricAlgorithm
            public static Create ($algName: string) : System.Security.Cryptography.SymmetricAlgorithm
        }
        class TripleDESCryptoServiceProvider extends System.Security.Cryptography.TripleDES implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class CryptoAPITransform extends System.Object implements System.IDisposable, System.Security.Cryptography.ICryptoTransform
        {
            protected [__keep_incompatibility]: never;
            public get CanReuseTransform(): boolean;
            public get CanTransformMultipleBlocks(): boolean;
            public get InputBlockSize(): number;
            public get KeyHandle(): System.IntPtr;
            public get OutputBlockSize(): number;
            public Dispose () : void
            public Clear () : void
            public TransformBlock ($inputBuffer: System.Array$1<number>, $inputOffset: number, $inputCount: number, $outputBuffer: System.Array$1<number>, $outputOffset: number) : number
            public TransformFinalBlock ($inputBuffer: System.Array$1<number>, $inputOffset: number, $inputCount: number) : System.Array$1<number>
            public Reset () : void
        }
        class CryptoConfig extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get AllowOnlyFipsAlgorithms(): boolean;
            public static AddOID ($oid: string, ...names: string[]) : void
            public static CreateFromName ($name: string) : any
            public static CreateFromName ($name: string, ...args: any[]) : any
            public static MapNameToOID ($name: string) : string
            public static AddAlgorithm ($algorithm: System.Type, ...names: string[]) : void
            public static EncodeOID ($str: string) : System.Array$1<number>
            public constructor ()
        }
        class DSACryptoServiceProvider extends System.Security.Cryptography.DSA implements System.Security.Cryptography.ICspAsymmetricAlgorithm, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get KeyExchangeAlgorithm(): string;
            public get KeySize(): number;
            public get PersistKeyInCsp(): boolean;
            public set PersistKeyInCsp(value: boolean);
            public get PublicOnly(): boolean;
            public get SignatureAlgorithm(): string;
            public static get UseMachineKeyStore(): boolean;
            public static set UseMachineKeyStore(value: boolean);
            public get CspKeyContainerInfo(): System.Security.Cryptography.CspKeyContainerInfo;
            public SignData ($buffer: System.Array$1<number>) : System.Array$1<number>
            public SignData ($buffer: System.Array$1<number>, $offset: number, $count: number) : System.Array$1<number>
            public SignData ($inputStream: System.IO.Stream) : System.Array$1<number>
            public SignHash ($rgbHash: System.Array$1<number>, $str: string) : System.Array$1<number>
            public VerifyData ($rgbData: System.Array$1<number>, $rgbSignature: System.Array$1<number>) : boolean
            public VerifyHash ($rgbHash: System.Array$1<number>, $str: string, $rgbSignature: System.Array$1<number>) : boolean
            public ExportCspBlob ($includePrivateParameters: boolean) : System.Array$1<number>
            public ImportCspBlob ($keyBlob: System.Array$1<number>) : void
            public constructor ()
            public constructor ($parameters: System.Security.Cryptography.CspParameters)
            public constructor ($dwKeySize: number)
            public constructor ($dwKeySize: number, $parameters: System.Security.Cryptography.CspParameters)
            public ImportCspBlob ($rawData: System.Array$1<number>) : void
            public SignData ($data: System.Array$1<number>, $hashAlgorithm: System.Security.Cryptography.HashAlgorithmName) : System.Array$1<number>
            public SignData ($data: System.Array$1<number>, $offset: number, $count: number, $hashAlgorithm: System.Security.Cryptography.HashAlgorithmName) : System.Array$1<number>
            public SignData ($data: System.IO.Stream, $hashAlgorithm: System.Security.Cryptography.HashAlgorithmName) : System.Array$1<number>
            public VerifyData ($data: System.Array$1<number>, $signature: System.Array$1<number>, $hashAlgorithm: System.Security.Cryptography.HashAlgorithmName) : boolean
            public VerifyData ($data: System.Array$1<number>, $offset: number, $count: number, $signature: System.Array$1<number>, $hashAlgorithm: System.Security.Cryptography.HashAlgorithmName) : boolean
            public VerifyData ($data: System.IO.Stream, $signature: System.Array$1<number>, $hashAlgorithm: System.Security.Cryptography.HashAlgorithmName) : boolean
        }
        class MD5CryptoServiceProvider extends System.Security.Cryptography.MD5 implements System.IDisposable, System.Security.Cryptography.ICryptoTransform
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class RNGCryptoServiceProvider extends System.Security.Cryptography.RandomNumberGenerator implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($rgb: System.Array$1<number>)
            public constructor ($cspParams: System.Security.Cryptography.CspParameters)
            public constructor ($str: string)
        }
        class RSAPKCS1SignatureDeformatter extends System.Security.Cryptography.AsymmetricSignatureDeformatter
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($key: System.Security.Cryptography.AsymmetricAlgorithm)
        }
        class RSAPKCS1SignatureFormatter extends System.Security.Cryptography.AsymmetricSignatureFormatter
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($key: System.Security.Cryptography.AsymmetricAlgorithm)
        }
        class SHA1CryptoServiceProvider extends System.Security.Cryptography.SHA1 implements System.IDisposable, System.Security.Cryptography.ICryptoTransform
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class AesCcm extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public static get NonceByteSizes(): System.Security.Cryptography.KeySizes;
            public static get TagByteSizes(): System.Security.Cryptography.KeySizes;
            public Decrypt ($nonce: System.Array$1<number>, $ciphertext: System.Array$1<number>, $tag: System.Array$1<number>, $plaintext: System.Array$1<number>, $associatedData?: System.Array$1<number>) : void
            public Dispose () : void
            public Encrypt ($nonce: System.Array$1<number>, $plaintext: System.Array$1<number>, $ciphertext: System.Array$1<number>, $tag: System.Array$1<number>, $associatedData?: System.Array$1<number>) : void
            public constructor ($key: System.Array$1<number>)
            public constructor ()
        }
        class AesGcm extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public static get NonceByteSizes(): System.Security.Cryptography.KeySizes;
            public static get TagByteSizes(): System.Security.Cryptography.KeySizes;
            public Decrypt ($nonce: System.Array$1<number>, $ciphertext: System.Array$1<number>, $tag: System.Array$1<number>, $plaintext: System.Array$1<number>, $associatedData?: System.Array$1<number>) : void
            public Dispose () : void
            public Encrypt ($nonce: System.Array$1<number>, $plaintext: System.Array$1<number>, $ciphertext: System.Array$1<number>, $tag: System.Array$1<number>, $associatedData?: System.Array$1<number>) : void
            public constructor ($key: System.Array$1<number>)
            public constructor ()
        }
        enum PbeEncryptionAlgorithm
        { Unknown = 0, Aes128Cbc = 1, Aes192Cbc = 2, Aes256Cbc = 3, TripleDes3KeyPkcs12 = 4 }
    }
    namespace System.Security.Claims {
        class ClaimsIdentity extends System.Object implements System.Security.Principal.IIdentity
        {
            protected [__keep_incompatibility]: never;
            public static DefaultIssuer : string
            public static DefaultNameClaimType : string
            public static DefaultRoleClaimType : string
            public get AuthenticationType(): string;
            public get IsAuthenticated(): boolean;
            public get Actor(): System.Security.Claims.ClaimsIdentity;
            public set Actor(value: System.Security.Claims.ClaimsIdentity);
            public get BootstrapContext(): any;
            public set BootstrapContext(value: any);
            public get Claims(): System.Collections.Generic.IEnumerable$1<System.Security.Claims.Claim>;
            public get Label(): string;
            public set Label(value: string);
            public get Name(): string;
            public get NameClaimType(): string;
            public get RoleClaimType(): string;
            public Clone () : System.Security.Claims.ClaimsIdentity
            public AddClaim ($claim: System.Security.Claims.Claim) : void
            public AddClaims ($claims: System.Collections.Generic.IEnumerable$1<System.Security.Claims.Claim>) : void
            public TryRemoveClaim ($claim: System.Security.Claims.Claim) : boolean
            public RemoveClaim ($claim: System.Security.Claims.Claim) : void
            public FindAll ($match: System.Predicate$1<System.Security.Claims.Claim>) : System.Collections.Generic.IEnumerable$1<System.Security.Claims.Claim>
            public FindAll ($type: string) : System.Collections.Generic.IEnumerable$1<System.Security.Claims.Claim>
            public HasClaim ($match: System.Predicate$1<System.Security.Claims.Claim>) : boolean
            public HasClaim ($type: string, $value: string) : boolean
            public FindFirst ($match: System.Predicate$1<System.Security.Claims.Claim>) : System.Security.Claims.Claim
            public FindFirst ($type: string) : System.Security.Claims.Claim
            public WriteTo ($writer: System.IO.BinaryWriter) : void
            public constructor ()
            public constructor ($identity: System.Security.Principal.IIdentity)
            public constructor ($claims: System.Collections.Generic.IEnumerable$1<System.Security.Claims.Claim>)
            public constructor ($authenticationType: string)
            public constructor ($claims: System.Collections.Generic.IEnumerable$1<System.Security.Claims.Claim>, $authenticationType: string)
            public constructor ($identity: System.Security.Principal.IIdentity, $claims: System.Collections.Generic.IEnumerable$1<System.Security.Claims.Claim>)
            public constructor ($authenticationType: string, $nameType: string, $roleType: string)
            public constructor ($claims: System.Collections.Generic.IEnumerable$1<System.Security.Claims.Claim>, $authenticationType: string, $nameType: string, $roleType: string)
            public constructor ($identity: System.Security.Principal.IIdentity, $claims: System.Collections.Generic.IEnumerable$1<System.Security.Claims.Claim>, $authenticationType: string, $nameType: string, $roleType: string)
            public constructor ($reader: System.IO.BinaryReader)
        }
        class Claim extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get Issuer(): string;
            public get OriginalIssuer(): string;
            public get Properties(): System.Collections.Generic.IDictionary$2<string, string>;
            public get Subject(): System.Security.Claims.ClaimsIdentity;
            public get Type(): string;
            public get Value(): string;
            public get ValueType(): string;
            public Clone () : System.Security.Claims.Claim
            public Clone ($identity: System.Security.Claims.ClaimsIdentity) : System.Security.Claims.Claim
            public WriteTo ($writer: System.IO.BinaryWriter) : void
            public constructor ($reader: System.IO.BinaryReader)
            public constructor ($reader: System.IO.BinaryReader, $subject: System.Security.Claims.ClaimsIdentity)
            public constructor ($type: string, $value: string)
            public constructor ($type: string, $value: string, $valueType: string)
            public constructor ($type: string, $value: string, $valueType: string, $issuer: string)
            public constructor ($type: string, $value: string, $valueType: string, $issuer: string, $originalIssuer: string)
            public constructor ($type: string, $value: string, $valueType: string, $issuer: string, $originalIssuer: string, $subject: System.Security.Claims.ClaimsIdentity)
            public constructor ()
        }
        class ClaimsPrincipal extends System.Object implements System.Security.Principal.IPrincipal
        {
            protected [__keep_incompatibility]: never;
            public static get PrimaryIdentitySelector(): System.Func$2<System.Collections.Generic.IEnumerable$1<System.Security.Claims.ClaimsIdentity>, System.Security.Claims.ClaimsIdentity>;
            public static set PrimaryIdentitySelector(value: System.Func$2<System.Collections.Generic.IEnumerable$1<System.Security.Claims.ClaimsIdentity>, System.Security.Claims.ClaimsIdentity>);
            public static get ClaimsPrincipalSelector(): System.Func$1<System.Security.Claims.ClaimsPrincipal>;
            public static set ClaimsPrincipalSelector(value: System.Func$1<System.Security.Claims.ClaimsPrincipal>);
            public get Claims(): System.Collections.Generic.IEnumerable$1<System.Security.Claims.Claim>;
            public static get Current(): System.Security.Claims.ClaimsPrincipal;
            public get Identities(): System.Collections.Generic.IEnumerable$1<System.Security.Claims.ClaimsIdentity>;
            public get Identity(): System.Security.Principal.IIdentity;
            public Clone () : System.Security.Claims.ClaimsPrincipal
            public AddIdentity ($identity: System.Security.Claims.ClaimsIdentity) : void
            public AddIdentities ($identities: System.Collections.Generic.IEnumerable$1<System.Security.Claims.ClaimsIdentity>) : void
            public FindAll ($match: System.Predicate$1<System.Security.Claims.Claim>) : System.Collections.Generic.IEnumerable$1<System.Security.Claims.Claim>
            public FindAll ($type: string) : System.Collections.Generic.IEnumerable$1<System.Security.Claims.Claim>
            public FindFirst ($match: System.Predicate$1<System.Security.Claims.Claim>) : System.Security.Claims.Claim
            public FindFirst ($type: string) : System.Security.Claims.Claim
            public HasClaim ($match: System.Predicate$1<System.Security.Claims.Claim>) : boolean
            public HasClaim ($type: string, $value: string) : boolean
            public IsInRole ($role: string) : boolean
            public WriteTo ($writer: System.IO.BinaryWriter) : void
            public constructor ()
            public constructor ($identities: System.Collections.Generic.IEnumerable$1<System.Security.Claims.ClaimsIdentity>)
            public constructor ($identity: System.Security.Principal.IIdentity)
            public constructor ($principal: System.Security.Principal.IPrincipal)
            public constructor ($reader: System.IO.BinaryReader)
        }
        class ClaimTypes extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static AuthenticationInstant : string
            public static AuthenticationMethod : string
            public static CookiePath : string
            public static DenyOnlyPrimarySid : string
            public static DenyOnlyPrimaryGroupSid : string
            public static DenyOnlyWindowsDeviceGroup : string
            public static Dsa : string
            public static Expiration : string
            public static Expired : string
            public static GroupSid : string
            public static IsPersistent : string
            public static PrimaryGroupSid : string
            public static PrimarySid : string
            public static Role : string
            public static SerialNumber : string
            public static UserData : string
            public static Version : string
            public static WindowsAccountName : string
            public static WindowsDeviceClaim : string
            public static WindowsDeviceGroup : string
            public static WindowsUserClaim : string
            public static WindowsFqbnVersion : string
            public static WindowsSubAuthority : string
            public static Anonymous : string
            public static Authentication : string
            public static AuthorizationDecision : string
            public static Country : string
            public static DateOfBirth : string
            public static Dns : string
            public static DenyOnlySid : string
            public static Email : string
            public static Gender : string
            public static GivenName : string
            public static Hash : string
            public static HomePhone : string
            public static Locality : string
            public static MobilePhone : string
            public static Name : string
            public static NameIdentifier : string
            public static OtherPhone : string
            public static PostalCode : string
            public static Rsa : string
            public static Sid : string
            public static Spn : string
            public static StateOrProvince : string
            public static StreetAddress : string
            public static Surname : string
            public static System : string
            public static Thumbprint : string
            public static Upn : string
            public static Uri : string
            public static Webpage : string
            public static X500DistinguishedName : string
            public static Actor : string
        }
        class ClaimValueTypes extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static Base64Binary : string
            public static Base64Octet : string
            public static Boolean : string
            public static Date : string
            public static DateTime : string
            public static Double : string
            public static Fqbn : string
            public static HexBinary : string
            public static Integer : string
            public static Integer32 : string
            public static Integer64 : string
            public static Sid : string
            public static String : string
            public static Time : string
            public static UInteger32 : string
            public static UInteger64 : string
            public static DnsName : string
            public static Email : string
            public static Rsa : string
            public static UpnName : string
            public static DsaKeyValue : string
            public static KeyInfo : string
            public static RsaKeyValue : string
            public static DaytimeDuration : string
            public static YearMonthDuration : string
            public static Rfc822Name : string
            public static X500Name : string
        }
    }
    namespace System.Runtime {
        class AssemblyTargetedPatchBandAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get TargetedPatchBand(): string;
            public constructor ($targetedPatchBand: string)
            public constructor ()
        }
        class TargetedPatchingOptOutAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Reason(): string;
            public constructor ($reason: string)
            public constructor ()
        }
        class AmbiguousImplementationException extends System.Exception implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class ProfileOptimization extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static SetProfileRoot ($directoryPath: string) : void
            public static StartProfile ($profile: string) : void
        }
        enum GCLargeObjectHeapCompactionMode
        { Default = 1, CompactOnce = 2 }
        enum GCLatencyMode
        { Batch = 0, Interactive = 1, LowLatency = 2, SustainedLowLatency = 3, NoGCRegion = 4 }
        class GCSettings extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get IsServerGC(): boolean;
            public static get LatencyMode(): System.Runtime.GCLatencyMode;
            public static set LatencyMode(value: System.Runtime.GCLatencyMode);
            public static get LargeObjectHeapCompactionMode(): System.Runtime.GCLargeObjectHeapCompactionMode;
            public static set LargeObjectHeapCompactionMode(value: System.Runtime.GCLargeObjectHeapCompactionMode);
        }
        class MemoryFailPoint extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public Dispose () : void
            public constructor ($sizeInMegabytes: number)
            public constructor ()
        }
        class RuntimeImports extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace System.Runtime.Remoting.Messaging {
        interface IMessageSink
        {
            NextSink : System.Runtime.Remoting.Messaging.IMessageSink
            SyncProcessMessage ($msg: System.Runtime.Remoting.Messaging.IMessage) : System.Runtime.Remoting.Messaging.IMessage
            AsyncProcessMessage ($msg: System.Runtime.Remoting.Messaging.IMessage, $replySink: System.Runtime.Remoting.Messaging.IMessageSink) : System.Runtime.Remoting.Messaging.IMessageCtrl
        }
        class MethodCall extends System.Object implements System.Runtime.Remoting.Messaging.IMessage, System.Runtime.Serialization.ISerializable, System.Runtime.Remoting.Messaging.IMethodCallMessage, System.Runtime.Remoting.Messaging.IMethodMessage, System.Runtime.Remoting.Messaging.ISerializationRootObject, System.Runtime.Remoting.Messaging.IInternalMessage
        {
            protected [__keep_incompatibility]: never;
            public get ArgCount(): number;
            public get Args(): System.Array$1<any>;
            public get HasVarArgs(): boolean;
            public get InArgCount(): number;
            public get InArgs(): System.Array$1<any>;
            public get LogicalCallContext(): System.Runtime.Remoting.Messaging.LogicalCallContext;
            public get MethodBase(): System.Reflection.MethodBase;
            public get MethodName(): string;
            public get MethodSignature(): any;
            public get Properties(): System.Collections.IDictionary;
            public get TypeName(): string;
            public get Uri(): string;
            public set Uri(value: string);
            public GetObjectData ($info: System.Runtime.Serialization.SerializationInfo, $context: System.Runtime.Serialization.StreamingContext) : void
            public GetArg ($argNum: number) : any
            public GetArgName ($index: number) : string
            public GetInArg ($argNum: number) : any
            public GetInArgName ($index: number) : string
            public HeaderHandler ($h: System.Array$1<System.Runtime.Remoting.Messaging.Header>) : any
            public Init () : void
            public ResolveMethod () : void
            public RootSetObjectData ($info: System.Runtime.Serialization.SerializationInfo, $ctx: System.Runtime.Serialization.StreamingContext) : void
            public constructor ($h1: System.Array$1<System.Runtime.Remoting.Messaging.Header>)
            public constructor ($msg: System.Runtime.Remoting.Messaging.IMessage)
            public constructor ()
        }
        interface IMessage
        {
            Properties : System.Collections.IDictionary
        }
        interface IMethodCallMessage extends System.Runtime.Remoting.Messaging.IMessage, System.Runtime.Remoting.Messaging.IMethodMessage
        {
            InArgCount : number
            InArgs : System.Array$1<any>
            Properties : System.Collections.IDictionary
            ArgCount : number
            Args : System.Array$1<any>
            HasVarArgs : boolean
            LogicalCallContext : System.Runtime.Remoting.Messaging.LogicalCallContext
            MethodBase : System.Reflection.MethodBase
            MethodName : string
            MethodSignature : any
            TypeName : string
            Uri : string
            GetInArg ($argNum: number) : any
            GetInArgName ($index: number) : string
            GetArg ($argNum: number) : any
            GetArgName ($index: number) : string
        }
        interface IMethodMessage extends System.Runtime.Remoting.Messaging.IMessage
        {
            ArgCount : number
            Args : System.Array$1<any>
            HasVarArgs : boolean
            LogicalCallContext : System.Runtime.Remoting.Messaging.LogicalCallContext
            MethodBase : System.Reflection.MethodBase
            MethodName : string
            MethodSignature : any
            TypeName : string
            Uri : string
            Properties : System.Collections.IDictionary
            GetArg ($argNum: number) : any
            GetArgName ($index: number) : string
        }
        interface ISerializationRootObject
        {
        }
        interface IInternalMessage
        {
        }
        interface IMethodReturnMessage extends System.Runtime.Remoting.Messaging.IMessage, System.Runtime.Remoting.Messaging.IMethodMessage
        {
            Exception : System.Exception
            OutArgCount : number
            OutArgs : System.Array$1<any>
            ReturnValue : any
            Properties : System.Collections.IDictionary
            ArgCount : number
            Args : System.Array$1<any>
            HasVarArgs : boolean
            LogicalCallContext : System.Runtime.Remoting.Messaging.LogicalCallContext
            MethodBase : System.Reflection.MethodBase
            MethodName : string
            MethodSignature : any
            TypeName : string
            Uri : string
            GetOutArg ($argNum: number) : any
            GetOutArgName ($index: number) : string
            GetArg ($argNum: number) : any
            GetArgName ($index: number) : string
        }
        interface IMessageCtrl
        {
            Cancel ($msToCancel: number) : void
        }
        class CallContext extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get HostContext(): any;
            public static set HostContext(value: any);
            public static FreeNamedDataSlot ($name: string) : void
            public static LogicalGetData ($name: string) : any
            public static GetData ($name: string) : any
            public static SetData ($name: string, $data: any) : void
            public static LogicalSetData ($name: string, $data: any) : void
            public static GetHeaders () : System.Array$1<System.Runtime.Remoting.Messaging.Header>
            public static SetHeaders ($headers: System.Array$1<System.Runtime.Remoting.Messaging.Header>) : void
        }
        class Header extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public HeaderNamespace : string
            public MustUnderstand : boolean
            public Name : string
            public Value : any
            public constructor ($_Name: string, $_Value: any)
            public constructor ($_Name: string, $_Value: any, $_MustUnderstand: boolean)
            public constructor ($_Name: string, $_Value: any, $_MustUnderstand: boolean, $_HeaderNamespace: string)
            public constructor ()
        }
        interface ILogicalThreadAffinative
        {
        }
        class LogicalCallContext extends System.Object implements System.ICloneable, System.Runtime.Serialization.ISerializable
        {
            protected [__keep_incompatibility]: never;
            public get HasInfo(): boolean;
            public GetObjectData ($info: System.Runtime.Serialization.SerializationInfo, $context: System.Runtime.Serialization.StreamingContext) : void
            public Clone () : any
            public FreeNamedDataSlot ($name: string) : void
            public GetData ($name: string) : any
            public SetData ($name: string, $data: any) : void
        }
        class AsyncResult extends System.Object implements System.Threading.IThreadPoolWorkItem, System.Runtime.Remoting.Messaging.IMessageSink, System.IAsyncResult
        {
            protected [__keep_incompatibility]: never;
            public get AsyncState(): any;
            public get AsyncWaitHandle(): System.Threading.WaitHandle;
            public get CompletedSynchronously(): boolean;
            public get IsCompleted(): boolean;
            public get EndInvokeCalled(): boolean;
            public set EndInvokeCalled(value: boolean);
            public get AsyncDelegate(): any;
            public get NextSink(): System.Runtime.Remoting.Messaging.IMessageSink;
            public AsyncProcessMessage ($msg: System.Runtime.Remoting.Messaging.IMessage, $replySink: System.Runtime.Remoting.Messaging.IMessageSink) : System.Runtime.Remoting.Messaging.IMessageCtrl
            public GetReplyMessage () : System.Runtime.Remoting.Messaging.IMessage
            public SetMessageCtrl ($mc: System.Runtime.Remoting.Messaging.IMessageCtrl) : void
            public SyncProcessMessage ($msg: System.Runtime.Remoting.Messaging.IMessage) : System.Runtime.Remoting.Messaging.IMessage
        }
        class ConstructionCall extends System.Runtime.Remoting.Messaging.MethodCall implements System.Runtime.Remoting.Messaging.IMessage, System.Runtime.Serialization.ISerializable, System.Runtime.Remoting.Messaging.IMethodCallMessage, System.Runtime.Remoting.Activation.IConstructionCallMessage, System.Runtime.Remoting.Messaging.IMethodMessage, System.Runtime.Remoting.Messaging.ISerializationRootObject, System.Runtime.Remoting.Messaging.IInternalMessage
        {
            protected [__keep_incompatibility]: never;
            public get ActivationType(): System.Type;
            public get ActivationTypeName(): string;
            public get Activator(): System.Runtime.Remoting.Activation.IActivator;
            public set Activator(value: System.Runtime.Remoting.Activation.IActivator);
            public get CallSiteActivationAttributes(): System.Array$1<any>;
            public get ContextProperties(): System.Collections.IList;
            public get Properties(): System.Collections.IDictionary;
            public constructor ($m: System.Runtime.Remoting.Messaging.IMessage)
            public constructor ($headers: System.Array$1<System.Runtime.Remoting.Messaging.Header>)
            public constructor ($h1: System.Array$1<System.Runtime.Remoting.Messaging.Header>)
            public constructor ($msg: System.Runtime.Remoting.Messaging.IMessage)
            public constructor ()
        }
        class MethodResponse extends System.Object implements System.Runtime.Remoting.Messaging.IMessage, System.Runtime.Serialization.ISerializable, System.Runtime.Remoting.Messaging.IMethodMessage, System.Runtime.Remoting.Messaging.IMethodReturnMessage, System.Runtime.Remoting.Messaging.ISerializationRootObject, System.Runtime.Remoting.Messaging.IInternalMessage
        {
            protected [__keep_incompatibility]: never;
            public get ArgCount(): number;
            public get Args(): System.Array$1<any>;
            public get Exception(): System.Exception;
            public get HasVarArgs(): boolean;
            public get LogicalCallContext(): System.Runtime.Remoting.Messaging.LogicalCallContext;
            public get MethodBase(): System.Reflection.MethodBase;
            public get MethodName(): string;
            public get MethodSignature(): any;
            public get OutArgCount(): number;
            public get OutArgs(): System.Array$1<any>;
            public get Properties(): System.Collections.IDictionary;
            public get ReturnValue(): any;
            public get TypeName(): string;
            public get Uri(): string;
            public set Uri(value: string);
            public GetArg ($argNum: number) : any
            public GetArgName ($index: number) : string
            public GetObjectData ($info: System.Runtime.Serialization.SerializationInfo, $context: System.Runtime.Serialization.StreamingContext) : void
            public GetOutArg ($argNum: number) : any
            public GetOutArgName ($index: number) : string
            public HeaderHandler ($h: System.Array$1<System.Runtime.Remoting.Messaging.Header>) : any
            public RootSetObjectData ($info: System.Runtime.Serialization.SerializationInfo, $ctx: System.Runtime.Serialization.StreamingContext) : void
            public constructor ($h1: System.Array$1<System.Runtime.Remoting.Messaging.Header>, $mcm: System.Runtime.Remoting.Messaging.IMethodCallMessage)
            public constructor ()
        }
        class ConstructionResponse extends System.Runtime.Remoting.Messaging.MethodResponse implements System.Runtime.Remoting.Messaging.IMessage, System.Runtime.Serialization.ISerializable, System.Runtime.Remoting.Messaging.IMethodMessage, System.Runtime.Remoting.Activation.IConstructionReturnMessage, System.Runtime.Remoting.Messaging.IMethodReturnMessage, System.Runtime.Remoting.Messaging.ISerializationRootObject, System.Runtime.Remoting.Messaging.IInternalMessage
        {
            protected [__keep_incompatibility]: never;
            public get Properties(): System.Collections.IDictionary;
            public constructor ($h: System.Array$1<System.Runtime.Remoting.Messaging.Header>, $mcm: System.Runtime.Remoting.Messaging.IMethodCallMessage)
            public constructor ($h1: System.Array$1<System.Runtime.Remoting.Messaging.Header>, $mcm: System.Runtime.Remoting.Messaging.IMethodCallMessage)
            public constructor ()
        }
        interface HeaderHandler
        { 
        (headers: System.Array$1<System.Runtime.Remoting.Messaging.Header>) : any; 
        Invoke?: (headers: System.Array$1<System.Runtime.Remoting.Messaging.Header>) => any;
        }
        var HeaderHandler: { new (func: (headers: System.Array$1<System.Runtime.Remoting.Messaging.Header>) => any): HeaderHandler; }
        interface IRemotingFormatter extends System.Runtime.Serialization.IFormatter
        {
            SurrogateSelector : System.Runtime.Serialization.ISurrogateSelector
            Binder : System.Runtime.Serialization.SerializationBinder
            Context : System.Runtime.Serialization.StreamingContext
            Deserialize ($serializationStream: System.IO.Stream, $handler: System.Runtime.Remoting.Messaging.HeaderHandler) : any
            Serialize ($serializationStream: System.IO.Stream, $graph: any, $headers: System.Array$1<System.Runtime.Remoting.Messaging.Header>) : void
            Deserialize ($serializationStream: System.IO.Stream) : any
            Serialize ($serializationStream: System.IO.Stream, $graph: any) : void
        }
        class InternalMessageWrapper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public constructor ($msg: System.Runtime.Remoting.Messaging.IMessage)
            public constructor ()
        }
        interface MessageSurrogateFilter
        { 
        (key: string, value: any) : boolean; 
        Invoke?: (key: string, value: any) => boolean;
        }
        var MessageSurrogateFilter: { new (func: (key: string, value: any) => boolean): MessageSurrogateFilter; }
        class MethodCallMessageWrapper extends System.Runtime.Remoting.Messaging.InternalMessageWrapper implements System.Runtime.Remoting.Messaging.IMessage, System.Runtime.Remoting.Messaging.IMethodCallMessage, System.Runtime.Remoting.Messaging.IMethodMessage
        {
            protected [__keep_incompatibility]: never;
            public get ArgCount(): number;
            public get Args(): System.Array$1<any>;
            public set Args(value: System.Array$1<any>);
            public get HasVarArgs(): boolean;
            public get InArgCount(): number;
            public get InArgs(): System.Array$1<any>;
            public get LogicalCallContext(): System.Runtime.Remoting.Messaging.LogicalCallContext;
            public get MethodBase(): System.Reflection.MethodBase;
            public get MethodName(): string;
            public get MethodSignature(): any;
            public get Properties(): System.Collections.IDictionary;
            public get TypeName(): string;
            public get Uri(): string;
            public set Uri(value: string);
            public GetArg ($argNum: number) : any
            public GetArgName ($index: number) : string
            public GetInArg ($argNum: number) : any
            public GetInArgName ($index: number) : string
            public constructor ($msg: System.Runtime.Remoting.Messaging.IMethodCallMessage)
            public constructor ($msg: System.Runtime.Remoting.Messaging.IMessage)
            public constructor ()
        }
        class MethodReturnMessageWrapper extends System.Runtime.Remoting.Messaging.InternalMessageWrapper implements System.Runtime.Remoting.Messaging.IMessage, System.Runtime.Remoting.Messaging.IMethodMessage, System.Runtime.Remoting.Messaging.IMethodReturnMessage
        {
            protected [__keep_incompatibility]: never;
            public get ArgCount(): number;
            public get Args(): System.Array$1<any>;
            public set Args(value: System.Array$1<any>);
            public get Exception(): System.Exception;
            public set Exception(value: System.Exception);
            public get HasVarArgs(): boolean;
            public get LogicalCallContext(): System.Runtime.Remoting.Messaging.LogicalCallContext;
            public get MethodBase(): System.Reflection.MethodBase;
            public get MethodName(): string;
            public get MethodSignature(): any;
            public get OutArgCount(): number;
            public get OutArgs(): System.Array$1<any>;
            public get Properties(): System.Collections.IDictionary;
            public get ReturnValue(): any;
            public set ReturnValue(value: any);
            public get TypeName(): string;
            public get Uri(): string;
            public set Uri(value: string);
            public GetArg ($argNum: number) : any
            public GetArgName ($index: number) : string
            public GetOutArg ($argNum: number) : any
            public GetOutArgName ($index: number) : string
            public constructor ($msg: System.Runtime.Remoting.Messaging.IMethodReturnMessage)
            public constructor ($msg: System.Runtime.Remoting.Messaging.IMessage)
            public constructor ()
        }
        class OneWayAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class RemotingSurrogateSelector extends System.Object implements System.Runtime.Serialization.ISurrogateSelector
        {
            protected [__keep_incompatibility]: never;
            public get Filter(): System.Runtime.Remoting.Messaging.MessageSurrogateFilter;
            public set Filter(value: System.Runtime.Remoting.Messaging.MessageSurrogateFilter);
            public ChainSelector ($selector: System.Runtime.Serialization.ISurrogateSelector) : void
            public GetNextSelector () : System.Runtime.Serialization.ISurrogateSelector
            public GetRootObject () : any
            public GetSurrogate ($type: System.Type, $context: System.Runtime.Serialization.StreamingContext, $ssout: $Ref<System.Runtime.Serialization.ISurrogateSelector>) : System.Runtime.Serialization.ISerializationSurrogate
            public SetRootObject ($obj: any) : void
            public UseSoapFormat () : void
            public constructor ()
            public GetSurrogate ($type: System.Type, $context: System.Runtime.Serialization.StreamingContext, $selector: $Ref<System.Runtime.Serialization.ISurrogateSelector>) : System.Runtime.Serialization.ISerializationSurrogate
        }
        class ReturnMessage extends System.Object implements System.Runtime.Remoting.Messaging.IMessage, System.Runtime.Remoting.Messaging.IMethodMessage, System.Runtime.Remoting.Messaging.IMethodReturnMessage, System.Runtime.Remoting.Messaging.IInternalMessage
        {
            protected [__keep_incompatibility]: never;
            public get ArgCount(): number;
            public get Args(): System.Array$1<any>;
            public get HasVarArgs(): boolean;
            public get LogicalCallContext(): System.Runtime.Remoting.Messaging.LogicalCallContext;
            public get MethodBase(): System.Reflection.MethodBase;
            public get MethodName(): string;
            public get MethodSignature(): any;
            public get Properties(): System.Collections.IDictionary;
            public get TypeName(): string;
            public get Uri(): string;
            public set Uri(value: string);
            public get Exception(): System.Exception;
            public get OutArgCount(): number;
            public get OutArgs(): System.Array$1<any>;
            public get ReturnValue(): any;
            public GetArg ($argNum: number) : any
            public GetArgName ($index: number) : string
            public GetOutArg ($argNum: number) : any
            public GetOutArgName ($index: number) : string
            public constructor ($ret: any, $outArgs: System.Array$1<any>, $outArgsCount: number, $callCtx: System.Runtime.Remoting.Messaging.LogicalCallContext, $mcm: System.Runtime.Remoting.Messaging.IMethodCallMessage)
            public constructor ($e: System.Exception, $mcm: System.Runtime.Remoting.Messaging.IMethodCallMessage)
            public constructor ()
        }
    }
    namespace System.Runtime.Remoting.Metadata {
        class SoapAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Embedded(): boolean;
            public set Embedded(value: boolean);
            public get UseAttribute(): boolean;
            public set UseAttribute(value: boolean);
            public get XmlNamespace(): string;
            public set XmlNamespace(value: string);
            public constructor ()
        }
        class SoapFieldAttribute extends System.Runtime.Remoting.Metadata.SoapAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Order(): number;
            public set Order(value: number);
            public get XmlElementName(): string;
            public set XmlElementName(value: string);
            public IsInteropXmlElement () : boolean
            public constructor ()
        }
        class SoapMethodAttribute extends System.Runtime.Remoting.Metadata.SoapAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get ResponseXmlElementName(): string;
            public set ResponseXmlElementName(value: string);
            public get ResponseXmlNamespace(): string;
            public set ResponseXmlNamespace(value: string);
            public get ReturnXmlElementName(): string;
            public set ReturnXmlElementName(value: string);
            public get SoapAction(): string;
            public set SoapAction(value: string);
            public get UseAttribute(): boolean;
            public set UseAttribute(value: boolean);
            public get XmlNamespace(): string;
            public set XmlNamespace(value: string);
            public constructor ()
        }
        enum SoapOption
        { None = 0, AlwaysIncludeTypes = 1, XsdString = 2, EmbedAll = 4, Option1 = 8, Option2 = 16 }
        class SoapParameterAttribute extends System.Runtime.Remoting.Metadata.SoapAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class SoapTypeAttribute extends System.Runtime.Remoting.Metadata.SoapAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get SoapOptions(): System.Runtime.Remoting.Metadata.SoapOption;
            public set SoapOptions(value: System.Runtime.Remoting.Metadata.SoapOption);
            public get UseAttribute(): boolean;
            public set UseAttribute(value: boolean);
            public get XmlElementName(): string;
            public set XmlElementName(value: string);
            public get XmlFieldOrder(): System.Runtime.Remoting.Metadata.XmlFieldOrderOption;
            public set XmlFieldOrder(value: System.Runtime.Remoting.Metadata.XmlFieldOrderOption);
            public get XmlNamespace(): string;
            public set XmlNamespace(value: string);
            public get XmlTypeName(): string;
            public set XmlTypeName(value: string);
            public get XmlTypeNamespace(): string;
            public set XmlTypeNamespace(value: string);
            public constructor ()
        }
        enum XmlFieldOrderOption
        { All = 0, Sequence = 1, Choice = 2 }
    }
    namespace System.Runtime.Remoting.Proxies {
        class RealProxy extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public GetProxiedType () : System.Type
            public CreateObjRef ($requestedType: System.Type) : System.Runtime.Remoting.ObjRef
            public GetObjectData ($info: System.Runtime.Serialization.SerializationInfo, $context: System.Runtime.Serialization.StreamingContext) : void
            public GetCOMIUnknown ($fIsMarshalled: boolean) : System.IntPtr
            public SetCOMIUnknown ($i: System.IntPtr) : void
            public SupportsInterface ($iid: $Ref<System.Guid>) : System.IntPtr
            public static GetStubData ($rp: System.Runtime.Remoting.Proxies.RealProxy) : any
            public static SetStubData ($rp: System.Runtime.Remoting.Proxies.RealProxy, $stubData: any) : void
            public Invoke ($msg: System.Runtime.Remoting.Messaging.IMessage) : System.Runtime.Remoting.Messaging.IMessage
            public GetTransparentProxy () : any
            public InitializeServerObject ($ctorMsg: System.Runtime.Remoting.Activation.IConstructionCallMessage) : System.Runtime.Remoting.Activation.IConstructionReturnMessage
        }
        class ProxyAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute, System.Runtime.Remoting.Contexts.IContextAttribute
        {
            protected [__keep_incompatibility]: never;
            public CreateInstance ($serverType: System.Type) : System.MarshalByRefObject
            public CreateProxy ($objRef: System.Runtime.Remoting.ObjRef, $serverType: System.Type, $serverObject: any, $serverContext: System.Runtime.Remoting.Contexts.Context) : System.Runtime.Remoting.Proxies.RealProxy
            public GetPropertiesForNewContext ($msg: System.Runtime.Remoting.Activation.IConstructionCallMessage) : void
            public IsContextOK ($ctx: System.Runtime.Remoting.Contexts.Context, $msg: System.Runtime.Remoting.Activation.IConstructionCallMessage) : boolean
            public constructor ()
        }
    }
    namespace System.Runtime.Remoting.Services {
        class EnterpriseServicesHelper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static CreateConstructionReturnMessage ($ctorMsg: System.Runtime.Remoting.Activation.IConstructionCallMessage, $retObj: System.MarshalByRefObject) : System.Runtime.Remoting.Activation.IConstructionReturnMessage
            public static SwitchWrappers ($oldcp: System.Runtime.Remoting.Proxies.RealProxy, $newcp: System.Runtime.Remoting.Proxies.RealProxy) : void
            public static WrapIUnknownWithComObject ($punk: System.IntPtr) : any
            public constructor ()
        }
        interface ITrackingHandler
        {
            DisconnectedObject ($obj: any) : void
            MarshaledObject ($obj: any, $or: System.Runtime.Remoting.ObjRef) : void
            UnmarshaledObject ($obj: any, $or: System.Runtime.Remoting.ObjRef) : void
        }
        class TrackingServices extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get RegisteredHandlers(): System.Array$1<System.Runtime.Remoting.Services.ITrackingHandler>;
            public static RegisterTrackingHandler ($handler: System.Runtime.Remoting.Services.ITrackingHandler) : void
            public static UnregisterTrackingHandler ($handler: System.Runtime.Remoting.Services.ITrackingHandler) : void
            public constructor ()
        }
    }
    namespace System.Runtime.Remoting.Activation {
        interface IConstructionReturnMessage extends System.Runtime.Remoting.Messaging.IMessage, System.Runtime.Remoting.Messaging.IMethodMessage, System.Runtime.Remoting.Messaging.IMethodReturnMessage
        {
            Properties : System.Collections.IDictionary
            ArgCount : number
            Args : System.Array$1<any>
            HasVarArgs : boolean
            LogicalCallContext : System.Runtime.Remoting.Messaging.LogicalCallContext
            MethodBase : System.Reflection.MethodBase
            MethodName : string
            MethodSignature : any
            TypeName : string
            Uri : string
            Exception : System.Exception
            OutArgCount : number
            OutArgs : System.Array$1<any>
            ReturnValue : any
            GetArg ($argNum: number) : any
            GetArgName ($index: number) : string
            GetOutArg ($argNum: number) : any
            GetOutArgName ($index: number) : string
        }
        interface IConstructionCallMessage extends System.Runtime.Remoting.Messaging.IMessage, System.Runtime.Remoting.Messaging.IMethodCallMessage, System.Runtime.Remoting.Messaging.IMethodMessage
        {
            ActivationType : System.Type
            ActivationTypeName : string
            Activator : System.Runtime.Remoting.Activation.IActivator
            CallSiteActivationAttributes : System.Array$1<any>
            ContextProperties : System.Collections.IList
            Properties : System.Collections.IDictionary
            InArgCount : number
            InArgs : System.Array$1<any>
            ArgCount : number
            Args : System.Array$1<any>
            HasVarArgs : boolean
            LogicalCallContext : System.Runtime.Remoting.Messaging.LogicalCallContext
            MethodBase : System.Reflection.MethodBase
            MethodName : string
            MethodSignature : any
            TypeName : string
            Uri : string
            GetInArg ($argNum: number) : any
            GetInArgName ($index: number) : string
            GetArg ($argNum: number) : any
            GetArgName ($index: number) : string
        }
        enum ActivatorLevel
        { Construction = 4, Context = 8, AppDomain = 12, Process = 16, Machine = 20 }
        interface IActivator
        {
            Level : System.Runtime.Remoting.Activation.ActivatorLevel
            NextActivator : System.Runtime.Remoting.Activation.IActivator
            Activate ($msg: System.Runtime.Remoting.Activation.IConstructionCallMessage) : System.Runtime.Remoting.Activation.IConstructionReturnMessage
        }
        class UrlAttribute extends System.Runtime.Remoting.Contexts.ContextAttribute implements System.Runtime.InteropServices._Attribute, System.Runtime.Remoting.Contexts.IContextAttribute, System.Runtime.Remoting.Contexts.IContextProperty
        {
            protected [__keep_incompatibility]: never;
            public get UrlValue(): string;
            public constructor ($callsiteURL: string)
            public constructor ($name: string)
            public constructor ()
        }
    }
    namespace System.Runtime.Remoting.Lifetime {
        class ClientSponsor extends System.MarshalByRefObject implements System.Runtime.Remoting.Lifetime.ISponsor
        {
            protected [__keep_incompatibility]: never;
            public get RenewalTime(): System.TimeSpan;
            public set RenewalTime(value: System.TimeSpan);
            public Close () : void
            public Register ($obj: System.MarshalByRefObject) : boolean
            public Renewal ($lease: System.Runtime.Remoting.Lifetime.ILease) : System.TimeSpan
            public Unregister ($obj: System.MarshalByRefObject) : void
            public constructor ()
            public constructor ($renewalTime: System.TimeSpan)
        }
        interface ISponsor
        {
            Renewal ($lease: System.Runtime.Remoting.Lifetime.ILease) : System.TimeSpan
        }
        interface ILease
        {
            CurrentLeaseTime : System.TimeSpan
            CurrentState : System.Runtime.Remoting.Lifetime.LeaseState
            InitialLeaseTime : System.TimeSpan
            RenewOnCallTime : System.TimeSpan
            SponsorshipTimeout : System.TimeSpan
            Register ($obj: System.Runtime.Remoting.Lifetime.ISponsor) : void
            Register ($obj: System.Runtime.Remoting.Lifetime.ISponsor, $renewalTime: System.TimeSpan) : void
            Renew ($renewalTime: System.TimeSpan) : System.TimeSpan
            Unregister ($obj: System.Runtime.Remoting.Lifetime.ISponsor) : void
        }
        enum LeaseState
        { Null = 0, Initial = 1, Active = 2, Renewing = 3, Expired = 4 }
        class LifetimeServices extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get LeaseManagerPollTime(): System.TimeSpan;
            public static set LeaseManagerPollTime(value: System.TimeSpan);
            public static get LeaseTime(): System.TimeSpan;
            public static set LeaseTime(value: System.TimeSpan);
            public static get RenewOnCallTime(): System.TimeSpan;
            public static set RenewOnCallTime(value: System.TimeSpan);
            public static get SponsorshipTimeout(): System.TimeSpan;
            public static set SponsorshipTimeout(value: System.TimeSpan);
        }
    }
    namespace System.Runtime.Remoting.Channels {
        class BaseChannelObjectWithProperties extends System.Object implements System.Collections.ICollection, System.Collections.IDictionary, System.Collections.IEnumerable
        {
            protected [__keep_incompatibility]: never;
            public get Count(): number;
            public get IsFixedSize(): boolean;
            public get IsReadOnly(): boolean;
            public get IsSynchronized(): boolean;
            public get Keys(): System.Collections.ICollection;
            public get Properties(): System.Collections.IDictionary;
            public get SyncRoot(): any;
            public get Values(): System.Collections.ICollection;
            public get_Item ($key: any) : any
            public set_Item ($key: any, $value: any) : void
            public Add ($key: any, $value: any) : void
            public Clear () : void
            public Contains ($key: any) : boolean
            public CopyTo ($array: System.Array, $index: number) : void
            public GetEnumerator () : System.Collections.IDictionaryEnumerator
            public Remove ($key: any) : void
            public GetEnumerator () : System.Collections.IEnumerator
        }
        class BaseChannelSinkWithProperties extends System.Runtime.Remoting.Channels.BaseChannelObjectWithProperties implements System.Collections.ICollection, System.Collections.IDictionary, System.Collections.IEnumerable
        {
            protected [__keep_incompatibility]: never;
        }
        class BaseChannelWithProperties extends System.Runtime.Remoting.Channels.BaseChannelObjectWithProperties implements System.Collections.ICollection, System.Collections.IDictionary, System.Collections.IEnumerable
        {
            protected [__keep_incompatibility]: never;
            public get Properties(): System.Collections.IDictionary;
        }
        class ChannelDataStore extends System.Object implements System.Runtime.Remoting.Channels.IChannelDataStore
        {
            protected [__keep_incompatibility]: never;
            public get ChannelUris(): System.Array$1<string>;
            public set ChannelUris(value: System.Array$1<string>);
            public get_Item ($key: any) : any
            public set_Item ($key: any, $value: any) : void
            public constructor ($channelURIs: System.Array$1<string>)
            public constructor ()
        }
        interface IChannelDataStore
        {
            ChannelUris : System.Array$1<string>
            get_Item ($key: any) : any
            set_Item ($key: any, $value: any) : void
        }
        class ChannelServices extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get RegisteredChannels(): System.Array$1<System.Runtime.Remoting.Channels.IChannel>;
            public static CreateServerChannelSinkChain ($provider: System.Runtime.Remoting.Channels.IServerChannelSinkProvider, $channel: System.Runtime.Remoting.Channels.IChannelReceiver) : System.Runtime.Remoting.Channels.IServerChannelSink
            public static DispatchMessage ($sinkStack: System.Runtime.Remoting.Channels.IServerChannelSinkStack, $msg: System.Runtime.Remoting.Messaging.IMessage, $replyMsg: $Ref<System.Runtime.Remoting.Messaging.IMessage>) : System.Runtime.Remoting.Channels.ServerProcessing
            public static GetChannel ($name: string) : System.Runtime.Remoting.Channels.IChannel
            public static GetChannelSinkProperties ($obj: any) : System.Collections.IDictionary
            public static GetUrlsForObject ($obj: System.MarshalByRefObject) : System.Array$1<string>
            public static RegisterChannel ($chnl: System.Runtime.Remoting.Channels.IChannel, $ensureSecurity: boolean) : void
            public static SyncDispatchMessage ($msg: System.Runtime.Remoting.Messaging.IMessage) : System.Runtime.Remoting.Messaging.IMessage
            public static AsyncDispatchMessage ($msg: System.Runtime.Remoting.Messaging.IMessage, $replySink: System.Runtime.Remoting.Messaging.IMessageSink) : System.Runtime.Remoting.Messaging.IMessageCtrl
            public static UnregisterChannel ($chnl: System.Runtime.Remoting.Channels.IChannel) : void
        }
        interface IChannel
        {
            ChannelName : string
            ChannelPriority : number
            Parse ($url: string, $objectURI: $Ref<string>) : string
        }
        interface IServerChannelSink extends System.Runtime.Remoting.Channels.IChannelSinkBase
        {
            NextChannelSink : System.Runtime.Remoting.Channels.IServerChannelSink
            Properties : System.Collections.IDictionary
            AsyncProcessResponse ($sinkStack: System.Runtime.Remoting.Channels.IServerResponseChannelSinkStack, $state: any, $msg: System.Runtime.Remoting.Messaging.IMessage, $headers: System.Runtime.Remoting.Channels.ITransportHeaders, $stream: System.IO.Stream) : void
            GetResponseStream ($sinkStack: System.Runtime.Remoting.Channels.IServerResponseChannelSinkStack, $state: any, $msg: System.Runtime.Remoting.Messaging.IMessage, $headers: System.Runtime.Remoting.Channels.ITransportHeaders) : System.IO.Stream
            ProcessMessage ($sinkStack: System.Runtime.Remoting.Channels.IServerChannelSinkStack, $requestMsg: System.Runtime.Remoting.Messaging.IMessage, $requestHeaders: System.Runtime.Remoting.Channels.ITransportHeaders, $requestStream: System.IO.Stream, $responseMsg: $Ref<System.Runtime.Remoting.Messaging.IMessage>, $responseHeaders: $Ref<System.Runtime.Remoting.Channels.ITransportHeaders>, $responseStream: $Ref<System.IO.Stream>) : System.Runtime.Remoting.Channels.ServerProcessing
        }
        interface IChannelSinkBase
        {
            Properties : System.Collections.IDictionary
        }
        interface IServerChannelSinkProvider
        {
            Next : System.Runtime.Remoting.Channels.IServerChannelSinkProvider
            CreateSink ($channel: System.Runtime.Remoting.Channels.IChannelReceiver) : System.Runtime.Remoting.Channels.IServerChannelSink
            GetChannelData ($channelData: System.Runtime.Remoting.Channels.IChannelDataStore) : void
        }
        interface IChannelReceiver extends System.Runtime.Remoting.Channels.IChannel
        {
            ChannelData : any
            ChannelName : string
            ChannelPriority : number
            GetUrlsForUri ($objectURI: string) : System.Array$1<string>
            StartListening ($data: any) : void
            StopListening ($data: any) : void
            Parse ($url: string, $objectURI: $Ref<string>) : string
        }
        enum ServerProcessing
        { Complete = 0, OneWay = 1, Async = 2 }
        interface IServerChannelSinkStack extends System.Runtime.Remoting.Channels.IServerResponseChannelSinkStack
        {
            Pop ($sink: System.Runtime.Remoting.Channels.IServerChannelSink) : any
            Push ($sink: System.Runtime.Remoting.Channels.IServerChannelSink, $state: any) : void
            ServerCallback ($ar: System.IAsyncResult) : void
            Store ($sink: System.Runtime.Remoting.Channels.IServerChannelSink, $state: any) : void
            StoreAndDispatch ($sink: System.Runtime.Remoting.Channels.IServerChannelSink, $state: any) : void
            AsyncProcessResponse ($msg: System.Runtime.Remoting.Messaging.IMessage, $headers: System.Runtime.Remoting.Channels.ITransportHeaders, $stream: System.IO.Stream) : void
            GetResponseStream ($msg: System.Runtime.Remoting.Messaging.IMessage, $headers: System.Runtime.Remoting.Channels.ITransportHeaders) : System.IO.Stream
        }
        interface IServerResponseChannelSinkStack
        {
            AsyncProcessResponse ($msg: System.Runtime.Remoting.Messaging.IMessage, $headers: System.Runtime.Remoting.Channels.ITransportHeaders, $stream: System.IO.Stream) : void
            GetResponseStream ($msg: System.Runtime.Remoting.Messaging.IMessage, $headers: System.Runtime.Remoting.Channels.ITransportHeaders) : System.IO.Stream
        }
        class ClientChannelSinkStack extends System.Object implements System.Runtime.Remoting.Channels.IClientChannelSinkStack, System.Runtime.Remoting.Channels.IClientResponseChannelSinkStack
        {
            protected [__keep_incompatibility]: never;
            public AsyncProcessResponse ($headers: System.Runtime.Remoting.Channels.ITransportHeaders, $stream: System.IO.Stream) : void
            public DispatchException ($e: System.Exception) : void
            public DispatchReplyMessage ($msg: System.Runtime.Remoting.Messaging.IMessage) : void
            public Pop ($sink: System.Runtime.Remoting.Channels.IClientChannelSink) : any
            public Push ($sink: System.Runtime.Remoting.Channels.IClientChannelSink, $state: any) : void
            public constructor ()
            public constructor ($replySink: System.Runtime.Remoting.Messaging.IMessageSink)
        }
        interface IClientChannelSinkStack extends System.Runtime.Remoting.Channels.IClientResponseChannelSinkStack
        {
            Pop ($sink: System.Runtime.Remoting.Channels.IClientChannelSink) : any
            Push ($sink: System.Runtime.Remoting.Channels.IClientChannelSink, $state: any) : void
            AsyncProcessResponse ($headers: System.Runtime.Remoting.Channels.ITransportHeaders, $stream: System.IO.Stream) : void
            DispatchException ($e: System.Exception) : void
            DispatchReplyMessage ($msg: System.Runtime.Remoting.Messaging.IMessage) : void
        }
        interface IClientResponseChannelSinkStack
        {
            AsyncProcessResponse ($headers: System.Runtime.Remoting.Channels.ITransportHeaders, $stream: System.IO.Stream) : void
            DispatchException ($e: System.Exception) : void
            DispatchReplyMessage ($msg: System.Runtime.Remoting.Messaging.IMessage) : void
        }
        interface ITransportHeaders
        {
            get_Item ($key: any) : any
            set_Item ($key: any, $value: any) : void
            GetEnumerator () : System.Collections.IEnumerator
        }
        interface IClientChannelSink extends System.Runtime.Remoting.Channels.IChannelSinkBase
        {
            NextChannelSink : System.Runtime.Remoting.Channels.IClientChannelSink
            Properties : System.Collections.IDictionary
            AsyncProcessRequest ($sinkStack: System.Runtime.Remoting.Channels.IClientChannelSinkStack, $msg: System.Runtime.Remoting.Messaging.IMessage, $headers: System.Runtime.Remoting.Channels.ITransportHeaders, $stream: System.IO.Stream) : void
            AsyncProcessResponse ($sinkStack: System.Runtime.Remoting.Channels.IClientResponseChannelSinkStack, $state: any, $headers: System.Runtime.Remoting.Channels.ITransportHeaders, $stream: System.IO.Stream) : void
            GetRequestStream ($msg: System.Runtime.Remoting.Messaging.IMessage, $headers: System.Runtime.Remoting.Channels.ITransportHeaders) : System.IO.Stream
            ProcessMessage ($msg: System.Runtime.Remoting.Messaging.IMessage, $requestHeaders: System.Runtime.Remoting.Channels.ITransportHeaders, $requestStream: System.IO.Stream, $responseHeaders: $Ref<System.Runtime.Remoting.Channels.ITransportHeaders>, $responseStream: $Ref<System.IO.Stream>) : void
        }
        interface IChannelReceiverHook
        {
            ChannelScheme : string
            ChannelSinkChain : System.Runtime.Remoting.Channels.IServerChannelSink
            WantsToListen : boolean
            AddHookChannelUri ($channelUri: string) : void
        }
        interface IChannelSender extends System.Runtime.Remoting.Channels.IChannel
        {
            ChannelName : string
            ChannelPriority : number
            CreateMessageSink ($url: string, $remoteChannelData: any, $objectURI: $Ref<string>) : System.Runtime.Remoting.Messaging.IMessageSink
            Parse ($url: string, $objectURI: $Ref<string>) : string
        }
        interface IClientChannelSinkProvider
        {
            Next : System.Runtime.Remoting.Channels.IClientChannelSinkProvider
            CreateSink ($channel: System.Runtime.Remoting.Channels.IChannelSender, $url: string, $remoteChannelData: any) : System.Runtime.Remoting.Channels.IClientChannelSink
        }
        interface IClientFormatterSink extends System.Runtime.Remoting.Channels.IClientChannelSink, System.Runtime.Remoting.Messaging.IMessageSink, System.Runtime.Remoting.Channels.IChannelSinkBase
        {
            NextChannelSink : System.Runtime.Remoting.Channels.IClientChannelSink
            Properties : System.Collections.IDictionary
            NextSink : System.Runtime.Remoting.Messaging.IMessageSink
            AsyncProcessRequest ($sinkStack: System.Runtime.Remoting.Channels.IClientChannelSinkStack, $msg: System.Runtime.Remoting.Messaging.IMessage, $headers: System.Runtime.Remoting.Channels.ITransportHeaders, $stream: System.IO.Stream) : void
            AsyncProcessResponse ($sinkStack: System.Runtime.Remoting.Channels.IClientResponseChannelSinkStack, $state: any, $headers: System.Runtime.Remoting.Channels.ITransportHeaders, $stream: System.IO.Stream) : void
            GetRequestStream ($msg: System.Runtime.Remoting.Messaging.IMessage, $headers: System.Runtime.Remoting.Channels.ITransportHeaders) : System.IO.Stream
            ProcessMessage ($msg: System.Runtime.Remoting.Messaging.IMessage, $requestHeaders: System.Runtime.Remoting.Channels.ITransportHeaders, $requestStream: System.IO.Stream, $responseHeaders: $Ref<System.Runtime.Remoting.Channels.ITransportHeaders>, $responseStream: $Ref<System.IO.Stream>) : void
            SyncProcessMessage ($msg: System.Runtime.Remoting.Messaging.IMessage) : System.Runtime.Remoting.Messaging.IMessage
            AsyncProcessMessage ($msg: System.Runtime.Remoting.Messaging.IMessage, $replySink: System.Runtime.Remoting.Messaging.IMessageSink) : System.Runtime.Remoting.Messaging.IMessageCtrl
        }
        interface IClientFormatterSinkProvider extends System.Runtime.Remoting.Channels.IClientChannelSinkProvider
        {
            Next : System.Runtime.Remoting.Channels.IClientChannelSinkProvider
            CreateSink ($channel: System.Runtime.Remoting.Channels.IChannelSender, $url: string, $remoteChannelData: any) : System.Runtime.Remoting.Channels.IClientChannelSink
        }
        interface ISecurableChannel
        {
            IsSecured : boolean
        }
        interface IServerFormatterSinkProvider extends System.Runtime.Remoting.Channels.IServerChannelSinkProvider
        {
            Next : System.Runtime.Remoting.Channels.IServerChannelSinkProvider
            CreateSink ($channel: System.Runtime.Remoting.Channels.IChannelReceiver) : System.Runtime.Remoting.Channels.IServerChannelSink
            GetChannelData ($channelData: System.Runtime.Remoting.Channels.IChannelDataStore) : void
        }
        class ServerChannelSinkStack extends System.Object implements System.Runtime.Remoting.Channels.IServerResponseChannelSinkStack, System.Runtime.Remoting.Channels.IServerChannelSinkStack
        {
            protected [__keep_incompatibility]: never;
            public GetResponseStream ($msg: System.Runtime.Remoting.Messaging.IMessage, $headers: System.Runtime.Remoting.Channels.ITransportHeaders) : System.IO.Stream
            public Pop ($sink: System.Runtime.Remoting.Channels.IServerChannelSink) : any
            public Push ($sink: System.Runtime.Remoting.Channels.IServerChannelSink, $state: any) : void
            public ServerCallback ($ar: System.IAsyncResult) : void
            public Store ($sink: System.Runtime.Remoting.Channels.IServerChannelSink, $state: any) : void
            public StoreAndDispatch ($sink: System.Runtime.Remoting.Channels.IServerChannelSink, $state: any) : void
            public AsyncProcessResponse ($msg: System.Runtime.Remoting.Messaging.IMessage, $headers: System.Runtime.Remoting.Channels.ITransportHeaders, $stream: System.IO.Stream) : void
            public constructor ()
        }
        class SinkProviderData extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get Children(): System.Collections.IList;
            public get Name(): string;
            public get Properties(): System.Collections.IDictionary;
            public constructor ($name: string)
            public constructor ()
        }
        class TransportHeaders extends System.Object implements System.Runtime.Remoting.Channels.ITransportHeaders
        {
            protected [__keep_incompatibility]: never;
            public get_Item ($key: any) : any
            public set_Item ($key: any, $value: any) : void
            public GetEnumerator () : System.Collections.IEnumerator
            public constructor ()
        }
    }
    namespace System.Runtime.Remoting.Metadata.W3cXsd2001 {
        interface ISoapXsd
        {
            GetXsdType () : string
        }
        class SoapAnyUri extends System.Object implements System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
        {
            protected [__keep_incompatibility]: never;
            public get Value(): string;
            public set Value(value: string);
            public static get XsdType(): string;
            public GetXsdType () : string
            public static Parse ($value: string) : System.Runtime.Remoting.Metadata.W3cXsd2001.SoapAnyUri
            public constructor ()
            public constructor ($value: string)
        }
        class SoapBase64Binary extends System.Object implements System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
        {
            protected [__keep_incompatibility]: never;
            public get Value(): System.Array$1<number>;
            public set Value(value: System.Array$1<number>);
            public static get XsdType(): string;
            public GetXsdType () : string
            public static Parse ($value: string) : System.Runtime.Remoting.Metadata.W3cXsd2001.SoapBase64Binary
            public constructor ()
            public constructor ($value: System.Array$1<number>)
        }
        class SoapDate extends System.Object implements System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
        {
            protected [__keep_incompatibility]: never;
            public get Sign(): number;
            public set Sign(value: number);
            public get Value(): System.DateTime;
            public set Value(value: System.DateTime);
            public static get XsdType(): string;
            public GetXsdType () : string
            public static Parse ($value: string) : System.Runtime.Remoting.Metadata.W3cXsd2001.SoapDate
            public constructor ()
            public constructor ($value: System.DateTime)
            public constructor ($value: System.DateTime, $sign: number)
        }
        class SoapDateTime extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get XsdType(): string;
            public static Parse ($value: string) : System.DateTime
            public static ToString ($value: System.DateTime) : string
            public constructor ()
            public ToString () : string
        }
        class SoapDay extends System.Object implements System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
        {
            protected [__keep_incompatibility]: never;
            public get Value(): System.DateTime;
            public set Value(value: System.DateTime);
            public static get XsdType(): string;
            public GetXsdType () : string
            public static Parse ($value: string) : System.Runtime.Remoting.Metadata.W3cXsd2001.SoapDay
            public constructor ()
            public constructor ($value: System.DateTime)
        }
        class SoapDuration extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get XsdType(): string;
            public static Parse ($value: string) : System.TimeSpan
            public static ToString ($timeSpan: System.TimeSpan) : string
            public constructor ()
            public ToString () : string
        }
        class SoapEntities extends System.Object implements System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
        {
            protected [__keep_incompatibility]: never;
            public get Value(): string;
            public set Value(value: string);
            public static get XsdType(): string;
            public GetXsdType () : string
            public static Parse ($value: string) : System.Runtime.Remoting.Metadata.W3cXsd2001.SoapEntities
            public constructor ()
            public constructor ($value: string)
        }
        class SoapEntity extends System.Object implements System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
        {
            protected [__keep_incompatibility]: never;
            public get Value(): string;
            public set Value(value: string);
            public static get XsdType(): string;
            public GetXsdType () : string
            public static Parse ($value: string) : System.Runtime.Remoting.Metadata.W3cXsd2001.SoapEntity
            public constructor ()
            public constructor ($value: string)
        }
        class SoapHexBinary extends System.Object implements System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
        {
            protected [__keep_incompatibility]: never;
            public get Value(): System.Array$1<number>;
            public set Value(value: System.Array$1<number>);
            public static get XsdType(): string;
            public GetXsdType () : string
            public static Parse ($value: string) : System.Runtime.Remoting.Metadata.W3cXsd2001.SoapHexBinary
            public constructor ()
            public constructor ($value: System.Array$1<number>)
        }
        class SoapId extends System.Object implements System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
        {
            protected [__keep_incompatibility]: never;
            public get Value(): string;
            public set Value(value: string);
            public static get XsdType(): string;
            public GetXsdType () : string
            public static Parse ($value: string) : System.Runtime.Remoting.Metadata.W3cXsd2001.SoapId
            public constructor ()
            public constructor ($value: string)
        }
        class SoapIdref extends System.Object implements System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
        {
            protected [__keep_incompatibility]: never;
            public get Value(): string;
            public set Value(value: string);
            public static get XsdType(): string;
            public GetXsdType () : string
            public static Parse ($value: string) : System.Runtime.Remoting.Metadata.W3cXsd2001.SoapIdref
            public constructor ()
            public constructor ($value: string)
        }
        class SoapIdrefs extends System.Object implements System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
        {
            protected [__keep_incompatibility]: never;
            public get Value(): string;
            public set Value(value: string);
            public static get XsdType(): string;
            public GetXsdType () : string
            public static Parse ($value: string) : System.Runtime.Remoting.Metadata.W3cXsd2001.SoapIdrefs
            public constructor ()
            public constructor ($value: string)
        }
        class SoapInteger extends System.Object implements System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
        {
            protected [__keep_incompatibility]: never;
            public get Value(): System.Decimal;
            public set Value(value: System.Decimal);
            public static get XsdType(): string;
            public GetXsdType () : string
            public static Parse ($value: string) : System.Runtime.Remoting.Metadata.W3cXsd2001.SoapInteger
            public constructor ()
            public constructor ($value: System.Decimal)
        }
        class SoapLanguage extends System.Object implements System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
        {
            protected [__keep_incompatibility]: never;
            public get Value(): string;
            public set Value(value: string);
            public static get XsdType(): string;
            public GetXsdType () : string
            public static Parse ($value: string) : System.Runtime.Remoting.Metadata.W3cXsd2001.SoapLanguage
            public constructor ()
            public constructor ($value: string)
        }
        class SoapMonth extends System.Object implements System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
        {
            protected [__keep_incompatibility]: never;
            public get Value(): System.DateTime;
            public set Value(value: System.DateTime);
            public static get XsdType(): string;
            public GetXsdType () : string
            public static Parse ($value: string) : System.Runtime.Remoting.Metadata.W3cXsd2001.SoapMonth
            public constructor ()
            public constructor ($value: System.DateTime)
        }
        class SoapMonthDay extends System.Object implements System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
        {
            protected [__keep_incompatibility]: never;
            public get Value(): System.DateTime;
            public set Value(value: System.DateTime);
            public static get XsdType(): string;
            public GetXsdType () : string
            public static Parse ($value: string) : System.Runtime.Remoting.Metadata.W3cXsd2001.SoapMonthDay
            public constructor ()
            public constructor ($value: System.DateTime)
        }
        class SoapName extends System.Object implements System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
        {
            protected [__keep_incompatibility]: never;
            public get Value(): string;
            public set Value(value: string);
            public static get XsdType(): string;
            public GetXsdType () : string
            public static Parse ($value: string) : System.Runtime.Remoting.Metadata.W3cXsd2001.SoapName
            public constructor ()
            public constructor ($value: string)
        }
        class SoapNcName extends System.Object implements System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
        {
            protected [__keep_incompatibility]: never;
            public get Value(): string;
            public set Value(value: string);
            public static get XsdType(): string;
            public GetXsdType () : string
            public static Parse ($value: string) : System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNcName
            public constructor ()
            public constructor ($value: string)
        }
        class SoapNegativeInteger extends System.Object implements System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
        {
            protected [__keep_incompatibility]: never;
            public get Value(): System.Decimal;
            public set Value(value: System.Decimal);
            public static get XsdType(): string;
            public GetXsdType () : string
            public static Parse ($value: string) : System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNegativeInteger
            public constructor ()
            public constructor ($value: System.Decimal)
        }
        class SoapNmtoken extends System.Object implements System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
        {
            protected [__keep_incompatibility]: never;
            public get Value(): string;
            public set Value(value: string);
            public static get XsdType(): string;
            public GetXsdType () : string
            public static Parse ($value: string) : System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNmtoken
            public constructor ()
            public constructor ($value: string)
        }
        class SoapNmtokens extends System.Object implements System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
        {
            protected [__keep_incompatibility]: never;
            public get Value(): string;
            public set Value(value: string);
            public static get XsdType(): string;
            public GetXsdType () : string
            public static Parse ($value: string) : System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNmtokens
            public constructor ()
            public constructor ($value: string)
        }
        class SoapNonNegativeInteger extends System.Object implements System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
        {
            protected [__keep_incompatibility]: never;
            public get Value(): System.Decimal;
            public set Value(value: System.Decimal);
            public static get XsdType(): string;
            public GetXsdType () : string
            public static Parse ($value: string) : System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNonNegativeInteger
            public constructor ()
            public constructor ($value: System.Decimal)
        }
        class SoapNonPositiveInteger extends System.Object implements System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
        {
            protected [__keep_incompatibility]: never;
            public get Value(): System.Decimal;
            public set Value(value: System.Decimal);
            public static get XsdType(): string;
            public GetXsdType () : string
            public static Parse ($value: string) : System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNonPositiveInteger
            public constructor ()
            public constructor ($value: System.Decimal)
        }
        class SoapNormalizedString extends System.Object implements System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
        {
            protected [__keep_incompatibility]: never;
            public get Value(): string;
            public set Value(value: string);
            public static get XsdType(): string;
            public GetXsdType () : string
            public static Parse ($value: string) : System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNormalizedString
            public constructor ()
            public constructor ($value: string)
        }
        class SoapNotation extends System.Object implements System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
        {
            protected [__keep_incompatibility]: never;
            public get Value(): string;
            public set Value(value: string);
            public static get XsdType(): string;
            public GetXsdType () : string
            public static Parse ($value: string) : System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNotation
            public constructor ()
            public constructor ($value: string)
        }
        class SoapPositiveInteger extends System.Object implements System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
        {
            protected [__keep_incompatibility]: never;
            public get Value(): System.Decimal;
            public set Value(value: System.Decimal);
            public static get XsdType(): string;
            public GetXsdType () : string
            public static Parse ($value: string) : System.Runtime.Remoting.Metadata.W3cXsd2001.SoapPositiveInteger
            public constructor ()
            public constructor ($value: System.Decimal)
        }
        class SoapQName extends System.Object implements System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
        {
            protected [__keep_incompatibility]: never;
            public get Key(): string;
            public set Key(value: string);
            public get Name(): string;
            public set Name(value: string);
            public get Namespace(): string;
            public set Namespace(value: string);
            public static get XsdType(): string;
            public GetXsdType () : string
            public static Parse ($value: string) : System.Runtime.Remoting.Metadata.W3cXsd2001.SoapQName
            public constructor ()
            public constructor ($value: string)
            public constructor ($key: string, $name: string)
            public constructor ($key: string, $name: string, $namespaceValue: string)
        }
        class SoapTime extends System.Object implements System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
        {
            protected [__keep_incompatibility]: never;
            public get Value(): System.DateTime;
            public set Value(value: System.DateTime);
            public static get XsdType(): string;
            public GetXsdType () : string
            public static Parse ($value: string) : System.Runtime.Remoting.Metadata.W3cXsd2001.SoapTime
            public constructor ()
            public constructor ($value: System.DateTime)
        }
        class SoapToken extends System.Object implements System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
        {
            protected [__keep_incompatibility]: never;
            public get Value(): string;
            public set Value(value: string);
            public static get XsdType(): string;
            public GetXsdType () : string
            public static Parse ($value: string) : System.Runtime.Remoting.Metadata.W3cXsd2001.SoapToken
            public constructor ()
            public constructor ($value: string)
        }
        class SoapYear extends System.Object implements System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
        {
            protected [__keep_incompatibility]: never;
            public get Sign(): number;
            public set Sign(value: number);
            public get Value(): System.DateTime;
            public set Value(value: System.DateTime);
            public static get XsdType(): string;
            public GetXsdType () : string
            public static Parse ($value: string) : System.Runtime.Remoting.Metadata.W3cXsd2001.SoapYear
            public constructor ()
            public constructor ($value: System.DateTime)
            public constructor ($value: System.DateTime, $sign: number)
        }
        class SoapYearMonth extends System.Object implements System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
        {
            protected [__keep_incompatibility]: never;
            public get Sign(): number;
            public set Sign(value: number);
            public get Value(): System.DateTime;
            public set Value(value: System.DateTime);
            public static get XsdType(): string;
            public GetXsdType () : string
            public static Parse ($value: string) : System.Runtime.Remoting.Metadata.W3cXsd2001.SoapYearMonth
            public constructor ()
            public constructor ($value: System.DateTime)
            public constructor ($value: System.DateTime, $sign: number)
        }
    }
    namespace System.Runtime.Versioning {
        class TargetFrameworkAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get FrameworkName(): string;
            public get FrameworkDisplayName(): string;
            public set FrameworkDisplayName(value: string);
            public constructor ($frameworkName: string)
            public constructor ()
        }
        class ComponentGuaranteesAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Guarantees(): System.Runtime.Versioning.ComponentGuaranteesOptions;
            public constructor ($guarantees: System.Runtime.Versioning.ComponentGuaranteesOptions)
            public constructor ()
        }
        enum ComponentGuaranteesOptions
        { None = 0, Exchange = 1, Stable = 2, SideBySide = 4 }
        class ResourceConsumptionAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get ResourceScope(): System.Runtime.Versioning.ResourceScope;
            public get ConsumptionScope(): System.Runtime.Versioning.ResourceScope;
            public constructor ($resourceScope: System.Runtime.Versioning.ResourceScope)
            public constructor ($resourceScope: System.Runtime.Versioning.ResourceScope, $consumptionScope: System.Runtime.Versioning.ResourceScope)
            public constructor ()
        }
        enum ResourceScope
        { None = 0, Machine = 1, Process = 2, AppDomain = 4, Library = 8, Private = 16, Assembly = 32 }
        class ResourceExposureAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get ResourceExposureLevel(): System.Runtime.Versioning.ResourceScope;
            public constructor ($exposureLevel: System.Runtime.Versioning.ResourceScope)
            public constructor ()
        }
        class VersioningHelper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static MakeVersionSafeName ($name: string, $from: System.Runtime.Versioning.ResourceScope, $to: System.Runtime.Versioning.ResourceScope) : string
            public static MakeVersionSafeName ($name: string, $from: System.Runtime.Versioning.ResourceScope, $to: System.Runtime.Versioning.ResourceScope, $type: System.Type) : string
        }
        class CompatibilitySwitch extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static IsEnabled ($compatibilitySwitchName: string) : boolean
            public static GetValue ($compatibilitySwitchName: string) : string
        }
    }
    namespace System.Runtime.Serialization.Formatters {
        enum TypeFilterLevel
        { Low = 2, Full = 3 }
        enum FormatterTypeStyle
        { TypesWhenNeeded = 0, TypesAlways = 1, XsdString = 2 }
        enum FormatterAssemblyStyle
        { Simple = 0, Full = 1 }
        interface IFieldInfo
        {
            FieldNames : System.Array$1<string>
            FieldTypes : System.Array$1<System.Type>
        }
        interface ISoapMessage
        {
            ParamNames : System.Array$1<string>
            ParamValues : System.Array$1<any>
            ParamTypes : System.Array$1<System.Type>
            MethodName : string
            XmlNameSpace : string
            Headers : System.Array$1<System.Runtime.Remoting.Messaging.Header>
        }
        class InternalRM extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static InfoSoap (...messages: any[]) : void
            public static SoapCheckEnabled () : boolean
            public constructor ()
        }
        class InternalST extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static InfoSoap (...messages: any[]) : void
            public static SoapCheckEnabled () : boolean
            public static Soap (...messages: any[]) : void
            public static SoapAssert ($condition: boolean, $message: string) : void
            public static SerializationSetValue ($fi: System.Reflection.FieldInfo, $target: any, $value: any) : void
            public static LoadAssemblyFromString ($assemblyString: string) : System.Reflection.Assembly
        }
        class SoapFault extends System.Object implements System.Runtime.Serialization.ISerializable
        {
            protected [__keep_incompatibility]: never;
            public get FaultCode(): string;
            public set FaultCode(value: string);
            public get FaultString(): string;
            public set FaultString(value: string);
            public get FaultActor(): string;
            public set FaultActor(value: string);
            public get Detail(): any;
            public set Detail(value: any);
            public GetObjectData ($info: System.Runtime.Serialization.SerializationInfo, $context: System.Runtime.Serialization.StreamingContext) : void
            public constructor ()
            public constructor ($faultCode: string, $faultString: string, $faultActor: string, $serverFault: System.Runtime.Serialization.Formatters.ServerFault)
        }
        class ServerFault extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get ExceptionType(): string;
            public set ExceptionType(value: string);
            public get ExceptionMessage(): string;
            public set ExceptionMessage(value: string);
            public get StackTrace(): string;
            public set StackTrace(value: string);
            public constructor ($exceptionType: string, $message: string, $stackTrace: string)
            public constructor ()
        }
        class SoapMessage extends System.Object implements System.Runtime.Serialization.Formatters.ISoapMessage
        {
            protected [__keep_incompatibility]: never;
            public get ParamNames(): System.Array$1<string>;
            public set ParamNames(value: System.Array$1<string>);
            public get ParamValues(): System.Array$1<any>;
            public set ParamValues(value: System.Array$1<any>);
            public get ParamTypes(): System.Array$1<System.Type>;
            public set ParamTypes(value: System.Array$1<System.Type>);
            public get MethodName(): string;
            public set MethodName(value: string);
            public get XmlNameSpace(): string;
            public set XmlNameSpace(value: string);
            public get Headers(): System.Array$1<System.Runtime.Remoting.Messaging.Header>;
            public set Headers(value: System.Array$1<System.Runtime.Remoting.Messaging.Header>);
            public constructor ()
        }
    }
    namespace System.Runtime.Serialization.Formatters.Binary {
        class BinaryFormatter extends System.Object implements System.Runtime.Serialization.IFormatter, System.Runtime.Remoting.Messaging.IRemotingFormatter
        {
            protected [__keep_incompatibility]: never;
            public get TypeFormat(): System.Runtime.Serialization.Formatters.FormatterTypeStyle;
            public set TypeFormat(value: System.Runtime.Serialization.Formatters.FormatterTypeStyle);
            public get AssemblyFormat(): System.Runtime.Serialization.Formatters.FormatterAssemblyStyle;
            public set AssemblyFormat(value: System.Runtime.Serialization.Formatters.FormatterAssemblyStyle);
            public get FilterLevel(): System.Runtime.Serialization.Formatters.TypeFilterLevel;
            public set FilterLevel(value: System.Runtime.Serialization.Formatters.TypeFilterLevel);
            public get SurrogateSelector(): System.Runtime.Serialization.ISurrogateSelector;
            public set SurrogateSelector(value: System.Runtime.Serialization.ISurrogateSelector);
            public get Binder(): System.Runtime.Serialization.SerializationBinder;
            public set Binder(value: System.Runtime.Serialization.SerializationBinder);
            public get Context(): System.Runtime.Serialization.StreamingContext;
            public set Context(value: System.Runtime.Serialization.StreamingContext);
            public Deserialize ($serializationStream: System.IO.Stream) : any
            public Deserialize ($serializationStream: System.IO.Stream, $handler: System.Runtime.Remoting.Messaging.HeaderHandler) : any
            public DeserializeMethodResponse ($serializationStream: System.IO.Stream, $handler: System.Runtime.Remoting.Messaging.HeaderHandler, $methodCallMessage: System.Runtime.Remoting.Messaging.IMethodCallMessage) : any
            public UnsafeDeserialize ($serializationStream: System.IO.Stream, $handler: System.Runtime.Remoting.Messaging.HeaderHandler) : any
            public UnsafeDeserializeMethodResponse ($serializationStream: System.IO.Stream, $handler: System.Runtime.Remoting.Messaging.HeaderHandler, $methodCallMessage: System.Runtime.Remoting.Messaging.IMethodCallMessage) : any
            public Serialize ($serializationStream: System.IO.Stream, $graph: any) : void
            public Serialize ($serializationStream: System.IO.Stream, $graph: any, $headers: System.Array$1<System.Runtime.Remoting.Messaging.Header>) : void
            public constructor ()
            public constructor ($selector: System.Runtime.Serialization.ISurrogateSelector, $context: System.Runtime.Serialization.StreamingContext)
        }
    }
    namespace System.Runtime.InteropServices.ELEMDESC {
        class DESCUNION extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public idldesc : System.Runtime.InteropServices.IDLDESC
            public paramdesc : System.Runtime.InteropServices.PARAMDESC
        }
    }
    namespace System.Runtime.InteropServices.VARDESC {
        class DESCUNION extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public oInst : number
            public lpvarValue : System.IntPtr
        }
    }
    namespace System.Runtime.InteropServices.ComTypes {
        interface ITypeLib
        {
            GetTypeInfoCount () : number
            GetTypeInfo ($index: number, $ppTI: $Ref<System.Runtime.InteropServices.ComTypes.ITypeInfo>) : void
            GetTypeInfoType ($index: number, $pTKind: $Ref<System.Runtime.InteropServices.ComTypes.TYPEKIND>) : void
            GetTypeInfoOfGuid ($guid: $Ref<System.Guid>, $ppTInfo: $Ref<System.Runtime.InteropServices.ComTypes.ITypeInfo>) : void
            GetLibAttr ($ppTLibAttr: $Ref<System.IntPtr>) : void
            GetTypeComp ($ppTComp: $Ref<System.Runtime.InteropServices.ComTypes.ITypeComp>) : void
            GetDocumentation ($index: number, $strName: $Ref<string>, $strDocString: $Ref<string>, $dwHelpContext: $Ref<number>, $strHelpFile: $Ref<string>) : void
            IsName ($szNameBuf: string, $lHashVal: number) : boolean
            FindName ($szNameBuf: string, $lHashVal: number, $ppTInfo: System.Array$1<System.Runtime.InteropServices.ComTypes.ITypeInfo>, $rgMemId: System.Array$1<number>, $pcFound: $Ref<number>) : void
            ReleaseTLibAttr ($pTLibAttr: System.IntPtr) : void
        }
        interface ITypeInfo
        {
            GetTypeAttr ($ppTypeAttr: $Ref<System.IntPtr>) : void
            GetTypeComp ($ppTComp: $Ref<System.Runtime.InteropServices.ComTypes.ITypeComp>) : void
            GetFuncDesc ($index: number, $ppFuncDesc: $Ref<System.IntPtr>) : void
            GetVarDesc ($index: number, $ppVarDesc: $Ref<System.IntPtr>) : void
            GetNames ($memid: number, $rgBstrNames: System.Array$1<string>, $cMaxNames: number, $pcNames: $Ref<number>) : void
            GetRefTypeOfImplType ($index: number, $href: $Ref<number>) : void
            GetImplTypeFlags ($index: number, $pImplTypeFlags: $Ref<System.Runtime.InteropServices.ComTypes.IMPLTYPEFLAGS>) : void
            GetIDsOfNames ($rgszNames: System.Array$1<string>, $cNames: number, $pMemId: System.Array$1<number>) : void
            Invoke ($pvInstance: any, $memid: number, $wFlags: number, $pDispParams: $Ref<System.Runtime.InteropServices.ComTypes.DISPPARAMS>, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: $Ref<number>) : void
            GetDocumentation ($index: number, $strName: $Ref<string>, $strDocString: $Ref<string>, $dwHelpContext: $Ref<number>, $strHelpFile: $Ref<string>) : void
            GetDllEntry ($memid: number, $invKind: System.Runtime.InteropServices.ComTypes.INVOKEKIND, $pBstrDllName: System.IntPtr, $pBstrName: System.IntPtr, $pwOrdinal: System.IntPtr) : void
            GetRefTypeInfo ($hRef: number, $ppTI: $Ref<System.Runtime.InteropServices.ComTypes.ITypeInfo>) : void
            AddressOfMember ($memid: number, $invKind: System.Runtime.InteropServices.ComTypes.INVOKEKIND, $ppv: $Ref<System.IntPtr>) : void
            CreateInstance ($pUnkOuter: any, $riid: $Ref<System.Guid>, $ppvObj: $Ref<any>) : void
            GetMops ($memid: number, $pBstrMops: $Ref<string>) : void
            GetContainingTypeLib ($ppTLB: $Ref<System.Runtime.InteropServices.ComTypes.ITypeLib>, $pIndex: $Ref<number>) : void
            ReleaseTypeAttr ($pTypeAttr: System.IntPtr) : void
            ReleaseFuncDesc ($pFuncDesc: System.IntPtr) : void
            ReleaseVarDesc ($pVarDesc: System.IntPtr) : void
        }
        interface IConnectionPoint
        {
            GetConnectionInterface ($pIID: $Ref<System.Guid>) : void
            GetConnectionPointContainer ($ppCPC: $Ref<System.Runtime.InteropServices.ComTypes.IConnectionPointContainer>) : void
            Advise ($pUnkSink: any, $pdwCookie: $Ref<number>) : void
            Unadvise ($dwCookie: number) : void
            EnumConnections ($ppEnum: $Ref<System.Runtime.InteropServices.ComTypes.IEnumConnections>) : void
        }
        interface IConnectionPointContainer
        {
            EnumConnectionPoints ($ppEnum: $Ref<System.Runtime.InteropServices.ComTypes.IEnumConnectionPoints>) : void
            FindConnectionPoint ($riid: $Ref<System.Guid>, $ppCP: $Ref<System.Runtime.InteropServices.ComTypes.IConnectionPoint>) : void
        }
        interface IEnumConnections
        {
            Next ($celt: number, $rgelt: System.Array$1<System.Runtime.InteropServices.ComTypes.CONNECTDATA>, $pceltFetched: System.IntPtr) : number
            Skip ($celt: number) : number
            Reset () : void
            Clone ($ppenum: $Ref<System.Runtime.InteropServices.ComTypes.IEnumConnections>) : void
        }
        interface IEnumConnectionPoints
        {
            Next ($celt: number, $rgelt: System.Array$1<System.Runtime.InteropServices.ComTypes.IConnectionPoint>, $pceltFetched: System.IntPtr) : number
            Skip ($celt: number) : number
            Reset () : void
            Clone ($ppenum: $Ref<System.Runtime.InteropServices.ComTypes.IEnumConnectionPoints>) : void
        }
        class BIND_OPTS extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public cbStruct : number
            public grfFlags : number
            public grfMode : number
            public dwTickCountDeadline : number
        }
        interface IBindCtx
        {
            RegisterObjectBound ($punk: any) : void
            RevokeObjectBound ($punk: any) : void
            ReleaseBoundObjects () : void
            SetBindOptions ($pbindopts: $Ref<System.Runtime.InteropServices.ComTypes.BIND_OPTS>) : void
            GetBindOptions ($pbindopts: $Ref<System.Runtime.InteropServices.ComTypes.BIND_OPTS>) : void
            GetRunningObjectTable ($pprot: $Ref<System.Runtime.InteropServices.ComTypes.IRunningObjectTable>) : void
            RegisterObjectParam ($pszKey: string, $punk: any) : void
            GetObjectParam ($pszKey: string, $ppunk: $Ref<any>) : void
            EnumObjectParam ($ppenum: $Ref<System.Runtime.InteropServices.ComTypes.IEnumString>) : void
            RevokeObjectParam ($pszKey: string) : number
        }
        interface IRunningObjectTable
        {
            Register ($grfFlags: number, $punkObject: any, $pmkObjectName: System.Runtime.InteropServices.ComTypes.IMoniker) : number
            Revoke ($dwRegister: number) : void
            IsRunning ($pmkObjectName: System.Runtime.InteropServices.ComTypes.IMoniker) : number
            GetObject ($pmkObjectName: System.Runtime.InteropServices.ComTypes.IMoniker, $ppunkObject: $Ref<any>) : number
            NoteChangeTime ($dwRegister: number, $pfiletime: $Ref<System.Runtime.InteropServices.ComTypes.FILETIME>) : void
            GetTimeOfLastChange ($pmkObjectName: System.Runtime.InteropServices.ComTypes.IMoniker, $pfiletime: $Ref<System.Runtime.InteropServices.ComTypes.FILETIME>) : number
            EnumRunning ($ppenumMoniker: $Ref<System.Runtime.InteropServices.ComTypes.IEnumMoniker>) : void
        }
        interface IEnumString
        {
            Next ($celt: number, $rgelt: System.Array$1<string>, $pceltFetched: System.IntPtr) : number
            Skip ($celt: number) : number
            Reset () : void
            Clone ($ppenum: $Ref<System.Runtime.InteropServices.ComTypes.IEnumString>) : void
        }
        class CONNECTDATA extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public pUnk : any
            public dwCookie : number
        }
        interface IEnumMoniker
        {
            Next ($celt: number, $rgelt: System.Array$1<System.Runtime.InteropServices.ComTypes.IMoniker>, $pceltFetched: System.IntPtr) : number
            Skip ($celt: number) : number
            Reset () : void
            Clone ($ppenum: $Ref<System.Runtime.InteropServices.ComTypes.IEnumMoniker>) : void
        }
        interface IMoniker
        {
            GetClassID ($pClassID: $Ref<System.Guid>) : void
            IsDirty () : number
            Load ($pStm: System.Runtime.InteropServices.ComTypes.IStream) : void
            Save ($pStm: System.Runtime.InteropServices.ComTypes.IStream, $fClearDirty: boolean) : void
            GetSizeMax ($pcbSize: $Ref<bigint>) : void
            BindToObject ($pbc: System.Runtime.InteropServices.ComTypes.IBindCtx, $pmkToLeft: System.Runtime.InteropServices.ComTypes.IMoniker, $riidResult: $Ref<System.Guid>, $ppvResult: $Ref<any>) : void
            BindToStorage ($pbc: System.Runtime.InteropServices.ComTypes.IBindCtx, $pmkToLeft: System.Runtime.InteropServices.ComTypes.IMoniker, $riid: $Ref<System.Guid>, $ppvObj: $Ref<any>) : void
            Reduce ($pbc: System.Runtime.InteropServices.ComTypes.IBindCtx, $dwReduceHowFar: number, $ppmkToLeft: $Ref<System.Runtime.InteropServices.ComTypes.IMoniker>, $ppmkReduced: $Ref<System.Runtime.InteropServices.ComTypes.IMoniker>) : void
            ComposeWith ($pmkRight: System.Runtime.InteropServices.ComTypes.IMoniker, $fOnlyIfNotGeneric: boolean, $ppmkComposite: $Ref<System.Runtime.InteropServices.ComTypes.IMoniker>) : void
            Enum ($fForward: boolean, $ppenumMoniker: $Ref<System.Runtime.InteropServices.ComTypes.IEnumMoniker>) : void
            IsEqual ($pmkOtherMoniker: System.Runtime.InteropServices.ComTypes.IMoniker) : number
            Hash ($pdwHash: $Ref<number>) : void
            IsRunning ($pbc: System.Runtime.InteropServices.ComTypes.IBindCtx, $pmkToLeft: System.Runtime.InteropServices.ComTypes.IMoniker, $pmkNewlyRunning: System.Runtime.InteropServices.ComTypes.IMoniker) : number
            GetTimeOfLastChange ($pbc: System.Runtime.InteropServices.ComTypes.IBindCtx, $pmkToLeft: System.Runtime.InteropServices.ComTypes.IMoniker, $pFileTime: $Ref<System.Runtime.InteropServices.ComTypes.FILETIME>) : void
            Inverse ($ppmk: $Ref<System.Runtime.InteropServices.ComTypes.IMoniker>) : void
            CommonPrefixWith ($pmkOther: System.Runtime.InteropServices.ComTypes.IMoniker, $ppmkPrefix: $Ref<System.Runtime.InteropServices.ComTypes.IMoniker>) : void
            RelativePathTo ($pmkOther: System.Runtime.InteropServices.ComTypes.IMoniker, $ppmkRelPath: $Ref<System.Runtime.InteropServices.ComTypes.IMoniker>) : void
            GetDisplayName ($pbc: System.Runtime.InteropServices.ComTypes.IBindCtx, $pmkToLeft: System.Runtime.InteropServices.ComTypes.IMoniker, $ppszDisplayName: $Ref<string>) : void
            ParseDisplayName ($pbc: System.Runtime.InteropServices.ComTypes.IBindCtx, $pmkToLeft: System.Runtime.InteropServices.ComTypes.IMoniker, $pszDisplayName: string, $pchEaten: $Ref<number>, $ppmkOut: $Ref<System.Runtime.InteropServices.ComTypes.IMoniker>) : void
            IsSystemMoniker ($pdwMksys: $Ref<number>) : number
        }
        interface IEnumVARIANT
        {
            Next ($celt: number, $rgVar: System.Array$1<any>, $pceltFetched: System.IntPtr) : number
            Skip ($celt: number) : number
            Reset () : number
            Clone () : System.Runtime.InteropServices.ComTypes.IEnumVARIANT
        }
        class FILETIME extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public dwLowDateTime : number
            public dwHighDateTime : number
        }
        interface IStream
        {
            Read ($pv: System.Array$1<number>, $cb: number, $pcbRead: System.IntPtr) : void
            Write ($pv: System.Array$1<number>, $cb: number, $pcbWritten: System.IntPtr) : void
            Seek ($dlibMove: bigint, $dwOrigin: number, $plibNewPosition: System.IntPtr) : void
            SetSize ($libNewSize: bigint) : void
            CopyTo ($pstm: System.Runtime.InteropServices.ComTypes.IStream, $cb: bigint, $pcbRead: System.IntPtr, $pcbWritten: System.IntPtr) : void
            Commit ($grfCommitFlags: number) : void
            Revert () : void
            LockRegion ($libOffset: bigint, $cb: bigint, $dwLockType: number) : void
            UnlockRegion ($libOffset: bigint, $cb: bigint, $dwLockType: number) : void
            Stat ($pstatstg: $Ref<System.Runtime.InteropServices.ComTypes.STATSTG>, $grfStatFlag: number) : void
            Clone ($ppstm: $Ref<System.Runtime.InteropServices.ComTypes.IStream>) : void
        }
        interface IPersistFile
        {
            GetClassID ($pClassID: $Ref<System.Guid>) : void
            IsDirty () : number
            Load ($pszFileName: string, $dwMode: number) : void
            Save ($pszFileName: string, $fRemember: boolean) : void
            SaveCompleted ($pszFileName: string) : void
            GetCurFile ($ppszFileName: $Ref<string>) : void
        }
        class STATSTG extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public pwcsName : string
            public type : number
            public cbSize : bigint
            public mtime : System.Runtime.InteropServices.ComTypes.FILETIME
            public ctime : System.Runtime.InteropServices.ComTypes.FILETIME
            public atime : System.Runtime.InteropServices.ComTypes.FILETIME
            public grfMode : number
            public grfLocksSupported : number
            public clsid : System.Guid
            public grfStateBits : number
            public reserved : number
        }
        enum DESCKIND
        { DESCKIND_NONE = 0, DESCKIND_FUNCDESC = 1, DESCKIND_VARDESC = 2, DESCKIND_TYPECOMP = 3, DESCKIND_IMPLICITAPPOBJ = 4, DESCKIND_MAX = 5 }
        class BINDPTR extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public lpfuncdesc : System.IntPtr
            public lpvardesc : System.IntPtr
            public lptcomp : System.IntPtr
        }
        interface ITypeComp
        {
            Bind ($szName: string, $lHashVal: number, $wFlags: number, $ppTInfo: $Ref<System.Runtime.InteropServices.ComTypes.ITypeInfo>, $pDescKind: $Ref<System.Runtime.InteropServices.ComTypes.DESCKIND>, $pBindPtr: $Ref<System.Runtime.InteropServices.ComTypes.BINDPTR>) : void
            BindType ($szName: string, $lHashVal: number, $ppTInfo: $Ref<System.Runtime.InteropServices.ComTypes.ITypeInfo>, $ppTComp: $Ref<System.Runtime.InteropServices.ComTypes.ITypeComp>) : void
        }
        enum TYPEKIND
        { TKIND_ENUM = 0, TKIND_RECORD = 1, TKIND_MODULE = 2, TKIND_INTERFACE = 3, TKIND_DISPATCH = 4, TKIND_COCLASS = 5, TKIND_ALIAS = 6, TKIND_UNION = 7, TKIND_MAX = 8 }
        enum TYPEFLAGS
        { TYPEFLAG_FAPPOBJECT = 1, TYPEFLAG_FCANCREATE = 2, TYPEFLAG_FLICENSED = 4, TYPEFLAG_FPREDECLID = 8, TYPEFLAG_FHIDDEN = 16, TYPEFLAG_FCONTROL = 32, TYPEFLAG_FDUAL = 64, TYPEFLAG_FNONEXTENSIBLE = 128, TYPEFLAG_FOLEAUTOMATION = 256, TYPEFLAG_FRESTRICTED = 512, TYPEFLAG_FAGGREGATABLE = 1024, TYPEFLAG_FREPLACEABLE = 2048, TYPEFLAG_FDISPATCHABLE = 4096, TYPEFLAG_FREVERSEBIND = 8192, TYPEFLAG_FPROXY = 16384 }
        enum IMPLTYPEFLAGS
        { IMPLTYPEFLAG_FDEFAULT = 1, IMPLTYPEFLAG_FSOURCE = 2, IMPLTYPEFLAG_FRESTRICTED = 4, IMPLTYPEFLAG_FDEFAULTVTABLE = 8 }
        class TYPEATTR extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public static MEMBER_ID_NIL : number
            public guid : System.Guid
            public lcid : number
            public dwReserved : number
            public memidConstructor : number
            public memidDestructor : number
            public lpstrSchema : System.IntPtr
            public cbSizeInstance : number
            public typekind : System.Runtime.InteropServices.ComTypes.TYPEKIND
            public cFuncs : number
            public cVars : number
            public cImplTypes : number
            public cbSizeVft : number
            public cbAlignment : number
            public wTypeFlags : System.Runtime.InteropServices.ComTypes.TYPEFLAGS
            public wMajorVerNum : number
            public wMinorVerNum : number
            public tdescAlias : System.Runtime.InteropServices.ComTypes.TYPEDESC
            public idldescType : System.Runtime.InteropServices.ComTypes.IDLDESC
        }
        class TYPEDESC extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public lpValue : System.IntPtr
            public vt : number
        }
        class IDLDESC extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public dwReserved : System.IntPtr
            public wIDLFlags : System.Runtime.InteropServices.ComTypes.IDLFLAG
        }
        class FUNCDESC extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public memid : number
            public lprgscode : System.IntPtr
            public lprgelemdescParam : System.IntPtr
            public funckind : System.Runtime.InteropServices.ComTypes.FUNCKIND
            public invkind : System.Runtime.InteropServices.ComTypes.INVOKEKIND
            public callconv : System.Runtime.InteropServices.ComTypes.CALLCONV
            public cParams : number
            public cParamsOpt : number
            public oVft : number
            public cScodes : number
            public elemdescFunc : System.Runtime.InteropServices.ComTypes.ELEMDESC
            public wFuncFlags : number
        }
        enum FUNCKIND
        { FUNC_VIRTUAL = 0, FUNC_PUREVIRTUAL = 1, FUNC_NONVIRTUAL = 2, FUNC_STATIC = 3, FUNC_DISPATCH = 4 }
        enum INVOKEKIND
        { INVOKE_FUNC = 1, INVOKE_PROPERTYGET = 2, INVOKE_PROPERTYPUT = 4, INVOKE_PROPERTYPUTREF = 8 }
        enum CALLCONV
        { CC_CDECL = 1, CC_MSCPASCAL = 2, CC_PASCAL = 2, CC_MACPASCAL = 3, CC_STDCALL = 4, CC_RESERVED = 5, CC_SYSCALL = 6, CC_MPWCDECL = 7, CC_MPWPASCAL = 8, CC_MAX = 9 }
        class ELEMDESC extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public tdesc : System.Runtime.InteropServices.ComTypes.TYPEDESC
            public desc : System.Runtime.InteropServices.ComTypes.ELEMDESC.DESCUNION
        }
        enum IDLFLAG
        { IDLFLAG_NONE = 0, IDLFLAG_FIN = 1, IDLFLAG_FOUT = 2, IDLFLAG_FLCID = 4, IDLFLAG_FRETVAL = 8 }
        enum PARAMFLAG
        { PARAMFLAG_NONE = 0, PARAMFLAG_FIN = 1, PARAMFLAG_FOUT = 2, PARAMFLAG_FLCID = 4, PARAMFLAG_FRETVAL = 8, PARAMFLAG_FOPT = 16, PARAMFLAG_FHASDEFAULT = 32, PARAMFLAG_FHASCUSTDATA = 64 }
        class PARAMDESC extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public lpVarValue : System.IntPtr
            public wParamFlags : System.Runtime.InteropServices.ComTypes.PARAMFLAG
        }
        enum VARKIND
        { VAR_PERINSTANCE = 0, VAR_STATIC = 1, VAR_CONST = 2, VAR_DISPATCH = 3 }
        class VARDESC extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public memid : number
            public lpstrSchema : string
            public desc : System.Runtime.InteropServices.ComTypes.VARDESC.DESCUNION
            public elemdescVar : System.Runtime.InteropServices.ComTypes.ELEMDESC
            public wVarFlags : number
            public varkind : System.Runtime.InteropServices.ComTypes.VARKIND
        }
        class DISPPARAMS extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public rgvarg : System.IntPtr
            public rgdispidNamedArgs : System.IntPtr
            public cArgs : number
            public cNamedArgs : number
        }
        class EXCEPINFO extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public wCode : number
            public wReserved : number
            public bstrSource : string
            public bstrDescription : string
            public bstrHelpFile : string
            public dwHelpContext : number
            public pvReserved : System.IntPtr
            public pfnDeferredFillIn : System.IntPtr
            public scode : number
        }
        enum FUNCFLAGS
        { FUNCFLAG_FRESTRICTED = 1, FUNCFLAG_FSOURCE = 2, FUNCFLAG_FBINDABLE = 4, FUNCFLAG_FREQUESTEDIT = 8, FUNCFLAG_FDISPLAYBIND = 16, FUNCFLAG_FDEFAULTBIND = 32, FUNCFLAG_FHIDDEN = 64, FUNCFLAG_FUSESGETLASTERROR = 128, FUNCFLAG_FDEFAULTCOLLELEM = 256, FUNCFLAG_FUIDEFAULT = 512, FUNCFLAG_FNONBROWSABLE = 1024, FUNCFLAG_FREPLACEABLE = 2048, FUNCFLAG_FIMMEDIATEBIND = 4096 }
        enum VARFLAGS
        { VARFLAG_FREADONLY = 1, VARFLAG_FSOURCE = 2, VARFLAG_FBINDABLE = 4, VARFLAG_FREQUESTEDIT = 8, VARFLAG_FDISPLAYBIND = 16, VARFLAG_FDEFAULTBIND = 32, VARFLAG_FHIDDEN = 64, VARFLAG_FRESTRICTED = 128, VARFLAG_FDEFAULTCOLLELEM = 256, VARFLAG_FUIDEFAULT = 512, VARFLAG_FNONBROWSABLE = 1024, VARFLAG_FREPLACEABLE = 2048, VARFLAG_FIMMEDIATEBIND = 4096 }
        interface ITypeInfo2 extends System.Runtime.InteropServices.ComTypes.ITypeInfo
        {
            GetTypeAttr ($ppTypeAttr: $Ref<System.IntPtr>) : void
            GetTypeComp ($ppTComp: $Ref<System.Runtime.InteropServices.ComTypes.ITypeComp>) : void
            GetFuncDesc ($index: number, $ppFuncDesc: $Ref<System.IntPtr>) : void
            GetVarDesc ($index: number, $ppVarDesc: $Ref<System.IntPtr>) : void
            GetNames ($memid: number, $rgBstrNames: System.Array$1<string>, $cMaxNames: number, $pcNames: $Ref<number>) : void
            GetRefTypeOfImplType ($index: number, $href: $Ref<number>) : void
            GetImplTypeFlags ($index: number, $pImplTypeFlags: $Ref<System.Runtime.InteropServices.ComTypes.IMPLTYPEFLAGS>) : void
            GetIDsOfNames ($rgszNames: System.Array$1<string>, $cNames: number, $pMemId: System.Array$1<number>) : void
            Invoke ($pvInstance: any, $memid: number, $wFlags: number, $pDispParams: $Ref<System.Runtime.InteropServices.ComTypes.DISPPARAMS>, $pVarResult: System.IntPtr, $pExcepInfo: System.IntPtr, $puArgErr: $Ref<number>) : void
            GetDocumentation ($index: number, $strName: $Ref<string>, $strDocString: $Ref<string>, $dwHelpContext: $Ref<number>, $strHelpFile: $Ref<string>) : void
            GetDllEntry ($memid: number, $invKind: System.Runtime.InteropServices.ComTypes.INVOKEKIND, $pBstrDllName: System.IntPtr, $pBstrName: System.IntPtr, $pwOrdinal: System.IntPtr) : void
            GetRefTypeInfo ($hRef: number, $ppTI: $Ref<System.Runtime.InteropServices.ComTypes.ITypeInfo>) : void
            AddressOfMember ($memid: number, $invKind: System.Runtime.InteropServices.ComTypes.INVOKEKIND, $ppv: $Ref<System.IntPtr>) : void
            CreateInstance ($pUnkOuter: any, $riid: $Ref<System.Guid>, $ppvObj: $Ref<any>) : void
            GetMops ($memid: number, $pBstrMops: $Ref<string>) : void
            GetContainingTypeLib ($ppTLB: $Ref<System.Runtime.InteropServices.ComTypes.ITypeLib>, $pIndex: $Ref<number>) : void
            ReleaseTypeAttr ($pTypeAttr: System.IntPtr) : void
            ReleaseFuncDesc ($pFuncDesc: System.IntPtr) : void
            ReleaseVarDesc ($pVarDesc: System.IntPtr) : void
            GetTypeKind ($pTypeKind: $Ref<System.Runtime.InteropServices.ComTypes.TYPEKIND>) : void
            GetTypeFlags ($pTypeFlags: $Ref<number>) : void
            GetFuncIndexOfMemId ($memid: number, $invKind: System.Runtime.InteropServices.ComTypes.INVOKEKIND, $pFuncIndex: $Ref<number>) : void
            GetVarIndexOfMemId ($memid: number, $pVarIndex: $Ref<number>) : void
            GetCustData ($guid: $Ref<System.Guid>, $pVarVal: $Ref<any>) : void
            GetFuncCustData ($index: number, $guid: $Ref<System.Guid>, $pVarVal: $Ref<any>) : void
            GetParamCustData ($indexFunc: number, $indexParam: number, $guid: $Ref<System.Guid>, $pVarVal: $Ref<any>) : void
            GetVarCustData ($index: number, $guid: $Ref<System.Guid>, $pVarVal: $Ref<any>) : void
            GetImplTypeCustData ($index: number, $guid: $Ref<System.Guid>, $pVarVal: $Ref<any>) : void
            GetDocumentation2 ($memid: number, $pbstrHelpString: $Ref<string>, $pdwHelpStringContext: $Ref<number>, $pbstrHelpStringDll: $Ref<string>) : void
            GetAllCustData ($pCustData: System.IntPtr) : void
            GetAllFuncCustData ($index: number, $pCustData: System.IntPtr) : void
            GetAllParamCustData ($indexFunc: number, $indexParam: number, $pCustData: System.IntPtr) : void
            GetAllVarCustData ($index: number, $pCustData: System.IntPtr) : void
            GetAllImplTypeCustData ($index: number, $pCustData: System.IntPtr) : void
        }
        enum SYSKIND
        { SYS_WIN16 = 0, SYS_WIN32 = 1, SYS_MAC = 2, SYS_WIN64 = 3 }
        enum LIBFLAGS
        { LIBFLAG_FRESTRICTED = 1, LIBFLAG_FCONTROL = 2, LIBFLAG_FHIDDEN = 4, LIBFLAG_FHASDISKIMAGE = 8 }
        class TYPELIBATTR extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public guid : System.Guid
            public lcid : number
            public syskind : System.Runtime.InteropServices.ComTypes.SYSKIND
            public wMajorVerNum : number
            public wMinorVerNum : number
            public wLibFlags : System.Runtime.InteropServices.ComTypes.LIBFLAGS
        }
        interface ITypeLib2 extends System.Runtime.InteropServices.ComTypes.ITypeLib
        {
            GetTypeInfoCount () : number
            GetTypeInfo ($index: number, $ppTI: $Ref<System.Runtime.InteropServices.ComTypes.ITypeInfo>) : void
            GetTypeInfoType ($index: number, $pTKind: $Ref<System.Runtime.InteropServices.ComTypes.TYPEKIND>) : void
            GetTypeInfoOfGuid ($guid: $Ref<System.Guid>, $ppTInfo: $Ref<System.Runtime.InteropServices.ComTypes.ITypeInfo>) : void
            GetLibAttr ($ppTLibAttr: $Ref<System.IntPtr>) : void
            GetTypeComp ($ppTComp: $Ref<System.Runtime.InteropServices.ComTypes.ITypeComp>) : void
            GetDocumentation ($index: number, $strName: $Ref<string>, $strDocString: $Ref<string>, $dwHelpContext: $Ref<number>, $strHelpFile: $Ref<string>) : void
            IsName ($szNameBuf: string, $lHashVal: number) : boolean
            FindName ($szNameBuf: string, $lHashVal: number, $ppTInfo: System.Array$1<System.Runtime.InteropServices.ComTypes.ITypeInfo>, $rgMemId: System.Array$1<number>, $pcFound: $Ref<number>) : void
            ReleaseTLibAttr ($pTLibAttr: System.IntPtr) : void
            GetCustData ($guid: $Ref<System.Guid>, $pVarVal: $Ref<any>) : void
            GetDocumentation2 ($index: number, $pbstrHelpString: $Ref<string>, $pdwHelpStringContext: $Ref<number>, $pbstrHelpStringDll: $Ref<string>) : void
            GetLibStatistics ($pcUniqueNames: System.IntPtr, $pcchUniqueNames: $Ref<number>) : void
            GetAllCustData ($pCustData: System.IntPtr) : void
        }
    }
    namespace System.Runtime.InteropServices.WindowsRuntime {
        class DefaultInterfaceAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get DefaultInterface(): System.Type;
            public constructor ($defaultInterface: System.Type)
            public constructor ()
        }
        class InterfaceImplementedInVersionAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get InterfaceType(): System.Type;
            public get MajorVersion(): number;
            public get MinorVersion(): number;
            public get BuildVersion(): number;
            public get RevisionVersion(): number;
            public constructor ($interfaceType: System.Type, $majorVersion: number, $minorVersion: number, $buildVersion: number, $revisionVersion: number)
            public constructor ()
        }
        class ReadOnlyArrayAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class WriteOnlyArrayAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class ReturnValueNameAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Name(): string;
            public constructor ($name: string)
            public constructor ()
        }
        class EventRegistrationToken extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public static op_Equality ($left: System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken, $right: System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken) : boolean
            public static op_Inequality ($left: System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken, $right: System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken) : boolean
        }
        class EventRegistrationTokenTable$1<T> extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get InvocationList(): T;
            public set InvocationList(value: T);
            public AddEventHandler ($handler: T) : System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken
            public RemoveEventHandler ($token: System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken) : void
            public RemoveEventHandler ($handler: T) : void
            public static GetOrCreateEventRegistrationTokenTable ($refEventTable: any) : any
            public constructor ()
        }
        interface IActivationFactory
        {
            ActivateInstance () : any
        }
        class WindowsRuntimeMarshal extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static RemoveAllEventHandlers ($removeMethod: System.Action$1<System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken>) : void
            public static GetActivationFactory ($type: System.Type) : System.Runtime.InteropServices.WindowsRuntime.IActivationFactory
            public static StringToHString ($s: string) : System.IntPtr
            public static PtrToStringHString ($ptr: System.IntPtr) : string
            public static FreeHString ($ptr: System.IntPtr) : void
        }
        class DesignerNamespaceResolveEventArgs extends System.EventArgs
        {
            protected [__keep_incompatibility]: never;
            public get NamespaceName(): string;
            public get ResolvedAssemblyFiles(): System.Collections.ObjectModel.Collection$1<string>;
            public constructor ($namespaceName: string)
            public constructor ()
        }
        class NamespaceResolveEventArgs extends System.EventArgs
        {
            protected [__keep_incompatibility]: never;
            public get NamespaceName(): string;
            public get RequestingAssembly(): System.Reflection.Assembly;
            public get ResolvedAssemblies(): System.Collections.ObjectModel.Collection$1<System.Reflection.Assembly>;
            public constructor ($namespaceName: string, $requestingAssembly: System.Reflection.Assembly)
            public constructor ()
        }
        class WindowsRuntimeMetadata extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static ResolveNamespace ($namespaceName: string, $packageGraphFilePaths: System.Collections.Generic.IEnumerable$1<string>) : System.Collections.Generic.IEnumerable$1<string>
            public static ResolveNamespace ($namespaceName: string, $windowsSdkFilePath: string, $packageGraphFilePaths: System.Collections.Generic.IEnumerable$1<string>) : System.Collections.Generic.IEnumerable$1<string>
            public static add_DesignerNamespaceResolve ($value: System.EventHandler$1<System.Runtime.InteropServices.WindowsRuntime.DesignerNamespaceResolveEventArgs>) : void
            public static remove_DesignerNamespaceResolve ($value: System.EventHandler$1<System.Runtime.InteropServices.WindowsRuntime.DesignerNamespaceResolveEventArgs>) : void
            public static add_ReflectionOnlyNamespaceResolve ($value: System.EventHandler$1<System.Runtime.InteropServices.WindowsRuntime.NamespaceResolveEventArgs>) : void
            public static remove_ReflectionOnlyNamespaceResolve ($value: System.EventHandler$1<System.Runtime.InteropServices.WindowsRuntime.NamespaceResolveEventArgs>) : void
        }
    }
    namespace System.Runtime.InteropServices.Expando {
        interface IExpando extends System.Reflection.IReflect
        {
            UnderlyingSystemType : System.Type
            AddField ($name: string) : System.Reflection.FieldInfo
            AddProperty ($name: string) : System.Reflection.PropertyInfo
            AddMethod ($name: string, $method: Function) : System.Reflection.MethodInfo
            RemoveMember ($m: System.Reflection.MemberInfo) : void
            GetMethod ($name: string, $bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>) : System.Reflection.MethodInfo
            GetMethod ($name: string, $bindingAttr: System.Reflection.BindingFlags) : System.Reflection.MethodInfo
            GetMethods ($bindingAttr: System.Reflection.BindingFlags) : System.Array$1<System.Reflection.MethodInfo>
            GetField ($name: string, $bindingAttr: System.Reflection.BindingFlags) : System.Reflection.FieldInfo
            GetFields ($bindingAttr: System.Reflection.BindingFlags) : System.Array$1<System.Reflection.FieldInfo>
            GetProperty ($name: string, $bindingAttr: System.Reflection.BindingFlags) : System.Reflection.PropertyInfo
            GetProperty ($name: string, $bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $returnType: System.Type, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>) : System.Reflection.PropertyInfo
            GetProperties ($bindingAttr: System.Reflection.BindingFlags) : System.Array$1<System.Reflection.PropertyInfo>
            GetMember ($name: string, $bindingAttr: System.Reflection.BindingFlags) : System.Array$1<System.Reflection.MemberInfo>
            GetMembers ($bindingAttr: System.Reflection.BindingFlags) : System.Array$1<System.Reflection.MemberInfo>
            InvokeMember ($name: string, $invokeAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $target: any, $args: System.Array$1<any>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>, $culture: System.Globalization.CultureInfo, $namedParameters: System.Array$1<string>) : any
        }
    }
    namespace System.Runtime.InteropServices.ComTypes.ELEMDESC {
        class DESCUNION extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public idldesc : System.Runtime.InteropServices.ComTypes.IDLDESC
            public paramdesc : System.Runtime.InteropServices.ComTypes.PARAMDESC
        }
    }
    namespace System.Runtime.InteropServices.ComTypes.VARDESC {
        class DESCUNION extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public oInst : number
            public lpvarValue : System.IntPtr
        }
    }
    namespace System.Runtime.CompilerServices.ConfiguredCancelableAsyncEnumerable$1 {
        class Enumerator<T> extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get Current(): T;
            public MoveNextAsync () : System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable$1<boolean>
            public DisposeAsync () : System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable
        }
    }
    namespace System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable {
        class ConfiguredValueTaskAwaiter extends System.ValueType implements System.Runtime.CompilerServices.INotifyCompletion, System.Runtime.CompilerServices.ICriticalNotifyCompletion
        {
            protected [__keep_incompatibility]: never;
            public get IsCompleted(): boolean;
            public GetResult () : void
            public OnCompleted ($continuation: System.Action) : void
            public UnsafeOnCompleted ($continuation: System.Action) : void
        }
    }
    namespace System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable$1 {
        class ConfiguredValueTaskAwaiter<TResult> extends System.ValueType implements System.Runtime.CompilerServices.INotifyCompletion, System.Runtime.CompilerServices.ICriticalNotifyCompletion
        {
            protected [__keep_incompatibility]: never;
            public get IsCompleted(): boolean;
            public GetResult () : TResult
            public OnCompleted ($continuation: System.Action) : void
            public UnsafeOnCompleted ($continuation: System.Action) : void
        }
    }
    namespace System.Runtime.CompilerServices.ConfiguredTaskAwaitable {
        class ConfiguredTaskAwaiter extends System.ValueType implements System.Runtime.CompilerServices.INotifyCompletion, System.Runtime.CompilerServices.ICriticalNotifyCompletion, System.Runtime.CompilerServices.IConfiguredTaskAwaiter
        {
            protected [__keep_incompatibility]: never;
            public get IsCompleted(): boolean;
            public OnCompleted ($continuation: System.Action) : void
            public UnsafeOnCompleted ($continuation: System.Action) : void
            public GetResult () : void
        }
    }
    namespace System.Runtime.CompilerServices.ConfiguredTaskAwaitable$1 {
        class ConfiguredTaskAwaiter<TResult> extends System.ValueType implements System.Runtime.CompilerServices.INotifyCompletion, System.Runtime.CompilerServices.ICriticalNotifyCompletion, System.Runtime.CompilerServices.IConfiguredTaskAwaiter
        {
            protected [__keep_incompatibility]: never;
            public get IsCompleted(): boolean;
            public OnCompleted ($continuation: System.Action) : void
            public UnsafeOnCompleted ($continuation: System.Action) : void
            public GetResult () : TResult
        }
    }
    namespace System.Diagnostics.Contracts {
        enum ContractFailureKind
        { Precondition = 0, Postcondition = 1, PostconditionOnException = 2, Invariant = 3, Assert = 4, Assume = 5 }
        class PureAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class ContractClassAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get TypeContainingContracts(): System.Type;
            public constructor ($typeContainingContracts: System.Type)
            public constructor ()
        }
        class ContractClassForAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get TypeContractsAreFor(): System.Type;
            public constructor ($typeContractsAreFor: System.Type)
            public constructor ()
        }
        class ContractInvariantMethodAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class ContractReferenceAssemblyAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class ContractRuntimeIgnoredAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class ContractVerificationAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Value(): boolean;
            public constructor ($value: boolean)
            public constructor ()
        }
        class ContractPublicPropertyNameAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Name(): string;
            public constructor ($name: string)
            public constructor ()
        }
        class ContractArgumentValidatorAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class ContractAbbreviatorAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class ContractOptionAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Category(): string;
            public get Setting(): string;
            public get Enabled(): boolean;
            public get Value(): string;
            public constructor ($category: string, $setting: string, $enabled: boolean)
            public constructor ($category: string, $setting: string, $value: string)
            public constructor ()
        }
        class Contract extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static Assume ($condition: boolean) : void
            public static Assume ($condition: boolean, $userMessage: string) : void
            public static Assert ($condition: boolean) : void
            public static Assert ($condition: boolean, $userMessage: string) : void
            public static Requires ($condition: boolean) : void
            public static Requires ($condition: boolean, $userMessage: string) : void
            public static Ensures ($condition: boolean) : void
            public static Ensures ($condition: boolean, $userMessage: string) : void
            public static Invariant ($condition: boolean) : void
            public static Invariant ($condition: boolean, $userMessage: string) : void
            public static ForAll ($fromInclusive: number, $toExclusive: number, $predicate: System.Predicate$1<number>) : boolean
            public static Exists ($fromInclusive: number, $toExclusive: number, $predicate: System.Predicate$1<number>) : boolean
            public static EndContractBlock () : void
            public static add_ContractFailed ($value: System.EventHandler$1<System.Diagnostics.Contracts.ContractFailedEventArgs>) : void
            public static remove_ContractFailed ($value: System.EventHandler$1<System.Diagnostics.Contracts.ContractFailedEventArgs>) : void
        }
        class ContractFailedEventArgs extends System.EventArgs
        {
            protected [__keep_incompatibility]: never;
            public get Message(): string;
            public get Condition(): string;
            public get FailureKind(): System.Diagnostics.Contracts.ContractFailureKind;
            public get OriginalException(): System.Exception;
            public get Handled(): boolean;
            public get Unwind(): boolean;
            public SetHandled () : void
            public SetUnwind () : void
            public constructor ($failureKind: System.Diagnostics.Contracts.ContractFailureKind, $message: string, $condition: string, $originalException: System.Exception)
            public constructor ()
        }
    }
    namespace System.Runtime.CompilerServices.YieldAwaitable {
        class YieldAwaiter extends System.ValueType implements System.Runtime.CompilerServices.INotifyCompletion, System.Runtime.CompilerServices.ICriticalNotifyCompletion
        {
            protected [__keep_incompatibility]: never;
            public get IsCompleted(): boolean;
            public OnCompleted ($continuation: System.Action) : void
            public UnsafeOnCompleted ($continuation: System.Action) : void
            public GetResult () : void
        }
    }
    namespace System.Runtime.CompilerServices.ConditionalWeakTable$2 {
        interface CreateValueCallback<TKey, TValue>
        { 
        (key: TKey) : TValue; 
        Invoke?: (key: TKey) => TValue;
        }
    }
    namespace System.Runtime.CompilerServices.RuntimeHelpers {
        interface TryCode
        { 
        (userData: any) : void; 
        Invoke?: (userData: any) => void;
        }
        var TryCode: { new (func: (userData: any) => void): TryCode; }
        interface CleanupCode
        { 
        (userData: any, exceptionThrown: boolean) : void; 
        Invoke?: (userData: any, exceptionThrown: boolean) => void;
        }
        var CleanupCode: { new (func: (userData: any, exceptionThrown: boolean) => void): CleanupCode; }
    }
    namespace System.Resources {
        interface IResourceReader extends System.Collections.IEnumerable, System.IDisposable
        {
            Close () : void
            GetEnumerator () : System.Collections.IDictionaryEnumerator
            GetEnumerator () : System.Collections.IEnumerator
        }
        class MissingManifestResourceException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $inner: System.Exception)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class MissingSatelliteAssemblyException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public get CultureName(): string;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $cultureName: string)
            public constructor ($message: string, $inner: System.Exception)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class NeutralResourcesLanguageAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get CultureName(): string;
            public get Location(): System.Resources.UltimateResourceFallbackLocation;
            public constructor ($cultureName: string)
            public constructor ($cultureName: string, $location: System.Resources.UltimateResourceFallbackLocation)
            public constructor ()
        }
        enum UltimateResourceFallbackLocation
        { MainAssembly = 0, Satellite = 1 }
        class SatelliteContractVersionAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Version(): string;
            public constructor ($version: string)
            public constructor ()
        }
        interface IResourceWriter extends System.IDisposable
        {
            AddResource ($name: string, $value: string) : void
            AddResource ($name: string, $value: any) : void
            AddResource ($name: string, $value: System.Array$1<number>) : void
            Close () : void
            Generate () : void
        }
        class ResourceManager extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static MagicNumber : number
            public static HeaderVersionNumber : number
            public get BaseName(): string;
            public get IgnoreCase(): boolean;
            public set IgnoreCase(value: boolean);
            public get ResourceSetType(): System.Type;
            public ReleaseAllResources () : void
            public static CreateFileBasedResourceManager ($baseName: string, $resourceDir: string, $usingResourceSet: System.Type) : System.Resources.ResourceManager
            public GetResourceSet ($culture: System.Globalization.CultureInfo, $createIfNotExists: boolean, $tryParents: boolean) : System.Resources.ResourceSet
            public GetString ($name: string) : string
            public GetString ($name: string, $culture: System.Globalization.CultureInfo) : string
            public GetObject ($name: string) : any
            public GetObject ($name: string, $culture: System.Globalization.CultureInfo) : any
            public GetStream ($name: string) : System.IO.UnmanagedMemoryStream
            public GetStream ($name: string, $culture: System.Globalization.CultureInfo) : System.IO.UnmanagedMemoryStream
            public constructor ($baseName: string, $assembly: System.Reflection.Assembly)
            public constructor ($baseName: string, $assembly: System.Reflection.Assembly, $usingResourceSet: System.Type)
            public constructor ($resourceSource: System.Type)
            public constructor ()
        }
        class ResourceSet extends System.Object implements System.Collections.IEnumerable, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public Close () : void
            public Dispose () : void
            public GetDefaultReader () : System.Type
            public GetDefaultWriter () : System.Type
            public GetEnumerator () : System.Collections.IDictionaryEnumerator
            public GetString ($name: string) : string
            public GetString ($name: string, $ignoreCase: boolean) : string
            public GetObject ($name: string) : any
            public GetObject ($name: string, $ignoreCase: boolean) : any
            public constructor ($fileName: string)
            public constructor ($stream: System.IO.Stream)
            public constructor ($reader: System.Resources.IResourceReader)
            public GetEnumerator () : System.Collections.IEnumerator
            public constructor ()
        }
        class ResourceReader extends System.Object implements System.Resources.IResourceReader, System.Collections.IEnumerable, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public Close () : void
            public Dispose () : void
            public GetEnumerator () : System.Collections.IDictionaryEnumerator
            public GetResourceData ($resourceName: string, $resourceType: $Ref<string>, $resourceData: $Ref<System.Array$1<number>>) : void
            public constructor ($fileName: string)
            public constructor ($stream: System.IO.Stream)
            public GetEnumerator () : System.Collections.IEnumerator
            public constructor ()
        }
        class ResourceWriter extends System.Object implements System.Resources.IResourceWriter, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get TypeNameConverter(): System.Func$2<System.Type, string>;
            public set TypeNameConverter(value: System.Func$2<System.Type, string>);
            public AddResource ($name: string, $value: string) : void
            public AddResource ($name: string, $value: any) : void
            public AddResource ($name: string, $value: System.IO.Stream) : void
            public AddResource ($name: string, $value: System.IO.Stream, $closeAfterWrite: boolean) : void
            public AddResource ($name: string, $value: System.Array$1<number>) : void
            public AddResourceData ($name: string, $typeName: string, $serializedData: System.Array$1<number>) : void
            public Close () : void
            public Dispose () : void
            public Generate () : void
            public constructor ($fileName: string)
            public constructor ($stream: System.IO.Stream)
            public constructor ()
        }
    }
    namespace System.Reflection.Metadata {
        class AssemblyExtensions extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static TryGetRawMetadata ($assembly: System.Reflection.Assembly, $blob: $Ref<System.Byte>, $length: $Ref<number>) : boolean
        }
    }
    namespace System.Diagnostics.SymbolStore {
        interface ISymbolDocumentWriter
        {
            SetCheckSum ($algorithmId: System.Guid, $checkSum: System.Array$1<number>) : void
            SetSource ($source: System.Array$1<number>) : void
        }
        interface ISymbolWriter
        {
            Close () : void
            CloseMethod () : void
            CloseNamespace () : void
            CloseScope ($endOffset: number) : void
            DefineDocument ($url: string, $language: System.Guid, $languageVendor: System.Guid, $documentType: System.Guid) : System.Diagnostics.SymbolStore.ISymbolDocumentWriter
            DefineField ($parent: System.Diagnostics.SymbolStore.SymbolToken, $name: string, $attributes: System.Reflection.FieldAttributes, $signature: System.Array$1<number>, $addrKind: System.Diagnostics.SymbolStore.SymAddressKind, $addr1: number, $addr2: number, $addr3: number) : void
            DefineGlobalVariable ($name: string, $attributes: System.Reflection.FieldAttributes, $signature: System.Array$1<number>, $addrKind: System.Diagnostics.SymbolStore.SymAddressKind, $addr1: number, $addr2: number, $addr3: number) : void
            DefineLocalVariable ($name: string, $attributes: System.Reflection.FieldAttributes, $signature: System.Array$1<number>, $addrKind: System.Diagnostics.SymbolStore.SymAddressKind, $addr1: number, $addr2: number, $addr3: number, $startOffset: number, $endOffset: number) : void
            DefineParameter ($name: string, $attributes: System.Reflection.ParameterAttributes, $sequence: number, $addrKind: System.Diagnostics.SymbolStore.SymAddressKind, $addr1: number, $addr2: number, $addr3: number) : void
            DefineSequencePoints ($document: System.Diagnostics.SymbolStore.ISymbolDocumentWriter, $offsets: System.Array$1<number>, $lines: System.Array$1<number>, $columns: System.Array$1<number>, $endLines: System.Array$1<number>, $endColumns: System.Array$1<number>) : void
            Initialize ($emitter: System.IntPtr, $filename: string, $fFullBuild: boolean) : void
            OpenMethod ($method: System.Diagnostics.SymbolStore.SymbolToken) : void
            OpenNamespace ($name: string) : void
            OpenScope ($startOffset: number) : number
            SetMethodSourceRange ($startDoc: System.Diagnostics.SymbolStore.ISymbolDocumentWriter, $startLine: number, $startColumn: number, $endDoc: System.Diagnostics.SymbolStore.ISymbolDocumentWriter, $endLine: number, $endColumn: number) : void
            SetScopeRange ($scopeID: number, $startOffset: number, $endOffset: number) : void
            SetSymAttribute ($parent: System.Diagnostics.SymbolStore.SymbolToken, $name: string, $data: System.Array$1<number>) : void
            SetUnderlyingWriter ($underlyingWriter: System.IntPtr) : void
            SetUserEntryPoint ($entryMethod: System.Diagnostics.SymbolStore.SymbolToken) : void
            UsingNamespace ($fullName: string) : void
        }
        class SymbolToken extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public GetToken () : number
            public Equals ($obj: any) : boolean
            public Equals ($obj: System.Diagnostics.SymbolStore.SymbolToken) : boolean
            public static op_Equality ($a: System.Diagnostics.SymbolStore.SymbolToken, $b: System.Diagnostics.SymbolStore.SymbolToken) : boolean
            public static op_Inequality ($a: System.Diagnostics.SymbolStore.SymbolToken, $b: System.Diagnostics.SymbolStore.SymbolToken) : boolean
            public constructor ($val: number)
            public static Equals ($objA: any, $objB: any) : boolean
            public constructor ()
        }
        interface ISymbolBinder
        {
        }
        interface ISymbolReader
        {
            UserEntryPoint : System.Diagnostics.SymbolStore.SymbolToken
            GetDocument ($url: string, $language: System.Guid, $languageVendor: System.Guid, $documentType: System.Guid) : System.Diagnostics.SymbolStore.ISymbolDocument
            GetDocuments () : System.Array$1<System.Diagnostics.SymbolStore.ISymbolDocument>
            GetGlobalVariables () : System.Array$1<System.Diagnostics.SymbolStore.ISymbolVariable>
            GetMethod ($method: System.Diagnostics.SymbolStore.SymbolToken) : System.Diagnostics.SymbolStore.ISymbolMethod
            GetMethod ($method: System.Diagnostics.SymbolStore.SymbolToken, $version: number) : System.Diagnostics.SymbolStore.ISymbolMethod
            GetMethodFromDocumentPosition ($document: System.Diagnostics.SymbolStore.ISymbolDocument, $line: number, $column: number) : System.Diagnostics.SymbolStore.ISymbolMethod
            GetNamespaces () : System.Array$1<System.Diagnostics.SymbolStore.ISymbolNamespace>
            GetSymAttribute ($parent: System.Diagnostics.SymbolStore.SymbolToken, $name: string) : System.Array$1<number>
            GetVariables ($parent: System.Diagnostics.SymbolStore.SymbolToken) : System.Array$1<System.Diagnostics.SymbolStore.ISymbolVariable>
        }
        interface ISymbolBinder1
        {
            GetReader ($importer: System.IntPtr, $filename: string, $searchPath: string) : System.Diagnostics.SymbolStore.ISymbolReader
        }
        interface ISymbolDocument
        {
            CheckSumAlgorithmId : System.Guid
            DocumentType : System.Guid
            HasEmbeddedSource : boolean
            Language : System.Guid
            LanguageVendor : System.Guid
            SourceLength : number
            URL : string
            FindClosestLine ($line: number) : number
            GetCheckSum () : System.Array$1<number>
            GetSourceRange ($startLine: number, $startColumn: number, $endLine: number, $endColumn: number) : System.Array$1<number>
        }
        interface ISymbolMethod
        {
            RootScope : System.Diagnostics.SymbolStore.ISymbolScope
            SequencePointCount : number
            Token : System.Diagnostics.SymbolStore.SymbolToken
            GetNamespace () : System.Diagnostics.SymbolStore.ISymbolNamespace
            GetOffset ($document: System.Diagnostics.SymbolStore.ISymbolDocument, $line: number, $column: number) : number
            GetParameters () : System.Array$1<System.Diagnostics.SymbolStore.ISymbolVariable>
            GetRanges ($document: System.Diagnostics.SymbolStore.ISymbolDocument, $line: number, $column: number) : System.Array$1<number>
            GetScope ($offset: number) : System.Diagnostics.SymbolStore.ISymbolScope
            GetSequencePoints ($offsets: System.Array$1<number>, $documents: System.Array$1<System.Diagnostics.SymbolStore.ISymbolDocument>, $lines: System.Array$1<number>, $columns: System.Array$1<number>, $endLines: System.Array$1<number>, $endColumns: System.Array$1<number>) : void
            GetSourceStartEnd ($docs: System.Array$1<System.Diagnostics.SymbolStore.ISymbolDocument>, $lines: System.Array$1<number>, $columns: System.Array$1<number>) : boolean
        }
        interface ISymbolScope
        {
            EndOffset : number
            Method : System.Diagnostics.SymbolStore.ISymbolMethod
            Parent : System.Diagnostics.SymbolStore.ISymbolScope
            StartOffset : number
            GetChildren () : System.Array$1<System.Diagnostics.SymbolStore.ISymbolScope>
            GetLocals () : System.Array$1<System.Diagnostics.SymbolStore.ISymbolVariable>
            GetNamespaces () : System.Array$1<System.Diagnostics.SymbolStore.ISymbolNamespace>
        }
        interface ISymbolNamespace
        {
            Name : string
            GetNamespaces () : System.Array$1<System.Diagnostics.SymbolStore.ISymbolNamespace>
            GetVariables () : System.Array$1<System.Diagnostics.SymbolStore.ISymbolVariable>
        }
        interface ISymbolVariable
        {
            AddressField1 : number
            AddressField2 : number
            AddressField3 : number
            AddressKind : System.Diagnostics.SymbolStore.SymAddressKind
            Attributes : any
            EndOffset : number
            Name : string
            StartOffset : number
            GetSignature () : System.Array$1<number>
        }
        enum SymAddressKind
        { ILOffset = 1, NativeRVA = 2, NativeRegister = 3, NativeRegisterRelative = 4, NativeOffset = 5, NativeRegisterRegister = 6, NativeRegisterStack = 7, NativeStackRegister = 8, BitField = 9, NativeSectionOffset = 10 }
        class SymDocumentType extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static Text : System.Guid
            public constructor ()
        }
        class SymLanguageType extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static Basic : System.Guid
            public static C : System.Guid
            public static Cobol : System.Guid
            public static CPlusPlus : System.Guid
            public static CSharp : System.Guid
            public static ILAssembly : System.Guid
            public static Java : System.Guid
            public static JScript : System.Guid
            public static MCPlusPlus : System.Guid
            public static Pascal : System.Guid
            public static SMC : System.Guid
            public constructor ()
        }
        class SymLanguageVendor extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static Microsoft : System.Guid
            public constructor ()
        }
    }
    namespace System.Numerics {
        class Vector$1<T> extends System.ValueType implements System.IFormattable, System.IEquatable$1<System.Numerics.Vector$1<T>>
        {
            protected [__keep_incompatibility]: never;
            public static get Count(): any;
            public static get Zero(): any;
            public static get One(): any;
            public CopyTo ($destination: System.Array$1<T>) : void
            public CopyTo ($destination: System.Array$1<T>, $startIndex: number) : void
            public get_Item ($index: number) : T
            public Equals ($obj: any) : boolean
            public Equals ($other: System.Numerics.Vector$1<T>) : boolean
            public ToString () : string
            public ToString ($format: string) : string
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            public static op_Addition ($left: any, $right: any) : any
            public static op_Subtraction ($left: any, $right: any) : any
            public static op_Multiply ($left: any, $right: any) : any
            public static op_Multiply ($value: any, $factor: any) : any
            public static op_Multiply ($factor: any, $value: any) : any
            public static op_Division ($left: any, $right: any) : any
            public static op_UnaryNegation ($value: any) : any
            public static op_BitwiseAnd ($left: any, $right: any) : any
            public static op_BitwiseOr ($left: any, $right: any) : any
            public static op_ExclusiveOr ($left: any, $right: any) : any
            public static op_OnesComplement ($value: any) : any
            public static op_Equality ($left: any, $right: any) : any
            public static op_Inequality ($left: any, $right: any) : any
            public static op_Explicit ($value: any) : any
            public static op_Explicit ($value: any) : any
            public constructor ($value: T)
            public constructor ($values: System.Array$1<T>)
            public constructor ($values: System.Array$1<T>, $index: number)
            public static Equals ($objA: any, $objB: any) : any
            public constructor ()
        }
        class Vector extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get IsHardwareAccelerated(): boolean;
            public static Widen ($source: System.Numerics.Vector$1<number>, $low: $Ref<System.Numerics.Vector$1<number>>, $high: $Ref<System.Numerics.Vector$1<number>>) : void
            public static Widen ($source: System.Numerics.Vector$1<number>, $low: $Ref<System.Numerics.Vector$1<bigint>>, $high: $Ref<System.Numerics.Vector$1<bigint>>) : void
            public static Narrow ($low: System.Numerics.Vector$1<number>, $high: System.Numerics.Vector$1<number>) : System.Numerics.Vector$1<number>
            public static Narrow ($low: System.Numerics.Vector$1<bigint>, $high: System.Numerics.Vector$1<bigint>) : System.Numerics.Vector$1<number>
            public static ConvertToSingle ($value: System.Numerics.Vector$1<number>) : System.Numerics.Vector$1<number>
            public static ConvertToDouble ($value: System.Numerics.Vector$1<bigint>) : System.Numerics.Vector$1<number>
            public static ConvertToInt32 ($value: System.Numerics.Vector$1<number>) : System.Numerics.Vector$1<number>
            public static ConvertToUInt32 ($value: System.Numerics.Vector$1<number>) : System.Numerics.Vector$1<number>
            public static ConvertToInt64 ($value: System.Numerics.Vector$1<number>) : System.Numerics.Vector$1<bigint>
            public static ConvertToUInt64 ($value: System.Numerics.Vector$1<number>) : System.Numerics.Vector$1<bigint>
            public static ConditionalSelect ($condition: System.Numerics.Vector$1<number>, $left: System.Numerics.Vector$1<number>, $right: System.Numerics.Vector$1<number>) : System.Numerics.Vector$1<number>
            public static ConditionalSelect ($condition: System.Numerics.Vector$1<bigint>, $left: System.Numerics.Vector$1<number>, $right: System.Numerics.Vector$1<number>) : System.Numerics.Vector$1<number>
            public static Equals ($left: System.Numerics.Vector$1<number>, $right: System.Numerics.Vector$1<number>) : System.Numerics.Vector$1<number>
            public static Equals ($left: System.Numerics.Vector$1<number>, $right: System.Numerics.Vector$1<number>) : System.Numerics.Vector$1<bigint>
            public static Equals ($left: System.Numerics.Vector$1<bigint>, $right: System.Numerics.Vector$1<bigint>) : System.Numerics.Vector$1<bigint>
            public static LessThan ($left: System.Numerics.Vector$1<number>, $right: System.Numerics.Vector$1<number>) : System.Numerics.Vector$1<number>
            public static LessThan ($left: System.Numerics.Vector$1<number>, $right: System.Numerics.Vector$1<number>) : System.Numerics.Vector$1<bigint>
            public static LessThan ($left: System.Numerics.Vector$1<bigint>, $right: System.Numerics.Vector$1<bigint>) : System.Numerics.Vector$1<bigint>
            public static LessThanOrEqual ($left: System.Numerics.Vector$1<number>, $right: System.Numerics.Vector$1<number>) : System.Numerics.Vector$1<number>
            public static LessThanOrEqual ($left: System.Numerics.Vector$1<bigint>, $right: System.Numerics.Vector$1<bigint>) : System.Numerics.Vector$1<bigint>
            public static LessThanOrEqual ($left: System.Numerics.Vector$1<number>, $right: System.Numerics.Vector$1<number>) : System.Numerics.Vector$1<bigint>
            public static GreaterThan ($left: System.Numerics.Vector$1<number>, $right: System.Numerics.Vector$1<number>) : System.Numerics.Vector$1<number>
            public static GreaterThan ($left: System.Numerics.Vector$1<number>, $right: System.Numerics.Vector$1<number>) : System.Numerics.Vector$1<bigint>
            public static GreaterThan ($left: System.Numerics.Vector$1<bigint>, $right: System.Numerics.Vector$1<bigint>) : System.Numerics.Vector$1<bigint>
            public static GreaterThanOrEqual ($left: System.Numerics.Vector$1<number>, $right: System.Numerics.Vector$1<number>) : System.Numerics.Vector$1<number>
            public static GreaterThanOrEqual ($left: System.Numerics.Vector$1<bigint>, $right: System.Numerics.Vector$1<bigint>) : System.Numerics.Vector$1<bigint>
            public static GreaterThanOrEqual ($left: System.Numerics.Vector$1<number>, $right: System.Numerics.Vector$1<number>) : System.Numerics.Vector$1<bigint>
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
        }
    }
    namespace System.Diagnostics {
        class ConditionalAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get ConditionString(): string;
            public constructor ($conditionString: string)
            public constructor ()
        }
        class DebuggerStepThroughAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class DebuggerStepperBoundaryAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class DebuggerHiddenAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class DebuggerNonUserCodeAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class DebuggableAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get IsJITTrackingEnabled(): boolean;
            public get IsJITOptimizerDisabled(): boolean;
            public get DebuggingFlags(): System.Diagnostics.DebuggableAttribute.DebuggingModes;
            public constructor ($isJITTrackingEnabled: boolean, $isJITOptimizerDisabled: boolean)
            public constructor ($modes: System.Diagnostics.DebuggableAttribute.DebuggingModes)
            public constructor ()
        }
        enum DebuggerBrowsableState
        { Never = 0, Collapsed = 2, RootHidden = 3 }
        class DebuggerBrowsableAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get State(): System.Diagnostics.DebuggerBrowsableState;
            public constructor ($state: System.Diagnostics.DebuggerBrowsableState)
            public constructor ()
        }
        class DebuggerTypeProxyAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get ProxyTypeName(): string;
            public get Target(): System.Type;
            public set Target(value: System.Type);
            public get TargetTypeName(): string;
            public set TargetTypeName(value: string);
            public constructor ($type: System.Type)
            public constructor ($typeName: string)
            public constructor ()
        }
        class DebuggerDisplayAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Value(): string;
            public get Name(): string;
            public set Name(value: string);
            public get Type(): string;
            public set Type(value: string);
            public get Target(): System.Type;
            public set Target(value: System.Type);
            public get TargetTypeName(): string;
            public set TargetTypeName(value: string);
            public constructor ($value: string)
            public constructor ()
        }
        class DebuggerVisualizerAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get VisualizerObjectSourceTypeName(): string;
            public get VisualizerTypeName(): string;
            public get Description(): string;
            public set Description(value: string);
            public get Target(): System.Type;
            public set Target(value: System.Type);
            public get TargetTypeName(): string;
            public set TargetTypeName(value: string);
            public constructor ($visualizerTypeName: string)
            public constructor ($visualizerTypeName: string, $visualizerObjectSourceTypeName: string)
            public constructor ($visualizerTypeName: string, $visualizerObjectSource: System.Type)
            public constructor ($visualizer: System.Type)
            public constructor ($visualizer: System.Type, $visualizerObjectSource: System.Type)
            public constructor ($visualizer: System.Type, $visualizerObjectSourceTypeName: string)
            public constructor ()
        }
        class Debugger extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static DefaultCategory : string
            public static get IsAttached(): boolean;
            public static Break () : void
            public static IsLogging () : boolean
            public static Launch () : boolean
            public static Log ($level: number, $category: string, $message: string) : void
            public static NotifyOfCrossThreadDependency () : void
        }
        class StackFrame extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static OFFSET_UNKNOWN : number
            public GetFileLineNumber () : number
            public GetFileColumnNumber () : number
            public GetFileName () : string
            public GetILOffset () : number
            public GetMethod () : System.Reflection.MethodBase
            public GetNativeOffset () : number
            public constructor ()
            public constructor ($fNeedFileInfo: boolean)
            public constructor ($skipFrames: number)
            public constructor ($skipFrames: number, $fNeedFileInfo: boolean)
            public constructor ($fileName: string, $lineNumber: number)
            public constructor ($fileName: string, $lineNumber: number, $colNumber: number)
        }
        class StackTrace extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static METHODS_TO_SKIP : number
            public get FrameCount(): number;
            public GetFrame ($index: number) : System.Diagnostics.StackFrame
            public GetFrames () : System.Array$1<System.Diagnostics.StackFrame>
            public constructor ()
            public constructor ($fNeedFileInfo: boolean)
            public constructor ($skipFrames: number)
            public constructor ($skipFrames: number, $fNeedFileInfo: boolean)
            public constructor ($e: System.Exception)
            public constructor ($e: System.Exception, $fNeedFileInfo: boolean)
            public constructor ($e: System.Exception, $skipFrames: number)
            public constructor ($e: System.Exception, $skipFrames: number, $fNeedFileInfo: boolean)
            public constructor ($frame: System.Diagnostics.StackFrame)
        }
    }
    namespace System.Diagnostics.DebuggableAttribute {
        enum DebuggingModes
        { None = 0, Default = 1, DisableOptimizations = 256, IgnoreSymbolStoreSequencePoints = 2, EnableEditAndContinue = 4 }
    }
    namespace System.Diagnostics.Contracts.Internal {
        class ContractHelper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static RaiseContractFailedEvent ($failureKind: System.Diagnostics.Contracts.ContractFailureKind, $userMessage: string, $conditionText: string, $innerException: System.Exception) : string
            public static TriggerFailure ($kind: System.Diagnostics.Contracts.ContractFailureKind, $displayMessage: string, $userMessage: string, $conditionText: string, $innerException: System.Exception) : void
        }
    }
    namespace System.Diagnostics.Tracing {
        enum EventActivityOptions
        { None = 0, Disable = 2, Recursive = 4, Detachable = 8 }
        class EventSourceException extends System.Exception implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class EventSourceOptions extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get Level(): System.Diagnostics.Tracing.EventLevel;
            public set Level(value: System.Diagnostics.Tracing.EventLevel);
            public get Opcode(): System.Diagnostics.Tracing.EventOpcode;
            public set Opcode(value: System.Diagnostics.Tracing.EventOpcode);
            public get Keywords(): System.Diagnostics.Tracing.EventKeywords;
            public set Keywords(value: System.Diagnostics.Tracing.EventKeywords);
            public get Tags(): System.Diagnostics.Tracing.EventTags;
            public set Tags(value: System.Diagnostics.Tracing.EventTags);
            public get ActivityOptions(): System.Diagnostics.Tracing.EventActivityOptions;
            public set ActivityOptions(value: System.Diagnostics.Tracing.EventActivityOptions);
        }
        enum EventLevel
        { LogAlways = 0, Critical = 1, Error = 2, Warning = 3, Informational = 4, Verbose = 5 }
        enum EventOpcode
        { Info = 0, Start = 1, Stop = 2, DataCollectionStart = 3, DataCollectionStop = 4, Extension = 5, Reply = 6, Resume = 7, Suspend = 8, Send = 9, Receive = 240 }
        enum EventKeywords
        { None = 0, All = -1, MicrosoftTelemetry = 562949953421312, WdiContext = 562949953421312, WdiDiagnostic = 1125899906842624, Sqm = 2251799813685248, AuditFailure = 4503599627370496, AuditSuccess = 9007199254740992, CorrelationHint = 4503599627370496, EventLogClassic = 36028797018963968 }
        enum EventTags
        { None = 0 }
        enum EventTask
        { None = 0 }
        enum EventChannel
        { None = 0, Admin = 16, Operational = 17, Analytic = 18, Debug = 19 }
        class EventAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get EventId(): number;
            public get ActivityOptions(): System.Diagnostics.Tracing.EventActivityOptions;
            public set ActivityOptions(value: System.Diagnostics.Tracing.EventActivityOptions);
            public get Level(): System.Diagnostics.Tracing.EventLevel;
            public set Level(value: System.Diagnostics.Tracing.EventLevel);
            public get Keywords(): System.Diagnostics.Tracing.EventKeywords;
            public set Keywords(value: System.Diagnostics.Tracing.EventKeywords);
            public get Opcode(): System.Diagnostics.Tracing.EventOpcode;
            public set Opcode(value: System.Diagnostics.Tracing.EventOpcode);
            public get Channel(): System.Diagnostics.Tracing.EventChannel;
            public set Channel(value: System.Diagnostics.Tracing.EventChannel);
            public get Message(): string;
            public set Message(value: string);
            public get Task(): System.Diagnostics.Tracing.EventTask;
            public set Task(value: System.Diagnostics.Tracing.EventTask);
            public get Tags(): System.Diagnostics.Tracing.EventTags;
            public set Tags(value: System.Diagnostics.Tracing.EventTags);
            public get Version(): number;
            public set Version(value: number);
            public constructor ($eventId: number)
            public constructor ()
        }
        enum EventCommand
        { Update = 0, SendManifest = -1, Enable = -2, Disable = -3 }
        class EventCommandEventArgs extends System.EventArgs
        {
            protected [__keep_incompatibility]: never;
            public get Arguments(): System.Collections.Generic.IDictionary$2<string, string>;
            public get Command(): System.Diagnostics.Tracing.EventCommand;
            public DisableEvent ($eventId: number) : boolean
            public EnableEvent ($eventId: number) : boolean
        }
        class DiagnosticCounter extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get DisplayName(): string;
            public set DisplayName(value: string);
            public get DisplayUnits(): string;
            public set DisplayUnits(value: string);
            public get EventSource(): System.Diagnostics.Tracing.EventSource;
            public get Name(): string;
            public AddMetadata ($key: string, $value: string) : void
            public Dispose () : void
        }
        class EventCounter extends System.Diagnostics.Tracing.DiagnosticCounter implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public WriteMetric ($value: number) : void
            public constructor ($name: string, $eventSource: System.Diagnostics.Tracing.EventSource)
            public constructor ()
        }
        class EventSource extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get ConstructionException(): System.Exception;
            public static get CurrentThreadActivityId(): System.Guid;
            public get Guid(): System.Guid;
            public get Name(): string;
            public get Settings(): System.Diagnostics.Tracing.EventSourceSettings;
            public IsEnabled () : boolean
            public IsEnabled ($level: System.Diagnostics.Tracing.EventLevel, $keywords: System.Diagnostics.Tracing.EventKeywords) : boolean
            public IsEnabled ($level: System.Diagnostics.Tracing.EventLevel, $keywords: System.Diagnostics.Tracing.EventKeywords, $channel: System.Diagnostics.Tracing.EventChannel) : boolean
            public Dispose () : void
            public GetTrait ($key: string) : string
            public Write ($eventName: string) : void
            public Write ($eventName: string, $options: System.Diagnostics.Tracing.EventSourceOptions) : void
            public add_EventCommandExecuted ($value: System.EventHandler$1<System.Diagnostics.Tracing.EventCommandEventArgs>) : void
            public remove_EventCommandExecuted ($value: System.EventHandler$1<System.Diagnostics.Tracing.EventCommandEventArgs>) : void
            public static GenerateManifest ($eventSourceType: System.Type, $assemblyPathToIncludeInManifest: string) : string
            public static GenerateManifest ($eventSourceType: System.Type, $assemblyPathToIncludeInManifest: string, $flags: System.Diagnostics.Tracing.EventManifestOptions) : string
            public static GetGuid ($eventSourceType: System.Type) : System.Guid
            public static GetName ($eventSourceType: System.Type) : string
            public static GetSources () : System.Collections.Generic.IEnumerable$1<System.Diagnostics.Tracing.EventSource>
            public static SendCommand ($eventSource: System.Diagnostics.Tracing.EventSource, $command: System.Diagnostics.Tracing.EventCommand, $commandArguments: System.Collections.Generic.IDictionary$2<string, string>) : void
            public static SetCurrentThreadActivityId ($activityId: System.Guid) : void
            public static SetCurrentThreadActivityId ($activityId: System.Guid, $oldActivityThatWillContinue: $Ref<System.Guid>) : void
            public constructor ($eventSourceName: string)
            public constructor ($eventSourceName: string, $config: System.Diagnostics.Tracing.EventSourceSettings)
            public constructor ($eventSourceName: string, $config: System.Diagnostics.Tracing.EventSourceSettings, ...traits: string[])
            public constructor ()
        }
        class EventDataAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Name(): string;
            public set Name(value: string);
            public constructor ()
        }
        class EventFieldAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Format(): System.Diagnostics.Tracing.EventFieldFormat;
            public set Format(value: System.Diagnostics.Tracing.EventFieldFormat);
            public get Tags(): System.Diagnostics.Tracing.EventFieldTags;
            public set Tags(value: System.Diagnostics.Tracing.EventFieldTags);
            public constructor ()
        }
        enum EventFieldFormat
        { Boolean = 3, Default = 0, Hexadecimal = 4, HResult = 15, Json = 12, String = 2, Xml = 11 }
        enum EventFieldTags
        { None = 0 }
        class EventIgnoreAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class EventListener extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public static EventSourceIndex ($eventSource: System.Diagnostics.Tracing.EventSource) : number
            public EnableEvents ($eventSource: System.Diagnostics.Tracing.EventSource, $level: System.Diagnostics.Tracing.EventLevel) : void
            public EnableEvents ($eventSource: System.Diagnostics.Tracing.EventSource, $level: System.Diagnostics.Tracing.EventLevel, $matchAnyKeyword: System.Diagnostics.Tracing.EventKeywords) : void
            public EnableEvents ($eventSource: System.Diagnostics.Tracing.EventSource, $level: System.Diagnostics.Tracing.EventLevel, $matchAnyKeyword: System.Diagnostics.Tracing.EventKeywords, $arguments: System.Collections.Generic.IDictionary$2<string, string>) : void
            public DisableEvents ($eventSource: System.Diagnostics.Tracing.EventSource) : void
            public Dispose () : void
            public add_EventSourceCreated ($value: System.EventHandler$1<System.Diagnostics.Tracing.EventSourceCreatedEventArgs>) : void
            public remove_EventSourceCreated ($value: System.EventHandler$1<System.Diagnostics.Tracing.EventSourceCreatedEventArgs>) : void
            public add_EventWritten ($value: System.EventHandler$1<System.Diagnostics.Tracing.EventWrittenEventArgs>) : void
            public remove_EventWritten ($value: System.EventHandler$1<System.Diagnostics.Tracing.EventWrittenEventArgs>) : void
            public constructor ()
        }
        class EventSourceCreatedEventArgs extends System.EventArgs
        {
            protected [__keep_incompatibility]: never;
            public get EventSource(): System.Diagnostics.Tracing.EventSource;
            public constructor ()
        }
        class EventWrittenEventArgs extends System.EventArgs
        {
            protected [__keep_incompatibility]: never;
            public get ActivityId(): System.Guid;
            public get Channel(): System.Diagnostics.Tracing.EventChannel;
            public get EventId(): number;
            public get OSThreadId(): bigint;
            public get TimeStamp(): System.DateTime;
            public get EventName(): string;
            public get EventSource(): System.Diagnostics.Tracing.EventSource;
            public get Keywords(): System.Diagnostics.Tracing.EventKeywords;
            public get Level(): System.Diagnostics.Tracing.EventLevel;
            public get Message(): string;
            public get Opcode(): System.Diagnostics.Tracing.EventOpcode;
            public get Payload(): System.Collections.ObjectModel.ReadOnlyCollection$1<any>;
            public get PayloadNames(): System.Collections.ObjectModel.ReadOnlyCollection$1<string>;
            public get RelatedActivityId(): System.Guid;
            public get Tags(): System.Diagnostics.Tracing.EventTags;
            public get Task(): System.Diagnostics.Tracing.EventTask;
            public get Version(): number;
        }
        enum EventManifestOptions
        { AllCultures = 2, AllowEventSourceOverride = 8, None = 0, OnlyIfNeededForRegistration = 4, Strict = 1 }
        enum EventSourceSettings
        { Default = 0, ThrowOnEventWriteErrors = 1, EtwManifestEventFormat = 4, EtwSelfDescribingEventFormat = 8 }
        class EventSourceAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Guid(): string;
            public set Guid(value: string);
            public get LocalizationResources(): string;
            public set LocalizationResources(value: string);
            public get Name(): string;
            public set Name(value: string);
            public constructor ()
        }
        class NonEventAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class IncrementingEventCounter extends System.Diagnostics.Tracing.DiagnosticCounter implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get DisplayRateTimeScale(): System.TimeSpan;
            public set DisplayRateTimeScale(value: System.TimeSpan);
            public Increment ($increment?: number) : void
            public constructor ($name: string, $eventSource: System.Diagnostics.Tracing.EventSource)
            public constructor ()
        }
        class IncrementingPollingCounter extends System.Diagnostics.Tracing.DiagnosticCounter implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get DisplayRateTimeScale(): System.TimeSpan;
            public set DisplayRateTimeScale(value: System.TimeSpan);
            public constructor ($name: string, $eventSource: System.Diagnostics.Tracing.EventSource, $totalValueProvider: System.Func$1<number>)
            public constructor ()
        }
        class PollingCounter extends System.Diagnostics.Tracing.DiagnosticCounter implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public constructor ($name: string, $eventSource: System.Diagnostics.Tracing.EventSource, $metricProvider: System.Func$1<number>)
            public constructor ()
        }
    }
    namespace System.Diagnostics.CodeAnalysis {
        class SuppressMessageAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Category(): string;
            public get CheckId(): string;
            public get Scope(): string;
            public set Scope(value: string);
            public get Target(): string;
            public set Target(value: string);
            public get MessageId(): string;
            public set MessageId(value: string);
            public get Justification(): string;
            public set Justification(value: string);
            public constructor ($category: string, $checkId: string)
            public constructor ()
        }
        class AllowNullAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class DisallowNullAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class MaybeNullAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class NotNullAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class MaybeNullWhenAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get ReturnValue(): boolean;
            public constructor ($returnValue: boolean)
            public constructor ()
        }
        class NotNullWhenAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get ReturnValue(): boolean;
            public constructor ($returnValue: boolean)
            public constructor ()
        }
        class NotNullIfNotNullAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get ParameterName(): string;
            public constructor ($parameterName: string)
            public constructor ()
        }
        class DoesNotReturnAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class DoesNotReturnIfAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get ParameterValue(): boolean;
            public constructor ($parameterValue: boolean)
            public constructor ()
        }
    }
    namespace System.Collections.Generic.Dictionary$2 {
        class KeyCollection<TKey, TValue> extends System.Object implements System.Collections.ICollection, System.Collections.Generic.IEnumerable$1<TKey>, System.Collections.IEnumerable, System.Collections.Generic.IReadOnlyCollection$1<TKey>, System.Collections.Generic.ICollection$1<TKey>
        {
            protected [__keep_incompatibility]: never;
            public get Count(): number;
            public get SyncRoot(): any;
            public get IsSynchronized(): boolean;
            public GetEnumerator () : System.Collections.Generic.Dictionary$2.KeyCollection.Enumerator<TKey, TValue>
            public CopyTo ($array: System.Array$1<TKey>, $index: number) : void
            public constructor ($dictionary: System.Collections.Generic.Dictionary$2<TKey, TValue>)
            public CopyTo ($array: System.Array, $index: number) : void
            public GetEnumerator () : System.Collections.IEnumerator
            public constructor ()
            public [Symbol.iterator]() : IterableIterator<TKey>
        }
        class ValueCollection<TKey, TValue> extends System.Object implements System.Collections.ICollection, System.Collections.Generic.IEnumerable$1<TValue>, System.Collections.IEnumerable, System.Collections.Generic.IReadOnlyCollection$1<TValue>, System.Collections.Generic.ICollection$1<TValue>
        {
            protected [__keep_incompatibility]: never;
            public get Count(): number;
            public get SyncRoot(): any;
            public get IsSynchronized(): boolean;
            public GetEnumerator () : System.Collections.Generic.Dictionary$2.ValueCollection.Enumerator<TKey, TValue>
            public CopyTo ($array: System.Array$1<TValue>, $index: number) : void
            public constructor ($dictionary: System.Collections.Generic.Dictionary$2<TKey, TValue>)
            public CopyTo ($array: System.Array, $index: number) : void
            public GetEnumerator () : System.Collections.IEnumerator
            public constructor ()
            public [Symbol.iterator]() : IterableIterator<TValue>
        }
        class Enumerator<TKey, TValue> extends System.ValueType implements System.Collections.IDictionaryEnumerator, System.Collections.Generic.IEnumerator$1<System.Collections.Generic.KeyValuePair$2<TKey, TValue>>, System.Collections.IEnumerator, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get Current(): System.Collections.Generic.KeyValuePair$2<TKey, TValue>;
            public get Key(): any;
            public get Value(): any;
            public get Entry(): System.Collections.DictionaryEntry;
            public MoveNext () : boolean
            public Dispose () : void
        }
    }
    namespace System.Collections.Generic.Dictionary$2.KeyCollection {
        class Enumerator<TKey, TValue> extends System.ValueType implements System.Collections.Generic.IEnumerator$1<TKey>, System.Collections.IEnumerator, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace System.Collections.Generic.Dictionary$2.ValueCollection {
        class Enumerator<TKey, TValue> extends System.ValueType implements System.Collections.Generic.IEnumerator$1<TValue>, System.Collections.IEnumerator, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace System.Collections.Generic.List$1 {
        class Enumerator<T> extends System.ValueType implements System.Collections.Generic.IEnumerator$1<T>, System.Collections.IEnumerator, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get Current(): T;
            public Dispose () : void
            public MoveNext () : boolean
        }
    }
    namespace System.Collections.Generic.Queue$1 {
        class Enumerator<T> extends System.ValueType implements System.Collections.Generic.IEnumerator$1<T>, System.Collections.IEnumerator, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get Current(): T;
            public Dispose () : void
            public MoveNext () : boolean
        }
    }
    namespace System.Collections.Generic.Stack$1 {
        class Enumerator<T> extends System.ValueType implements System.Collections.Generic.IEnumerator$1<T>, System.Collections.IEnumerator, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get Current(): T;
            public Dispose () : void
            public MoveNext () : boolean
        }
    }
    namespace System.Buffers.ReadOnlySequence$1 {
        class Enumerator<T> extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get Current(): System.ReadOnlyMemory$1<T>;
            public MoveNext () : boolean
            public constructor ($sequence: $Ref<System.Buffers.ReadOnlySequence$1<T>>)
            public constructor ()
        }
    }
    namespace System.Buffers.Binary {
        class BinaryPrimitives extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static ReverseEndianness ($value: number) : number
            public static ReverseEndianness ($value: bigint) : bigint
        }
    }
    namespace System.Buffers.Text {
        class Base64 extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static GetMaxDecodedFromUtf8Length ($length: number) : number
            public static GetMaxEncodedToUtf8Length ($length: number) : number
        }
        class Utf8Formatter extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class Utf8Parser extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace System.IO.IsolatedStorage {
        interface INormalizeForIsolatedStorage
        {
            Normalize () : any
        }
        enum IsolatedStorageScope
        { None = 0, User = 1, Domain = 2, Assembly = 4, Roaming = 8, Machine = 16, Application = 32 }
        class IsolatedStorage extends System.MarshalByRefObject
        {
            protected [__keep_incompatibility]: never;
            public get ApplicationIdentity(): any;
            public get AssemblyIdentity(): any;
            public get DomainIdentity(): any;
            public get Scope(): System.IO.IsolatedStorage.IsolatedStorageScope;
            public get AvailableFreeSpace(): bigint;
            public get Quota(): bigint;
            public get UsedSize(): bigint;
            public Remove () : void
            public IncreaseQuotaTo ($newQuotaSize: bigint) : boolean
        }
        class IsolatedStorageException extends System.Exception implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $inner: System.Exception)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class IsolatedStorageFile extends System.IO.IsolatedStorage.IsolatedStorage implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get AvailableFreeSpace(): bigint;
            public get Quota(): bigint;
            public get UsedSize(): bigint;
            public static get IsEnabled(): boolean;
            public static GetEnumerator ($scope: System.IO.IsolatedStorage.IsolatedStorageScope) : System.Collections.IEnumerator
            public static GetStore ($scope: System.IO.IsolatedStorage.IsolatedStorageScope, $domainEvidence: System.Security.Policy.Evidence, $domainEvidenceType: System.Type, $assemblyEvidence: System.Security.Policy.Evidence, $assemblyEvidenceType: System.Type) : System.IO.IsolatedStorage.IsolatedStorageFile
            public static GetStore ($scope: System.IO.IsolatedStorage.IsolatedStorageScope, $domainIdentity: any, $assemblyIdentity: any) : System.IO.IsolatedStorage.IsolatedStorageFile
            public static GetStore ($scope: System.IO.IsolatedStorage.IsolatedStorageScope, $domainEvidenceType: System.Type, $assemblyEvidenceType: System.Type) : System.IO.IsolatedStorage.IsolatedStorageFile
            public static GetStore ($scope: System.IO.IsolatedStorage.IsolatedStorageScope, $applicationIdentity: any) : System.IO.IsolatedStorage.IsolatedStorageFile
            public static GetStore ($scope: System.IO.IsolatedStorage.IsolatedStorageScope, $applicationEvidenceType: System.Type) : System.IO.IsolatedStorage.IsolatedStorageFile
            public static GetMachineStoreForApplication () : System.IO.IsolatedStorage.IsolatedStorageFile
            public static GetMachineStoreForAssembly () : System.IO.IsolatedStorage.IsolatedStorageFile
            public static GetMachineStoreForDomain () : System.IO.IsolatedStorage.IsolatedStorageFile
            public static GetUserStoreForApplication () : System.IO.IsolatedStorage.IsolatedStorageFile
            public static GetUserStoreForAssembly () : System.IO.IsolatedStorage.IsolatedStorageFile
            public static GetUserStoreForDomain () : System.IO.IsolatedStorage.IsolatedStorageFile
            public static GetUserStoreForSite () : System.IO.IsolatedStorage.IsolatedStorageFile
            public static Remove ($scope: System.IO.IsolatedStorage.IsolatedStorageScope) : void
            public Close () : void
            public CreateDirectory ($dir: string) : void
            public CopyFile ($sourceFileName: string, $destinationFileName: string) : void
            public CopyFile ($sourceFileName: string, $destinationFileName: string, $overwrite: boolean) : void
            public CreateFile ($path: string) : System.IO.IsolatedStorage.IsolatedStorageFileStream
            public DeleteDirectory ($dir: string) : void
            public DeleteFile ($file: string) : void
            public Dispose () : void
            public DirectoryExists ($path: string) : boolean
            public FileExists ($path: string) : boolean
            public GetCreationTime ($path: string) : System.DateTimeOffset
            public GetLastAccessTime ($path: string) : System.DateTimeOffset
            public GetLastWriteTime ($path: string) : System.DateTimeOffset
            public GetDirectoryNames ($searchPattern: string) : System.Array$1<string>
            public GetDirectoryNames () : System.Array$1<string>
            public GetFileNames ($searchPattern: string) : System.Array$1<string>
            public GetFileNames () : System.Array$1<string>
            public MoveDirectory ($sourceDirectoryName: string, $destinationDirectoryName: string) : void
            public MoveFile ($sourceFileName: string, $destinationFileName: string) : void
            public OpenFile ($path: string, $mode: System.IO.FileMode) : System.IO.IsolatedStorage.IsolatedStorageFileStream
            public OpenFile ($path: string, $mode: System.IO.FileMode, $access: System.IO.FileAccess) : System.IO.IsolatedStorage.IsolatedStorageFileStream
            public OpenFile ($path: string, $mode: System.IO.FileMode, $access: System.IO.FileAccess, $share: System.IO.FileShare) : System.IO.IsolatedStorage.IsolatedStorageFileStream
            public Remove () : void
        }
        class IsolatedStorageFileStream extends System.IO.FileStream implements System.IAsyncDisposable, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get CanRead(): boolean;
            public get CanSeek(): boolean;
            public get CanWrite(): boolean;
            public get SafeFileHandle(): Microsoft.Win32.SafeHandles.SafeFileHandle;
            public get IsAsync(): boolean;
            public get Length(): bigint;
            public get Position(): bigint;
            public set Position(value: bigint);
            public constructor ($path: string, $mode: System.IO.FileMode)
            public constructor ($path: string, $mode: System.IO.FileMode, $access: System.IO.FileAccess)
            public constructor ($path: string, $mode: System.IO.FileMode, $access: System.IO.FileAccess, $share: System.IO.FileShare)
            public constructor ($path: string, $mode: System.IO.FileMode, $access: System.IO.FileAccess, $share: System.IO.FileShare, $bufferSize: number)
            public constructor ($path: string, $mode: System.IO.FileMode, $access: System.IO.FileAccess, $share: System.IO.FileShare, $bufferSize: number, $isf: System.IO.IsolatedStorage.IsolatedStorageFile)
            public constructor ($path: string, $mode: System.IO.FileMode, $access: System.IO.FileAccess, $share: System.IO.FileShare, $isf: System.IO.IsolatedStorage.IsolatedStorageFile)
            public constructor ($path: string, $mode: System.IO.FileMode, $access: System.IO.FileAccess, $isf: System.IO.IsolatedStorage.IsolatedStorageFile)
            public constructor ($path: string, $mode: System.IO.FileMode, $isf: System.IO.IsolatedStorage.IsolatedStorageFile)
            public constructor ($path: string, $mode: System.IO.FileMode, $access: System.IO.FileAccess, $share: System.IO.FileShare, $bufferSize: number, $useAsync: boolean)
            public constructor ($path: string, $mode: System.IO.FileMode, $access: System.IO.FileAccess, $share: System.IO.FileShare, $bufferSize: number, $options: System.IO.FileOptions)
            public constructor ($handle: Microsoft.Win32.SafeHandles.SafeFileHandle, $access: System.IO.FileAccess)
            public constructor ($handle: Microsoft.Win32.SafeHandles.SafeFileHandle, $access: System.IO.FileAccess, $bufferSize: number)
            public constructor ($handle: Microsoft.Win32.SafeHandles.SafeFileHandle, $access: System.IO.FileAccess, $bufferSize: number, $isAsync: boolean)
            public constructor ($path: string, $mode: System.IO.FileMode, $rights: System.Security.AccessControl.FileSystemRights, $share: System.IO.FileShare, $bufferSize: number, $options: System.IO.FileOptions)
            public constructor ($path: string, $mode: System.IO.FileMode, $rights: System.Security.AccessControl.FileSystemRights, $share: System.IO.FileShare, $bufferSize: number, $options: System.IO.FileOptions, $fileSecurity: System.Security.AccessControl.FileSecurity)
            public constructor ()
        }
        enum IsolatedStorageSecurityOptions
        { IncreaseQuotaForApplication = 4 }
        class IsolatedStorageSecurityState extends System.Security.SecurityState
        {
            protected [__keep_incompatibility]: never;
            public get Options(): System.IO.IsolatedStorage.IsolatedStorageSecurityOptions;
            public get Quota(): bigint;
            public set Quota(value: bigint);
            public get UsedSize(): bigint;
        }
    }
    namespace System.IO.Enumeration {
        class FileSystemEntry extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get Attributes(): System.IO.FileAttributes;
            public get Length(): bigint;
            public get CreationTimeUtc(): System.DateTimeOffset;
            public get LastAccessTimeUtc(): System.DateTimeOffset;
            public get LastWriteTimeUtc(): System.DateTimeOffset;
            public get IsDirectory(): boolean;
            public get IsHidden(): boolean;
            public ToFileSystemInfo () : System.IO.FileSystemInfo
            public ToFullPath () : string
            public ToSpecifiedFullPath () : string
        }
        class FileSystemEnumerable$1<TResult> extends System.Object implements System.Collections.Generic.IEnumerable$1<TResult>, System.Collections.IEnumerable
        {
            protected [__keep_incompatibility]: never;
            public get ShouldIncludePredicate(): System.IO.Enumeration.FileSystemEnumerable$1.FindPredicate<TResult>;
            public set ShouldIncludePredicate(value: System.IO.Enumeration.FileSystemEnumerable$1.FindPredicate<TResult>);
            public get ShouldRecursePredicate(): System.IO.Enumeration.FileSystemEnumerable$1.FindPredicate<TResult>;
            public set ShouldRecursePredicate(value: System.IO.Enumeration.FileSystemEnumerable$1.FindPredicate<TResult>);
            public GetEnumerator () : System.Collections.Generic.IEnumerator$1<TResult>
            public constructor ($directory: string, $transform: System.IO.Enumeration.FileSystemEnumerable$1.FindTransform<TResult>, $options?: System.IO.EnumerationOptions)
            public GetEnumerator () : System.Collections.IEnumerator
            public constructor ()
            public [Symbol.iterator]() : IterableIterator<TResult>
        }
        class FileSystemEnumerator$1<TResult> extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements System.Collections.Generic.IEnumerator$1<TResult>, System.Collections.IEnumerator, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get Current(): TResult;
            public MoveNext () : boolean
            public Reset () : void
            public Dispose () : void
        }
        class FileSystemName extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static TranslateWin32Expression ($expression: string) : string
        }
    }
    namespace System.IO.Enumeration.FileSystemEnumerable$1 {
        interface FindPredicate<TResult>
        { 
        (entry: $Ref<System.IO.Enumeration.FileSystemEntry>) : boolean; 
        Invoke?: (entry: $Ref<System.IO.Enumeration.FileSystemEntry>) => boolean;
        }
        interface FindTransform<TResult>
        { 
        (entry: $Ref<System.IO.Enumeration.FileSystemEntry>) : TResult; 
        Invoke?: (entry: $Ref<System.IO.Enumeration.FileSystemEntry>) => TResult;
        }
    }
    namespace System.Runtime.DesignerServices {
        class WindowsRuntimeDesignerContext extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get Name(): string;
            public GetAssembly ($assemblyName: string) : System.Reflection.Assembly
            public GetType ($typeName: string) : System.Type
            public static InitializeSharedContext ($paths: System.Collections.Generic.IEnumerable$1<string>) : void
            public static SetIterationContext ($context: System.Runtime.DesignerServices.WindowsRuntimeDesignerContext) : void
            public constructor ($paths: System.Collections.Generic.IEnumerable$1<string>, $name: string)
            public GetType () : System.Type
            public constructor ()
        }
    }
}
