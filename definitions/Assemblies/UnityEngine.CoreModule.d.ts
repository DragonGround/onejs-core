
declare namespace CS {
    // const __keep_incompatibility: unique symbol;
    // 
    // interface $Ref<T> {
    //     value: T
    // }
    // namespace System {
    //     interface Array$1<T> extends System.Array {
    //         get_Item(index: number):T;
    //         
    //         set_Item(index: number, value: T):void;
    //     }
    // }
    // interface $Task<T> {}
    namespace AOT {
        class MonoPInvokeCallbackAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ($type: System.Type)
        }
    }
    namespace UnityEditor.Experimental {
        /** Experimental render settings features.
        */
        class RenderSettings extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
    }
    namespace UnityEngineInternal {
        enum GITextureType
        { Charting = 0, Albedo = 1, Emissive = 2, Irradiance = 3, Directionality = 4, Baked = 5, BakedDirectional = 6, InputWorkspace = 7, BakedShadowMask = 8, BakedAlbedo = 9, BakedEmissive = 10, BakedCharting = 11, BakedTexelValidity = 12, BakedUVOverlap = 13, BakedLightmapCulling = 14 }
        class GIDebugVisualisation extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get cycleMode(): boolean;
            public static get pauseCycleMode(): boolean;
            public static get texType(): UnityEngineInternal.GITextureType;
            public static set texType(value: UnityEngineInternal.GITextureType);
            public static ResetRuntimeInputTextures () : void
            public static PlayCycleMode () : void
            public static PauseCycleMode () : void
            public static StopCycleMode () : void
            public static CycleSkipSystems ($skip: number) : void
            public static CycleSkipInstances ($skip: number) : void
        }
        enum MemorylessMode
        { Unused = 0, Forced = 1, Automatic = 2 }
        class MemorylessManager extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get depthMemorylessMode(): UnityEngineInternal.MemorylessMode;
            public static set depthMemorylessMode(value: UnityEngineInternal.MemorylessMode);
            public constructor ()
        }
        class MathfInternal extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public static FloatMinNormal : number
            public static FloatMinDenormal : number
            public static IsFlushToZeroEnabled : boolean
        }
        class APIUpdaterRuntimeServices extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        enum TypeInferenceRules
        { TypeReferencedByFirstArgument = 0, TypeReferencedBySecondArgument = 1, ArrayOfTypeReferencedByFirstArgument = 2, TypeOfFirstArgument = 3 }
        class TypeInferenceRuleAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ($rule: UnityEngineInternal.TypeInferenceRules)
            public constructor ($rule: string)
        }
        class GenericStack extends System.Collections.Stack implements System.ICloneable, System.Collections.ICollection, System.Collections.IEnumerable
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
    }
    namespace UnityEngine {
        /** Base class for all objects Unity can reference.
        */
        class Object extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** The name of the object.
            */
            public get name(): string;
            public set name(value: string);
            /** Should the object be hidden, saved with the Scene or modifiable by the user?
            */
            public get hideFlags(): UnityEngine.HideFlags;
            public set hideFlags(value: UnityEngine.HideFlags);
            /** Gets  the instance ID of the object.
            * @returns Returns the instance ID of the object. 
            */
            public GetInstanceID () : number
            public static op_Implicit ($exists: UnityEngine.Object) : boolean
            /** Clones the object original and returns the clone.
            * @param $original An existing object that you want to make a copy of.
            * @param $position Position for the new object.
            * @param $rotation Orientation of the new object.
            * @param $parent Parent that will be assigned to the new object.
            * @param $instantiateInWorldSpace When you assign a parent Object, pass true to position the new object directly in world space. Pass false to set the Object’s position relative to its new parent.
            * @returns The instantiated clone. 
            */
            public static Instantiate ($original: UnityEngine.Object, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion) : UnityEngine.Object
            /** Clones the object original and returns the clone.
            * @param $original An existing object that you want to make a copy of.
            * @param $position Position for the new object.
            * @param $rotation Orientation of the new object.
            * @param $parent Parent that will be assigned to the new object.
            * @param $instantiateInWorldSpace When you assign a parent Object, pass true to position the new object directly in world space. Pass false to set the Object’s position relative to its new parent.
            * @returns The instantiated clone. 
            */
            public static Instantiate ($original: UnityEngine.Object, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $parent: UnityEngine.Transform) : UnityEngine.Object
            /** Clones the object original and returns the clone.
            * @param $original An existing object that you want to make a copy of.
            * @param $position Position for the new object.
            * @param $rotation Orientation of the new object.
            * @param $parent Parent that will be assigned to the new object.
            * @param $instantiateInWorldSpace When you assign a parent Object, pass true to position the new object directly in world space. Pass false to set the Object’s position relative to its new parent.
            * @returns The instantiated clone. 
            */
            public static Instantiate ($original: UnityEngine.Object) : UnityEngine.Object
            /** Clones the object original and returns the clone.
            * @param $original An existing object that you want to make a copy of.
            * @param $position Position for the new object.
            * @param $rotation Orientation of the new object.
            * @param $parent Parent that will be assigned to the new object.
            * @param $instantiateInWorldSpace When you assign a parent Object, pass true to position the new object directly in world space. Pass false to set the Object’s position relative to its new parent.
            * @returns The instantiated clone. 
            */
            public static Instantiate ($original: UnityEngine.Object, $parent: UnityEngine.Transform) : UnityEngine.Object
            /** Clones the object original and returns the clone.
            * @param $original An existing object that you want to make a copy of.
            * @param $position Position for the new object.
            * @param $rotation Orientation of the new object.
            * @param $parent Parent that will be assigned to the new object.
            * @param $instantiateInWorldSpace When you assign a parent Object, pass true to position the new object directly in world space. Pass false to set the Object’s position relative to its new parent.
            * @returns The instantiated clone. 
            */
            public static Instantiate ($original: UnityEngine.Object, $parent: UnityEngine.Transform, $instantiateInWorldSpace: boolean) : UnityEngine.Object
            public static Instantiate ($original: UnityEngine.Object, $parent: UnityEngine.Transform, $worldPositionStays: boolean) : UnityEngine.Object
            /** Removes a GameObject, component or asset.
            * @param $obj The object to destroy.
            * @param $t The optional amount of time to delay before destroying the object.
            */
            public static Destroy ($obj: UnityEngine.Object, $t: number) : void
            /** Removes a GameObject, component or asset.
            * @param $obj The object to destroy.
            * @param $t The optional amount of time to delay before destroying the object.
            */
            public static Destroy ($obj: UnityEngine.Object) : void
            /** Destroys the object obj immediately. You are strongly recommended to use Destroy instead.
            * @param $obj Object to be destroyed.
            * @param $allowDestroyingAssets Set to true to allow assets to be destroyed.
            */
            public static DestroyImmediate ($obj: UnityEngine.Object, $allowDestroyingAssets: boolean) : void
            /** Destroys the object obj immediately. You are strongly recommended to use Destroy instead.
            * @param $obj Object to be destroyed.
            * @param $allowDestroyingAssets Set to true to allow assets to be destroyed.
            */
            public static DestroyImmediate ($obj: UnityEngine.Object) : void
            /** Retrieves a list of all loaded objects of Type type.
            * @param $type The type of object to find.
            * @param $findObjectsInactive Whether to include components attached to inactive GameObjects. If you don't specify this parameter, this function doesn't include inactive objects in the results.
            * @param $sortMode Whether and how to sort the returned array. Not sorting the array makes this function run significantly faster.
            * @returns The array of objects found matching the type specified. 
            */
            public static FindObjectsByType ($type: System.Type, $sortMode: UnityEngine.FindObjectsSortMode) : System.Array$1<UnityEngine.Object>
            /** Retrieves a list of all loaded objects of Type type.
            * @param $type The type of object to find.
            * @param $findObjectsInactive Whether to include components attached to inactive GameObjects. If you don't specify this parameter, this function doesn't include inactive objects in the results.
            * @param $sortMode Whether and how to sort the returned array. Not sorting the array makes this function run significantly faster.
            * @returns The array of objects found matching the type specified. 
            */
            public static FindObjectsByType ($type: System.Type, $findObjectsInactive: UnityEngine.FindObjectsInactive, $sortMode: UnityEngine.FindObjectsSortMode) : System.Array$1<UnityEngine.Object>
            /** Do not destroy the target Object when loading a new Scene.
            * @param $target An Object not destroyed on Scene change.
            */
            public static DontDestroyOnLoad ($target: UnityEngine.Object) : void
            /** Retrieves the first active loaded object of Type type.
            * @param $type The type of object to find.
            * @param $findObjectsInactive Whether to include components attached to inactive GameObjects. If you don't specify this parameter, this function doesn't include inactive objects in the results.
            * @returns Returns the first active loaded object that matches the specified type. If no object matches the specified type, returns null. 
            */
            public static FindFirstObjectByType ($type: System.Type) : UnityEngine.Object
            /** Retrieves any active loaded object of Type type.
            * @param $type The type of object to find.
            * @param $findObjectsInactive Whether to include components attached to inactive GameObjects. If you don't specify this parameter, this function doesn't include inactive objects in the results.
            * @returns Returns an arbitrary active loaded object that matches the specified type. If no object matches the specified type, returns null. 
            */
            public static FindAnyObjectByType ($type: System.Type) : UnityEngine.Object
            /** Retrieves the first active loaded object of Type type.
            * @param $type The type of object to find.
            * @param $findObjectsInactive Whether to include components attached to inactive GameObjects. If you don't specify this parameter, this function doesn't include inactive objects in the results.
            * @returns Returns the first active loaded object that matches the specified type. If no object matches the specified type, returns null. 
            */
            public static FindFirstObjectByType ($type: System.Type, $findObjectsInactive: UnityEngine.FindObjectsInactive) : UnityEngine.Object
            /** Retrieves any active loaded object of Type type.
            * @param $type The type of object to find.
            * @param $findObjectsInactive Whether to include components attached to inactive GameObjects. If you don't specify this parameter, this function doesn't include inactive objects in the results.
            * @returns Returns an arbitrary active loaded object that matches the specified type. If no object matches the specified type, returns null. 
            */
            public static FindAnyObjectByType ($type: System.Type, $findObjectsInactive: UnityEngine.FindObjectsInactive) : UnityEngine.Object
            public static op_Equality ($x: UnityEngine.Object, $y: UnityEngine.Object) : boolean
            public static op_Inequality ($x: UnityEngine.Object, $y: UnityEngine.Object) : boolean
            public constructor ()
        }
        /** Base class for everything attached to a GameObject.
        */
        class Component extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** The Transform attached to this GameObject.
            */
            public get transform(): UnityEngine.Transform;
            /** The game object this component is attached to. A component is always attached to a game object.
            */
            public get gameObject(): UnityEngine.GameObject;
            /** The tag of this game object.
            */
            public get tag(): string;
            public set tag(value: string);
            /** The non-generic version of this method.
            * @param $type The type of Component to retrieve.
            * @returns A Component of the matching type, otherwise null if no Component is found. 
            */
            public GetComponent ($type: System.Type) : UnityEngine.Component
            /** The non-generic version of this method.
            * @param $type The type of component to search for.
            * @param $component The output argument that will contain the component or null.
            * @returns Returns true if the component is found, false otherwise. 
            */
            public TryGetComponent ($type: System.Type, $component: $Ref<UnityEngine.Component>) : boolean
            /** The string-based version of this method.
            * @param $type The name of the type of Component to get.
            * @returns A Component of the matching type, otherwise null if no Component is found. 
            */
            public GetComponent ($type: string) : UnityEngine.Component
            /** This is the non-generic version of this method.
            * @param $t The type of component to search for.
            * @param $includeInactive Whether to include inactive child GameObjects in the search.
            * @returns A Component of the matching type, otherwise null if no Component is found. 
            */
            public GetComponentInChildren ($t: System.Type, $includeInactive: boolean) : UnityEngine.Component
            /** This is the non-generic version of this method.
            * @param $t The type of component to search for.
            * @param $includeInactive Whether to include inactive child GameObjects in the search.
            * @returns A Component of the matching type, otherwise null if no Component is found. 
            */
            public GetComponentInChildren ($t: System.Type) : UnityEngine.Component
            /** The non-generic version of this method.
            * @param $t The type of component to search for.
            * @param $includeInactive Whether to include inactive child GameObjects in the search.
            * @returns An array of all found components matching the specified type. 
            */
            public GetComponentsInChildren ($t: System.Type, $includeInactive: boolean) : System.Array$1<UnityEngine.Component>
            public GetComponentsInChildren ($t: System.Type) : System.Array$1<UnityEngine.Component>
            /** The non-generic version of this method.
            * @param $t The type of component to search for.
            * @param $includeInactive Whether to include inactive parent GameObjects in the search.
            * @returns A Component of the matching type, otherwise null if no Component is found. 
            */
            public GetComponentInParent ($t: System.Type, $includeInactive: boolean) : UnityEngine.Component
            /** The non-generic version of this method.
            * @param $t The type of component to search for.
            * @param $includeInactive Whether to include inactive parent GameObjects in the search.
            * @returns A Component of the matching type, otherwise null if no Component is found. 
            */
            public GetComponentInParent ($t: System.Type) : UnityEngine.Component
            /** The non-generic version of this method.
            * @param $t The type of component to search for.
            * @param $includeInactive Whether to include inactive parent GameObjects in the search.
            * @returns An array of all found components matching the specified type. 
            */
            public GetComponentsInParent ($t: System.Type, $includeInactive: boolean) : System.Array$1<UnityEngine.Component>
            public GetComponentsInParent ($t: System.Type) : System.Array$1<UnityEngine.Component>
            /** The non-generic version of this method.
            * @param $type The type of component to search for.
            * @returns An array containing all matching components of type type. 
            */
            public GetComponents ($type: System.Type) : System.Array$1<UnityEngine.Component>
            public GetComponents ($type: System.Type, $results: System.Collections.Generic.List$1<UnityEngine.Component>) : void
            /** Checks the GameObject's tag against the defined tag.
            * @param $tag The tag to compare.
            * @returns Returns true if GameObject has same tag. Returns false otherwise. 
            */
            public CompareTag ($tag: string) : boolean
            /** Checks the GameObject's tag against the defined tag.
            * @param $tag A TagHandle representing the tag to compare.
            * @returns Returns true if GameObject has same tag. Returns false otherwise. 
            */
            public CompareTag ($tag: UnityEngine.TagHandle) : boolean
            /** Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour.
            * @param $methodName Name of method to call.
            * @param $value Optional parameter value for the method.
            * @param $options Should an error be raised if the method does not exist on the target object?
            */
            public SendMessageUpwards ($methodName: string, $value: any, $options: UnityEngine.SendMessageOptions) : void
            /** Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour.
            * @param $methodName Name of method to call.
            * @param $value Optional parameter value for the method.
            * @param $options Should an error be raised if the method does not exist on the target object?
            */
            public SendMessageUpwards ($methodName: string, $value: any) : void
            /** Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour.
            * @param $methodName Name of method to call.
            * @param $value Optional parameter value for the method.
            * @param $options Should an error be raised if the method does not exist on the target object?
            */
            public SendMessageUpwards ($methodName: string) : void
            /** Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour.
            * @param $methodName Name of method to call.
            * @param $value Optional parameter value for the method.
            * @param $options Should an error be raised if the method does not exist on the target object?
            */
            public SendMessageUpwards ($methodName: string, $options: UnityEngine.SendMessageOptions) : void
            /** Calls the method named methodName on every MonoBehaviour in this game object.
            * @param $methodName Name of the method to call.
            * @param $value Optional parameter for the method.
            * @param $options Should an error be raised if the target object doesn't implement the method for the message?
            */
            public SendMessage ($methodName: string, $value: any) : void
            /** Calls the method named methodName on every MonoBehaviour in this game object.
            * @param $methodName Name of the method to call.
            * @param $value Optional parameter for the method.
            * @param $options Should an error be raised if the target object doesn't implement the method for the message?
            */
            public SendMessage ($methodName: string) : void
            /** Calls the method named methodName on every MonoBehaviour in this game object.
            * @param $methodName Name of the method to call.
            * @param $value Optional parameter for the method.
            * @param $options Should an error be raised if the target object doesn't implement the method for the message?
            */
            public SendMessage ($methodName: string, $value: any, $options: UnityEngine.SendMessageOptions) : void
            /** Calls the method named methodName on every MonoBehaviour in this game object.
            * @param $methodName Name of the method to call.
            * @param $value Optional parameter for the method.
            * @param $options Should an error be raised if the target object doesn't implement the method for the message?
            */
            public SendMessage ($methodName: string, $options: UnityEngine.SendMessageOptions) : void
            /** Calls the method named methodName on every MonoBehaviour in this game object or any of its children.
            * @param $methodName Name of the method to call.
            * @param $parameter Optional parameter to pass to the method (can be any value).
            * @param $options Should an error be raised if the method does not exist for a given target object?
            */
            public BroadcastMessage ($methodName: string, $parameter: any, $options: UnityEngine.SendMessageOptions) : void
            /** Calls the method named methodName on every MonoBehaviour in this game object or any of its children.
            * @param $methodName Name of the method to call.
            * @param $parameter Optional parameter to pass to the method (can be any value).
            * @param $options Should an error be raised if the method does not exist for a given target object?
            */
            public BroadcastMessage ($methodName: string, $parameter: any) : void
            /** Calls the method named methodName on every MonoBehaviour in this game object or any of its children.
            * @param $methodName Name of the method to call.
            * @param $parameter Optional parameter to pass to the method (can be any value).
            * @param $options Should an error be raised if the method does not exist for a given target object?
            */
            public BroadcastMessage ($methodName: string) : void
            /** Calls the method named methodName on every MonoBehaviour in this game object or any of its children.
            * @param $methodName Name of the method to call.
            * @param $parameter Optional parameter to pass to the method (can be any value).
            * @param $options Should an error be raised if the method does not exist for a given target object?
            */
            public BroadcastMessage ($methodName: string, $options: UnityEngine.SendMessageOptions) : void
            public constructor ()
        }
        /** Base class for all entities in Unity Scenes.
        */
        class GameObject extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** The Transform attached to this GameObject.
            */
            public get transform(): UnityEngine.Transform;
            /** The layer the GameObject is in.
            */
            public get layer(): number;
            public set layer(value: number);
            /** The local active state of this GameObject. (Read Only)
            */
            public get activeSelf(): boolean;
            /** Defines whether the GameObject is active in the Scene.
            */
            public get activeInHierarchy(): boolean;
            /** Gets and sets the GameObject's StaticEditorFlags.
            */
            public get isStatic(): boolean;
            public set isStatic(value: boolean);
            /** The tag of this GameObject.
            */
            public get tag(): string;
            public set tag(value: string);
            /** Scene that the GameObject is part of.
            */
            public get scene(): UnityEngine.SceneManagement.Scene;
            /** Scene culling mask Unity uses to determine which scene to render the GameObject in.
            */
            public get sceneCullingMask(): bigint;
            public get gameObject(): UnityEngine.GameObject;
            /** Creates a GameObject with a primitive mesh renderer and appropriate collider.
            * @param $type The type of primitive object to create.
            */
            public static CreatePrimitive ($type: UnityEngine.PrimitiveType) : UnityEngine.GameObject
            /** The non-generic version of this method.
            * @param $type The type of Component to search for.
            * @returns A Component of the matching type, otherwise null if no Component is found. 
            */
            public GetComponent ($type: System.Type) : UnityEngine.Component
            /** The string-based version of this method.
            * @param $type The name of the type of Component to search for.
            * @returns A Component of the matching type, otherwise null if no Component is found. 
            */
            public GetComponent ($type: string) : UnityEngine.Component
            /** This is the non-generic version of this method.
            * @param $type The type of Component to retrieve.
            * @param $includeInactive Whether to include inactive child GameObjects in the search.
            * @returns A component of the matching type, if found. 
            */
            public GetComponentInChildren ($type: System.Type, $includeInactive: boolean) : UnityEngine.Component
            /** This is the non-generic version of this method.
            * @param $type The type of Component to retrieve.
            * @param $includeInactive Whether to include inactive child GameObjects in the search.
            * @returns A component of the matching type, if found. 
            */
            public GetComponentInChildren ($type: System.Type) : UnityEngine.Component
            /** The non-generic version of this method.
            * @param $type The type of component to search for.
            * @param $includeInactive Whether to include inactive parent GameObjects in the search.
            * @returns A Component of the matching type, otherwise null if no Component is found. 
            */
            public GetComponentInParent ($type: System.Type, $includeInactive: boolean) : UnityEngine.Component
            /** The non-generic version of this method.
            * @param $type The type of component to search for.
            * @param $includeInactive Whether to include inactive parent GameObjects in the search.
            * @returns A Component of the matching type, otherwise null if no Component is found. 
            */
            public GetComponentInParent ($type: System.Type) : UnityEngine.Component
            /** The non-generic version of this method.
            * @param $type The type of component to search for.
            * @returns An array containing all matching components of type type. 
            */
            public GetComponents ($type: System.Type) : System.Array$1<UnityEngine.Component>
            public GetComponents ($type: System.Type, $results: System.Collections.Generic.List$1<UnityEngine.Component>) : void
            /** The non-generic version of this method.
            * @param $type The type of component to search for.
            * @param $includeInactive Whether to include inactive child GameObjects in the search.
            * @returns An array of all found components matching the specified type. 
            */
            public GetComponentsInChildren ($type: System.Type) : System.Array$1<UnityEngine.Component>
            /** The non-generic version of this method.
            * @param $type The type of component to search for.
            * @param $includeInactive Whether to include inactive child GameObjects in the search.
            * @returns An array of all found components matching the specified type. 
            */
            public GetComponentsInChildren ($type: System.Type, $includeInactive: boolean) : System.Array$1<UnityEngine.Component>
            public GetComponentsInParent ($type: System.Type) : System.Array$1<UnityEngine.Component>
            /** The non-generic version of this method.
            * @param $type The type of component to search for.
            * @param $includeInactive Whether to include inactive parent GameObjects in the search.
            * @returns An array of all found components matching the specified type. 
            */
            public GetComponentsInParent ($type: System.Type, $includeInactive: boolean) : System.Array$1<UnityEngine.Component>
            /** The non-generic version of this method.
            * @param $type The type of component to search for.
            * @param $component The output argument that will contain the component or null.
            * @returns Returns true if the component is found, false otherwise. 
            */
            public TryGetComponent ($type: System.Type, $component: $Ref<UnityEngine.Component>) : boolean
            /** Returns one active GameObject tagged tag. Returns null if no GameObject was found.
            * @param $tag The tag to search for.
            */
            public static FindWithTag ($tag: string) : UnityEngine.GameObject
            public static FindGameObjectsWithTag ($tag: string, $results: System.Collections.Generic.List$1<UnityEngine.GameObject>) : void
            public SendMessageUpwards ($methodName: string, $options: UnityEngine.SendMessageOptions) : void
            public SendMessage ($methodName: string, $options: UnityEngine.SendMessageOptions) : void
            public BroadcastMessage ($methodName: string, $options: UnityEngine.SendMessageOptions) : void
            /** Adds a component class of type componentType to the GameObject. C# Users can use a generic version.
            */
            public AddComponent ($componentType: System.Type) : UnityEngine.Component
            /** ActivatesDeactivates the GameObject, depending on the given true or false/ value.
            * @param $value Activate or deactivate the object, where true activates the GameObject and false deactivates the GameObject.
            */
            public SetActive ($value: boolean) : void
            /** Is this GameObject tagged with tag ?
            * @param $tag The tag to compare.
            * @returns true if the GameObject has the given tag, false otherwise. 
            */
            public CompareTag ($tag: string) : boolean
            /** Is this GameObject tagged with tag?
            * @param $tag A TagHandle representing the tag to compare.
            * @returns true if the GameObject has the given tag, false otherwise. 
            */
            public CompareTag ($tag: UnityEngine.TagHandle) : boolean
            public static FindGameObjectWithTag ($tag: string) : UnityEngine.GameObject
            /** Returns an array of active GameObjects tagged tag. Returns empty array if no GameObject was found.
            * @param $tag The name of the tag to search GameObjects for.
            */
            public static FindGameObjectsWithTag ($tag: string) : System.Array$1<UnityEngine.GameObject>
            /** Calls the method named methodName on every MonoBehaviour in this GameObject and on every ancestor of the behaviour.
            * @param $methodName The name of the method to call.
            * @param $value An optional parameter value to pass to the called method.
            * @param $options Should an error be raised if the method doesn't exist on the target object?
            */
            public SendMessageUpwards ($methodName: string, $value: any, $options: UnityEngine.SendMessageOptions) : void
            /** Calls the method named methodName on every MonoBehaviour in this GameObject and on every ancestor of the behaviour.
            * @param $methodName The name of the method to call.
            * @param $value An optional parameter value to pass to the called method.
            * @param $options Should an error be raised if the method doesn't exist on the target object?
            */
            public SendMessageUpwards ($methodName: string, $value: any) : void
            /** Calls the method named methodName on every MonoBehaviour in this GameObject and on every ancestor of the behaviour.
            * @param $methodName The name of the method to call.
            * @param $value An optional parameter value to pass to the called method.
            * @param $options Should an error be raised if the method doesn't exist on the target object?
            */
            public SendMessageUpwards ($methodName: string) : void
            /** Calls the method named methodName on every MonoBehaviour in this GameObject.
            * @param $methodName The name of the method to call.
            * @param $value An optional parameter value to pass to the called method.
            * @param $options Should an error be raised if the method doesn't exist on the target object?
            */
            public SendMessage ($methodName: string, $value: any, $options: UnityEngine.SendMessageOptions) : void
            /** Calls the method named methodName on every MonoBehaviour in this GameObject.
            * @param $methodName The name of the method to call.
            * @param $value An optional parameter value to pass to the called method.
            * @param $options Should an error be raised if the method doesn't exist on the target object?
            */
            public SendMessage ($methodName: string, $value: any) : void
            /** Calls the method named methodName on every MonoBehaviour in this GameObject.
            * @param $methodName The name of the method to call.
            * @param $value An optional parameter value to pass to the called method.
            * @param $options Should an error be raised if the method doesn't exist on the target object?
            */
            public SendMessage ($methodName: string) : void
            /** Calls the method named methodName on every MonoBehaviour in this GameObject or any of its children.
            */
            public BroadcastMessage ($methodName: string, $parameter: any, $options: UnityEngine.SendMessageOptions) : void
            /** Calls the method named methodName on every MonoBehaviour in this GameObject or any of its children.
            */
            public BroadcastMessage ($methodName: string, $parameter: any) : void
            /** Calls the method named methodName on every MonoBehaviour in this GameObject or any of its children.
            */
            public BroadcastMessage ($methodName: string) : void
            /** Finds a GameObject by name and returns it.
            */
            public static Find ($name: string) : UnityEngine.GameObject
            public static SetGameObjectsActive ($instanceIDs: Unity.Collections.NativeArray$1<number>, $active: boolean) : void
            public static InstantiateGameObjects ($sourceInstanceID: number, $count: number, $newInstanceIDs: Unity.Collections.NativeArray$1<number>, $newTransformInstanceIDs: Unity.Collections.NativeArray$1<number>, $destinationScene?: UnityEngine.SceneManagement.Scene) : void
            /** Returns the Scene of a GameObject given by instance ID.
            * @param $instanceID The instance ID of a GameObject.
            * @returns Scene of GameObject of instance ID. 
            */
            public static GetScene ($instanceID: number) : UnityEngine.SceneManagement.Scene
            public constructor ($name: string)
            public constructor ()
            public constructor ($name: string, ...components: System.Type[])
        }
        /** Representation of RGBA colors in 32 bit format.
        */
        class Color32 extends System.ValueType implements System.IFormattable
        {
            protected [__keep_incompatibility]: never;
            /** Red component of the color.
            */
            public r : number
            /** Green component of the color.
            */
            public g : number
            /** Blue component of the color.
            */
            public b : number
            /** Alpha component of the color.
            */
            public a : number
            public static op_Implicit ($c: UnityEngine.Color) : UnityEngine.Color32
            public static op_Implicit ($c: UnityEngine.Color32) : UnityEngine.Color
            /** Linearly interpolates between colors a and b by t.
            */
            public static Lerp ($a: UnityEngine.Color32, $b: UnityEngine.Color32, $t: number) : UnityEngine.Color32
            /** Linearly interpolates between colors a and b by t.
            */
            public static LerpUnclamped ($a: UnityEngine.Color32, $b: UnityEngine.Color32, $t: number) : UnityEngine.Color32
            public get_Item ($index: number) : number
            public set_Item ($index: number, $value: number) : void
            /** Returns a formatted string for this color.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString () : string
            /** Returns a formatted string for this color.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string) : string
            /** Returns a formatted string for this color.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            public constructor ($r: number, $g: number, $b: number, $a: number)
        }
        /** Format used when creating textures from scripts.
        */
        enum TextureFormat
        { Alpha8 = 1, ARGB4444 = 2, RGB24 = 3, RGBA32 = 4, ARGB32 = 5, RGB565 = 7, R16 = 9, DXT1 = 10, DXT5 = 12, RGBA4444 = 13, BGRA32 = 14, RHalf = 15, RGHalf = 16, RGBAHalf = 17, RFloat = 18, RGFloat = 19, RGBAFloat = 20, YUY2 = 21, RGB9e5Float = 22, BC4 = 26, BC5 = 27, BC6H = 24, BC7 = 25, DXT1Crunched = 28, DXT5Crunched = 29, PVRTC_RGB2 = 30, PVRTC_RGBA2 = 31, PVRTC_RGB4 = 32, PVRTC_RGBA4 = 33, ETC_RGB4 = 34, EAC_R = 41, EAC_R_SIGNED = 42, EAC_RG = 43, EAC_RG_SIGNED = 44, ETC2_RGB = 45, ETC2_RGBA1 = 46, ETC2_RGBA8 = 47, ASTC_4x4 = 48, ASTC_5x5 = 49, ASTC_6x6 = 50, ASTC_8x8 = 51, ASTC_10x10 = 52, ASTC_12x12 = 53, ETC_RGB4_3DS = -60, ETC_RGBA8_3DS = -61, RG16 = 62, R8 = 63, ETC_RGB4Crunched = 64, ETC2_RGBA8Crunched = 65, ASTC_HDR_4x4 = 66, ASTC_HDR_5x5 = 67, ASTC_HDR_6x6 = 68, ASTC_HDR_8x8 = 69, ASTC_HDR_10x10 = 70, ASTC_HDR_12x12 = 71, RG32 = 72, RGB48 = 73, RGBA64 = 74, R8_SIGNED = 75, RG16_SIGNED = 76, RGB24_SIGNED = 77, RGBA32_SIGNED = 78, R16_SIGNED = 79, RG32_SIGNED = 80, RGB48_SIGNED = 81, RGBA64_SIGNED = 82, ASTC_RGB_4x4 = -48, ASTC_RGB_5x5 = -49, ASTC_RGB_6x6 = -50, ASTC_RGB_8x8 = -51, ASTC_RGB_10x10 = -52, ASTC_RGB_12x12 = -53, ASTC_RGBA_4x4 = -54, ASTC_RGBA_5x5 = -55, ASTC_RGBA_6x6 = -56, ASTC_RGBA_8x8 = -57, ASTC_RGBA_10x10 = -58, ASTC_RGBA_12x12 = -59 }
        /** Compression Method for Asset Bundles.
        */
        enum CompressionType
        { None = 0, Lzma = 1, Lz4 = 2, Lz4HC = 3 }
        /** SortingLayer allows you to set the render order of multiple sprites easily. There is always a default SortingLayer named "Default" which all sprites are added to initially. Added more SortingLayers to easily control the order of rendering of groups of sprites. Layers can be ordered before or after the default layer.
        */
        class SortingLayer extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Delegate for sorting layer events when a layer is added.
            */
            public static onLayerAdded : UnityEngine.SortingLayer.LayerCallback
            /** Delegate for sorting layer events when a layer is removed.
            */
            public static onLayerRemoved : UnityEngine.SortingLayer.LayerCallback
            /** This is the unique id assigned to the layer. It is not an ordered running value and it should not be used to compare with other layers to determine the sorting order.
            */
            public get id(): number;
            /** Returns the name of the layer as defined in the TagManager.
            */
            public get name(): string;
            /** This is the relative value that indicates the sort order of this layer relative to the other layers.
            */
            public get value(): number;
            /** Returns all the layers defined in this project.
            */
            public static get layers(): System.Array$1<UnityEngine.SortingLayer>;
            /** Returns the final sorting layer value. To determine the sorting order between the various sorting layers, use this method to retrieve the final sorting value and use CompareTo to determine the order.
            * @param $id The unique value of the sorting layer as returned by any renderer's sortingLayerID property.
            * @returns The final sorting value of the layer relative to other layers. 
            */
            public static GetLayerValueFromID ($id: number) : number
            /** Returns the final sorting layer value. Additional resources: GetLayerValueFromID.
            * @param $name The unique value of the sorting layer as returned by any renderer's sortingLayerID property.
            * @returns The final sorting value of the layer relative to other layers. 
            */
            public static GetLayerValueFromName ($name: string) : number
            /** Returns the id given the name. Will return 0 if an invalid name was given.
            * @param $name The name of the layer.
            * @returns Returns the unique id of the layer with name. 
            */
            public static NameToID ($name: string) : number
            /** Returns the unique id of the layer. Will return "<unknown layer>" if an invalid id is given.
            * @param $id The unique id of the layer.
            * @returns The name of the layer with id or "<unknown layer>" for invalid id. 
            */
            public static IDToName ($id: number) : string
            /** Returns true if the id provided is a valid layer id.
            * @param $id The unique id of a layer.
            * @returns True if the id provided is valid and assigned to a layer. 
            */
            public static IsValid ($id: number) : boolean
        }
        /** Sets which weights to use when calculating curve segments.
        */
        enum WeightedMode
        { None = 0, In = 1, Out = 2, Both = 3 }
        /** A single keyframe that can be injected into an animation curve.
        */
        class Keyframe extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The time of the keyframe.
            */
            public get time(): number;
            public set time(value: number);
            /** The value of the curve at keyframe.
            */
            public get value(): number;
            public set value(value: number);
            /** Sets the incoming tangent for this key. The incoming tangent affects the slope of the curve from the previous key to this key.
            */
            public get inTangent(): number;
            public set inTangent(value: number);
            /** Sets the outgoing tangent for this key. The outgoing tangent affects the slope of the curve from this key to the next key.
            */
            public get outTangent(): number;
            public set outTangent(value: number);
            /** Sets the incoming weight for this key. The incoming weight affects the slope of the curve from the previous key to this key.
            */
            public get inWeight(): number;
            public set inWeight(value: number);
            /** Sets the outgoing weight for this key. The outgoing weight affects the slope of the curve from this key to the next key.
            */
            public get outWeight(): number;
            public set outWeight(value: number);
            /** Weighted mode for the keyframe.
            */
            public get weightedMode(): UnityEngine.WeightedMode;
            public set weightedMode(value: UnityEngine.WeightedMode);
            public constructor ($time: number, $value: number)
            public constructor ($time: number, $value: number, $inTangent: number, $outTangent: number)
            public constructor ($time: number, $value: number, $inTangent: number, $outTangent: number, $inWeight: number, $outWeight: number)
        }
        /** Determines how time is treated outside of the keyframed range of an AnimationClip or AnimationCurve.
        */
        enum WrapMode
        { Once = 1, Loop = 2, PingPong = 4, Default = 0, ClampForever = 8, Clamp = 1 }
        /** Store a collection of Keyframes that can be evaluated over time.
        */
        class AnimationCurve extends System.Object implements System.IEquatable$1<UnityEngine.AnimationCurve>
        {
            protected [__keep_incompatibility]: never;
            /** All keys defined in the animation curve.
            */
            public get keys(): System.Array$1<UnityEngine.Keyframe>;
            public set keys(value: System.Array$1<UnityEngine.Keyframe>);
            /** The number of keys in the curve. (Read Only)
            */
            public get length(): number;
            /** The behaviour of the animation before the first keyframe.
            */
            public get preWrapMode(): UnityEngine.WrapMode;
            public set preWrapMode(value: UnityEngine.WrapMode);
            /** The behaviour of the animation after the last keyframe.
            */
            public get postWrapMode(): UnityEngine.WrapMode;
            public set postWrapMode(value: UnityEngine.WrapMode);
            /** Evaluate the curve at time.
            * @param $time The time within the curve you want to evaluate (the horizontal axis in the curve graph).
            * @returns The value of the curve, at the point in time specified. 
            */
            public Evaluate ($time: number) : number
            /** Add a new key to the curve.
            * @param $time The time at which to add the key (horizontal axis in the curve graph).
            * @param $value The value for the key (vertical axis in the curve graph).
            * @returns The index of the added key, or -1 if the key could not be added. 
            */
            public AddKey ($time: number, $value: number) : number
            /** Add a new key to the curve.
            * @param $key The key to add to the curve.
            * @returns The index of the added key, or -1 if the key could not be added. 
            */
            public AddKey ($key: UnityEngine.Keyframe) : number
            /** Removes the keyframe at index and inserts key.
            * @param $index The index of the key to move.
            * @param $key The key (with its new time) to insert.
            * @returns The index of the keyframe after moving it. 
            */
            public MoveKey ($index: number, $key: UnityEngine.Keyframe) : number
            /** Erases all KeyFrame from this instance of the AnimationCurve.
            */
            public ClearKeys () : void
            /** Removes a key.
            * @param $index The index of the key to remove.
            */
            public RemoveKey ($index: number) : void
            public get_Item ($index: number) : UnityEngine.Keyframe
            /** Smooth the in and out tangents of the keyframe at index.
            * @param $index The index of the keyframe to be smoothed.
            * @param $weight The smoothing weight to apply to the keyframe's tangents.
            */
            public SmoothTangents ($index: number, $weight: number) : void
            /** Creates a constant "curve" starting at timeStart, ending at timeEnd, and set to the value value.
            * @param $timeStart The start time for the constant curve.
            * @param $timeEnd The end time for the constant curve.
            * @param $value The value for the constant curve.
            * @returns The constant curve created from the specified values. 
            */
            public static Constant ($timeStart: number, $timeEnd: number, $value: number) : UnityEngine.AnimationCurve
            /** A straight Line starting at timeStart, valueStart and ending at timeEnd, valueEnd.
            * @param $timeStart The start time for the linear curve.
            * @param $valueStart The start value for the linear curve.
            * @param $timeEnd The end time for the linear curve.
            * @param $valueEnd The end value for the linear curve.
            * @returns The linear curve created from the specified values. 
            */
            public static Linear ($timeStart: number, $valueStart: number, $timeEnd: number, $valueEnd: number) : UnityEngine.AnimationCurve
            /** Creates an ease-in and out curve starting at timeStart, valueStart and ending at timeEnd, valueEnd.
            * @param $timeStart The start time for the ease curve.
            * @param $valueStart The start value for the ease curve.
            * @param $timeEnd The end time for the ease curve.
            * @param $valueEnd The end value for the ease curve.
            * @returns The ease-in and out curve generated from the specified values. 
            */
            public static EaseInOut ($timeStart: number, $valueStart: number, $timeEnd: number, $valueEnd: number) : UnityEngine.AnimationCurve
            public Equals ($o: any) : boolean
            public Equals ($other: UnityEngine.AnimationCurve) : boolean
            /** Copies the keys and properties of the specified AnimationCurve object into this instance of the  AnimationCurve class.
            * @param $other The AnimationCurve object to obtain the values to copy.
            */
            public CopyFrom ($other: UnityEngine.AnimationCurve) : void
            public constructor (...keys: UnityEngine.Keyframe[])
            public constructor ()
        }
        /** Provides access to application runtime data.
        */
        class Application extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Returns true when called in any kind of built Player, or when called in the Editor in Play mode (Read Only).
            */
            public static get isPlaying(): boolean;
            /** Whether the Player currently has focus (Read Only).
            */
            public static get isFocused(): boolean;
            /** Returns a GUID for this build (Read Only).
            */
            public static get buildGUID(): string;
            /** Determines whether the Player should run when the application is in the background
            */
            public static get runInBackground(): boolean;
            public static set runInBackground(value: boolean);
            /** Returns true when Unity is launched with the -batchmode flag from the command line (Read Only).
            */
            public static get isBatchMode(): boolean;
            /** Contains the path to the game data folder on the target device (Read Only).
            */
            public static get dataPath(): string;
            /** The path to the StreamingAssets  folder (Read Only).
            */
            public static get streamingAssetsPath(): string;
            /** Contains the path to a persistent data directory (Read-only).
            */
            public static get persistentDataPath(): string;
            /** Contains the path to a temporary data / cache directory (Read Only).
            */
            public static get temporaryCachePath(): string;
            /** The URL of the document. For WebGL, this is a web URL. For Android, iOS, or Universal Windows Platform (UWP) this is a deep link URL (Read Only).
            */
            public static get absoluteURL(): string;
            /** The version of the Unity runtime used to play the content.
            */
            public static get unityVersion(): string;
            /** Returns application version number (Read Only).
            */
            public static get version(): string;
            /** Returns the name of the store or package that installed the application (Read Only).
            */
            public static get installerName(): string;
            /** Returns the application identifier at runtime. 
            */
            public static get identifier(): string;
            /** Returns application install mode (Read Only).
            */
            public static get installMode(): UnityEngine.ApplicationInstallMode;
            /** Returns application running in a sandbox environment (Read-only).
            */
            public static get sandboxType(): UnityEngine.ApplicationSandboxType;
            /** Returns application product name (Read Only).
            */
            public static get productName(): string;
            /** Returns application company name (Read Only).
            */
            public static get companyName(): string;
            /** A unique cloud project identifier. It is unique for every project (Read Only).
            */
            public static get cloudProjectId(): string;
            /** Specifies the target frame rate at which Unity tries to render your game.
            */
            public static get targetFrameRate(): number;
            public static set targetFrameRate(value: number);
            /** Returns the path to the console log file, or an empty string if the current platform does not support log files.
            */
            public static get consoleLogPath(): string;
            /** Priority of background loading thread.
            */
            public static get backgroundLoadingPriority(): UnityEngine.ThreadPriority;
            public static set backgroundLoadingPriority(value: UnityEngine.ThreadPriority);
            /** Returns false if application is altered in any way after it was built.
            */
            public static get genuine(): boolean;
            /** Returns true if application integrity can be confirmed.
            */
            public static get genuineCheckAvailable(): boolean;
            /** Returns the platform the game is running on (Read Only).
            */
            public static get platform(): UnityEngine.RuntimePlatform;
            /** Identifies whether the current Runtime platform is a known mobile platform.
            */
            public static get isMobilePlatform(): boolean;
            /** Is the current Runtime platform a known console platform.
            */
            public static get isConsolePlatform(): boolean;
            /** The language in which the user's operating system is running in.
            */
            public static get systemLanguage(): UnityEngine.SystemLanguage;
            /** Returns the type of internet reachability currently possible on the device.
            */
            public static get internetReachability(): UnityEngine.NetworkReachability;
            /** Cancellation token raised on exiting Play mode (Editor) or on quitting the application (Read Only).
            */
            public static get exitCancellationToken(): System.Threading.CancellationToken;
            /** Whether the game is running inside the Unity Editor (Read Only).
            */
            public static get isEditor(): boolean;
            public static Quit ($exitCode: number) : void
            /** Quits the player application.
            * @param $exitCode An optional exit code to return when the player application terminates on Windows, Mac and Linux. Defaults to 0.
            */
            public static Quit () : void
            /** Unloads the Unity Player.
            */
            public static Unload () : void
            /** Checks if the streamed level can be loaded.
            */
            public static CanStreamedLevelBeLoaded ($levelIndex: number) : boolean
            /** Checks if the streamed level can be loaded.
            */
            public static CanStreamedLevelBeLoaded ($levelName: string) : boolean
            /** Returns true if the given object is part of the playing world either in any kind of built Player or in Play Mode.
            * @param $obj The object to test.
            * @returns True if the object is part of the playing world. 
            */
            public static IsPlaying ($obj: UnityEngine.Object) : boolean
            /** Is Unity activated with the Pro license?
            */
            public static HasProLicense () : boolean
            public static RequestAdvertisingIdentifierAsync ($delegateMethod: UnityEngine.Application.AdvertisingIdentifierCallback) : boolean
            /** Opens the URL specified, subject to the permissions and limitations of your app’s current platform and environment. 
            * @param $url The URL to open.
            */
            public static OpenURL ($url: string) : void
            /** Get stack trace logging options. The default value is StackTraceLogType.ScriptOnly.
            */
            public static GetStackTraceLogType ($logType: UnityEngine.LogType) : UnityEngine.StackTraceLogType
            /** Set stack trace logging options. The default value is StackTraceLogType.ScriptOnly.
            */
            public static SetStackTraceLogType ($logType: UnityEngine.LogType, $stackTraceType: UnityEngine.StackTraceLogType) : void
            /** Request authorization to use the webcam or microphone on iOS and WebGL.
            */
            public static RequestUserAuthorization ($mode: UnityEngine.UserAuthorization) : UnityEngine.AsyncOperation
            /** Check if the user has authorized use of the webcam or microphone on iOS and WebGL.
            */
            public static HasUserAuthorization ($mode: UnityEngine.UserAuthorization) : boolean
            public static add_lowMemory ($value: UnityEngine.Application.LowMemoryCallback) : void
            public static remove_lowMemory ($value: UnityEngine.Application.LowMemoryCallback) : void
            public static add_memoryUsageChanged ($value: UnityEngine.Application.MemoryUsageChangedCallback) : void
            public static remove_memoryUsageChanged ($value: UnityEngine.Application.MemoryUsageChangedCallback) : void
            public static add_logMessageReceived ($value: UnityEngine.Application.LogCallback) : void
            public static remove_logMessageReceived ($value: UnityEngine.Application.LogCallback) : void
            public static add_logMessageReceivedThreaded ($value: UnityEngine.Application.LogCallback) : void
            public static remove_logMessageReceivedThreaded ($value: UnityEngine.Application.LogCallback) : void
            public static add_onBeforeRender ($value: UnityEngine.Events.UnityAction) : void
            public static remove_onBeforeRender ($value: UnityEngine.Events.UnityAction) : void
            public static add_focusChanged ($value: System.Action$1<boolean>) : void
            public static remove_focusChanged ($value: System.Action$1<boolean>) : void
            public static add_deepLinkActivated ($value: System.Action$1<string>) : void
            public static remove_deepLinkActivated ($value: System.Action$1<string>) : void
            public static add_wantsToQuit ($value: System.Func$1<boolean>) : void
            public static remove_wantsToQuit ($value: System.Func$1<boolean>) : void
            public static add_quitting ($value: System.Action) : void
            public static remove_quitting ($value: System.Action) : void
            public static add_unloading ($value: System.Action) : void
            public static remove_unloading ($value: System.Action) : void
            public constructor ()
        }
        /** Application installation mode (Read Only).
        */
        enum ApplicationInstallMode
        { Unknown = 0, Store = 1, DeveloperBuild = 2, Adhoc = 3, Enterprise = 4, Editor = 5 }
        /** Application sandbox type.
        */
        enum ApplicationSandboxType
        { Unknown = 0, NotSandboxed = 1, Sandboxed = 2, SandboxBroken = 3 }
        /** Stack trace logging options.
        */
        enum StackTraceLogType
        { None = 0, ScriptOnly = 1, Full = 2 }
        /** The type of the log message in Debug.unityLogger.Log or delegate registered with Application.RegisterLogCallback.
        */
        enum LogType
        { Error = 0, Assert = 1, Warning = 2, Log = 3, Exception = 4 }
        /** Priority of a thread.
        */
        enum ThreadPriority
        { Low = 0, BelowNormal = 1, Normal = 2, High = 4 }
        /** Base class for all yield instructions.
        */
        class YieldInstruction extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Asynchronous operation coroutine.
        */
        class AsyncOperation extends UnityEngine.YieldInstruction
        {
            protected [__keep_incompatibility]: never;
            /** Has the operation finished? (Read Only)
            */
            public get isDone(): boolean;
            /** What's the operation's progress. (Read Only)
            */
            public get progress(): number;
            /** Priority lets you tweak in which order async operation calls will be performed.
            */
            public get priority(): number;
            public set priority(value: number);
            /** Allow Scenes to be activated as soon as it is ready.
            */
            public get allowSceneActivation(): boolean;
            public set allowSceneActivation(value: boolean);
            public add_completed ($value: System.Action$1<UnityEngine.AsyncOperation>) : void
            public remove_completed ($value: System.Action$1<UnityEngine.AsyncOperation>) : void
            public constructor ()
        }
        /** Constants to pass to Application.RequestUserAuthorization.
        */
        enum UserAuthorization
        { WebCam = 1, Microphone = 2 }
        /** The platform application is running. Returned by Application.platform.
        */
        enum RuntimePlatform
        { OSXEditor = 0, OSXPlayer = 1, WindowsPlayer = 2, OSXWebPlayer = 3, OSXDashboardPlayer = 4, WindowsWebPlayer = 5, WindowsEditor = 7, IPhonePlayer = 8, XBOX360 = 10, PS3 = 9, Android = 11, NaCl = 12, FlashPlayer = 15, LinuxPlayer = 13, LinuxEditor = 16, WebGLPlayer = 17, MetroPlayerX86 = 18, WSAPlayerX86 = 18, MetroPlayerX64 = 19, WSAPlayerX64 = 19, MetroPlayerARM = 20, WSAPlayerARM = 20, WP8Player = 21, BB10Player = 22, BlackBerryPlayer = 22, TizenPlayer = 23, PSP2 = 24, PS4 = 25, PSM = 26, XboxOne = 27, SamsungTVPlayer = 28, WiiU = 30, tvOS = 31, Switch = 32, Lumin = 33, Stadia = 34, CloudRendering = -1, LinuxHeadlessSimulation = 35, GameCoreScarlett = -1, GameCoreXboxSeries = 36, GameCoreXboxOne = 37, PS5 = 38, EmbeddedLinuxArm64 = 39, EmbeddedLinuxArm32 = 40, EmbeddedLinuxX64 = 41, EmbeddedLinuxX86 = 42, LinuxServer = 43, WindowsServer = 44, OSXServer = 45, QNXArm32 = 46, QNXArm64 = 47, QNXX64 = 48, QNXX86 = 49 }
        /** The language the user's operating system is running in. Returned by Application.systemLanguage.
        */
        enum SystemLanguage
        { Afrikaans = 0, Arabic = 1, Basque = 2, Belarusian = 3, Bulgarian = 4, Catalan = 5, Chinese = 6, Czech = 7, Danish = 8, Dutch = 9, English = 10, Estonian = 11, Faroese = 12, Finnish = 13, French = 14, German = 15, Greek = 16, Hebrew = 17, Hugarian = 18, Icelandic = 19, Indonesian = 20, Italian = 21, Japanese = 22, Korean = 23, Latvian = 24, Lithuanian = 25, Norwegian = 26, Polish = 27, Portuguese = 28, Romanian = 29, Russian = 30, SerboCroatian = 31, Slovak = 32, Slovenian = 33, Spanish = 34, Swedish = 35, Thai = 36, Turkish = 37, Ukrainian = 38, Vietnamese = 39, ChineseSimplified = 40, ChineseTraditional = 41, Hindi = 42, Unknown = 43, Hungarian = 18 }
        /** Describes network reachability options.
        */
        enum NetworkReachability
        { NotReachable = 0, ReachableViaCarrierDataNetwork = 1, ReachableViaLocalAreaNetwork = 2 }
        /** Contains information about a change in the application's memory usage.
        */
        class ApplicationMemoryUsageChange extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The memory usage level for the application.
            */
            public get memoryUsage(): UnityEngine.ApplicationMemoryUsage;
            public constructor ($usage: UnityEngine.ApplicationMemoryUsage)
        }
        /** Describes the application memory usage level.
        */
        enum ApplicationMemoryUsage
        { Unknown = 0, Low = 1, Medium = 2, High = 3, Critical = 4 }
        /** Type of the imported(native) data.
        */
        enum AudioType
        { UNKNOWN = 0, ACC = 1, AIFF = 2, IT = 10, MOD = 12, MPEG = 13, OGGVORBIS = 14, S3M = 17, WAV = 20, XM = 21, XMA = 22, VAG = 23, AUDIOQUEUE = 24 }
        /** Options for how to send a message.
        */
        enum SendMessageOptions
        { RequireReceiver = 0, DontRequireReceiver = 1 }
        /** The various primitives that can be created using the GameObject.CreatePrimitive function.
        */
        enum PrimitiveType
        { Sphere = 0, Capsule = 1, Cylinder = 2, Cube = 3, Plane = 4, Quad = 5 }
        /** The coordinate space in which to operate.
        */
        enum Space
        { World = 0, Self = 1 }
        /** Option flags for specifying special treatment of a log message.
        */
        enum LogOption
        { None = 0, NoStacktrace = 1 }
        /** Data structure for downloading AssetBundles to a customized cache path. Additional resources:UnityWebRequestAssetBundle.GetAssetBundle for more information.
        */
        class CachedAssetBundle extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** AssetBundle name which is used as the customized cache path.
            */
            public get name(): string;
            public set name(value: string);
            /** Hash128 which is used as the version of the AssetBundle.
            */
            public get hash(): UnityEngine.Hash128;
            public set hash(value: UnityEngine.Hash128);
            public constructor ($name: string, $hash: UnityEngine.Hash128)
        }
        /** Represents  a 128-bit hash value.
        */
        class Hash128 extends System.ValueType implements System.IComparable, System.IComparable$1<UnityEngine.Hash128>, System.IEquatable$1<UnityEngine.Hash128>
        {
            protected [__keep_incompatibility]: never;
            /** Returns true is the hash value is valid. (Read Only)
            */
            public get isValid(): boolean;
            public CompareTo ($rhs: UnityEngine.Hash128) : number
            /** Convert a hex-encoded string into Hash128 value.
            * @param $hashString A hexadecimal-encoded hash string.
            * @returns The 128-bit hash. 
            */
            public static Parse ($hashString: string) : UnityEngine.Hash128
            /** Compute a hash of input data string.
            * @param $data Input data string. Note that Unity interprets the string as UTF-8 data, even if internally in C# strings are UTF-16.
            * @returns The 128-bit hash. 
            */
            public static Compute ($data: string) : UnityEngine.Hash128
            /** Compute a hash of input data.
            * @param $val Input value.
            * @returns The 128-bit hash. 
            */
            public static Compute ($val: number) : UnityEngine.Hash128
            /** Hash new input string and combine with the current hash value.
            * @param $data Input data string. Note that Unity interprets the string as UTF-8 data, even if internally in C# strings are UTF-16.
            */
            public Append ($data: string) : void
            /** Hash new input data and combine with the current hash value.
            * @param $val Input value.
            */
            public Append ($val: number) : void
            public Equals ($obj: any) : boolean
            public Equals ($obj: UnityEngine.Hash128) : boolean
            public CompareTo ($obj: any) : number
            public static op_Equality ($hash1: UnityEngine.Hash128, $hash2: UnityEngine.Hash128) : boolean
            public static op_Inequality ($hash1: UnityEngine.Hash128, $hash2: UnityEngine.Hash128) : boolean
            public static op_LessThan ($x: UnityEngine.Hash128, $y: UnityEngine.Hash128) : boolean
            public static op_GreaterThan ($x: UnityEngine.Hash128, $y: UnityEngine.Hash128) : boolean
            public constructor ($u32_0: number, $u32_1: number, $u32_2: number, $u32_3: number)
            public constructor ($u64_0: bigint, $u64_1: bigint)
        }
        /** Data structure for cache. For more information, see Caching.AddCache.
        */
        class Cache extends System.ValueType implements System.IEquatable$1<UnityEngine.Cache>
        {
            protected [__keep_incompatibility]: never;
            /** Returns true if the cache is valid.
            */
            public get valid(): boolean;
            /** Returns true if the cache is ready.
            */
            public get ready(): boolean;
            /** Returns true if the cache is readonly.
            */
            public get readOnly(): boolean;
            /** Returns the path of the cache.
            */
            public get path(): string;
            /** Returns the index of the cache in the cache list.
            */
            public get index(): number;
            /** Returns the number of currently unused bytes in the cache.
            */
            public get spaceFree(): bigint;
            /** Allows you to specify the total number of bytes that can be allocated for the cache.
            */
            public get maximumAvailableStorageSpace(): bigint;
            public set maximumAvailableStorageSpace(value: bigint);
            /** Returns the used disk space in bytes.
            */
            public get spaceOccupied(): bigint;
            /** The number of seconds that an AssetBundle may remain unused in the cache before it is automatically deleted.
            */
            public get expirationDelay(): number;
            public set expirationDelay(value: number);
            public static op_Equality ($lhs: UnityEngine.Cache, $rhs: UnityEngine.Cache) : boolean
            public static op_Inequality ($lhs: UnityEngine.Cache, $rhs: UnityEngine.Cache) : boolean
            public Equals ($other: any) : boolean
            public Equals ($other: UnityEngine.Cache) : boolean
            /** Removes all cached content in the cache that has been cached by the current application.
            * @param $expiration The number of seconds that AssetBundles may remain unused in the cache.
            * @returns Returns True when cache clearing succeeded. 
            */
            public ClearCache () : boolean
            /** Removes all cached content in the cache that has been cached by the current application.
            * @param $expiration The number of seconds that AssetBundles may remain unused in the cache.
            * @returns Returns True when cache clearing succeeded. 
            */
            public ClearCache ($expiration: number) : boolean
        }
        class CacheIndex extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public name : string
            public bytesUsed : number
            public expires : number
        }
        /** The Caching class lets you manage cached AssetBundles, downloaded using UnityWebRequestAssetBundle.GetAssetBundle. 
        */
        class Caching extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Controls compression of cache data. Enabled by default.
            */
            public static get compressionEnabled(): boolean;
            public static set compressionEnabled(value: boolean);
            /** Returns true if Caching system is ready for use.
            */
            public static get ready(): boolean;
            /** Returns the cache count in the cache list.
            */
            public static get cacheCount(): number;
            /** Returns the default cache which is added by Unity internally.
            */
            public static get defaultCache(): UnityEngine.Cache;
            /** Gets or sets the current cache in which AssetBundles should be cached.
            */
            public static get currentCacheForWriting(): UnityEngine.Cache;
            public static set currentCacheForWriting(value: UnityEngine.Cache);
            /** Removes all AssetBundle content that has been cached by the current application.
            * @param $expiration The number of seconds that AssetBundles may remain unused in the cache.
            * @returns True when cache clearing succeeded, false if cache was in use. 
            */
            public static ClearCache () : boolean
            /** Removes all AssetBundle content that has been cached by the current application.
            * @param $expiration The number of seconds that AssetBundles may remain unused in the cache.
            * @returns True when cache clearing succeeded, false if cache was in use. 
            */
            public static ClearCache ($expiration: number) : boolean
            /** Removes the given version of the AssetBundle.
            * @param $assetBundleName The AssetBundle name.
            * @param $hash Version needs to be cleaned.
            * @returns Returns true when cache clearing succeeded.  Can return false if any cached bundle is in use. 
            */
            public static ClearCachedVersion ($assetBundleName: string, $hash: UnityEngine.Hash128) : boolean
            /** Removes all the cached versions of the AssetBundle from the cache, except for the specified version.
            * @param $assetBundleName The AssetBundle name.
            * @param $hash Version needs to be kept.
            * @returns Returns true when cache clearing succeeded. 
            */
            public static ClearOtherCachedVersions ($assetBundleName: string, $hash: UnityEngine.Hash128) : boolean
            /** Removes all the cached versions of the given AssetBundle from the cache.
            * @param $assetBundleName The AssetBundle name.
            * @returns Returns true when cache clearing succeeded. 
            */
            public static ClearAllCachedVersions ($assetBundleName: string) : boolean
            public static GetCachedVersions ($assetBundleName: string, $outCachedVersions: System.Collections.Generic.List$1<UnityEngine.Hash128>) : void
            /** Checks if an AssetBundle is cached.
            * @param $Url The filename of the AssetBundle. Domain and path information are stripped from this string automatically.
            * @param $hash The version hash of the AssetBundle to check for. Corresponds to the version hash in some signatures of UnityWebRequestAssetBundle.GetAssetBundle.
            * @param $version The version number of the AssetBundle to check for. Corresponds to the numeric version in some signatures of UnityWebRequestAssetBundle.GetAssetBundle.
            * @returns True if an AssetBundle matching the url and version parameters has previously been loaded using UnityWebRequestAssetBundle.GetAssetBundle() and is currently stored in the cache. Returns false if the AssetBundle is not in cache, either because it has been flushed from the cache or was never loaded using the Caching API. 
            */
            public static IsVersionCached ($url: string, $hash: UnityEngine.Hash128) : boolean
            public static IsVersionCached ($cachedBundle: UnityEngine.CachedAssetBundle) : boolean
            public static MarkAsUsed ($url: string, $hash: UnityEngine.Hash128) : boolean
            public static MarkAsUsed ($cachedBundle: UnityEngine.CachedAssetBundle) : boolean
            public static SetNoBackupFlag ($url: string, $hash: UnityEngine.Hash128) : void
            public static SetNoBackupFlag ($cachedBundle: UnityEngine.CachedAssetBundle) : void
            public static ResetNoBackupFlag ($url: string, $hash: UnityEngine.Hash128) : void
            public static ResetNoBackupFlag ($cachedBundle: UnityEngine.CachedAssetBundle) : void
            /** Add a cache with the given path.
            * @param $cachePath Path to the cache folder.
            */
            public static AddCache ($cachePath: string) : UnityEngine.Cache
            /** Returns the Cache at the given position in the cache list.
            * @param $cacheIndex Index of the cache to get.
            * @returns A reference to the Cache at the index specified. 
            */
            public static GetCacheAt ($cacheIndex: number) : UnityEngine.Cache
            /** Returns the Cache that has the given cache path.
            * @param $cachePath The cache path.
            * @returns A reference to the Cache with the given path. 
            */
            public static GetCacheByPath ($cachePath: string) : UnityEngine.Cache
            public static GetAllCachePaths ($cachePaths: System.Collections.Generic.List$1<string>) : void
            /** Removes the Cache from cache list.
            * @param $cache The Cache to be removed.
            * @returns Returns true if the Cache is removed. 
            */
            public static RemoveCache ($cache: UnityEngine.Cache) : boolean
            /** Moves the source Cache before the destination Cache in the cache list.
            * @param $src The Cache to move.
            * @param $dst The Cache which should come after the source Cache in the cache list.
            */
            public static MoveCacheBefore ($src: UnityEngine.Cache, $dst: UnityEngine.Cache) : void
            /** Moves the source Cache after the destination Cache in the cache list.
            * @param $src The Cache to move.
            * @param $dst The Cache which should come before the source Cache in the cache list.
            */
            public static MoveCacheAfter ($src: UnityEngine.Cache, $dst: UnityEngine.Cache) : void
            public constructor ()
        }
        /** Behaviours are Components that can be enabled or disabled.
        */
        class Behaviour extends UnityEngine.Component
        {
            protected [__keep_incompatibility]: never;
            /** Enabled Behaviours are Updated, disabled Behaviours are not.
            */
            public get enabled(): boolean;
            public set enabled(value: boolean);
            /** Reports whether a GameObject and its associated Behaviour is active and enabled.
            */
            public get isActiveAndEnabled(): boolean;
            public constructor ()
        }
        /** A Camera is a device through which the player views the world.
        */
        class Camera extends UnityEngine.Behaviour
        {
            protected [__keep_incompatibility]: never;
            /** The minimum allowed aperture.
            */
            public static kMinAperture : number
            /** The maximum allowed aperture.
            */
            public static kMaxAperture : number
            /** The minimum blade count for the aperture diaphragm.
            */
            public static kMinBladeCount : number
            /** The maximum blade count for the aperture diaphragm.
            */
            public static kMaxBladeCount : number
            /** Delegate that you can use to execute custom code before a Camera culls the scene.
            */
            public static onPreCull : UnityEngine.Camera.CameraCallback
            /** Delegate that you can use to execute custom code before a Camera renders the scene.
            */
            public static onPreRender : UnityEngine.Camera.CameraCallback
            /** Delegate that you can use to execute custom code after a Camera renders the scene.
            */
            public static onPostRender : UnityEngine.Camera.CameraCallback
            /** The distance of the near clipping plane from the the Camera, in world units.
            */
            public get nearClipPlane(): number;
            public set nearClipPlane(value: number);
            /** The distance of the far clipping plane from the Camera, in world units.
            */
            public get farClipPlane(): number;
            public set farClipPlane(value: number);
            /** The vertical field of view of the Camera, in degrees.
            */
            public get fieldOfView(): number;
            public set fieldOfView(value: number);
            /** The rendering path that should be used, if possible.
            */
            public get renderingPath(): UnityEngine.RenderingPath;
            public set renderingPath(value: UnityEngine.RenderingPath);
            /** The rendering path that is currently being used (Read Only).
            */
            public get actualRenderingPath(): UnityEngine.RenderingPath;
            /** High dynamic range rendering.
            */
            public get allowHDR(): boolean;
            public set allowHDR(value: boolean);
            /** MSAA rendering.
            */
            public get allowMSAA(): boolean;
            public set allowMSAA(value: boolean);
            /** Dynamic Resolution Scaling.
            */
            public get allowDynamicResolution(): boolean;
            public set allowDynamicResolution(value: boolean);
            /** Should camera rendering be forced into a RenderTexture.
            */
            public get forceIntoRenderTexture(): boolean;
            public set forceIntoRenderTexture(value: boolean);
            /** Camera's half-size when in orthographic mode.
            */
            public get orthographicSize(): number;
            public set orthographicSize(value: number);
            /** Is the camera orthographic (true) or perspective (false)?
            */
            public get orthographic(): boolean;
            public set orthographic(value: boolean);
            /** Opaque object sorting mode.
            */
            public get opaqueSortMode(): UnityEngine.Rendering.OpaqueSortMode;
            public set opaqueSortMode(value: UnityEngine.Rendering.OpaqueSortMode);
            /** Transparent object sorting mode.
            */
            public get transparencySortMode(): UnityEngine.TransparencySortMode;
            public set transparencySortMode(value: UnityEngine.TransparencySortMode);
            /** An axis that describes the direction along which the distances of objects are measured for the purpose of sorting.
            */
            public get transparencySortAxis(): UnityEngine.Vector3;
            public set transparencySortAxis(value: UnityEngine.Vector3);
            /** Camera's depth in the camera rendering order.
            */
            public get depth(): number;
            public set depth(value: number);
            /** The aspect ratio (width divided by height).
            */
            public get aspect(): number;
            public set aspect(value: number);
            /** Get the world-space speed of the camera (Read Only).
            */
            public get velocity(): UnityEngine.Vector3;
            /** This is used to render parts of the Scene selectively.
            */
            public get cullingMask(): number;
            public set cullingMask(value: number);
            /** Mask to select which layers can trigger events on the camera.
            */
            public get eventMask(): number;
            public set eventMask(value: number);
            /** How to perform per-layer culling for a Camera.
            */
            public get layerCullSpherical(): boolean;
            public set layerCullSpherical(value: boolean);
            /** Identifies what kind of camera this is, using the CameraType enum.
            */
            public get cameraType(): UnityEngine.CameraType;
            public set cameraType(value: UnityEngine.CameraType);
            /** Sets the culling mask used to determine which objects from which Scenes to draw.
            See EditorSceneManager.SetSceneCullingMask.
            */
            public get overrideSceneCullingMask(): bigint;
            public set overrideSceneCullingMask(value: bigint);
            /** Per-layer culling distances.
            */
            public get layerCullDistances(): System.Array$1<number>;
            public set layerCullDistances(value: System.Array$1<number>);
            /** Whether or not the Camera will use occlusion culling during rendering.
            */
            public get useOcclusionCulling(): boolean;
            public set useOcclusionCulling(value: boolean);
            /** Sets a custom matrix for the camera to use for all culling queries.
            */
            public get cullingMatrix(): UnityEngine.Matrix4x4;
            public set cullingMatrix(value: UnityEngine.Matrix4x4);
            /** The color with which the screen will be cleared.
            */
            public get backgroundColor(): UnityEngine.Color;
            public set backgroundColor(value: UnityEngine.Color);
            /** How the camera clears the background.
            */
            public get clearFlags(): UnityEngine.CameraClearFlags;
            public set clearFlags(value: UnityEngine.CameraClearFlags);
            /** How and if camera generates a depth texture.
            */
            public get depthTextureMode(): UnityEngine.DepthTextureMode;
            public set depthTextureMode(value: UnityEngine.DepthTextureMode);
            /** Should the camera clear the stencil buffer after the deferred light pass?
            */
            public get clearStencilAfterLightingPass(): boolean;
            public set clearStencilAfterLightingPass(value: boolean);
            /** Enable usePhysicalProperties to use physical camera properties to compute the field of view and the frustum.
            */
            public get usePhysicalProperties(): boolean;
            public set usePhysicalProperties(value: boolean);
            /** The sensor sensitivity of the camera. To use this property, enable UsePhysicalProperties.
            */
            public get iso(): number;
            public set iso(value: number);
            /** The exposure time of the camera, in seconts. To use this property, enable UsePhysicalProperties.
            */
            public get shutterSpeed(): number;
            public set shutterSpeed(value: number);
            /** The camera aperture. To use this property, enable UsePhysicalProperties.
            */
            public get aperture(): number;
            public set aperture(value: number);
            /** The focus distance of the lens. To use this property, enable UsePhysicalProperties.
            */
            public get focusDistance(): number;
            public set focusDistance(value: number);
            /** The camera focal length, expressed in millimeters. To use this property, enable UsePhysicalProperties.
            */
            public get focalLength(): number;
            public set focalLength(value: number);
            /** The blade count in the lens of the camera. To use this property, enable UsePhysicalProperties.
            */
            public get bladeCount(): number;
            public set bladeCount(value: number);
            /** The curvature of the blades. To use this property, enable UsePhysicalProperties.
            */
            public get curvature(): UnityEngine.Vector2;
            public set curvature(value: UnityEngine.Vector2);
            /** The camera barrel clipping. To use this property, enable UsePhysicalProperties.
            */
            public get barrelClipping(): number;
            public set barrelClipping(value: number);
            /** The camera anamorphism. To use this property, enable UsePhysicalProperties.
            */
            public get anamorphism(): number;
            public set anamorphism(value: number);
            /** The size of the camera sensor, expressed in millimeters.
            */
            public get sensorSize(): UnityEngine.Vector2;
            public set sensorSize(value: UnityEngine.Vector2);
            /** The lens offset of the camera. The lens shift is relative to the sensor size. For example, a lens shift of 0.5 offsets the sensor by half its horizontal size.
            */
            public get lensShift(): UnityEngine.Vector2;
            public set lensShift(value: UnityEngine.Vector2);
            /** There are two gates for a camera, the sensor gate and the resolution gate. The physical camera sensor gate is defined by the sensorSize property, the resolution gate is defined by the render target area.
            */
            public get gateFit(): UnityEngine.Camera.GateFitMode;
            public set gateFit(value: UnityEngine.Camera.GateFitMode);
            /** Where on the screen is the camera rendered in normalized coordinates.
            */
            public get rect(): UnityEngine.Rect;
            public set rect(value: UnityEngine.Rect);
            /** Where on the screen is the camera rendered in pixel coordinates.
            */
            public get pixelRect(): UnityEngine.Rect;
            public set pixelRect(value: UnityEngine.Rect);
            /** How wide is the camera in pixels (not accounting for dynamic resolution scaling) (Read Only).
            */
            public get pixelWidth(): number;
            /** How tall is the camera in pixels (not accounting for dynamic resolution scaling) (Read Only).
            */
            public get pixelHeight(): number;
            /** How wide is the camera in pixels (accounting for dynamic resolution scaling) (Read Only).
            */
            public get scaledPixelWidth(): number;
            /** How tall is the camera in pixels (accounting for dynamic resolution scaling) (Read Only).
            */
            public get scaledPixelHeight(): number;
            /** Destination render texture.
            */
            public get targetTexture(): UnityEngine.RenderTexture;
            public set targetTexture(value: UnityEngine.RenderTexture);
            /** Gets the temporary RenderTexture target for this Camera.
            */
            public get activeTexture(): UnityEngine.RenderTexture;
            /** Set the target display for this Camera.
            */
            public get targetDisplay(): number;
            public set targetDisplay(value: number);
            /** Matrix that transforms from camera space to world space (Read Only).
            */
            public get cameraToWorldMatrix(): UnityEngine.Matrix4x4;
            /** Matrix that transforms from world to camera space.
            */
            public get worldToCameraMatrix(): UnityEngine.Matrix4x4;
            public set worldToCameraMatrix(value: UnityEngine.Matrix4x4);
            /** Set a custom projection matrix.
            */
            public get projectionMatrix(): UnityEngine.Matrix4x4;
            public set projectionMatrix(value: UnityEngine.Matrix4x4);
            /** Get or set the raw projection matrix with no camera offset (no jittering).
            */
            public get nonJitteredProjectionMatrix(): UnityEngine.Matrix4x4;
            public set nonJitteredProjectionMatrix(value: UnityEngine.Matrix4x4);
            /** Should the jittered matrix be used for transparency rendering?
            */
            public get useJitteredProjectionMatrixForTransparentRendering(): boolean;
            public set useJitteredProjectionMatrixForTransparentRendering(value: boolean);
            /** Get the view projection matrix used on the last frame.
            */
            public get previousViewProjectionMatrix(): UnityEngine.Matrix4x4;
            /** The first enabled Camera component that is tagged "MainCamera" (Read Only).
            */
            public static get main(): UnityEngine.Camera;
            /** The camera we are currently rendering with, for low-level render control only (Read Only).
            */
            public static get current(): UnityEngine.Camera;
            /** If not null, the camera will only render the contents of the specified Scene.
            */
            public get scene(): UnityEngine.SceneManagement.Scene;
            public set scene(value: UnityEngine.SceneManagement.Scene);
            /** Stereoscopic rendering.
            */
            public get stereoEnabled(): boolean;
            /** The distance between the virtual eyes. Use this to query or set the current eye separation. Note that most VR devices provide this value, in which case setting the value will have no effect.
            */
            public get stereoSeparation(): number;
            public set stereoSeparation(value: number);
            /** Distance to a point where virtual eyes converge.
            */
            public get stereoConvergence(): number;
            public set stereoConvergence(value: number);
            /** Determines whether the stereo view matrices are suitable to allow for a single pass cull.
            */
            public get areVRStereoViewMatricesWithinSingleCullTolerance(): boolean;
            /** Defines which eye of a VR display the Camera renders into.
            */
            public get stereoTargetEye(): UnityEngine.StereoTargetEyeMask;
            public set stereoTargetEye(value: UnityEngine.StereoTargetEyeMask);
            /** Returns the eye that is currently rendering.
            If called when stereo is not enabled it will return Camera.MonoOrStereoscopicEye.Mono.
            If called during a camera rendering callback such as OnRenderImage it will return the currently rendering eye.
            If called outside of a rendering callback and stereo is enabled, it will return the default eye which is Camera.MonoOrStereoscopicEye.Left.
            */
            public get stereoActiveEye(): UnityEngine.Camera.MonoOrStereoscopicEye;
            /** The number of cameras in the current Scene.
            */
            public static get allCamerasCount(): number;
            /** Returns all enabled cameras in the Scene.
            */
            public static get allCameras(): System.Array$1<UnityEngine.Camera>;
            public get sceneViewFilterMode(): UnityEngine.Camera.SceneViewFilterMode;
            /** If false, clouds are not rendered in the scene view of this camera.
            */
            public get renderCloudsInSceneView(): boolean;
            public set renderCloudsInSceneView(value: boolean);
            /** Number of command buffers set up on this camera (Read Only).
            */
            public get commandBufferCount(): number;
            /** Revert all camera parameters to default.
            */
            public Reset () : void
            /** Resets this Camera's transparency sort settings to the default. Default transparency settings are taken from GraphicsSettings instead of directly from this Camera.
            */
            public ResetTransparencySortSettings () : void
            /** Revert the aspect ratio to the screen's aspect ratio.
            */
            public ResetAspect () : void
            /** Make culling queries reflect the camera's built in parameters.
            */
            public ResetCullingMatrix () : void
            /** Make the camera render with shader replacement.
            */
            public SetReplacementShader ($shader: UnityEngine.Shader, $replacementTag: string) : void
            /** Remove shader replacement from camera.
            */
            public ResetReplacementShader () : void
            /** 
            Retrieves the effective vertical field of view of the camera, including GateFit.
            Fitting the sensor gate and the resolution gate has an impact on the final field of view. If the sensor gate aspect ratio is the same as the resolution gate aspect ratio or if the camera is not in physical mode, then this method returns the same value as the fieldofview property.
            * @returns Returns the effective vertical field of view. 
            */
            public GetGateFittedFieldOfView () : number
            /** 
            Retrieves the effective lens offset of the camera, including GateFit.
            Fitting the sensor gate and the resolution gate has an impact on the final obliqueness of the projection. If the sensor gate aspect ratio is the same as the resolution gate aspect ratio, then this method returns the same value as the lenshift property. If the camera is not in physical mode, then this methods returns Vector2.zero.
            * @returns Returns the effective lens shift value. 
            */
            public GetGateFittedLensShift () : UnityEngine.Vector2
            /** Sets the Camera to render to the chosen buffers of one or more RenderTextures.
            * @param $colorBuffer The RenderBuffer(s) to which color information will be rendered.
            * @param $depthBuffer The RenderBuffer to which depth information will be rendered.
            */
            public SetTargetBuffers ($colorBuffer: UnityEngine.RenderBuffer, $depthBuffer: UnityEngine.RenderBuffer) : void
            /** Sets the Camera to render to the chosen buffers of one or more RenderTextures.
            * @param $colorBuffer The RenderBuffer(s) to which color information will be rendered.
            * @param $depthBuffer The RenderBuffer to which depth information will be rendered.
            */
            public SetTargetBuffers ($colorBuffer: System.Array$1<UnityEngine.RenderBuffer>, $depthBuffer: UnityEngine.RenderBuffer) : void
            /** Make the rendering position reflect the camera's position in the Scene.
            */
            public ResetWorldToCameraMatrix () : void
            /** Make the projection reflect normal camera's parameters.
            */
            public ResetProjectionMatrix () : void
            /** Calculates and returns oblique near-plane projection matrix.
            * @param $clipPlane Vector4 that describes a clip plane.
            * @returns Oblique near-plane projection matrix. 
            */
            public CalculateObliqueMatrix ($clipPlane: UnityEngine.Vector4) : UnityEngine.Matrix4x4
            public WorldToScreenPoint ($position: UnityEngine.Vector3, $eye: UnityEngine.Camera.MonoOrStereoscopicEye) : UnityEngine.Vector3
            public WorldToViewportPoint ($position: UnityEngine.Vector3, $eye: UnityEngine.Camera.MonoOrStereoscopicEye) : UnityEngine.Vector3
            public ViewportToWorldPoint ($position: UnityEngine.Vector3, $eye: UnityEngine.Camera.MonoOrStereoscopicEye) : UnityEngine.Vector3
            public ScreenToWorldPoint ($position: UnityEngine.Vector3, $eye: UnityEngine.Camera.MonoOrStereoscopicEye) : UnityEngine.Vector3
            /** Transforms position from world space into screen space.
            * @param $position A 3D point in world space.
            * @param $eye Optional argument that can be used to specify which eye transform to use. Default is Mono.
            */
            public WorldToScreenPoint ($position: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Transforms position from world space into viewport space.
            * @param $position A 3D point in world space.
            * @param $eye Optional argument that can be used to specify which eye transform to use. Default is Mono.
            */
            public WorldToViewportPoint ($position: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Transforms position from viewport space into world space.
            * @param $position The 3d vector in Viewport space.
            * @returns The 3d vector in World space. 
            */
            public ViewportToWorldPoint ($position: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Transforms a point from screen space into world space, where world space is defined as the coordinate system at the very top of your game's hierarchy.
            * @param $position A 2D screenspace point in pixels, plus a z coordinate for the distance from the camera in world units. The lower left pixel of the screen is (0,0). The upper right pixel of the screen is (screen width in pixels - 1, screen height in pixels - 1).
            * @param $eye By default, Camera.MonoOrStereoscopicEye.Mono. Can be set to Camera.MonoOrStereoscopicEye.Left or Camera.MonoOrStereoscopicEye.Right for use in stereoscopic rendering (e.g., for VR).
            * @returns The world space point created by converting the screen space point at the provided distance z from the camera plane. 
            */
            public ScreenToWorldPoint ($position: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Transforms position from screen space into viewport space.
            */
            public ScreenToViewportPoint ($position: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Transforms position from viewport space into screen space.
            */
            public ViewportToScreenPoint ($position: UnityEngine.Vector3) : UnityEngine.Vector3
            public ViewportPointToRay ($pos: UnityEngine.Vector3, $eye: UnityEngine.Camera.MonoOrStereoscopicEye) : UnityEngine.Ray
            /** Returns a ray going from camera through a viewport point.
            * @param $eye Optional argument that can be used to specify which eye transform to use. Default is Mono.
            */
            public ViewportPointToRay ($pos: UnityEngine.Vector3) : UnityEngine.Ray
            public ScreenPointToRay ($pos: UnityEngine.Vector3, $eye: UnityEngine.Camera.MonoOrStereoscopicEye) : UnityEngine.Ray
            /** Returns a ray going from camera through a screen point.
            * @param $pos A 3D point, with the x and y coordinates containing a 2D screenspace point in pixels. The lower left pixel of the screen is (0,0). The upper right pixel of the screen is (screen width in pixels - 1, screen height in pixels - 1). Unity ignores the z coordinate.
            * @param $eye Optional argument that can be used to specify which eye transform to use. Default is Mono.
            */
            public ScreenPointToRay ($pos: UnityEngine.Vector3) : UnityEngine.Ray
            public CalculateFrustumCorners ($viewport: UnityEngine.Rect, $z: number, $eye: UnityEngine.Camera.MonoOrStereoscopicEye, $outCorners: System.Array$1<UnityEngine.Vector3>) : void
            public static CalculateProjectionMatrixFromPhysicalProperties ($output: $Ref<UnityEngine.Matrix4x4>, $focalLength: number, $sensorSize: UnityEngine.Vector2, $lensShift: UnityEngine.Vector2, $nearClip: number, $farClip: number, $gateFitParameters?: UnityEngine.Camera.GateFitParameters) : void
            /** Converts focal length to field of view.
            * @param $focalLength Focal length in millimeters.
            * @param $sensorSize Sensor size in millimeters. Use the sensor height to get the vertical field of view. Use the sensor width to get the horizontal field of view.
            * @returns field of view in degrees. 
            */
            public static FocalLengthToFieldOfView ($focalLength: number, $sensorSize: number) : number
            /** Converts field of view to focal length. Use either sensor height and vertical field of view or sensor width and horizontal field of view.
            * @param $fieldOfView field of view in degrees.
            * @param $sensorSize Sensor size in millimeters.
            * @returns Focal length in millimeters. 
            */
            public static FieldOfViewToFocalLength ($fieldOfView: number, $sensorSize: number) : number
            /** Converts the horizontal field of view (FOV) to the vertical FOV, based on the value of the aspect ratio parameter.
            * @param $horizontalFOV The horizontal FOV value in degrees.
            * @param $aspectRatio The aspect ratio value used for the conversion
            */
            public static HorizontalToVerticalFieldOfView ($horizontalFieldOfView: number, $aspectRatio: number) : number
            /** Converts the vertical field of view (FOV) to the horizontal FOV, based on the value of the aspect ratio parameter.
            * @param $verticalFieldOfView The vertical FOV value in degrees.
            * @param $aspectRatio The aspect ratio value used for the conversion
            */
            public static VerticalToHorizontalFieldOfView ($verticalFieldOfView: number, $aspectRatio: number) : number
            public GetStereoNonJitteredProjectionMatrix ($eye: UnityEngine.Camera.StereoscopicEye) : UnityEngine.Matrix4x4
            public GetStereoViewMatrix ($eye: UnityEngine.Camera.StereoscopicEye) : UnityEngine.Matrix4x4
            public CopyStereoDeviceProjectionMatrixToNonJittered ($eye: UnityEngine.Camera.StereoscopicEye) : void
            public GetStereoProjectionMatrix ($eye: UnityEngine.Camera.StereoscopicEye) : UnityEngine.Matrix4x4
            public SetStereoProjectionMatrix ($eye: UnityEngine.Camera.StereoscopicEye, $matrix: UnityEngine.Matrix4x4) : void
            /** Reset the camera to using the Unity computed projection matrices for all stereoscopic eyes.
            */
            public ResetStereoProjectionMatrices () : void
            public SetStereoViewMatrix ($eye: UnityEngine.Camera.StereoscopicEye, $matrix: UnityEngine.Matrix4x4) : void
            /** Reset the camera to using the Unity computed view matrices for all stereoscopic eyes.
            */
            public ResetStereoViewMatrices () : void
            /** Fills an array of Camera with the current cameras in the Scene, without allocating a new array.
            * @param $cameras An array to be filled up with cameras currently in the Scene.
            */
            public static GetAllCameras ($cameras: System.Array$1<UnityEngine.Camera>) : number
            /** Render into a static cubemap from this camera.
            * @param $cubemap The cube map to render to.
            * @param $faceMask A bitmask which determines which of the six faces are rendered to.
            * @returns False if rendering fails, else true. 
            */
            public RenderToCubemap ($cubemap: UnityEngine.Cubemap, $faceMask: number) : boolean
            public RenderToCubemap ($cubemap: UnityEngine.Cubemap) : boolean
            /** Render into a cubemap from this camera.
            * @param $faceMask A bitfield indicating which cubemap faces should be rendered into.
            * @param $cubemap The texture to render to.
            * @returns False if rendering fails, else true. 
            */
            public RenderToCubemap ($cubemap: UnityEngine.RenderTexture, $faceMask: number) : boolean
            public RenderToCubemap ($cubemap: UnityEngine.RenderTexture) : boolean
            public RenderToCubemap ($cubemap: UnityEngine.RenderTexture, $faceMask: number, $stereoEye: UnityEngine.Camera.MonoOrStereoscopicEye) : boolean
            /** Render the camera manually.
            */
            public Render () : void
            /** Render the camera with shader replacement.
            */
            public RenderWithShader ($shader: UnityEngine.Shader, $replacementTag: string) : void
            public RenderDontRestore () : void
            public static SetupCurrent ($cur: UnityEngine.Camera) : void
            /** Makes this camera's settings match other camera.
            * @param $other Copy camera settings to the other camera.
            */
            public CopyFrom ($other: UnityEngine.Camera) : void
            /** Remove command buffers from execution at a specified place.
            * @param $evt When to execute the command buffer during rendering.
            */
            public RemoveCommandBuffers ($evt: UnityEngine.Rendering.CameraEvent) : void
            /** Remove all command buffers set on this camera.
            */
            public RemoveAllCommandBuffers () : void
            /** Add a command buffer to be executed at a specified place.
            * @param $evt When to execute the command buffer during rendering.
            * @param $buffer The buffer to execute.
            */
            public AddCommandBuffer ($evt: UnityEngine.Rendering.CameraEvent, $buffer: UnityEngine.Rendering.CommandBuffer) : void
            /** Adds a command buffer to the GPU's async compute queues and executes that command buffer when graphics processing reaches a given point.
            * @param $evt The point during the graphics processing at which this command buffer should commence on the GPU.
            * @param $buffer The buffer to execute.
            * @param $queueType The desired async compute queue type to execute the buffer on.
            */
            public AddCommandBufferAsync ($evt: UnityEngine.Rendering.CameraEvent, $buffer: UnityEngine.Rendering.CommandBuffer, $queueType: UnityEngine.Rendering.ComputeQueueType) : void
            /** Remove command buffer from execution at a specified place.
            * @param $evt When to execute the command buffer during rendering.
            * @param $buffer The buffer to execute.
            */
            public RemoveCommandBuffer ($evt: UnityEngine.Rendering.CameraEvent, $buffer: UnityEngine.Rendering.CommandBuffer) : void
            /** Get command buffers to be executed at a specified place.
            * @param $evt When to execute the command buffer during rendering.
            * @returns Array of command buffers. 
            */
            public GetCommandBuffers ($evt: UnityEngine.Rendering.CameraEvent) : System.Array$1<UnityEngine.Rendering.CommandBuffer>
            /** Get culling parameters for a camera.
            * @param $cullingParameters Resultant culling parameters.
            * @param $stereoAware Generate single-pass stereo aware culling parameters.
            * @returns Flag indicating whether culling parameters are valid. 
            */
            public TryGetCullingParameters ($cullingParameters: $Ref<UnityEngine.Rendering.ScriptableCullingParameters>) : boolean
            /** Get culling parameters for a camera.
            * @param $cullingParameters Resultant culling parameters.
            * @param $stereoAware Generate single-pass stereo aware culling parameters.
            * @returns Flag indicating whether culling parameters are valid. 
            */
            public TryGetCullingParameters ($stereoAware: boolean, $cullingParameters: $Ref<UnityEngine.Rendering.ScriptableCullingParameters>) : boolean
            public constructor ()
        }
        /** Rendering path of a Camera.
        */
        enum RenderingPath
        { UsePlayerSettings = -1, VertexLit = 0, Forward = 1, DeferredLighting = 2, DeferredShading = 3 }
        /** Transparent object sorting mode of a Camera.
        */
        enum TransparencySortMode
        { Default = 0, Perspective = 1, Orthographic = 2, CustomAxis = 3 }
        /** Representation of 3D vectors and points.
        */
        class Vector3 extends System.ValueType implements System.IFormattable, System.IEquatable$1<UnityEngine.Vector3>
        {
            protected [__keep_incompatibility]: never;
            public static kEpsilon : number
            public static kEpsilonNormalSqrt : number
            /** X component of the vector.
            */
            public x : number
            /** Y component of the vector.
            */
            public y : number
            /** Z component of the vector.
            */
            public z : number
            /** Returns this vector with a magnitude of 1 (Read Only).
            */
            public get normalized(): UnityEngine.Vector3;
            /** Returns the length of this vector (Read Only).
            */
            public get magnitude(): number;
            /** Returns the squared length of this vector (Read Only).
            */
            public get sqrMagnitude(): number;
            /** Shorthand for writing Vector3(0, 0, 0).
            */
            public static get zero(): UnityEngine.Vector3;
            /** Shorthand for writing Vector3(1, 1, 1).
            */
            public static get one(): UnityEngine.Vector3;
            /** Shorthand for writing Vector3(0, 0, 1).
            */
            public static get forward(): UnityEngine.Vector3;
            /** Shorthand for writing Vector3(0, 0, -1).
            */
            public static get back(): UnityEngine.Vector3;
            /** Shorthand for writing Vector3(0, 1, 0).
            */
            public static get up(): UnityEngine.Vector3;
            /** Shorthand for writing Vector3(0, -1, 0).
            */
            public static get down(): UnityEngine.Vector3;
            /** Shorthand for writing Vector3(-1, 0, 0).
            */
            public static get left(): UnityEngine.Vector3;
            /** Shorthand for writing Vector3(1, 0, 0).
            */
            public static get right(): UnityEngine.Vector3;
            /** Shorthand for writing Vector3(float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity).
            */
            public static get positiveInfinity(): UnityEngine.Vector3;
            /** Shorthand for writing Vector3(float.NegativeInfinity, float.NegativeInfinity, float.NegativeInfinity).
            */
            public static get negativeInfinity(): UnityEngine.Vector3;
            /** Spherically interpolates between two vectors.
            */
            public static Slerp ($a: UnityEngine.Vector3, $b: UnityEngine.Vector3, $t: number) : UnityEngine.Vector3
            /** Spherically interpolates between two vectors.
            */
            public static SlerpUnclamped ($a: UnityEngine.Vector3, $b: UnityEngine.Vector3, $t: number) : UnityEngine.Vector3
            /** Makes vectors normalized and orthogonal to each other.
            */
            public static OrthoNormalize ($normal: $Ref<UnityEngine.Vector3>, $tangent: $Ref<UnityEngine.Vector3>) : void
            /** Makes vectors normalized and orthogonal to each other.
            */
            public static OrthoNormalize ($normal: $Ref<UnityEngine.Vector3>, $tangent: $Ref<UnityEngine.Vector3>, $binormal: $Ref<UnityEngine.Vector3>) : void
            /** Rotates a vector current towards target.
            * @param $current The vector being managed.
            * @param $target The vector.
            * @param $maxRadiansDelta The maximum angle in radians allowed for this rotation.
            * @param $maxMagnitudeDelta The maximum allowed change in vector magnitude for this rotation.
            * @returns The location that RotateTowards generates. 
            */
            public static RotateTowards ($current: UnityEngine.Vector3, $target: UnityEngine.Vector3, $maxRadiansDelta: number, $maxMagnitudeDelta: number) : UnityEngine.Vector3
            /** Linearly interpolates between two points.
            * @param $a Start value, returned when t = 0.
            * @param $b End value, returned when t = 1.
            * @param $t Value used to interpolate between a and b.
            * @returns Interpolated value, equals to a + (b - a) * t. 
            */
            public static Lerp ($a: UnityEngine.Vector3, $b: UnityEngine.Vector3, $t: number) : UnityEngine.Vector3
            /** Linearly interpolates between two vectors.
            */
            public static LerpUnclamped ($a: UnityEngine.Vector3, $b: UnityEngine.Vector3, $t: number) : UnityEngine.Vector3
            /** Calculate a position between the points specified by current and target, moving no farther than the distance specified by maxDistanceDelta.
            * @param $current The position to move from.
            * @param $target The position to move towards.
            * @param $maxDistanceDelta Distance to move current per call.
            * @returns The new position. 
            */
            public static MoveTowards ($current: UnityEngine.Vector3, $target: UnityEngine.Vector3, $maxDistanceDelta: number) : UnityEngine.Vector3
            /** Gradually changes a vector towards a desired goal over time.
            * @param $current The current position.
            * @param $target The position we are trying to reach.
            * @param $currentVelocity The current velocity, this value is modified by the function every time you call it.
            * @param $smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
            * @param $maxSpeed Optionally allows you to clamp the maximum speed.
            * @param $deltaTime The time since the last call to this function. By default Time.deltaTime.
            */
            public static SmoothDamp ($current: UnityEngine.Vector3, $target: UnityEngine.Vector3, $currentVelocity: $Ref<UnityEngine.Vector3>, $smoothTime: number, $maxSpeed: number) : UnityEngine.Vector3
            /** Gradually changes a vector towards a desired goal over time.
            * @param $current The current position.
            * @param $target The position we are trying to reach.
            * @param $currentVelocity The current velocity, this value is modified by the function every time you call it.
            * @param $smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
            * @param $maxSpeed Optionally allows you to clamp the maximum speed.
            * @param $deltaTime The time since the last call to this function. By default Time.deltaTime.
            */
            public static SmoothDamp ($current: UnityEngine.Vector3, $target: UnityEngine.Vector3, $currentVelocity: $Ref<UnityEngine.Vector3>, $smoothTime: number) : UnityEngine.Vector3
            /** Gradually changes a vector towards a desired goal over time.
            * @param $current The current position.
            * @param $target The position we are trying to reach.
            * @param $currentVelocity The current velocity, this value is modified by the function every time you call it.
            * @param $smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
            * @param $maxSpeed Optionally allows you to clamp the maximum speed.
            * @param $deltaTime The time since the last call to this function. By default Time.deltaTime.
            */
            public static SmoothDamp ($current: UnityEngine.Vector3, $target: UnityEngine.Vector3, $currentVelocity: $Ref<UnityEngine.Vector3>, $smoothTime: number, $maxSpeed: number, $deltaTime: number) : UnityEngine.Vector3
            public get_Item ($index: number) : number
            public set_Item ($index: number, $value: number) : void
            /** Set x, y and z components of an existing Vector3.
            */
            public Set ($newX: number, $newY: number, $newZ: number) : void
            /** Multiplies two vectors component-wise.
            */
            public static Scale ($a: UnityEngine.Vector3, $b: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Multiplies every component of this vector by the same component of scale.
            */
            public Scale ($scale: UnityEngine.Vector3) : void
            /** Cross Product of two vectors.
            */
            public static Cross ($lhs: UnityEngine.Vector3, $rhs: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Returns true if the given vector is exactly equal to this vector.
            */
            public Equals ($other: any) : boolean
            public Equals ($other: UnityEngine.Vector3) : boolean
            /** Reflects a vector off the plane defined by a normal.
            * @param $inDirection The direction vector towards the plane.
            * @param $inNormal The normal vector that defines the plane.
            */
            public static Reflect ($inDirection: UnityEngine.Vector3, $inNormal: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Makes this vector have a magnitude of 1.
            */
            public static Normalize ($value: UnityEngine.Vector3) : UnityEngine.Vector3
            public Normalize () : void
            /** Dot Product of two vectors.
            */
            public static Dot ($lhs: UnityEngine.Vector3, $rhs: UnityEngine.Vector3) : number
            /** Projects a vector onto another vector.
            */
            public static Project ($vector: UnityEngine.Vector3, $onNormal: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Projects a vector onto a plane defined by a normal orthogonal to the plane.
            * @param $planeNormal The direction from the vector towards the plane.
            * @param $vector The location of the vector above the plane.
            * @returns The location of the vector on the plane. 
            */
            public static ProjectOnPlane ($vector: UnityEngine.Vector3, $planeNormal: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Calculates the angle between vectors from and.
            * @param $from The vector from which the angular difference is measured.
            * @param $to The vector to which the angular difference is measured.
            * @returns The angle in degrees between the two vectors. 
            */
            public static Angle ($from: UnityEngine.Vector3, $to: UnityEngine.Vector3) : number
            /** Calculates the signed angle between vectors from and to in relation to axis.
            * @param $from The vector from which the angular difference is measured.
            * @param $to The vector to which the angular difference is measured.
            * @param $axis A vector around which the other vectors are rotated.
            * @returns Returns the signed angle between from and to in degrees. 
            */
            public static SignedAngle ($from: UnityEngine.Vector3, $to: UnityEngine.Vector3, $axis: UnityEngine.Vector3) : number
            /** Returns the distance between a and b.
            */
            public static Distance ($a: UnityEngine.Vector3, $b: UnityEngine.Vector3) : number
            /** Returns a copy of vector with its magnitude clamped to maxLength.
            */
            public static ClampMagnitude ($vector: UnityEngine.Vector3, $maxLength: number) : UnityEngine.Vector3
            public static Magnitude ($vector: UnityEngine.Vector3) : number
            public static SqrMagnitude ($vector: UnityEngine.Vector3) : number
            /** Returns a vector that is made from the smallest components of two vectors.
            */
            public static Min ($lhs: UnityEngine.Vector3, $rhs: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Returns a vector that is made from the largest components of two vectors.
            */
            public static Max ($lhs: UnityEngine.Vector3, $rhs: UnityEngine.Vector3) : UnityEngine.Vector3
            public static op_Addition ($a: UnityEngine.Vector3, $b: UnityEngine.Vector3) : UnityEngine.Vector3
            public static op_Subtraction ($a: UnityEngine.Vector3, $b: UnityEngine.Vector3) : UnityEngine.Vector3
            public static op_UnaryNegation ($a: UnityEngine.Vector3) : UnityEngine.Vector3
            public static op_Multiply ($a: UnityEngine.Vector3, $d: number) : UnityEngine.Vector3
            public static op_Multiply ($d: number, $a: UnityEngine.Vector3) : UnityEngine.Vector3
            public static op_Division ($a: UnityEngine.Vector3, $d: number) : UnityEngine.Vector3
            public static op_Equality ($lhs: UnityEngine.Vector3, $rhs: UnityEngine.Vector3) : boolean
            public static op_Inequality ($lhs: UnityEngine.Vector3, $rhs: UnityEngine.Vector3) : boolean
            /** Returns a formatted string for this vector.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString () : string
            /** Returns a formatted string for this vector.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string) : string
            /** Returns a formatted string for this vector.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            public constructor ($x: number, $y: number, $z: number)
            public constructor ($x: number, $y: number)
        }
        /** Describes different types of camera.
        */
        enum CameraType
        { Game = 1, SceneView = 2, Preview = 4, VR = 8, Reflection = 16 }
        /** A standard 4x4 transformation matrix.
        */
        class Matrix4x4 extends System.ValueType implements System.IFormattable, System.IEquatable$1<UnityEngine.Matrix4x4>
        {
            protected [__keep_incompatibility]: never;
            public m00 : number
            public m10 : number
            public m20 : number
            public m30 : number
            public m01 : number
            public m11 : number
            public m21 : number
            public m31 : number
            public m02 : number
            public m12 : number
            public m22 : number
            public m32 : number
            public m03 : number
            public m13 : number
            public m23 : number
            public m33 : number
            /** Attempts to get a rotation quaternion from this matrix.
            */
            public get rotation(): UnityEngine.Quaternion;
            /** Attempts to get a scale value from the matrix. (Read Only)
            */
            public get lossyScale(): UnityEngine.Vector3;
            /** Checks whether this is an identity matrix. (Read Only)
            */
            public get isIdentity(): boolean;
            /** The determinant of the matrix. (Read Only)
            */
            public get determinant(): number;
            /** This property takes a projection matrix and returns the six plane coordinates that define a projection frustum.
            */
            public get decomposeProjection(): UnityEngine.FrustumPlanes;
            /** The inverse of this matrix. (Read Only)
            */
            public get inverse(): UnityEngine.Matrix4x4;
            /** Returns the transpose of this matrix (Read Only).
            */
            public get transpose(): UnityEngine.Matrix4x4;
            /** Returns a matrix with all elements set to zero (Read Only).
            */
            public static get zero(): UnityEngine.Matrix4x4;
            /** Returns the identity matrix (Read Only).
            */
            public static get identity(): UnityEngine.Matrix4x4;
            /** Checks if this matrix is a valid transform matrix.
            */
            public ValidTRS () : boolean
            public static Determinant ($m: UnityEngine.Matrix4x4) : number
            /** Creates a translation, rotation and scaling matrix.
            */
            public static TRS ($pos: UnityEngine.Vector3, $q: UnityEngine.Quaternion, $s: UnityEngine.Vector3) : UnityEngine.Matrix4x4
            /** Sets this matrix to a translation, rotation and scaling matrix.
            */
            public SetTRS ($pos: UnityEngine.Vector3, $q: UnityEngine.Quaternion, $s: UnityEngine.Vector3) : void
            /** Computes the inverse of a 3D affine matrix.
            * @param $input Input matrix to invert.
            * @param $result The result of the inversion. Equal to the input matrix if the function fails.
            * @returns Returns true and a valid result if the function succeeds, false and a copy of the input matrix if the function fails. 
            */
            public static Inverse3DAffine ($input: UnityEngine.Matrix4x4, $result: $Ref<UnityEngine.Matrix4x4>) : boolean
            public static Inverse ($m: UnityEngine.Matrix4x4) : UnityEngine.Matrix4x4
            public static Transpose ($m: UnityEngine.Matrix4x4) : UnityEngine.Matrix4x4
            /** Create an orthogonal projection matrix.
            * @param $left Left-side x-coordinate.
            * @param $right Right-side x-coordinate.
            * @param $bottom Bottom y-coordinate.
            * @param $top Top y-coordinate.
            * @param $zNear Near depth clipping plane value.
            * @param $zFar Far depth clipping plane value.
            * @returns The projection matrix. 
            */
            public static Ortho ($left: number, $right: number, $bottom: number, $top: number, $zNear: number, $zFar: number) : UnityEngine.Matrix4x4
            /** Create a perspective projection matrix.
            * @param $fov Vertical field-of-view in degrees.
            * @param $aspect Aspect ratio (width divided by height).
            * @param $zNear Near depth clipping plane value.
            * @param $zFar Far depth clipping plane value.
            * @returns The projection matrix. 
            */
            public static Perspective ($fov: number, $aspect: number, $zNear: number, $zFar: number) : UnityEngine.Matrix4x4
            /** Create a "look at" matrix.
            * @param $from The source point.
            * @param $to The target point.
            * @param $up The vector describing the up direction (typically Vector3.up).
            * @returns The resulting transformation matrix. 
            */
            public static LookAt ($from: UnityEngine.Vector3, $to: UnityEngine.Vector3, $up: UnityEngine.Vector3) : UnityEngine.Matrix4x4
            /** This function returns a projection matrix with viewing frustum that has a near plane defined by the coordinates that were passed in.
            * @param $left The X coordinate of the left side of the near projection plane in view space.
            * @param $right The X coordinate of the right side of the near projection plane in view space.
            * @param $bottom The Y coordinate of the bottom side of the near projection plane in view space.
            * @param $top The Y coordinate of the top side of the near projection plane in view space.
            * @param $zNear Z distance to the near plane from the origin in view space.
            * @param $zFar Z distance to the far plane from the origin in view space.
            * @param $frustumPlanes Frustum planes struct that contains the view space coordinates of that define a viewing frustum.
            * @returns A projection matrix with a viewing frustum defined by the plane coordinates passed in. 
            */
            public static Frustum ($left: number, $right: number, $bottom: number, $top: number, $zNear: number, $zFar: number) : UnityEngine.Matrix4x4
            /** This function returns a projection matrix with viewing frustum that has a near plane defined by the coordinates that were passed in.
            * @param $left The X coordinate of the left side of the near projection plane in view space.
            * @param $right The X coordinate of the right side of the near projection plane in view space.
            * @param $bottom The Y coordinate of the bottom side of the near projection plane in view space.
            * @param $top The Y coordinate of the top side of the near projection plane in view space.
            * @param $zNear Z distance to the near plane from the origin in view space.
            * @param $zFar Z distance to the far plane from the origin in view space.
            * @param $frustumPlanes Frustum planes struct that contains the view space coordinates of that define a viewing frustum.
            * @returns A projection matrix with a viewing frustum defined by the plane coordinates passed in. 
            */
            public static Frustum ($fp: UnityEngine.FrustumPlanes) : UnityEngine.Matrix4x4
            public get_Item ($index: number) : number
            public set_Item ($index: number, $value: number) : void
            public Equals ($other: any) : boolean
            public Equals ($other: UnityEngine.Matrix4x4) : boolean
            public static op_Multiply ($lhs: UnityEngine.Matrix4x4, $rhs: UnityEngine.Matrix4x4) : UnityEngine.Matrix4x4
            public static op_Multiply ($lhs: UnityEngine.Matrix4x4, $vector: UnityEngine.Vector4) : UnityEngine.Vector4
            public static op_Equality ($lhs: UnityEngine.Matrix4x4, $rhs: UnityEngine.Matrix4x4) : boolean
            public static op_Inequality ($lhs: UnityEngine.Matrix4x4, $rhs: UnityEngine.Matrix4x4) : boolean
            /** Get a column of the matrix.
            */
            public GetColumn ($index: number) : UnityEngine.Vector4
            /** Returns a row of the matrix.
            */
            public GetRow ($index: number) : UnityEngine.Vector4
            /** Get position vector from the matrix.
            */
            public GetPosition () : UnityEngine.Vector3
            /** Sets a column of the matrix.
            */
            public SetColumn ($index: number, $column: UnityEngine.Vector4) : void
            /** Sets a row of the matrix.
            */
            public SetRow ($index: number, $row: UnityEngine.Vector4) : void
            /** Transforms a position by this matrix (generic).
            */
            public MultiplyPoint ($point: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Transforms a position by this matrix (fast).
            */
            public MultiplyPoint3x4 ($point: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Transforms a direction by this matrix.
            */
            public MultiplyVector ($vector: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Returns a plane that is transformed in space.
            */
            public TransformPlane ($plane: UnityEngine.Plane) : UnityEngine.Plane
            /** Creates a scaling matrix.
            */
            public static Scale ($vector: UnityEngine.Vector3) : UnityEngine.Matrix4x4
            /** Creates a translation matrix.
            */
            public static Translate ($vector: UnityEngine.Vector3) : UnityEngine.Matrix4x4
            /** Creates a rotation matrix.
            */
            public static Rotate ($q: UnityEngine.Quaternion) : UnityEngine.Matrix4x4
            /** Returns a formatted string for this matrix.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString () : string
            /** Returns a formatted string for this matrix.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string) : string
            /** Returns a formatted string for this matrix.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            public constructor ($column0: UnityEngine.Vector4, $column1: UnityEngine.Vector4, $column2: UnityEngine.Vector4, $column3: UnityEngine.Vector4)
        }
        /** Representation of RGBA colors.
        */
        class Color extends System.ValueType implements System.IFormattable, System.IEquatable$1<UnityEngine.Color>
        {
            protected [__keep_incompatibility]: never;
            /** Red component of the color.
            */
            public r : number
            /** Green component of the color.
            */
            public g : number
            /** Blue component of the color.
            */
            public b : number
            /** Alpha component of the color (0 is transparent, 1 is opaque).
            */
            public a : number
            /** Solid red. RGBA is (1, 0, 0, 1).
            */
            public static get red(): UnityEngine.Color;
            /** Solid green. RGBA is (0, 1, 0, 1).
            */
            public static get green(): UnityEngine.Color;
            /** Solid blue. RGBA is (0, 0, 1, 1).
            */
            public static get blue(): UnityEngine.Color;
            /** Solid white. RGBA is (1, 1, 1, 1).
            */
            public static get white(): UnityEngine.Color;
            /** Solid black. RGBA is (0, 0, 0, 1).
            */
            public static get black(): UnityEngine.Color;
            /** Yellow. RGBA is (1, 0.92, 0.016, 1), but the color is nice to look at!
            */
            public static get yellow(): UnityEngine.Color;
            /** Cyan. RGBA is (0, 1, 1, 1).
            */
            public static get cyan(): UnityEngine.Color;
            /** Magenta. RGBA is (1, 0, 1, 1).
            */
            public static get magenta(): UnityEngine.Color;
            /** Gray. RGBA is (0.5, 0.5, 0.5, 1).
            */
            public static get gray(): UnityEngine.Color;
            /** English spelling for gray. RGBA is the same (0.5, 0.5, 0.5, 1).
            */
            public static get grey(): UnityEngine.Color;
            /** Completely transparent. RGBA is (0, 0, 0, 0).
            */
            public static get clear(): UnityEngine.Color;
            /** The grayscale value of the color. (Read Only)
            */
            public get grayscale(): number;
            /** A linear value of an sRGB color.
            */
            public get linear(): UnityEngine.Color;
            /** A version of the color that has had the gamma curve applied.
            */
            public get gamma(): UnityEngine.Color;
            /** Returns the maximum color component value: Max(r,g,b).
            */
            public get maxColorComponent(): number;
            /** Returns a formatted string of this color.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString () : string
            /** Returns a formatted string of this color.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string) : string
            /** Returns a formatted string of this color.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            public Equals ($other: any) : boolean
            public Equals ($other: UnityEngine.Color) : boolean
            public static op_Addition ($a: UnityEngine.Color, $b: UnityEngine.Color) : UnityEngine.Color
            public static op_Subtraction ($a: UnityEngine.Color, $b: UnityEngine.Color) : UnityEngine.Color
            public static op_Multiply ($a: UnityEngine.Color, $b: UnityEngine.Color) : UnityEngine.Color
            public static op_Multiply ($a: UnityEngine.Color, $b: number) : UnityEngine.Color
            public static op_Multiply ($b: number, $a: UnityEngine.Color) : UnityEngine.Color
            public static op_Division ($a: UnityEngine.Color, $b: number) : UnityEngine.Color
            public static op_Equality ($lhs: UnityEngine.Color, $rhs: UnityEngine.Color) : boolean
            public static op_Inequality ($lhs: UnityEngine.Color, $rhs: UnityEngine.Color) : boolean
            /** Linearly interpolates between colors a and b by t.
            * @param $a Color a.
            * @param $b Color b.
            * @param $t Float for combining a and b.
            */
            public static Lerp ($a: UnityEngine.Color, $b: UnityEngine.Color, $t: number) : UnityEngine.Color
            /** Linearly interpolates between colors a and b by t.
            */
            public static LerpUnclamped ($a: UnityEngine.Color, $b: UnityEngine.Color, $t: number) : UnityEngine.Color
            public static op_Implicit ($c: UnityEngine.Color) : UnityEngine.Vector4
            public static op_Implicit ($v: UnityEngine.Vector4) : UnityEngine.Color
            public get_Item ($index: number) : number
            public set_Item ($index: number, $value: number) : void
            /** Calculates the hue, saturation and value of an RGB input color.
            * @param $rgbColor An input color.
            * @param $H Output variable for hue.
            * @param $S Output variable for saturation.
            * @param $V Output variable for value.
            */
            public static RGBToHSV ($rgbColor: UnityEngine.Color, $H: $Ref<number>, $S: $Ref<number>, $V: $Ref<number>) : void
            /** Creates an RGB colour from HSV input.
            * @param $H Hue [0..1].
            * @param $S Saturation [0..1].
            * @param $V Brightness value [0..1].
            * @param $hdr Output HDR colours. If true, the returned colour will not be clamped to [0..1].
            * @returns An opaque colour with HSV matching the input. 
            */
            public static HSVToRGB ($H: number, $S: number, $V: number) : UnityEngine.Color
            /** Creates an RGB colour from HSV input.
            * @param $H Hue [0..1].
            * @param $S Saturation [0..1].
            * @param $V Brightness value [0..1].
            * @param $hdr Output HDR colours. If true, the returned colour will not be clamped to [0..1].
            * @returns An opaque colour with HSV matching the input. 
            */
            public static HSVToRGB ($H: number, $S: number, $V: number, $hdr: boolean) : UnityEngine.Color
            public constructor ($r: number, $g: number, $b: number, $a: number)
            public constructor ($r: number, $g: number, $b: number)
        }
        /** Values for Camera.clearFlags, determining what to clear when rendering a Camera.
        */
        enum CameraClearFlags
        { Skybox = 1, Color = 2, SolidColor = 2, Depth = 3, Nothing = 4 }
        /** Depth texture generation mode for Camera.
        */
        enum DepthTextureMode
        { None = 0, Depth = 1, DepthNormals = 2, MotionVectors = 4 }
        /** Shader scripts used for all rendering.
        */
        class Shader extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** Sets the limit on the number of shader variant chunks Unity loads and keeps in memory.
            */
            public static get maximumChunksOverride(): number;
            public static set maximumChunksOverride(value: number);
            /** Shader LOD level for this shader.
            */
            public get maximumLOD(): number;
            public set maximumLOD(value: number);
            /** Shader LOD level for all shaders.
            */
            public static get globalMaximumLOD(): number;
            public static set globalMaximumLOD(value: number);
            /** Can this shader run on the end-users graphics card? (Read Only)
            */
            public get isSupported(): boolean;
            /** Render pipeline currently in use.
            */
            public static get globalRenderPipeline(): string;
            public static set globalRenderPipeline(value: string);
            /** An array containing the global shader keywords that are currently enabled.
            */
            public static get enabledGlobalKeywords(): System.Array$1<UnityEngine.Rendering.GlobalKeyword>;
            /** An array containing the global shader keywords that currently exist. This includes enabled and disabled global shader keywords.
            */
            public static get globalKeywords(): System.Array$1<UnityEngine.Rendering.GlobalKeyword>;
            /** The local keyword space of this shader.
            */
            public get keywordSpace(): UnityEngine.Rendering.LocalKeywordSpace;
            /** Render queue of this shader. (Read Only)
            */
            public get renderQueue(): number;
            /** Returns the number of shader passes on the active SubShader.
            */
            public get passCount(): number;
            /** Returns the number of SubShaders in this shader.
            */
            public get subshaderCount(): number;
            /** Finds a shader with the given name. Returns null if the shader is not found.
            */
            public static Find ($name: string) : UnityEngine.Shader
            /** Enables a global shader keyword.
            * @param $keyword The name of the Rendering.GlobalKeyword to enable.
            */
            public static EnableKeyword ($keyword: string) : void
            /** Disables a global shader keyword.
            * @param $keyword The name of the Rendering.GlobalKeyword to disable.
            */
            public static DisableKeyword ($keyword: string) : void
            /** Checks whether a global shader keyword is enabled.
            * @param $keyword The name of the Rendering.GlobalKeyword to check.
            * @returns Returns true if a global shader keyword with the given name exists, and is enabled. Otherwise, returns false. 
            */
            public static IsKeywordEnabled ($keyword: string) : boolean
            /** Enables a global shader keyword.
            * @param $keyword The name of the Rendering.GlobalKeyword to enable.
            */
            public static EnableKeyword ($keyword: $Ref<UnityEngine.Rendering.GlobalKeyword>) : void
            /** Disables a global shader keyword.
            * @param $keyword The name of the Rendering.GlobalKeyword to disable.
            */
            public static DisableKeyword ($keyword: $Ref<UnityEngine.Rendering.GlobalKeyword>) : void
            /** Sets the state of a global shader keyword.
            * @param $keyword The Rendering.GlobalKeyword to enable or disable.
            * @param $value The desired keyword state.
            */
            public static SetKeyword ($keyword: $Ref<UnityEngine.Rendering.GlobalKeyword>, $value: boolean) : void
            /** Checks whether a global shader keyword is enabled.
            * @param $keyword The Rendering.GlobalKeyword to check.
            * @returns Returns true if the given global shader keyword is enabled. Otherwise, returns false. 
            */
            public static IsKeywordEnabled ($keyword: $Ref<UnityEngine.Rendering.GlobalKeyword>) : boolean
            /** Prewarms all shader variants of all Shaders currently in memory.
            */
            public static WarmupAllShaders () : void
            /** Gets unique identifier for a shader property name.
            * @param $name Shader property name.
            * @returns Unique integer for the name. 
            */
            public static PropertyToID ($name: string) : number
            /** Returns the dependency shader.
            * @param $name The name of the dependency to query.
            */
            public GetDependency ($name: string) : UnityEngine.Shader
            /** Returns the number of passes in the given SubShader.
            * @param $subshaderIndex The index of the SubShader.
            */
            public GetPassCountInSubshader ($subshaderIndex: number) : number
            /** Searches for the tag specified by tagName on the shader's active SubShader and returns the value of the tag.
            * @param $passIndex The index of the pass.
            * @param $tagName The name of the tag.
            */
            public FindPassTagValue ($passIndex: number, $tagName: UnityEngine.Rendering.ShaderTagId) : UnityEngine.Rendering.ShaderTagId
            /** Searches for the tag specified by tagName on the SubShader specified by subshaderIndex and returns the value of the tag.
            * @param $subshaderIndex The index of the SubShader.
            * @param $passIndex The index of the pass.
            * @param $tagName The name of the tag.
            */
            public FindPassTagValue ($subshaderIndex: number, $passIndex: number, $tagName: UnityEngine.Rendering.ShaderTagId) : UnityEngine.Rendering.ShaderTagId
            /** Searches for the tag specified by tagName on the SubShader specified by subshaderIndex and returns the value of the tag.
            * @param $subshaderIndex The index of the SubShader.
            * @param $tagName The name of the tag.
            */
            public FindSubshaderTagValue ($subshaderIndex: number, $tagName: UnityEngine.Rendering.ShaderTagId) : UnityEngine.Rendering.ShaderTagId
            /** This method is deprecated. Use SetGlobalFloat or SetGlobalInteger instead.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public static SetGlobalInt ($name: string, $value: number) : void
            /** This method is deprecated. Use SetGlobalFloat or SetGlobalInteger instead.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public static SetGlobalInt ($nameID: number, $value: number) : void
            /** Sets a global float property for all shaders.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public static SetGlobalFloat ($name: string, $value: number) : void
            /** Sets a global float property for all shaders.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public static SetGlobalFloat ($nameID: number, $value: number) : void
            /** Sets a global integer property for all shaders.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public static SetGlobalInteger ($name: string, $value: number) : void
            /** Sets a global integer property for all shaders.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public static SetGlobalInteger ($nameID: number, $value: number) : void
            /** Sets a global vector property for all shaders.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public static SetGlobalVector ($name: string, $value: UnityEngine.Vector4) : void
            /** Sets a global vector property for all shaders.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public static SetGlobalVector ($nameID: number, $value: UnityEngine.Vector4) : void
            /** Sets a global color property for all shaders.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public static SetGlobalColor ($name: string, $value: UnityEngine.Color) : void
            /** Sets a global color property for all shaders.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public static SetGlobalColor ($nameID: number, $value: UnityEngine.Color) : void
            /** Sets a global matrix property for all shaders.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public static SetGlobalMatrix ($name: string, $value: UnityEngine.Matrix4x4) : void
            /** Sets a global matrix property for all shaders.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public static SetGlobalMatrix ($nameID: number, $value: UnityEngine.Matrix4x4) : void
            /** Sets a global texture property for all shaders.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            * @param $value The texture to set.
            * @param $element Optional parameter that specifies the type of data to set from the RenderTexture.
            */
            public static SetGlobalTexture ($name: string, $value: UnityEngine.Texture) : void
            /** Sets a global texture property for all shaders.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            * @param $value The texture to set.
            * @param $element Optional parameter that specifies the type of data to set from the RenderTexture.
            */
            public static SetGlobalTexture ($nameID: number, $value: UnityEngine.Texture) : void
            /** Sets a global texture property for all shaders.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            * @param $value The texture to set.
            * @param $element Optional parameter that specifies the type of data to set from the RenderTexture.
            */
            public static SetGlobalTexture ($name: string, $value: UnityEngine.RenderTexture, $element: UnityEngine.Rendering.RenderTextureSubElement) : void
            /** Sets a global texture property for all shaders.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            * @param $value The texture to set.
            * @param $element Optional parameter that specifies the type of data to set from the RenderTexture.
            */
            public static SetGlobalTexture ($nameID: number, $value: UnityEngine.RenderTexture, $element: UnityEngine.Rendering.RenderTextureSubElement) : void
            /** Sets a global buffer property for all shaders.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            * @param $value The buffer to set.
            */
            public static SetGlobalBuffer ($name: string, $value: UnityEngine.ComputeBuffer) : void
            /** Sets a global buffer property for all shaders.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            * @param $value The buffer to set.
            */
            public static SetGlobalBuffer ($nameID: number, $value: UnityEngine.ComputeBuffer) : void
            /** Sets a global buffer property for all shaders.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            * @param $value The buffer to set.
            */
            public static SetGlobalBuffer ($name: string, $value: UnityEngine.GraphicsBuffer) : void
            /** Sets a global buffer property for all shaders.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            * @param $value The buffer to set.
            */
            public static SetGlobalBuffer ($nameID: number, $value: UnityEngine.GraphicsBuffer) : void
            /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for all shader types.
            * @param $nameID The name ID of the constant buffer retrieved by Shader.PropertyToID.
            * @param $name The name of the constant buffer to override.
            * @param $value The buffer to override the constant buffer values with, or null to remove binding.
            * @param $offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
            * @param $size The number of bytes to bind.
            */
            public static SetGlobalConstantBuffer ($name: string, $value: UnityEngine.ComputeBuffer, $offset: number, $size: number) : void
            /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for all shader types.
            * @param $nameID The name ID of the constant buffer retrieved by Shader.PropertyToID.
            * @param $name The name of the constant buffer to override.
            * @param $value The buffer to override the constant buffer values with, or null to remove binding.
            * @param $offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
            * @param $size The number of bytes to bind.
            */
            public static SetGlobalConstantBuffer ($nameID: number, $value: UnityEngine.ComputeBuffer, $offset: number, $size: number) : void
            /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for all shader types.
            * @param $nameID The name ID of the constant buffer retrieved by Shader.PropertyToID.
            * @param $name The name of the constant buffer to override.
            * @param $value The buffer to override the constant buffer values with, or null to remove binding.
            * @param $offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
            * @param $size The number of bytes to bind.
            */
            public static SetGlobalConstantBuffer ($name: string, $value: UnityEngine.GraphicsBuffer, $offset: number, $size: number) : void
            /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for all shader types.
            * @param $nameID The name ID of the constant buffer retrieved by Shader.PropertyToID.
            * @param $name The name of the constant buffer to override.
            * @param $value The buffer to override the constant buffer values with, or null to remove binding.
            * @param $offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
            * @param $size The number of bytes to bind.
            */
            public static SetGlobalConstantBuffer ($nameID: number, $value: UnityEngine.GraphicsBuffer, $offset: number, $size: number) : void
            /** Sets a global RayTracingAccelerationStructure property for all shaders.
            * @param $name The name of the acceleration structure in shader code.
            * @param $nameID The name ID of the acceleration structure in shader code. Use Shader.PropertyToID to get this value.
            * @param $value The acceleration structure to set.
            */
            public static SetGlobalRayTracingAccelerationStructure ($name: string, $value: UnityEngine.Rendering.RayTracingAccelerationStructure) : void
            /** Sets a global RayTracingAccelerationStructure property for all shaders.
            * @param $name The name of the acceleration structure in shader code.
            * @param $nameID The name ID of the acceleration structure in shader code. Use Shader.PropertyToID to get this value.
            * @param $value The acceleration structure to set.
            */
            public static SetGlobalRayTracingAccelerationStructure ($nameID: number, $value: UnityEngine.Rendering.RayTracingAccelerationStructure) : void
            public static SetGlobalFloatArray ($name: string, $values: System.Collections.Generic.List$1<number>) : void
            public static SetGlobalFloatArray ($nameID: number, $values: System.Collections.Generic.List$1<number>) : void
            /** Sets a global float array property for all shaders.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public static SetGlobalFloatArray ($name: string, $values: System.Array$1<number>) : void
            /** Sets a global float array property for all shaders.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public static SetGlobalFloatArray ($nameID: number, $values: System.Array$1<number>) : void
            public static SetGlobalVectorArray ($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>) : void
            public static SetGlobalVectorArray ($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>) : void
            /** Sets a global vector array property for all shaders.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public static SetGlobalVectorArray ($name: string, $values: System.Array$1<UnityEngine.Vector4>) : void
            /** Sets a global vector array property for all shaders.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public static SetGlobalVectorArray ($nameID: number, $values: System.Array$1<UnityEngine.Vector4>) : void
            public static SetGlobalMatrixArray ($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>) : void
            public static SetGlobalMatrixArray ($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>) : void
            /** Sets a global matrix array property for all shaders.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public static SetGlobalMatrixArray ($name: string, $values: System.Array$1<UnityEngine.Matrix4x4>) : void
            /** Sets a global matrix array property for all shaders.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public static SetGlobalMatrixArray ($nameID: number, $values: System.Array$1<UnityEngine.Matrix4x4>) : void
            /** This method is deprecated. Use GetGlobalFloat or GetGlobalInteger instead.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public static GetGlobalInt ($name: string) : number
            /** This method is deprecated. Use GetGlobalFloat or GetGlobalInteger instead.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public static GetGlobalInt ($nameID: number) : number
            /** Gets a global float property for all shaders previously set using SetGlobalFloat.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public static GetGlobalFloat ($name: string) : number
            /** Gets a global float property for all shaders previously set using SetGlobalFloat.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public static GetGlobalFloat ($nameID: number) : number
            /** Gets a global integer property for all shaders previously set using SetGlobalInteger.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public static GetGlobalInteger ($name: string) : number
            /** Gets a global integer property for all shaders previously set using SetGlobalInteger.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public static GetGlobalInteger ($nameID: number) : number
            /** Gets a global vector property for all shaders previously set using SetGlobalVector.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public static GetGlobalVector ($name: string) : UnityEngine.Vector4
            /** Gets a global vector property for all shaders previously set using SetGlobalVector.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public static GetGlobalVector ($nameID: number) : UnityEngine.Vector4
            /** Gets a global color property for all shaders previously set using SetGlobalColor.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public static GetGlobalColor ($name: string) : UnityEngine.Color
            /** Gets a global color property for all shaders previously set using SetGlobalColor.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public static GetGlobalColor ($nameID: number) : UnityEngine.Color
            /** Gets a global matrix property for all shaders previously set using SetGlobalMatrix.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public static GetGlobalMatrix ($name: string) : UnityEngine.Matrix4x4
            /** Gets a global matrix property for all shaders previously set using SetGlobalMatrix.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public static GetGlobalMatrix ($nameID: number) : UnityEngine.Matrix4x4
            /** Gets a global texture property for all shaders previously set using SetGlobalTexture.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public static GetGlobalTexture ($name: string) : UnityEngine.Texture
            /** Gets a global texture property for all shaders previously set using SetGlobalTexture.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public static GetGlobalTexture ($nameID: number) : UnityEngine.Texture
            /** Gets a global float array for all shaders previously set using SetGlobalFloatArray.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public static GetGlobalFloatArray ($name: string) : System.Array$1<number>
            /** Gets a global float array for all shaders previously set using SetGlobalFloatArray.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public static GetGlobalFloatArray ($nameID: number) : System.Array$1<number>
            /** Gets a global vector array for all shaders previously set using SetGlobalVectorArray.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public static GetGlobalVectorArray ($name: string) : System.Array$1<UnityEngine.Vector4>
            /** Gets a global vector array for all shaders previously set using SetGlobalVectorArray.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public static GetGlobalVectorArray ($nameID: number) : System.Array$1<UnityEngine.Vector4>
            /** Gets a global matrix array for all shaders previously set using SetGlobalMatrixArray.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public static GetGlobalMatrixArray ($name: string) : System.Array$1<UnityEngine.Matrix4x4>
            /** Gets a global matrix array for all shaders previously set using SetGlobalMatrixArray.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public static GetGlobalMatrixArray ($nameID: number) : System.Array$1<UnityEngine.Matrix4x4>
            public static GetGlobalFloatArray ($name: string, $values: System.Collections.Generic.List$1<number>) : void
            public static GetGlobalFloatArray ($nameID: number, $values: System.Collections.Generic.List$1<number>) : void
            public static GetGlobalVectorArray ($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>) : void
            public static GetGlobalVectorArray ($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>) : void
            public static GetGlobalMatrixArray ($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>) : void
            public static GetGlobalMatrixArray ($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>) : void
            /** Returns the number of properties in this Shader.
            */
            public GetPropertyCount () : number
            /** Finds the index of a shader property by its name.
            * @param $propertyName The name of the shader property.
            */
            public FindPropertyIndex ($propertyName: string) : number
            /** Returns the name of the shader property at the specified index.
            * @param $propertyIndex The index of the shader property.
            */
            public GetPropertyName ($propertyIndex: number) : string
            /** Returns the nameId of the shader property at the specified index.
            * @param $propertyIndex The index of the shader property.
            */
            public GetPropertyNameId ($propertyIndex: number) : number
            /** Returns the ShaderPropertyType of the property at the specified index.
            * @param $propertyIndex The index of the shader property.
            */
            public GetPropertyType ($propertyIndex: number) : UnityEngine.Rendering.ShaderPropertyType
            /** Returns the description string of the shader property at the specified index.
            * @param $propertyIndex The index of the shader property.
            */
            public GetPropertyDescription ($propertyIndex: number) : string
            /** Returns the ShaderPropertyFlags of the shader property at the specified index.
            * @param $propertyIndex The index of the shader property.
            */
            public GetPropertyFlags ($propertyIndex: number) : UnityEngine.Rendering.ShaderPropertyFlags
            /** Returns an array of strings containing attributes of the shader property at the specified index.
            * @param $propertyIndex The index of the shader property.
            */
            public GetPropertyAttributes ($propertyIndex: number) : System.Array$1<string>
            /** Returns the default float value of the shader property at the specified index.
            * @param $propertyIndex The index of the shader property.
            */
            public GetPropertyDefaultFloatValue ($propertyIndex: number) : number
            /** Returns the default Vector4 value of the shader property at the specified index.
            * @param $propertyIndex The index of the shader property.
            */
            public GetPropertyDefaultVectorValue ($propertyIndex: number) : UnityEngine.Vector4
            /** Returns the min and max limits for a <a href="Rendering.ShaderPropertyType.Range.html">Range</a> property at the specified index.
            * @param $propertyIndex The index of the shader property.
            */
            public GetPropertyRangeLimits ($propertyIndex: number) : UnityEngine.Vector2
            /** Returns the default int value of the shader property at the specified index.
            * @param $propertyIndex The index of the shader property.
            */
            public GetPropertyDefaultIntValue ($propertyIndex: number) : number
            /** Returns the TextureDimension of a <a href="Rendering.ShaderPropertyType.Texture.html">Texture</a> shader property at the specified index.
            * @param $propertyIndex The index of the shader property.
            */
            public GetPropertyTextureDimension ($propertyIndex: number) : UnityEngine.Rendering.TextureDimension
            /** Returns the default Texture name of a <a href="Rendering.ShaderPropertyType.Texture.html">Texture</a> shader property at the specified index.
            * @param $propertyIndex The index of the shader property.
            */
            public GetPropertyTextureDefaultName ($propertyIndex: number) : string
            /** Find the name of a texture stack a texture belongs too.
            * @param $propertyIndex Index of the property.
            * @param $stackName On exit, contanis the name of the stack if one was found.
            * @param $layerIndex On exit, contains the stack layer index of the texture property.
            * @returns True, if a stack was found for the given texture property, false if not. 
            */
            public FindTextureStack ($propertyIndex: number, $stackName: $Ref<string>, $layerIndex: $Ref<number>) : boolean
        }
        /** Representation of 2D vectors and points.
        */
        class Vector2 extends System.ValueType implements System.IFormattable, System.IEquatable$1<UnityEngine.Vector2>
        {
            protected [__keep_incompatibility]: never;
            /** X component of the vector.
            */
            public x : number
            /** Y component of the vector.
            */
            public y : number
            public static kEpsilon : number
            public static kEpsilonNormalSqrt : number
            /** Returns this vector with a magnitude of 1 (Read Only).
            */
            public get normalized(): UnityEngine.Vector2;
            /** Returns the length of this vector (Read Only).
            */
            public get magnitude(): number;
            /** Returns the squared length of this vector (Read Only).
            */
            public get sqrMagnitude(): number;
            /** Shorthand for writing Vector2(0, 0).
            */
            public static get zero(): UnityEngine.Vector2;
            /** Shorthand for writing Vector2(1, 1).
            */
            public static get one(): UnityEngine.Vector2;
            /** Shorthand for writing Vector2(0, 1).
            */
            public static get up(): UnityEngine.Vector2;
            /** Shorthand for writing Vector2(0, -1).
            */
            public static get down(): UnityEngine.Vector2;
            /** Shorthand for writing Vector2(-1, 0).
            */
            public static get left(): UnityEngine.Vector2;
            /** Shorthand for writing Vector2(1, 0).
            */
            public static get right(): UnityEngine.Vector2;
            /** Shorthand for writing Vector2(float.PositiveInfinity, float.PositiveInfinity).
            */
            public static get positiveInfinity(): UnityEngine.Vector2;
            /** Shorthand for writing Vector2(float.NegativeInfinity, float.NegativeInfinity).
            */
            public static get negativeInfinity(): UnityEngine.Vector2;
            public get_Item ($index: number) : number
            public set_Item ($index: number, $value: number) : void
            /** Set x and y components of an existing Vector2.
            */
            public Set ($newX: number, $newY: number) : void
            /** Linearly interpolates between vectors a and b by t.
            */
            public static Lerp ($a: UnityEngine.Vector2, $b: UnityEngine.Vector2, $t: number) : UnityEngine.Vector2
            /** Linearly interpolates between vectors a and b by t.
            */
            public static LerpUnclamped ($a: UnityEngine.Vector2, $b: UnityEngine.Vector2, $t: number) : UnityEngine.Vector2
            /** Moves a point current towards target.
            */
            public static MoveTowards ($current: UnityEngine.Vector2, $target: UnityEngine.Vector2, $maxDistanceDelta: number) : UnityEngine.Vector2
            /** Multiplies two vectors component-wise.
            */
            public static Scale ($a: UnityEngine.Vector2, $b: UnityEngine.Vector2) : UnityEngine.Vector2
            /** Multiplies every component of this vector by the same component of scale.
            */
            public Scale ($scale: UnityEngine.Vector2) : void
            /** Makes this vector have a magnitude of 1.
            */
            public Normalize () : void
            /** Returns a formatted string for this vector.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString () : string
            /** Returns a formatted string for this vector.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string) : string
            /** Returns a formatted string for this vector.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            /** Returns true if the given vector is exactly equal to this vector.
            */
            public Equals ($other: any) : boolean
            public Equals ($other: UnityEngine.Vector2) : boolean
            /** Reflects a vector off the vector defined by a normal.
            * @param $inDirection The direction vector towards the surface.
            * @param $inNormal The normal vector that defines the surface.
            */
            public static Reflect ($inDirection: UnityEngine.Vector2, $inNormal: UnityEngine.Vector2) : UnityEngine.Vector2
            /** Returns the 2D vector perpendicular to this 2D vector. The result is always rotated 90-degrees in a counter-clockwise direction for a 2D coordinate system where the positive Y axis goes up.
            * @param $inDirection The input direction.
            * @returns The perpendicular direction. 
            */
            public static Perpendicular ($inDirection: UnityEngine.Vector2) : UnityEngine.Vector2
            /** Dot Product of two vectors.
            */
            public static Dot ($lhs: UnityEngine.Vector2, $rhs: UnityEngine.Vector2) : number
            /** Gets the unsigned angle in degrees between from and to.
            * @param $from The vector from which the angular difference is measured.
            * @param $to The vector to which the angular difference is measured.
            * @returns The unsigned angle in degrees between the two vectors. 
            */
            public static Angle ($from: UnityEngine.Vector2, $to: UnityEngine.Vector2) : number
            /** Gets the signed angle in degrees between from and to.
            * @param $from The vector from which the angular difference is measured.
            * @param $to The vector to which the angular difference is measured.
            * @returns The signed angle in degrees between the two vectors. 
            */
            public static SignedAngle ($from: UnityEngine.Vector2, $to: UnityEngine.Vector2) : number
            /** Returns the distance between a and b.
            */
            public static Distance ($a: UnityEngine.Vector2, $b: UnityEngine.Vector2) : number
            /** Returns a copy of vector with its magnitude clamped to maxLength.
            */
            public static ClampMagnitude ($vector: UnityEngine.Vector2, $maxLength: number) : UnityEngine.Vector2
            public static SqrMagnitude ($a: UnityEngine.Vector2) : number
            public SqrMagnitude () : number
            /** Returns a vector that is made from the smallest components of two vectors.
            */
            public static Min ($lhs: UnityEngine.Vector2, $rhs: UnityEngine.Vector2) : UnityEngine.Vector2
            /** Returns a vector that is made from the largest components of two vectors.
            */
            public static Max ($lhs: UnityEngine.Vector2, $rhs: UnityEngine.Vector2) : UnityEngine.Vector2
            /** Gradually changes a vector towards a desired goal over time.
            * @param $current The current position.
            * @param $target The position we are trying to reach.
            * @param $currentVelocity The current velocity, this value is modified by the function every time you call it.
            * @param $smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
            * @param $maxSpeed Optionally allows you to clamp the maximum speed.
            * @param $deltaTime The time since the last call to this function. By default Time.deltaTime.
            */
            public static SmoothDamp ($current: UnityEngine.Vector2, $target: UnityEngine.Vector2, $currentVelocity: $Ref<UnityEngine.Vector2>, $smoothTime: number, $maxSpeed: number) : UnityEngine.Vector2
            /** Gradually changes a vector towards a desired goal over time.
            * @param $current The current position.
            * @param $target The position we are trying to reach.
            * @param $currentVelocity The current velocity, this value is modified by the function every time you call it.
            * @param $smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
            * @param $maxSpeed Optionally allows you to clamp the maximum speed.
            * @param $deltaTime The time since the last call to this function. By default Time.deltaTime.
            */
            public static SmoothDamp ($current: UnityEngine.Vector2, $target: UnityEngine.Vector2, $currentVelocity: $Ref<UnityEngine.Vector2>, $smoothTime: number) : UnityEngine.Vector2
            /** Gradually changes a vector towards a desired goal over time.
            * @param $current The current position.
            * @param $target The position we are trying to reach.
            * @param $currentVelocity The current velocity, this value is modified by the function every time you call it.
            * @param $smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
            * @param $maxSpeed Optionally allows you to clamp the maximum speed.
            * @param $deltaTime The time since the last call to this function. By default Time.deltaTime.
            */
            public static SmoothDamp ($current: UnityEngine.Vector2, $target: UnityEngine.Vector2, $currentVelocity: $Ref<UnityEngine.Vector2>, $smoothTime: number, $maxSpeed: number, $deltaTime: number) : UnityEngine.Vector2
            public static op_Addition ($a: UnityEngine.Vector2, $b: UnityEngine.Vector2) : UnityEngine.Vector2
            public static op_Subtraction ($a: UnityEngine.Vector2, $b: UnityEngine.Vector2) : UnityEngine.Vector2
            public static op_Multiply ($a: UnityEngine.Vector2, $b: UnityEngine.Vector2) : UnityEngine.Vector2
            public static op_Division ($a: UnityEngine.Vector2, $b: UnityEngine.Vector2) : UnityEngine.Vector2
            public static op_UnaryNegation ($a: UnityEngine.Vector2) : UnityEngine.Vector2
            public static op_Multiply ($a: UnityEngine.Vector2, $d: number) : UnityEngine.Vector2
            public static op_Multiply ($d: number, $a: UnityEngine.Vector2) : UnityEngine.Vector2
            public static op_Division ($a: UnityEngine.Vector2, $d: number) : UnityEngine.Vector2
            public static op_Equality ($lhs: UnityEngine.Vector2, $rhs: UnityEngine.Vector2) : boolean
            public static op_Inequality ($lhs: UnityEngine.Vector2, $rhs: UnityEngine.Vector2) : boolean
            public static op_Implicit ($v: UnityEngine.Vector3) : UnityEngine.Vector2
            public static op_Implicit ($v: UnityEngine.Vector2) : UnityEngine.Vector3
            public constructor ($x: number, $y: number)
        }
        /** A 2D Rectangle defined by X and Y position, width and height.
        */
        class Rect extends System.ValueType implements System.IFormattable, System.IEquatable$1<UnityEngine.Rect>
        {
            protected [__keep_incompatibility]: never;
            /** Shorthand for writing new Rect(0,0,0,0).
            */
            public static get zero(): UnityEngine.Rect;
            /** The X coordinate of the rectangle.
            */
            public get x(): number;
            public set x(value: number);
            /** The Y coordinate of the rectangle.
            */
            public get y(): number;
            public set y(value: number);
            /** The X and Y position of the rectangle.
            */
            public get position(): UnityEngine.Vector2;
            public set position(value: UnityEngine.Vector2);
            /** The position of the center of the rectangle.
            */
            public get center(): UnityEngine.Vector2;
            public set center(value: UnityEngine.Vector2);
            /** The position of the minimum corner of the rectangle.
            */
            public get min(): UnityEngine.Vector2;
            public set min(value: UnityEngine.Vector2);
            /** The position of the maximum corner of the rectangle.
            */
            public get max(): UnityEngine.Vector2;
            public set max(value: UnityEngine.Vector2);
            /** The width of the rectangle, measured from the X position.
            */
            public get width(): number;
            public set width(value: number);
            /** The height of the rectangle, measured from the Y position.
            */
            public get height(): number;
            public set height(value: number);
            /** The width and height of the rectangle.
            */
            public get size(): UnityEngine.Vector2;
            public set size(value: UnityEngine.Vector2);
            /** The minimum X coordinate of the rectangle.
            */
            public get xMin(): number;
            public set xMin(value: number);
            /** The minimum Y coordinate of the rectangle.
            */
            public get yMin(): number;
            public set yMin(value: number);
            /** The maximum X coordinate of the rectangle.
            */
            public get xMax(): number;
            public set xMax(value: number);
            /** The maximum Y coordinate of the rectangle.
            */
            public get yMax(): number;
            public set yMax(value: number);
            /** Creates a rectangle from min/max coordinate values.
            * @param $xmin The minimum X coordinate.
            * @param $ymin The minimum Y coordinate.
            * @param $xmax The maximum X coordinate.
            * @param $ymax The maximum Y coordinate.
            * @returns A rectangle matching the specified coordinates. 
            */
            public static MinMaxRect ($xmin: number, $ymin: number, $xmax: number, $ymax: number) : UnityEngine.Rect
            /** Set components of an existing Rect.
            */
            public Set ($x: number, $y: number, $width: number, $height: number) : void
            /** Returns true if the x and y components of point is a point inside this rectangle. If allowInverse is present and true, the width and height of the Rect are allowed to take negative values (ie, the min value is greater than the max), and the test will still work.
            * @param $point Point to test.
            * @param $allowInverse Does the test allow the Rect's width and height to be negative?
            * @returns True if the point lies within the specified rectangle. 
            */
            public Contains ($point: UnityEngine.Vector2) : boolean
            /** Returns true if the x and y components of point is a point inside this rectangle. If allowInverse is present and true, the width and height of the Rect are allowed to take negative values (ie, the min value is greater than the max), and the test will still work.
            * @param $point Point to test.
            * @param $allowInverse Does the test allow the Rect's width and height to be negative?
            * @returns True if the point lies within the specified rectangle. 
            */
            public Contains ($point: UnityEngine.Vector3) : boolean
            /** Returns true if the x and y components of point is a point inside this rectangle. If allowInverse is present and true, the width and height of the Rect are allowed to take negative values (ie, the min value is greater than the max), and the test will still work.
            * @param $point Point to test.
            * @param $allowInverse Does the test allow the Rect's width and height to be negative?
            * @returns True if the point lies within the specified rectangle. 
            */
            public Contains ($point: UnityEngine.Vector3, $allowInverse: boolean) : boolean
            /** Returns true if the other rectangle overlaps this one. If allowInverse is present and true, the widths and heights of the Rects are allowed to take negative values (ie, the min value is greater than the max), and the test will still work.
            * @param $other Other rectangle to test overlapping with.
            * @param $allowInverse Does the test allow the widths and heights of the Rects to be negative?
            */
            public Overlaps ($other: UnityEngine.Rect) : boolean
            /** Returns true if the other rectangle overlaps this one. If allowInverse is present and true, the widths and heights of the Rects are allowed to take negative values (ie, the min value is greater than the max), and the test will still work.
            * @param $other Other rectangle to test overlapping with.
            * @param $allowInverse Does the test allow the widths and heights of the Rects to be negative?
            */
            public Overlaps ($other: UnityEngine.Rect, $allowInverse: boolean) : boolean
            /** Returns a point inside a rectangle, given normalized coordinates.
            * @param $rectangle Rectangle to get a point inside.
            * @param $normalizedRectCoordinates Normalized coordinates to get a point for.
            */
            public static NormalizedToPoint ($rectangle: UnityEngine.Rect, $normalizedRectCoordinates: UnityEngine.Vector2) : UnityEngine.Vector2
            /** Returns the normalized coordinates cooresponding the the point.
            * @param $rectangle Rectangle to get normalized coordinates inside.
            * @param $point A point inside the rectangle to get normalized coordinates for.
            */
            public static PointToNormalized ($rectangle: UnityEngine.Rect, $point: UnityEngine.Vector2) : UnityEngine.Vector2
            public static op_Inequality ($lhs: UnityEngine.Rect, $rhs: UnityEngine.Rect) : boolean
            public static op_Equality ($lhs: UnityEngine.Rect, $rhs: UnityEngine.Rect) : boolean
            public Equals ($other: any) : boolean
            public Equals ($other: UnityEngine.Rect) : boolean
            /** Returns a formatted string for this Rect.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString () : string
            /** Returns a formatted string for this Rect.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string) : string
            /** Returns a formatted string for this Rect.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            public constructor ($x: number, $y: number, $width: number, $height: number)
            public constructor ($position: UnityEngine.Vector2, $size: UnityEngine.Vector2)
            public constructor ($source: UnityEngine.Rect)
        }
        /** Base class for Texture handling.
        */
        class Texture extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** Can be used with Texture constructors that take a mip count to indicate that all mips should be generated.  The value of this field is -1.
            */
            public static GenerateAllMips : number
            /** How many mipmap levels are in this Texture (Read Only).
            */
            public get mipmapCount(): number;
            public static get anisotropicFiltering(): UnityEngine.AnisotropicFiltering;
            public static set anisotropicFiltering(value: UnityEngine.AnisotropicFiltering);
            /** Returns the GraphicsFormat format or color format of a Texture object.
            */
            public get graphicsFormat(): UnityEngine.Experimental.Rendering.GraphicsFormat;
            /** Width of the Texture in pixels (Read Only).
            */
            public get width(): number;
            public set width(value: number);
            /** Height of the Texture in pixels (Read Only).
            */
            public get height(): number;
            public set height(value: number);
            /** Dimensionality (type) of the Texture (Read Only).
            */
            public get dimension(): UnityEngine.Rendering.TextureDimension;
            public set dimension(value: UnityEngine.Rendering.TextureDimension);
            /** Whether Unity stores an additional copy of this texture's pixel data in CPU-addressable memory.
            */
            public get isReadable(): boolean;
            /** Texture coordinate wrapping mode.
            */
            public get wrapMode(): UnityEngine.TextureWrapMode;
            public set wrapMode(value: UnityEngine.TextureWrapMode);
            /** Texture U coordinate wrapping mode.
            */
            public get wrapModeU(): UnityEngine.TextureWrapMode;
            public set wrapModeU(value: UnityEngine.TextureWrapMode);
            /** Texture V coordinate wrapping mode.
            */
            public get wrapModeV(): UnityEngine.TextureWrapMode;
            public set wrapModeV(value: UnityEngine.TextureWrapMode);
            /** Texture W coordinate wrapping mode for Texture3D.
            */
            public get wrapModeW(): UnityEngine.TextureWrapMode;
            public set wrapModeW(value: UnityEngine.TextureWrapMode);
            /** Filtering mode of the Texture.
            */
            public get filterMode(): UnityEngine.FilterMode;
            public set filterMode(value: UnityEngine.FilterMode);
            /** Defines the anisotropic filtering level of the Texture.
            */
            public get anisoLevel(): number;
            public set anisoLevel(value: number);
            /** The mipmap bias of the Texture.
            */
            public get mipMapBias(): number;
            public set mipMapBias(value: number);
            public get texelSize(): UnityEngine.Vector2;
            /** This counter is incremented when the Texture is updated.
            */
            public get updateCount(): number;
            /** Returns true if the texture pixel data is in sRGB color space (Read Only).
            */
            public get isDataSRGB(): boolean;
            /** The hash value of the Texture.
            */
            public get imageContentsHash(): UnityEngine.Hash128;
            public set imageContentsHash(value: UnityEngine.Hash128);
            /** The total amount of Texture memory that Unity would use if it loads all Textures at mipmap level 0.
            This is a theoretical value that does not take into account any input from the streaming system or any other input, for example when you set the`Texture2D.requestedMipmapLevel` manually.
            To see a Texture memory value that takes inputs into account, use `desiredTextureMemory`.
            `totalTextureMemory` only includes instances of Texture2D and CubeMap Textures. This value does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
            */
            public static get totalTextureMemory(): bigint;
            /** The total size of the Textures, in bytes, that Unity loads if there were no other constraints. Before Unity loads any Textures, it applies the which reduces the loaded Texture resolution if the Texture sizes exceed its value. The desiredTextureMemory value takes into account the mipmap levels that Unity has requested or that you have set manually.
            For example, if Unity does not load a Texture at full resolution because it is far away or its requested mipmap level is greater than 0,  Unity reduces the desiredTextureMemory value to match the total memory needed.
            The desiredTextureMemory value can be greater than the Texture.targetTextureMemory value.
            */
            public static get desiredTextureMemory(): bigint;
            /** The total amount of Texture memory that Unity allocates to the Textures in the scene after it applies the and finishes loading Textures. `targetTextureMemory`also takes mipmap streaming settings into account. This value only includes instances of Texture2D and CubeMap Textures. This value does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
            */
            public static get targetTextureMemory(): bigint;
            /** The amount of memory that all Textures in the scene use.
            */
            public static get currentTextureMemory(): bigint;
            /** The amount of memory Unity allocates for non-streaming Textures in the scene. This only includes instances of Texture2D and CubeMap Textures. This does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
            */
            public static get nonStreamingTextureMemory(): bigint;
            /** How many times has a Texture been uploaded due to Texture mipmap streaming.
            */
            public static get streamingMipmapUploadCount(): bigint;
            /** Number of renderers registered with the Texture streaming system.
            */
            public static get streamingRendererCount(): bigint;
            /** Number of streaming Textures.
            */
            public static get streamingTextureCount(): bigint;
            /** The number of non-streaming Textures in the scene. This includes instances of Texture2D and CubeMap Textures. This does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
            */
            public static get nonStreamingTextureCount(): bigint;
            /** Number of streaming Textures with outstanding mipmaps to be loaded.
            */
            public static get streamingTexturePendingLoadCount(): bigint;
            /** Number of streaming Textures with mipmaps currently loading.
            */
            public static get streamingTextureLoadingCount(): bigint;
            /** Force streaming Textures to load all mipmap levels.
            */
            public static get streamingTextureForceLoadAll(): boolean;
            public static set streamingTextureForceLoadAll(value: boolean);
            /** This property forces the streaming Texture system to discard all unused mipmaps instead of caching them until the Texture is exceeded. This is useful when you profile or write tests to keep a predictable set of Textures in memory.
            */
            public static get streamingTextureDiscardUnusedMips(): boolean;
            public static set streamingTextureDiscardUnusedMips(value: boolean);
            /** Allow Unity internals to perform Texture creation on any thread (rather than the dedicated render thread).
            */
            public static get allowThreadedTextureCreation(): boolean;
            public static set allowThreadedTextureCreation(value: boolean);
            /** GraphicsTexture that represents the texture resource uploaded to the graphics device (Read Only).
            */
            public get graphicsTexture(): UnityEngine.Rendering.GraphicsTexture;
            /** Sets Anisotropic limits.
            */
            public static SetGlobalAnisotropicFilteringLimits ($forcedMin: number, $globalMax: number) : void
            /** Retrieve a native (underlying graphics API) pointer to the Texture resource.
            * @returns Pointer to an underlying graphics API Texture resource. 
            */
            public GetNativeTexturePtr () : System.IntPtr
            /** Increment the update counter.
            */
            public IncrementUpdateCount () : void
            /** This function sets mipmap streaming debug properties on any materials that use this Texture through the mipmap streaming system.
            */
            public static SetStreamingTextureMaterialDebugProperties () : void
        }
        /** Render textures are textures that can be rendered to.
        */
        class RenderTexture extends UnityEngine.Texture
        {
            protected [__keep_incompatibility]: never;
            /** The width of the render texture in pixels.
            */
            public get width(): number;
            public set width(value: number);
            /** The height of the render texture in pixels.
            */
            public get height(): number;
            public set height(value: number);
            /** Dimensionality (type) of the render texture.
            */
            public get dimension(): UnityEngine.Rendering.TextureDimension;
            public set dimension(value: UnityEngine.Rendering.TextureDimension);
            /** The color format of the render texture. You can set the color format to None to achieve depth-only rendering.
            */
            public get graphicsFormat(): UnityEngine.Experimental.Rendering.GraphicsFormat;
            public set graphicsFormat(value: UnityEngine.Experimental.Rendering.GraphicsFormat);
            /** Render texture has mipmaps when this flag is set.
            */
            public get useMipMap(): boolean;
            public set useMipMap(value: boolean);
            /** Does this render texture use sRGB read/write conversions? (Read Only).
            */
            public get sRGB(): boolean;
            /** If this RenderTexture is a VR eye texture used in stereoscopic rendering, this property decides what special rendering occurs, if any.
            */
            public get vrUsage(): UnityEngine.VRTextureUsage;
            public set vrUsage(value: UnityEngine.VRTextureUsage);
            /** The render texture memoryless mode property.
            */
            public get memorylessMode(): UnityEngine.RenderTextureMemoryless;
            public set memorylessMode(value: UnityEngine.RenderTextureMemoryless);
            public get format(): UnityEngine.RenderTextureFormat;
            public set format(value: UnityEngine.RenderTextureFormat);
            /** The format of the stencil data that you can encapsulate within a RenderTexture.
            Specifying this property creates a stencil element for the RenderTexture and sets its format.
            This allows for stencil data to be bound as a Texture to all shader types for the platforms that support it.
            This property does not specify the format of the stencil buffer, which is constrained by the depth buffer format specified in RenderTexture.depth.
            Currently, most platforms only support R8_UInt (DirectX11, DirectX12), while PS4 also supports R8_UNorm.
            */
            public get stencilFormat(): UnityEngine.Experimental.Rendering.GraphicsFormat;
            public set stencilFormat(value: UnityEngine.Experimental.Rendering.GraphicsFormat);
            /** The format of the depth/stencil buffer.
            */
            public get depthStencilFormat(): UnityEngine.Experimental.Rendering.GraphicsFormat;
            public set depthStencilFormat(value: UnityEngine.Experimental.Rendering.GraphicsFormat);
            /** Mipmap levels are generated automatically when this flag is set.
            */
            public get autoGenerateMips(): boolean;
            public set autoGenerateMips(value: boolean);
            /** Volume extent of a 3D render texture or number of slices of array texture.
            */
            public get volumeDepth(): number;
            public set volumeDepth(value: number);
            /** The antialiasing level for the RenderTexture.
            */
            public get antiAliasing(): number;
            public set antiAliasing(value: number);
            /** If true and antiAliasing is greater than 1, the render texture will not be resolved by default.  Use this if the render texture needs to be bound as a multisampled texture in a shader.
            */
            public get bindTextureMS(): boolean;
            public set bindTextureMS(value: boolean);
            /** Enable random access write into this render texture on Shader Model 5.0 level shaders.
            */
            public get enableRandomWrite(): boolean;
            public set enableRandomWrite(value: boolean);
            /** When this flag is set to true, render texture is set to be used by the.
            */
            public get useDynamicScale(): boolean;
            public set useDynamicScale(value: boolean);
            /** When this flag is set to true, render texture is set to be used by the. Scale is applied with an explicit call to ApplyDynamicScale
            */
            public get useDynamicScaleExplicit(): boolean;
            public set useDynamicScaleExplicit(value: boolean);
            public get isPowerOfTwo(): boolean;
            public set isPowerOfTwo(value: boolean);
            /** Currently active render texture.
            */
            public static get active(): UnityEngine.RenderTexture;
            public static set active(value: UnityEngine.RenderTexture);
            /** Color buffer of the render texture (Read Only).
            */
            public get colorBuffer(): UnityEngine.RenderBuffer;
            /** Depth/stencil buffer of the render texture (Read Only).
            */
            public get depthBuffer(): UnityEngine.RenderBuffer;
            /** The precision of the render texture's depth buffer in bits (0, 16, 24 and 32 are supported).
            */
            public get depth(): number;
            public set depth(value: number);
            /** This struct contains all the information required to create a RenderTexture. It can be copied, cached, and reused to easily create RenderTextures that all share the same properties.
            */
            public get descriptor(): UnityEngine.RenderTextureDescriptor;
            public set descriptor(value: UnityEngine.RenderTextureDescriptor);
            /** Applies the scale.
            */
            public ApplyDynamicScale () : void
            /** Retrieve a native (underlying graphics API) pointer to the depth buffer resource.
            * @returns Pointer to an underlying graphics API depth buffer resource. 
            */
            public GetNativeDepthBufferPtr () : System.IntPtr
            /** Hint the GPU driver that the contents of the RenderTexture will not be used.
            * @param $discardColor Should the colour buffer be discarded?
            * @param $discardDepth Should the depth buffer be discarded?
            */
            public DiscardContents ($discardColor: boolean, $discardDepth: boolean) : void
            /** Hint the GPU driver that the contents of the RenderTexture will not be used.
            * @param $discardColor Should the colour buffer be discarded?
            * @param $discardDepth Should the depth buffer be discarded?
            */
            public DiscardContents () : void
            /** Force an antialiased render texture to be resolved.
            * @param $target The render texture to resolve into.  If set, the target render texture must have the same dimensions and format as the source.
            */
            public ResolveAntiAliasedSurface () : void
            /** Force an antialiased render texture to be resolved.
            * @param $target The render texture to resolve into.  If set, the target render texture must have the same dimensions and format as the source.
            */
            public ResolveAntiAliasedSurface ($target: UnityEngine.RenderTexture) : void
            /** Assigns this RenderTexture as a global shader property named propertyName.
            */
            public SetGlobalShaderProperty ($propertyName: string) : void
            /** Actually creates the RenderTexture.
            * @returns True if the texture is created, else false. 
            */
            public Create () : boolean
            /** Releases the RenderTexture.
            */
            public Release () : void
            /** Is the render texture actually created?
            */
            public IsCreated () : boolean
            /** Generate mipmap levels of a render texture.
            */
            public GenerateMips () : void
            public ConvertToEquirect ($equirect: UnityEngine.RenderTexture, $eye?: UnityEngine.Camera.MonoOrStereoscopicEye) : void
            /** Does a RenderTexture have stencil buffer?
            * @param $rt Render texture, or null for main screen.
            */
            public static SupportsStencil ($rt: UnityEngine.RenderTexture) : boolean
            /** Release a temporary texture allocated with GetTemporary.
            */
            public static ReleaseTemporary ($temp: UnityEngine.RenderTexture) : void
            /** Allocate a temporary render texture.
            * @param $width Width in pixels.
            * @param $height Height in pixels.
            * @param $depthBuffer Depth buffer bits (0, 16 or 24). Note that only 24 bit depth has stencil buffer.
            * @param $format Render texture format.
            * @param $readWrite Color space conversion mode.
            * @param $antiAliasing Number of antialiasing samples to store in the texture. Valid values are 1, 2, 4, and 8. Throws an exception if any other value is passed.
            * @param $memorylessMode Render texture memoryless mode.
            * @param $vrUsage How Unity uses the RenderTexture as a VR eye texture. The default is VRTextureUsage.None.
            * @param $useDynamicScale Determines whether Unity scales the render texture using. The default is false.
            * @param $desc Use this RenderTextureDesc for the settings when creating the temporary RenderTexture.
            */
            public static GetTemporary ($desc: UnityEngine.RenderTextureDescriptor) : UnityEngine.RenderTexture
            public static GetTemporary ($width: number, $height: number, $depthBuffer: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $antiAliasing: number, $memorylessMode: UnityEngine.RenderTextureMemoryless, $vrUsage: UnityEngine.VRTextureUsage, $useDynamicScale: boolean) : UnityEngine.RenderTexture
            public static GetTemporary ($width: number, $height: number, $depthBuffer: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $antiAliasing: number, $memorylessMode: UnityEngine.RenderTextureMemoryless, $vrUsage: UnityEngine.VRTextureUsage) : UnityEngine.RenderTexture
            public static GetTemporary ($width: number, $height: number, $depthBuffer: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $antiAliasing: number, $memorylessMode: UnityEngine.RenderTextureMemoryless) : UnityEngine.RenderTexture
            public static GetTemporary ($width: number, $height: number, $depthBuffer: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $antiAliasing: number) : UnityEngine.RenderTexture
            public static GetTemporary ($width: number, $height: number, $depthBuffer: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat) : UnityEngine.RenderTexture
            /** Allocate a temporary render texture.
            * @param $width Width in pixels.
            * @param $height Height in pixels.
            * @param $depthBuffer Depth buffer bits (0, 16 or 24). Note that only 24 bit depth has stencil buffer.
            * @param $format Render texture format.
            * @param $readWrite Color space conversion mode.
            * @param $antiAliasing Number of antialiasing samples to store in the texture. Valid values are 1, 2, 4, and 8. Throws an exception if any other value is passed.
            * @param $memorylessMode Render texture memoryless mode.
            * @param $vrUsage How Unity uses the RenderTexture as a VR eye texture. The default is VRTextureUsage.None.
            * @param $useDynamicScale Determines whether Unity scales the render texture using. The default is false.
            * @param $desc Use this RenderTextureDesc for the settings when creating the temporary RenderTexture.
            */
            public static GetTemporary ($width: number, $height: number, $depthBuffer: number, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite, $antiAliasing: number, $memorylessMode: UnityEngine.RenderTextureMemoryless, $vrUsage: UnityEngine.VRTextureUsage, $useDynamicScale: boolean) : UnityEngine.RenderTexture
            public static GetTemporary ($width: number, $height: number, $depthBuffer: number, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite, $antiAliasing: number, $memorylessMode: UnityEngine.RenderTextureMemoryless, $vrUsage: UnityEngine.VRTextureUsage) : UnityEngine.RenderTexture
            public static GetTemporary ($width: number, $height: number, $depthBuffer: number, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite, $antiAliasing: number, $memorylessMode: UnityEngine.RenderTextureMemoryless) : UnityEngine.RenderTexture
            public static GetTemporary ($width: number, $height: number, $depthBuffer: number, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite, $antiAliasing: number) : UnityEngine.RenderTexture
            public static GetTemporary ($width: number, $height: number, $depthBuffer: number, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite) : UnityEngine.RenderTexture
            public static GetTemporary ($width: number, $height: number, $depthBuffer: number, $format: UnityEngine.RenderTextureFormat) : UnityEngine.RenderTexture
            public static GetTemporary ($width: number, $height: number, $depthBuffer: number) : UnityEngine.RenderTexture
            public static GetTemporary ($width: number, $height: number) : UnityEngine.RenderTexture
            public constructor ($desc: UnityEngine.RenderTextureDescriptor)
            public constructor ($textureToCopy: UnityEngine.RenderTexture)
            public constructor ($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat)
            public constructor ($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat)
            public constructor ($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $mipCount: number)
            public constructor ($width: number, $height: number, $colorFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $depthStencilFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $mipCount: number)
            public constructor ($width: number, $height: number, $colorFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $depthStencilFormat: UnityEngine.Experimental.Rendering.GraphicsFormat)
            public constructor ($width: number, $height: number, $depth: number, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite)
            public constructor ($width: number, $height: number, $depth: number, $format: UnityEngine.RenderTextureFormat)
            public constructor ($width: number, $height: number, $depth: number)
            public constructor ($width: number, $height: number, $depth: number, $format: UnityEngine.RenderTextureFormat, $mipCount: number)
            public constructor ()
        }
        /** Color or depth buffer part of a RenderTexture.
        */
        class RenderBuffer extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Returns native RenderBuffer. Be warned this is not native Texture, but rather pointer to unity struct that can be used with native unity API. Currently such API exists only on iOS.
            */
            public GetNativeRenderBufferPtr () : System.IntPtr
        }
        /** Representation of four-dimensional vectors.
        */
        class Vector4 extends System.ValueType implements System.IFormattable, System.IEquatable$1<UnityEngine.Vector4>
        {
            protected [__keep_incompatibility]: never;
            public static kEpsilon : number
            /** X component of the vector.
            */
            public x : number
            /** Y component of the vector.
            */
            public y : number
            /** Z component of the vector.
            */
            public z : number
            /** W component of the vector.
            */
            public w : number
            /** Returns this vector with a magnitude of 1 (Read Only).
            */
            public get normalized(): UnityEngine.Vector4;
            /** Returns the length of this vector (Read Only).
            */
            public get magnitude(): number;
            /** Returns the squared length of this vector (Read Only).
            */
            public get sqrMagnitude(): number;
            /** Shorthand for writing Vector4(0,0,0,0).
            */
            public static get zero(): UnityEngine.Vector4;
            /** Shorthand for writing Vector4(1,1,1,1).
            */
            public static get one(): UnityEngine.Vector4;
            /** Shorthand for writing Vector4(float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity).
            */
            public static get positiveInfinity(): UnityEngine.Vector4;
            /** Shorthand for writing Vector4(float.NegativeInfinity, float.NegativeInfinity, float.NegativeInfinity, float.NegativeInfinity).
            */
            public static get negativeInfinity(): UnityEngine.Vector4;
            public get_Item ($index: number) : number
            public set_Item ($index: number, $value: number) : void
            /** Set x, y, z and w components of an existing Vector4.
            */
            public Set ($newX: number, $newY: number, $newZ: number, $newW: number) : void
            /** Linearly interpolates between two vectors.
            */
            public static Lerp ($a: UnityEngine.Vector4, $b: UnityEngine.Vector4, $t: number) : UnityEngine.Vector4
            /** Linearly interpolates between two vectors.
            */
            public static LerpUnclamped ($a: UnityEngine.Vector4, $b: UnityEngine.Vector4, $t: number) : UnityEngine.Vector4
            /** Moves a point current towards target.
            */
            public static MoveTowards ($current: UnityEngine.Vector4, $target: UnityEngine.Vector4, $maxDistanceDelta: number) : UnityEngine.Vector4
            /** Multiplies two vectors component-wise.
            */
            public static Scale ($a: UnityEngine.Vector4, $b: UnityEngine.Vector4) : UnityEngine.Vector4
            /** Multiplies every component of this vector by the same component of scale.
            */
            public Scale ($scale: UnityEngine.Vector4) : void
            /** Returns true if the given vector is exactly equal to this vector.
            */
            public Equals ($other: any) : boolean
            public Equals ($other: UnityEngine.Vector4) : boolean
            public static Normalize ($a: UnityEngine.Vector4) : UnityEngine.Vector4
            /** Makes this vector have a magnitude of 1.
            */
            public Normalize () : void
            /** Dot Product of two vectors.
            */
            public static Dot ($a: UnityEngine.Vector4, $b: UnityEngine.Vector4) : number
            /** Projects a vector onto another vector.
            */
            public static Project ($a: UnityEngine.Vector4, $b: UnityEngine.Vector4) : UnityEngine.Vector4
            /** Returns the distance between a and b.
            */
            public static Distance ($a: UnityEngine.Vector4, $b: UnityEngine.Vector4) : number
            public static Magnitude ($a: UnityEngine.Vector4) : number
            /** Returns a vector that is made from the smallest components of two vectors.
            */
            public static Min ($lhs: UnityEngine.Vector4, $rhs: UnityEngine.Vector4) : UnityEngine.Vector4
            /** Returns a vector that is made from the largest components of two vectors.
            */
            public static Max ($lhs: UnityEngine.Vector4, $rhs: UnityEngine.Vector4) : UnityEngine.Vector4
            public static op_Addition ($a: UnityEngine.Vector4, $b: UnityEngine.Vector4) : UnityEngine.Vector4
            public static op_Subtraction ($a: UnityEngine.Vector4, $b: UnityEngine.Vector4) : UnityEngine.Vector4
            public static op_UnaryNegation ($a: UnityEngine.Vector4) : UnityEngine.Vector4
            public static op_Multiply ($a: UnityEngine.Vector4, $d: number) : UnityEngine.Vector4
            public static op_Multiply ($d: number, $a: UnityEngine.Vector4) : UnityEngine.Vector4
            public static op_Division ($a: UnityEngine.Vector4, $d: number) : UnityEngine.Vector4
            public static op_Equality ($lhs: UnityEngine.Vector4, $rhs: UnityEngine.Vector4) : boolean
            public static op_Inequality ($lhs: UnityEngine.Vector4, $rhs: UnityEngine.Vector4) : boolean
            public static op_Implicit ($v: UnityEngine.Vector3) : UnityEngine.Vector4
            public static op_Implicit ($v: UnityEngine.Vector4) : UnityEngine.Vector3
            public static op_Implicit ($v: UnityEngine.Vector2) : UnityEngine.Vector4
            public static op_Implicit ($v: UnityEngine.Vector4) : UnityEngine.Vector2
            /** Returns a formatted string for this vector.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString () : string
            /** Returns a formatted string for this vector.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string) : string
            /** Returns a formatted string for this vector.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            public static SqrMagnitude ($a: UnityEngine.Vector4) : number
            public SqrMagnitude () : number
            public constructor ($x: number, $y: number, $z: number, $w: number)
            public constructor ($x: number, $y: number, $z: number)
            public constructor ($x: number, $y: number)
        }
        /** Representation of rays.
        */
        class Ray extends System.ValueType implements System.IFormattable
        {
            protected [__keep_incompatibility]: never;
            /** The origin point of the ray.
            */
            public get origin(): UnityEngine.Vector3;
            public set origin(value: UnityEngine.Vector3);
            /** The direction of the ray.
            */
            public get direction(): UnityEngine.Vector3;
            public set direction(value: UnityEngine.Vector3);
            /** Returns a point at distance units along the ray.
            */
            public GetPoint ($distance: number) : UnityEngine.Vector3
            /** Returns a formatted string for this ray.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString () : string
            /** Returns a formatted string for this ray.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string) : string
            /** Returns a formatted string for this ray.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            public constructor ($origin: UnityEngine.Vector3, $direction: UnityEngine.Vector3)
        }
        /** Enum values for the Camera's targetEye property.
        */
        enum StereoTargetEyeMask
        { None = 0, Left = 1, Right = 2, Both = 3 }
        /** Class for handling cube maps, Use this to create or modify existing.
        */
        class Cubemap extends UnityEngine.Texture
        {
            protected [__keep_incompatibility]: never;
            /** The format of the pixel data in the texture (Read Only).
            */
            public get format(): UnityEngine.TextureFormat;
            public get isReadable(): boolean;
            /** Determines whether mipmap streaming is enabled for this Texture.
            */
            public get streamingMipmaps(): boolean;
            /** Sets the relative priority for this Texture when reducing memory size to fit within the memory budget.
            */
            public get streamingMipmapsPriority(): number;
            /** The mipmap level to load.
            */
            public get requestedMipmapLevel(): number;
            public set requestedMipmapLevel(value: number);
            /** The mipmap level that the streaming system would load before memory budgets are applied.
            */
            public get desiredMipmapLevel(): number;
            /** The mipmap level that the mipmap streaming system is in the process of loading.
            */
            public get loadingMipmapLevel(): number;
            /** The mipmap level that is currently loaded by the streaming system.
            */
            public get loadedMipmapLevel(): number;
            /** Updates Unity cubemap to use different native cubemap texture object.
            * @param $nativeTexture Native cubemap texture object.
            */
            public UpdateExternalTexture ($nativeTexture: System.IntPtr) : void
            /** Performs smoothing of near edge regions.
            * @param $smoothRegionWidthInPixels Pixel distance at edges over which to apply smoothing.
            */
            public SmoothEdges ($smoothRegionWidthInPixels: number) : void
            public SmoothEdges () : void
            /** Gets the pixel color data for a mipmap level of a face as Color structs.
            * @param $face The CubemapFace to read from.
            * @param $miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns An array that contains the pixel colors. 
            */
            public GetPixels ($face: UnityEngine.CubemapFace, $miplevel: number) : System.Array$1<UnityEngine.Color>
            /** Gets the pixel color data for a mipmap level of a face as Color structs.
            * @param $face The CubemapFace to read from.
            * @param $miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns An array that contains the pixel colors. 
            */
            public GetPixels ($face: UnityEngine.CubemapFace) : System.Array$1<UnityEngine.Color>
            /** Sets the pixel colors of an entire mipmap level of a face.
            * @param $colors The array of pixel colours to use. This is a 2D image flattened to a 1D array.
            * @param $miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @param $face The CubemapFace to write colors to.
            */
            public SetPixels ($colors: System.Array$1<UnityEngine.Color>, $face: UnityEngine.CubemapFace, $miplevel: number) : void
            /** Sets the pixel colors of an entire mipmap level of a face.
            * @param $colors The array of pixel colours to use. This is a 2D image flattened to a 1D array.
            * @param $miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @param $face The CubemapFace to write colors to.
            */
            public SetPixels ($colors: System.Array$1<UnityEngine.Color>, $face: UnityEngine.CubemapFace) : void
            /** Resets the requestedMipmapLevel field.
            */
            public ClearRequestedMipmapLevel () : void
            /** Checks to see whether the mipmap level set by requestedMipmapLevel has finished loading.
            * @returns True if the mipmap level requested by requestedMipmapLevel has finished loading. 
            */
            public IsRequestedMipmapLevelLoaded () : boolean
            /** Creates a Unity cubemap out of externally created native cubemap object.
            * @param $size The width and height of each face of the cubemap should be the same.
            * @param $format Format of underlying cubemap object.
            * @param $mipmap Does the cubemap have mipmaps?
            * @param $nativeTex Native cubemap texture object.
            */
            public static CreateExternalTexture ($width: number, $format: UnityEngine.TextureFormat, $mipmap: boolean, $nativeTex: System.IntPtr) : UnityEngine.Cubemap
            /** Sets the pixel color at coordinates (x,y).
            * @param $x The x coordinate of the pixel to set. The range is 0 through (texture width - 1).
            * @param $y The y coordinate of the pixel to set. The range is 0 through (texture height - 1).
            * @param $color The color to set.
            * @param $mip The mipmap level to write to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @param $face The CubemapFace to write to.
            */
            public SetPixel ($face: UnityEngine.CubemapFace, $x: number, $y: number, $color: UnityEngine.Color) : void
            /** Sets the pixel color at coordinates (x,y).
            * @param $x The x coordinate of the pixel to set. The range is 0 through (texture width - 1).
            * @param $y The y coordinate of the pixel to set. The range is 0 through (texture height - 1).
            * @param $color The color to set.
            * @param $mip The mipmap level to write to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @param $face The CubemapFace to write to.
            */
            public SetPixel ($face: UnityEngine.CubemapFace, $x: number, $y: number, $color: UnityEngine.Color, $mip: number) : void
            /** Gets the pixel color at coordinates (x, y).
            * @param $x The x coordinate of the pixel to get. The range is 0 through (texture width - 1).
            * @param $y The y coordinate of the pixel to get. The range is 0 through (texture height - 1).
            * @param $mip The mipmap level to sample. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @param $face The CubemapFace to sample.
            * @returns The pixel color. 
            */
            public GetPixel ($face: UnityEngine.CubemapFace, $x: number, $y: number) : UnityEngine.Color
            /** Gets the pixel color at coordinates (x, y).
            * @param $x The x coordinate of the pixel to get. The range is 0 through (texture width - 1).
            * @param $y The y coordinate of the pixel to get. The range is 0 through (texture height - 1).
            * @param $mip The mipmap level to sample. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @param $face The CubemapFace to sample.
            * @returns The pixel color. 
            */
            public GetPixel ($face: UnityEngine.CubemapFace, $x: number, $y: number, $mip: number) : UnityEngine.Color
            /** Copies changes you've made in a CPU texture to the GPU.
            * @param $updateMipmaps When the value is true, Unity recalculates mipmap levels, using mipmap level 0 as the source. The default value is true.
            * @param $makeNoLongerReadable When the value is true, Unity deletes the texture in CPU memory after it uploads it to the GPU, and sets Texture.isReadable|isReadable to false. The default value is false.
            */
            public Apply ($updateMipmaps: boolean, $makeNoLongerReadable: boolean) : void
            public Apply ($updateMipmaps: boolean) : void
            public Apply () : void
            public constructor ($width: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags)
            public constructor ($width: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags, $mipCount: number)
            public constructor ($width: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags)
            public constructor ($width: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags, $mipCount: number)
            public constructor ($width: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean)
            public constructor ($width: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean, $createUninitialized: boolean)
            public constructor ($width: number, $format: UnityEngine.TextureFormat, $mipCount: number)
            public constructor ($width: number, $format: UnityEngine.TextureFormat, $mipCount: number, $createUninitialized: boolean)
            public constructor ()
        }
        /** Describes a single bounding sphere for use by a CullingGroup.
        */
        class BoundingSphere extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The position of the center of the BoundingSphere.
            */
            public position : UnityEngine.Vector3
            /** The radius of the BoundingSphere.
            */
            public radius : number
            public constructor ($pos: UnityEngine.Vector3, $rad: number)
            public constructor ($packedSphere: UnityEngine.Vector4)
        }
        /** Provides information about the current and previous states of one sphere in a CullingGroup.
        */
        class CullingGroupEvent extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The index of the sphere that has changed.
            */
            public get index(): number;
            /** Was the sphere considered visible by the most recent culling pass?
            */
            public get isVisible(): boolean;
            /** Was the sphere visible before the most recent culling pass?
            */
            public get wasVisible(): boolean;
            /** Did this sphere change from being invisible to being visible in the most recent culling pass?
            */
            public get hasBecomeVisible(): boolean;
            /** Did this sphere change from being visible to being invisible in the most recent culling pass?
            */
            public get hasBecomeInvisible(): boolean;
            /** The current distance band index of the sphere, after the most recent culling pass.
            */
            public get currentDistance(): number;
            /** The distance band index of the sphere before the most recent culling pass.
            */
            public get previousDistance(): number;
        }
        /** Describes a set of bounding spheres that should have their visibility and distances maintained.
        */
        class CullingGroup extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            /** Sets the callback that will be called when a sphere's visibility and/or distance state has changed.
            */
            public get onStateChanged(): UnityEngine.CullingGroup.StateChanged;
            public set onStateChanged(value: UnityEngine.CullingGroup.StateChanged);
            /** Pauses culling group execution.
            */
            public get enabled(): boolean;
            public set enabled(value: boolean);
            /** Locks the CullingGroup to a specific camera.
            */
            public get targetCamera(): UnityEngine.Camera;
            public set targetCamera(value: UnityEngine.Camera);
            /** Clean up all memory used by the CullingGroup immediately.
            */
            public Dispose () : void
            /** Sets the array of bounding sphere definitions that the CullingGroup should compute culling for.
            * @param $array The BoundingSpheres to cull.
            */
            public SetBoundingSpheres ($array: System.Array$1<UnityEngine.BoundingSphere>) : void
            /** Sets the number of bounding spheres in the bounding spheres array that are actually being used.
            * @param $count The number of bounding spheres being used.
            */
            public SetBoundingSphereCount ($count: number) : void
            /** Erase a given bounding sphere by moving the final sphere on top of it.
            * @param $index The index of the entry to erase.
            */
            public EraseSwapBack ($index: number) : void
            /** Retrieve the indices of spheres that have particular visibility and/or distance states.
            * @param $visible True if only visible spheres should be retrieved; false if only invisible spheres should be retrieved.
            * @param $distanceIndex The distance band that retrieved spheres must be in.
            * @param $result An array that will be filled with the retrieved sphere indices.
            * @param $firstIndex The index of the sphere to begin searching at.
            * @returns The number of sphere indices found and written into the result array. 
            */
            public QueryIndices ($visible: boolean, $result: System.Array$1<number>, $firstIndex: number) : number
            /** Retrieve the indices of spheres that have particular visibility and/or distance states.
            * @param $visible True if only visible spheres should be retrieved; false if only invisible spheres should be retrieved.
            * @param $distanceIndex The distance band that retrieved spheres must be in.
            * @param $result An array that will be filled with the retrieved sphere indices.
            * @param $firstIndex The index of the sphere to begin searching at.
            * @returns The number of sphere indices found and written into the result array. 
            */
            public QueryIndices ($distanceIndex: number, $result: System.Array$1<number>, $firstIndex: number) : number
            /** Retrieve the indices of spheres that have particular visibility and/or distance states.
            * @param $visible True if only visible spheres should be retrieved; false if only invisible spheres should be retrieved.
            * @param $distanceIndex The distance band that retrieved spheres must be in.
            * @param $result An array that will be filled with the retrieved sphere indices.
            * @param $firstIndex The index of the sphere to begin searching at.
            * @returns The number of sphere indices found and written into the result array. 
            */
            public QueryIndices ($visible: boolean, $distanceIndex: number, $result: System.Array$1<number>, $firstIndex: number) : number
            /** Returns true if the bounding sphere at index is currently visible from any of the contributing cameras.
            * @param $index The index of the bounding sphere.
            * @returns True if the sphere is visible; false if it is invisible. 
            */
            public IsVisible ($index: number) : boolean
            /** Get the current distance band index of a given sphere.
            * @param $index The index of the sphere.
            * @returns The sphere's current distance band index. 
            */
            public GetDistance ($index: number) : number
            /** Set bounding distances for 'distance bands' the group should compute, as well as options for how spheres falling into each distance band should be treated.
            * @param $distances An array of bounding distances. The distances should be sorted in increasing order.
            */
            public SetBoundingDistances ($distances: System.Array$1<number>) : void
            /** Set the reference point from which distance bands are measured.
            * @param $point A fixed point to measure the distance from.
            * @param $transform A transform to measure the distance from. The transform's position will be automatically tracked.
            */
            public SetDistanceReferencePoint ($point: UnityEngine.Vector3) : void
            /** Set the reference point from which distance bands are measured.
            * @param $point A fixed point to measure the distance from.
            * @param $transform A transform to measure the distance from. The transform's position will be automatically tracked.
            */
            public SetDistanceReferencePoint ($transform: UnityEngine.Transform) : void
            public constructor ()
        }
        /** Position, rotation and scale of an object.
        */
        class Transform extends UnityEngine.Component implements System.Collections.IEnumerable
        {
            protected [__keep_incompatibility]: never;
            /** The world space position of the Transform.
            */
            public get position(): UnityEngine.Vector3;
            public set position(value: UnityEngine.Vector3);
            /** Position of the transform relative to the parent transform.
            */
            public get localPosition(): UnityEngine.Vector3;
            public set localPosition(value: UnityEngine.Vector3);
            /** The rotation as Euler angles in degrees.
            */
            public get eulerAngles(): UnityEngine.Vector3;
            public set eulerAngles(value: UnityEngine.Vector3);
            /** The rotation as Euler angles in degrees relative to the parent transform's rotation.
            */
            public get localEulerAngles(): UnityEngine.Vector3;
            public set localEulerAngles(value: UnityEngine.Vector3);
            /** The red axis of the transform in world space.
            */
            public get right(): UnityEngine.Vector3;
            public set right(value: UnityEngine.Vector3);
            /** The green axis of the transform in world space.
            */
            public get up(): UnityEngine.Vector3;
            public set up(value: UnityEngine.Vector3);
            /** Returns a normalized vector representing the blue axis of the transform in world space.
            */
            public get forward(): UnityEngine.Vector3;
            public set forward(value: UnityEngine.Vector3);
            /** A Quaternion that stores the rotation of the Transform in world space.
            */
            public get rotation(): UnityEngine.Quaternion;
            public set rotation(value: UnityEngine.Quaternion);
            /** The rotation of the transform relative to the transform rotation of the parent.
            */
            public get localRotation(): UnityEngine.Quaternion;
            public set localRotation(value: UnityEngine.Quaternion);
            /** The scale of the transform relative to the GameObjects parent.
            */
            public get localScale(): UnityEngine.Vector3;
            public set localScale(value: UnityEngine.Vector3);
            /** The parent of the transform.
            */
            public get parent(): UnityEngine.Transform;
            public set parent(value: UnityEngine.Transform);
            /** Matrix that transforms a point from world space into local space (Read Only).
            */
            public get worldToLocalMatrix(): UnityEngine.Matrix4x4;
            /** Matrix that transforms a point from local space into world space (Read Only).
            */
            public get localToWorldMatrix(): UnityEngine.Matrix4x4;
            /** Returns the topmost transform in the hierarchy.
            */
            public get root(): UnityEngine.Transform;
            /** The number of children the parent Transform has.
            */
            public get childCount(): number;
            /** The global scale of the object (Read Only).
            */
            public get lossyScale(): UnityEngine.Vector3;
            /** Has the transform changed since the last time the flag was set to 'false'?
            */
            public get hasChanged(): boolean;
            public set hasChanged(value: boolean);
            /** The transform capacity of the transform's hierarchy data structure.
            */
            public get hierarchyCapacity(): number;
            public set hierarchyCapacity(value: number);
            /** The number of transforms in the transform's hierarchy data structure.
            */
            public get hierarchyCount(): number;
            /** Set the parent of the transform.
            * @param $parent The parent Transform to use.
            * @param $worldPositionStays If true, the parent-relative position, scale and rotation are modified such that the object keeps the same world space position, rotation and scale as before.
            */
            public SetParent ($p: UnityEngine.Transform) : void
            /** Set the parent of the transform.
            * @param $parent The parent Transform to use.
            * @param $worldPositionStays If true, the parent-relative position, scale and rotation are modified such that the object keeps the same world space position, rotation and scale as before.
            */
            public SetParent ($parent: UnityEngine.Transform, $worldPositionStays: boolean) : void
            /** Sets the world space position and rotation of the Transform component.
            */
            public SetPositionAndRotation ($position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion) : void
            /** Sets the position and rotation of the Transform component in local space (i.e. relative to its parent transform).
            */
            public SetLocalPositionAndRotation ($localPosition: UnityEngine.Vector3, $localRotation: UnityEngine.Quaternion) : void
            /** Gets the position and rotation of the Transform component in world space.
            */
            public GetPositionAndRotation ($position: $Ref<UnityEngine.Vector3>, $rotation: $Ref<UnityEngine.Quaternion>) : void
            /** Gets the position and rotation of the Transform component in local space (that is, relative to its parent transform).
            */
            public GetLocalPositionAndRotation ($localPosition: $Ref<UnityEngine.Vector3>, $localRotation: $Ref<UnityEngine.Quaternion>) : void
            /** Moves the transform in the direction and distance of translation.
            */
            public Translate ($translation: UnityEngine.Vector3, $relativeTo: UnityEngine.Space) : void
            /** Moves the transform in the direction and distance of translation.
            */
            public Translate ($translation: UnityEngine.Vector3) : void
            /** Moves the transform by x along the x axis, y along the y axis, and z along the z axis.
            */
            public Translate ($x: number, $y: number, $z: number, $relativeTo: UnityEngine.Space) : void
            /** Moves the transform by x along the x axis, y along the y axis, and z along the z axis.
            */
            public Translate ($x: number, $y: number, $z: number) : void
            /** Moves the transform in the direction and distance of translation.
            */
            public Translate ($translation: UnityEngine.Vector3, $relativeTo: UnityEngine.Transform) : void
            /** Moves the transform by x along the x axis, y along the y axis, and z along the z axis.
            */
            public Translate ($x: number, $y: number, $z: number, $relativeTo: UnityEngine.Transform) : void
            /** Applies a rotation of eulerAngles.z degrees around the z-axis, eulerAngles.x degrees around the x-axis, and eulerAngles.y degrees around the y-axis (in that order).
            * @param $eulers The rotation to apply in euler angles.
            * @param $relativeTo Determines whether to rotate the GameObject either locally to  the GameObject or relative to the Scene in world space.
            */
            public Rotate ($eulers: UnityEngine.Vector3, $relativeTo: UnityEngine.Space) : void
            /** Applies a rotation of eulerAngles.z degrees around the z-axis, eulerAngles.x degrees around the x-axis, and eulerAngles.y degrees around the y-axis (in that order).
            * @param $eulers The rotation to apply in euler angles.
            */
            public Rotate ($eulers: UnityEngine.Vector3) : void
            /** The implementation of this method applies a rotation of zAngle degrees around the z axis, xAngle degrees around the x axis, and yAngle degrees around the y axis (in that order).
            * @param $xAngle Degrees to rotate the GameObject around the X axis.
            * @param $yAngle Degrees to rotate the GameObject around the Y axis.
            * @param $zAngle Degrees to rotate the GameObject around the Z axis.
            * @param $relativeTo Determines whether to rotate the GameObject either locally to the GameObject or relative to the Scene in world space.
            */
            public Rotate ($xAngle: number, $yAngle: number, $zAngle: number, $relativeTo: UnityEngine.Space) : void
            /** The implementation of this method applies a rotation of zAngle degrees around the z axis, xAngle degrees around the x axis, and yAngle degrees around the y axis (in that order).
            * @param $xAngle Degrees to rotate the GameObject around the X axis.
            * @param $yAngle Degrees to rotate the GameObject around the Y axis.
            * @param $zAngle Degrees to rotate the GameObject around the Z axis.
            */
            public Rotate ($xAngle: number, $yAngle: number, $zAngle: number) : void
            /** Rotates the object around the given axis by the number of degrees defined by the given angle.
            * @param $axis The axis to apply rotation to.
            * @param $angle The degrees of rotation to apply.
            * @param $relativeTo Determines whether to rotate the GameObject either locally to the GameObject or relative to the Scene in world space.
            */
            public Rotate ($axis: UnityEngine.Vector3, $angle: number, $relativeTo: UnityEngine.Space) : void
            /** Rotates the object around the given axis by the number of degrees defined by the given angle.
            * @param $axis The axis to apply rotation to.
            * @param $angle The degrees of rotation to apply.
            */
            public Rotate ($axis: UnityEngine.Vector3, $angle: number) : void
            /** Rotates the transform about axis passing through point in world coordinates by angle degrees.
            */
            public RotateAround ($point: UnityEngine.Vector3, $axis: UnityEngine.Vector3, $angle: number) : void
            /** Rotates the transform so the forward vector points at target's current position.
            * @param $target Object to point towards.
            * @param $worldUp Vector specifying the upward direction.
            */
            public LookAt ($target: UnityEngine.Transform, $worldUp: UnityEngine.Vector3) : void
            /** Rotates the transform so the forward vector points at target's current position.
            * @param $target Object to point towards.
            * @param $worldUp Vector specifying the upward direction.
            */
            public LookAt ($target: UnityEngine.Transform) : void
            /** Rotates the transform so the forward vector points at worldPosition.
            * @param $worldPosition Point to look at.
            * @param $worldUp Vector specifying the upward direction.
            */
            public LookAt ($worldPosition: UnityEngine.Vector3, $worldUp: UnityEngine.Vector3) : void
            /** Rotates the transform so the forward vector points at worldPosition.
            * @param $worldPosition Point to look at.
            * @param $worldUp Vector specifying the upward direction.
            */
            public LookAt ($worldPosition: UnityEngine.Vector3) : void
            /** Transforms direction from local space to world space.
            */
            public TransformDirection ($direction: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Transforms direction x, y, z from local space to world space.
            */
            public TransformDirection ($x: number, $y: number, $z: number) : UnityEngine.Vector3
            /** Transforms a direction from world space to local space. The opposite of Transform.TransformDirection.
            */
            public InverseTransformDirection ($direction: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Transforms the direction x, y, z from world space to local space. The opposite of Transform.TransformDirection.
            */
            public InverseTransformDirection ($x: number, $y: number, $z: number) : UnityEngine.Vector3
            /** Transforms vector from local space to world space.
            */
            public TransformVector ($vector: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Transforms vector x, y, z from local space to world space.
            */
            public TransformVector ($x: number, $y: number, $z: number) : UnityEngine.Vector3
            /** Transforms a vector from world space to local space. The opposite of Transform.TransformVector.
            */
            public InverseTransformVector ($vector: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Transforms the vector x, y, z from world space to local space. The opposite of Transform.TransformVector.
            */
            public InverseTransformVector ($x: number, $y: number, $z: number) : UnityEngine.Vector3
            /** Transforms position from local space to world space.
            */
            public TransformPoint ($position: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Transforms the position x, y, z from local space to world space.
            */
            public TransformPoint ($x: number, $y: number, $z: number) : UnityEngine.Vector3
            /** Transforms position from world space to local space.
            */
            public InverseTransformPoint ($position: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Transforms the position x, y, z from world space to local space.
            */
            public InverseTransformPoint ($x: number, $y: number, $z: number) : UnityEngine.Vector3
            /** Unparents all children.
            */
            public DetachChildren () : void
            /** Move the transform to the start of the local transform list.
            */
            public SetAsFirstSibling () : void
            /** Move the transform to the end of the local transform list.
            */
            public SetAsLastSibling () : void
            /** Sets the sibling index.
            * @param $index Index to set.
            */
            public SetSiblingIndex ($index: number) : void
            /** Gets the sibling index.
            */
            public GetSiblingIndex () : number
            /** Finds a child by name n and returns it.
            * @param $n The search string, either the name of an immediate child or a hierarchy path for finding a descendent.
            * @returns The found child transform. Null if child with matching name isn't found. 
            */
            public Find ($n: string) : UnityEngine.Transform
            /** Is this transform a child of parent?
            */
            public IsChildOf ($parent: UnityEngine.Transform) : boolean
            public GetEnumerator () : System.Collections.IEnumerator
            /** Returns a transform child by index.
            * @param $index Index of the child transform to return. Must be smaller than Transform.childCount.
            * @returns Transform child by index. 
            */
            public GetChild ($index: number) : UnityEngine.Transform
        }
        /** FlareLayer component.
        */
        class FlareLayer extends UnityEngine.Behaviour
        {
            protected [__keep_incompatibility]: never;
        }
        /** The reflection probe is used to capture the surroundings into a texture which is passed to the shaders and used for reflections.
        */
        class ReflectionProbe extends UnityEngine.Behaviour
        {
            protected [__keep_incompatibility]: never;
            /** The size of the probe's bounding box in which the probe can contribute to reflections. The size is in world space.
            */
            public get size(): UnityEngine.Vector3;
            public set size(value: UnityEngine.Vector3);
            /** The center of the probe's bounding box in which the probe can contribute to reflections. The center is relative to the position of the probe.
            */
            public get center(): UnityEngine.Vector3;
            public set center(value: UnityEngine.Vector3);
            /** The near clipping plane distance when rendering the probe.
            */
            public get nearClipPlane(): number;
            public set nearClipPlane(value: number);
            /** The far clipping plane distance when rendering the probe.
            */
            public get farClipPlane(): number;
            public set farClipPlane(value: number);
            /** The intensity modifier that is applied to the texture of reflection probe in the shader.
            */
            public get intensity(): number;
            public set intensity(value: number);
            /** The probe's world space axis-aligned bounding box in which the probe can contribute to reflections (Read Only).
            */
            public get bounds(): UnityEngine.Bounds;
            /** Should this reflection probe use HDR rendering?
            */
            public get hdr(): boolean;
            public set hdr(value: boolean);
            /** Specifies whether Unity should render non-static GameObjects into the Reflection Probe. If you set this to true, Unity renders non-static GameObjects into the Reflection Probe. If you set this to false, Unity does not render non-static GameObjects into the Reflection Probe. Unity only takes this property into account if the Reflection Probe's Type is Custom.
            */
            public get renderDynamicObjects(): boolean;
            public set renderDynamicObjects(value: boolean);
            /** Shadow drawing distance when rendering the probe.
            */
            public get shadowDistance(): number;
            public set shadowDistance(value: number);
            /** Resolution of the underlying reflection texture in pixels.
            */
            public get resolution(): number;
            public set resolution(value: number);
            /** This is used to render parts of the reflecion probe's surrounding selectively.
            */
            public get cullingMask(): number;
            public set cullingMask(value: number);
            /** How the reflection probe clears the background.
            */
            public get clearFlags(): UnityEngine.Rendering.ReflectionProbeClearFlags;
            public set clearFlags(value: UnityEngine.Rendering.ReflectionProbeClearFlags);
            /** The color with which the texture of reflection probe will be cleared.
            */
            public get backgroundColor(): UnityEngine.Color;
            public set backgroundColor(value: UnityEngine.Color);
            /** Distance around probe used for blending (used in deferred probes).
            */
            public get blendDistance(): number;
            public set blendDistance(value: number);
            /** Should this reflection probe use box projection?
            */
            public get boxProjection(): boolean;
            public set boxProjection(value: boolean);
            /** Should reflection probe texture be generated in the Editor (ReflectionProbeMode.Baked) or should probe use custom specified texure (ReflectionProbeMode.Custom)?
            */
            public get mode(): UnityEngine.Rendering.ReflectionProbeMode;
            public set mode(value: UnityEngine.Rendering.ReflectionProbeMode);
            /** Reflection probe importance.
            */
            public get importance(): number;
            public set importance(value: number);
            /** Sets the way the probe will refresh.
            Additional resources: ReflectionProbeRefreshMode.
            */
            public get refreshMode(): UnityEngine.Rendering.ReflectionProbeRefreshMode;
            public set refreshMode(value: UnityEngine.Rendering.ReflectionProbeRefreshMode);
            /** Sets this probe time-slicing mode
            Additional resources: ReflectionProbeTimeSlicingMode.
            */
            public get timeSlicingMode(): UnityEngine.Rendering.ReflectionProbeTimeSlicingMode;
            public set timeSlicingMode(value: UnityEngine.Rendering.ReflectionProbeTimeSlicingMode);
            /** Reference to the baked texture of the reflection probe's surrounding.
            */
            public get bakedTexture(): UnityEngine.Texture;
            public set bakedTexture(value: UnityEngine.Texture);
            /** Reference to the baked texture of the reflection probe's surrounding. Use this to assign custom reflection texture.
            */
            public get customBakedTexture(): UnityEngine.Texture;
            public set customBakedTexture(value: UnityEngine.Texture);
            /** Reference to the real-time texture of the reflection probe's surroundings. Use this to assign a RenderTexture to use for real-time reflection.
            */
            public get realtimeTexture(): UnityEngine.RenderTexture;
            public set realtimeTexture(value: UnityEngine.RenderTexture);
            /** Texture which is passed to the shader of the objects in the vicinity of the reflection probe (Read Only).
            */
            public get texture(): UnityEngine.Texture;
            /** HDR decode values of the reflection probe texture.
            */
            public get textureHDRDecodeValues(): UnityEngine.Vector4;
            public static get minBakedCubemapResolution(): number;
            public static get maxBakedCubemapResolution(): number;
            /** HDR decode values of the default reflection probe texture.
            */
            public static get defaultTextureHDRDecodeValues(): UnityEngine.Vector4;
            /** The surface texture of the default reflection probe that captures the environment contribution. Read only.
            */
            public static get defaultTexture(): UnityEngine.Texture;
            /** Revert all ReflectionProbe parameters to default.
            */
            public Reset () : void
            public RenderProbe () : number
            /** Refreshes the probe's cubemap.
            * @param $targetTexture Target RenderTexture in which rendering should be done. Specifying null will update the probe's default texture.
            * @returns 
            An integer representing a RenderID which can subsequently be used to check if the probe has finished rendering while rendering in time-slice mode.
            Additional resources: IsFinishedRendering
            Additional resources: timeSlicingMode
            */
            public RenderProbe ($targetTexture: UnityEngine.RenderTexture) : number
            /** Checks if a probe has finished a time-sliced render.
            * @param $renderId An integer representing the RenderID as returned by the RenderProbe method.
            * @returns 
            True if the render has finished, false otherwise.
            Additional resources: timeSlicingMode
            */
            public IsFinishedRendering ($renderId: number) : boolean
            /** Utility method to blend 2 cubemaps into a target render texture.
            * @param $src Cubemap to blend from.
            * @param $dst Cubemap to blend to.
            * @param $blend Blend weight.
            * @param $target RenderTexture which will hold the result of the blend.
            * @returns Returns trues if cubemaps were blended, false otherwise. 
            */
            public static BlendCubemap ($src: UnityEngine.Texture, $dst: UnityEngine.Texture, $blend: number, $target: UnityEngine.RenderTexture) : boolean
            /** Updates the culling system with the ReflectionProbe's current state. This ensures that Unity correctly culls the ReflectionProbe during rendering if you implement your own runtime reflection system.
            */
            public static UpdateCachedState () : void
            public static add_reflectionProbeChanged ($value: System.Action$2<UnityEngine.ReflectionProbe, UnityEngine.ReflectionProbe.ReflectionProbeEvent>) : void
            public static remove_reflectionProbeChanged ($value: System.Action$2<UnityEngine.ReflectionProbe, UnityEngine.ReflectionProbe.ReflectionProbeEvent>) : void
            public static add_defaultReflectionSet ($value: System.Action$1<UnityEngine.Cubemap>) : void
            public static remove_defaultReflectionSet ($value: System.Action$1<UnityEngine.Cubemap>) : void
            public static add_defaultReflectionTexture ($value: System.Action$1<UnityEngine.Texture>) : void
            public static remove_defaultReflectionTexture ($value: System.Action$1<UnityEngine.Texture>) : void
            public constructor ()
        }
        /** Represents an axis aligned bounding box.
        */
        class Bounds extends System.ValueType implements System.IFormattable, System.IEquatable$1<UnityEngine.Bounds>
        {
            protected [__keep_incompatibility]: never;
            /** The center of the bounding box.
            */
            public get center(): UnityEngine.Vector3;
            public set center(value: UnityEngine.Vector3);
            /** The total size of the box. This is always twice as large as the extents.
            */
            public get size(): UnityEngine.Vector3;
            public set size(value: UnityEngine.Vector3);
            /** The extents of the Bounding Box. This is always half of the size of the Bounds.
            */
            public get extents(): UnityEngine.Vector3;
            public set extents(value: UnityEngine.Vector3);
            /** The minimal point of the box. This is always equal to center-extents.
            */
            public get min(): UnityEngine.Vector3;
            public set min(value: UnityEngine.Vector3);
            /** The maximal point of the box. This is always equal to center+extents.
            */
            public get max(): UnityEngine.Vector3;
            public set max(value: UnityEngine.Vector3);
            public Equals ($other: any) : boolean
            public Equals ($other: UnityEngine.Bounds) : boolean
            public static op_Equality ($lhs: UnityEngine.Bounds, $rhs: UnityEngine.Bounds) : boolean
            public static op_Inequality ($lhs: UnityEngine.Bounds, $rhs: UnityEngine.Bounds) : boolean
            /** Sets the bounds to the min and max value of the box.
            */
            public SetMinMax ($min: UnityEngine.Vector3, $max: UnityEngine.Vector3) : void
            /** Grows the Bounds to include the point.
            */
            public Encapsulate ($point: UnityEngine.Vector3) : void
            /** Grow the bounds to encapsulate the bounds.
            */
            public Encapsulate ($bounds: UnityEngine.Bounds) : void
            /** Expand the bounds by increasing its size by amount along each side.
            */
            public Expand ($amount: number) : void
            /** Expand the bounds by increasing its size by amount along each side.
            */
            public Expand ($amount: UnityEngine.Vector3) : void
            /** Does another bounding box intersect with this bounding box?
            */
            public Intersects ($bounds: UnityEngine.Bounds) : boolean
            /** Does ray intersect this bounding box?
            */
            public IntersectRay ($ray: UnityEngine.Ray) : boolean
            /** Does ray intersect this bounding box?
            */
            public IntersectRay ($ray: UnityEngine.Ray, $distance: $Ref<number>) : boolean
            /** Returns a formatted string for the bounds.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString () : string
            /** Returns a formatted string for the bounds.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string) : string
            /** Returns a formatted string for the bounds.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            /** Is point contained in the bounding box?
            */
            public Contains ($point: UnityEngine.Vector3) : boolean
            /** The smallest squared distance between the point and this bounding box.
            */
            public SqrDistance ($point: UnityEngine.Vector3) : number
            /** The closest point on the bounding box.
            * @param $point Arbitrary point.
            * @returns The point on the bounding box or inside the bounding box. 
            */
            public ClosestPoint ($point: UnityEngine.Vector3) : UnityEngine.Vector3
            public constructor ($center: UnityEngine.Vector3, $size: UnityEngine.Vector3)
        }
        /** Holds data for a single application crash event and provides access to all gathered crash reports.
        */
        class CrashReport extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Time, when the crash occured.
            */
            public time : System.DateTime
            /** Crash report data as formatted text.
            */
            public text : string
            /** Returns all currently available reports in a new array.
            */
            public static get reports(): System.Array$1<UnityEngine.CrashReport>;
            /** Returns last crash report, or null if no reports are available.
            */
            public static get lastReport(): UnityEngine.CrashReport;
            /** Remove all reports from available reports list.
            */
            public static RemoveAll () : void
            /** Remove report from available reports list.
            */
            public Remove () : void
        }
        /** Class containing methods to ease debugging while developing a game.
        */
        class Debug extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Get default debug logger.
            */
            public static get unityLogger(): UnityEngine.ILogger;
            /** Allows you to enable or disable the developer console.
            */
            public static get developerConsoleEnabled(): boolean;
            public static set developerConsoleEnabled(value: boolean);
            /** Controls whether the development console is visible.
            */
            public static get developerConsoleVisible(): boolean;
            public static set developerConsoleVisible(value: boolean);
            /** In the Build Settings dialog there is a check box called "Development Build".
            */
            public static get isDebugBuild(): boolean;
            /** Draws a line between specified start and end points.
            * @param $start Point in world space where the line should start.
            * @param $end Point in world space where the line should end.
            * @param $color Color of the line.
            * @param $duration How long the line should be visible for.
            * @param $depthTest Determines whether objects closer to the camera obscure the line.
            */
            public static DrawLine ($start: UnityEngine.Vector3, $end: UnityEngine.Vector3, $color: UnityEngine.Color, $duration: number) : void
            /** Draws a line between specified start and end points.
            * @param $start Point in world space where the line should start.
            * @param $end Point in world space where the line should end.
            * @param $color Color of the line.
            * @param $duration How long the line should be visible for.
            * @param $depthTest Determines whether objects closer to the camera obscure the line.
            */
            public static DrawLine ($start: UnityEngine.Vector3, $end: UnityEngine.Vector3, $color: UnityEngine.Color) : void
            /** Draws a line between specified start and end points.
            * @param $start Point in world space where the line should start.
            * @param $end Point in world space where the line should end.
            * @param $color Color of the line.
            * @param $duration How long the line should be visible for.
            * @param $depthTest Determines whether objects closer to the camera obscure the line.
            */
            public static DrawLine ($start: UnityEngine.Vector3, $end: UnityEngine.Vector3) : void
            /** Draws a line between specified start and end points.
            * @param $start Point in world space where the line should start.
            * @param $end Point in world space where the line should end.
            * @param $color Color of the line.
            * @param $duration How long the line should be visible for.
            * @param $depthTest Determines whether objects closer to the camera obscure the line.
            */
            public static DrawLine ($start: UnityEngine.Vector3, $end: UnityEngine.Vector3, $color: UnityEngine.Color, $duration: number, $depthTest: boolean) : void
            /** Draws a line from start to start + dir in world coordinates.
            * @param $start Point in world space where the ray should start.
            * @param $dir Direction and length of the ray.
            * @param $color Color of the drawn line.
            * @param $duration How long the line will be visible for (in seconds).
            * @param $depthTest Determines whether objects closer to the camera obscure the line.
            */
            public static DrawRay ($start: UnityEngine.Vector3, $dir: UnityEngine.Vector3, $color: UnityEngine.Color, $duration: number) : void
            /** Draws a line from start to start + dir in world coordinates.
            * @param $start Point in world space where the ray should start.
            * @param $dir Direction and length of the ray.
            * @param $color Color of the drawn line.
            * @param $duration How long the line will be visible for (in seconds).
            * @param $depthTest Determines whether objects closer to the camera obscure the line.
            */
            public static DrawRay ($start: UnityEngine.Vector3, $dir: UnityEngine.Vector3, $color: UnityEngine.Color) : void
            /** Draws a line from start to start + dir in world coordinates.
            * @param $start Point in world space where the ray should start.
            * @param $dir Direction and length of the ray.
            * @param $color Color of the drawn line.
            * @param $duration How long the line will be visible for (in seconds).
            * @param $depthTest Determines whether objects closer to the camera obscure the line.
            */
            public static DrawRay ($start: UnityEngine.Vector3, $dir: UnityEngine.Vector3) : void
            /** Draws a line from start to start + dir in world coordinates.
            * @param $start Point in world space where the ray should start.
            * @param $dir Direction and length of the ray.
            * @param $color Color of the drawn line.
            * @param $duration How long the line will be visible for (in seconds).
            * @param $depthTest Determines whether objects closer to the camera obscure the line.
            */
            public static DrawRay ($start: UnityEngine.Vector3, $dir: UnityEngine.Vector3, $color: UnityEngine.Color, $duration: number, $depthTest: boolean) : void
            /** Pauses the editor.
            */
            public static Break () : void
            public static DebugBreak () : void
            /** Logs a message to the Unity Console.
            * @param $message String or object to be converted to string representation for display.
            * @param $context Object to which the message applies.
            */
            public static Log ($message: any) : void
            /** Logs a message to the Unity Console.
            * @param $message String or object to be converted to string representation for display.
            * @param $context Object to which the message applies.
            */
            public static Log ($message: any, $context: UnityEngine.Object) : void
            /** Logs a formatted message to the Unity Console.
            * @param $format A composite format string.
            * @param $args Format arguments.
            * @param $context Object to which the message applies.
            * @param $logType Type of message e.g. warn or error etc.
            * @param $logOptions Option flags to treat the log message special.
            */
            public static LogFormat ($format: string, ...args: any[]) : void
            /** Logs a formatted message to the Unity Console.
            * @param $format A composite format string.
            * @param $args Format arguments.
            * @param $context Object to which the message applies.
            * @param $logType Type of message e.g. warn or error etc.
            * @param $logOptions Option flags to treat the log message special.
            */
            public static LogFormat ($context: UnityEngine.Object, $format: string, ...args: any[]) : void
            /** Logs a formatted message to the Unity Console.
            * @param $format A composite format string.
            * @param $args Format arguments.
            * @param $context Object to which the message applies.
            * @param $logType Type of message e.g. warn or error etc.
            * @param $logOptions Option flags to treat the log message special.
            */
            public static LogFormat ($logType: UnityEngine.LogType, $logOptions: UnityEngine.LogOption, $context: UnityEngine.Object, $format: string, ...args: any[]) : void
            /** A variant of Debug.Log that logs an error message to the console.
            * @param $message String or object to be converted to string representation for display.
            * @param $context Object to which the message applies.
            */
            public static LogError ($message: any) : void
            /** A variant of Debug.Log that logs an error message to the console.
            * @param $message String or object to be converted to string representation for display.
            * @param $context Object to which the message applies.
            */
            public static LogError ($message: any, $context: UnityEngine.Object) : void
            /** Logs a formatted error message to the Unity console.
            * @param $format A composite format string.
            * @param $args Format arguments.
            * @param $context Object to which the message applies.
            */
            public static LogErrorFormat ($format: string, ...args: any[]) : void
            /** Logs a formatted error message to the Unity console.
            * @param $format A composite format string.
            * @param $args Format arguments.
            * @param $context Object to which the message applies.
            */
            public static LogErrorFormat ($context: UnityEngine.Object, $format: string, ...args: any[]) : void
            /** Clears errors from the developer console.
            */
            public static ClearDeveloperConsole () : void
            /** A variant of Debug.Log that logs an error message to the console.
            * @param $context Object to which the message applies.
            * @param $exception Runtime Exception.
            */
            public static LogException ($exception: System.Exception) : void
            /** A variant of Debug.Log that logs an error message to the console.
            * @param $context Object to which the message applies.
            * @param $exception Runtime Exception.
            */
            public static LogException ($exception: System.Exception, $context: UnityEngine.Object) : void
            /** A variant of Debug.Log that logs a warning message to the console.
            * @param $message String or object to be converted to string representation for display.
            * @param $context Object to which the message applies.
            */
            public static LogWarning ($message: any) : void
            /** A variant of Debug.Log that logs a warning message to the console.
            * @param $message String or object to be converted to string representation for display.
            * @param $context Object to which the message applies.
            */
            public static LogWarning ($message: any, $context: UnityEngine.Object) : void
            /** Logs a formatted warning message to the Unity Console.
            * @param $format A composite format string.
            * @param $args Format arguments.
            * @param $context Object to which the message applies.
            */
            public static LogWarningFormat ($format: string, ...args: any[]) : void
            /** Logs a formatted warning message to the Unity Console.
            * @param $format A composite format string.
            * @param $args Format arguments.
            * @param $context Object to which the message applies.
            */
            public static LogWarningFormat ($context: UnityEngine.Object, $format: string, ...args: any[]) : void
            /** Assert a condition and logs an error message to the Unity console on failure.
            * @param $condition Condition you expect to be true.
            * @param $context Object to which the message applies.
            * @param $message String or object to be converted to string representation for display.
            */
            public static Assert ($condition: boolean) : void
            /** Assert a condition and logs an error message to the Unity console on failure.
            * @param $condition Condition you expect to be true.
            * @param $context Object to which the message applies.
            * @param $message String or object to be converted to string representation for display.
            */
            public static Assert ($condition: boolean, $context: UnityEngine.Object) : void
            /** Assert a condition and logs an error message to the Unity console on failure.
            * @param $condition Condition you expect to be true.
            * @param $context Object to which the message applies.
            * @param $message String or object to be converted to string representation for display.
            */
            public static Assert ($condition: boolean, $message: any) : void
            public static Assert ($condition: boolean, $message: string) : void
            /** Assert a condition and logs an error message to the Unity console on failure.
            * @param $condition Condition you expect to be true.
            * @param $context Object to which the message applies.
            * @param $message String or object to be converted to string representation for display.
            */
            public static Assert ($condition: boolean, $message: any, $context: UnityEngine.Object) : void
            public static Assert ($condition: boolean, $message: string, $context: UnityEngine.Object) : void
            /** Assert a condition and logs a formatted error message to the Unity console on failure.
            * @param $condition Condition you expect to be true.
            * @param $format A composite format string.
            * @param $args Format arguments.
            * @param $context Object to which the message applies.
            */
            public static AssertFormat ($condition: boolean, $format: string, ...args: any[]) : void
            /** Assert a condition and logs a formatted error message to the Unity console on failure.
            * @param $condition Condition you expect to be true.
            * @param $format A composite format string.
            * @param $args Format arguments.
            * @param $context Object to which the message applies.
            */
            public static AssertFormat ($condition: boolean, $context: UnityEngine.Object, $format: string, ...args: any[]) : void
            /** A variant of Debug.Log that logs an assertion message to the console.
            * @param $message String or object to be converted to string representation for display.
            * @param $context Object to which the message applies.
            */
            public static LogAssertion ($message: any) : void
            /** A variant of Debug.Log that logs an assertion message to the console.
            * @param $message String or object to be converted to string representation for display.
            * @param $context Object to which the message applies.
            */
            public static LogAssertion ($message: any, $context: UnityEngine.Object) : void
            /** Logs a formatted assertion message to the Unity console.
            * @param $format A composite format string.
            * @param $args Format arguments.
            * @param $context Object to which the message applies.
            */
            public static LogAssertionFormat ($format: string, ...args: any[]) : void
            /** Logs a formatted assertion message to the Unity console.
            * @param $format A composite format string.
            * @param $args Format arguments.
            * @param $context Object to which the message applies.
            */
            public static LogAssertionFormat ($context: UnityEngine.Object, $format: string, ...args: any[]) : void
            /** Returns any captured startup logs
            */
            public static RetrieveStartupLogs () : System.Array$1<UnityEngine.Debug.StartupLog>
            public constructor ()
        }
        interface ILogger extends UnityEngine.ILogHandler
        {
            /** Set Logger.ILogHandler.
            */
            logHandler : UnityEngine.ILogHandler
            /** To runtime toggle debug logging [ON/OFF].
            */
            logEnabled : boolean
            /** To selective enable debug log message.
            */
            filterLogType : UnityEngine.LogType
            /** Check logging is enabled based on the LogType.
            * @returns Retrun true in case logs of LogType will be logged otherwise returns false. 
            */
            IsLogTypeAllowed ($logType: UnityEngine.LogType) : boolean
            /** Logs message to the Unity Console using default logger.
            */
            Log ($logType: UnityEngine.LogType, $message: any) : void
            /** Logs message to the Unity Console using default logger.
            */
            Log ($logType: UnityEngine.LogType, $message: any, $context: UnityEngine.Object) : void
            /** Logs message to the Unity Console using default logger.
            */
            Log ($logType: UnityEngine.LogType, $tag: string, $message: any) : void
            /** Logs message to the Unity Console using default logger.
            */
            Log ($logType: UnityEngine.LogType, $tag: string, $message: any, $context: UnityEngine.Object) : void
            /** Logs message to the Unity Console using default logger.
            */
            Log ($message: any) : void
            /** Logs message to the Unity Console using default logger.
            */
            Log ($tag: string, $message: any) : void
            /** Logs message to the Unity Console using default logger.
            */
            Log ($tag: string, $message: any, $context: UnityEngine.Object) : void
            /** A variant of Logger.Log that logs an warning message.
            */
            LogWarning ($tag: string, $message: any) : void
            /** A variant of Logger.Log that logs an warning message.
            */
            LogWarning ($tag: string, $message: any, $context: UnityEngine.Object) : void
            /** A variant of ILogger.Log that logs an error message.
            */
            LogError ($tag: string, $message: any) : void
            /** A variant of ILogger.Log that logs an error message.
            */
            LogError ($tag: string, $message: any, $context: UnityEngine.Object) : void
            /** Logs a formatted message.
            */
            LogFormat ($logType: UnityEngine.LogType, $format: string, ...args: any[]) : void
            /** A variant of ILogger.Log that logs an exception message.
            */
            LogException ($exception: System.Exception) : void
            /** Logs a formatted message.
            * @param $logType The type of the log message.
            * @param $context Object to which the message applies.
            * @param $format A composite format string.
            * @param $args Format arguments.
            */
            LogFormat ($logType: UnityEngine.LogType, $context: UnityEngine.Object, $format: string, ...args: any[]) : void
            /** A variant of ILogHandler.LogFormat that logs an exception message.
            * @param $exception Runtime Exception.
            * @param $context Object to which the message applies.
            */
            LogException ($exception: System.Exception, $context: UnityEngine.Object) : void
        }
        interface ILogHandler
        {
            /** Logs a formatted message.
            * @param $logType The type of the log message.
            * @param $context Object to which the message applies.
            * @param $format A composite format string.
            * @param $args Format arguments.
            */
            LogFormat ($logType: UnityEngine.LogType, $context: UnityEngine.Object, $format: string, ...args: any[]) : void
            /** A variant of ILogHandler.LogFormat that logs an exception message.
            * @param $exception Runtime Exception.
            * @param $context Object to which the message applies.
            */
            LogException ($exception: System.Exception, $context: UnityEngine.Object) : void
        }
        /** Object that is used to resolve references to an ExposedReference field.
        */
        class ExposedPropertyResolver extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class ExposedReference$1<T> extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public exposedName : UnityEngine.PropertyName
            public defaultValue : UnityEngine.Object
            public Resolve ($resolver: UnityEngine.IExposedPropertyTable) : T
        }
        /** Represents a string as an int for efficient lookup and comparison. Use this for common PropertyNames.
        Internally stores just an int to represent the string. A PropertyName can be created from a string but can not be converted back to a string. The same string always results in the same int representing that string. Thus this is a very efficient string representation in both memory and speed when all you need is comparison.
        PropertyName is serializable.
        ToString() is only implemented for debugging purposes in the editor it returns "theName:3737" in the player it returns "Unknown:3737".
        */
        class PropertyName extends System.ValueType implements System.IEquatable$1<UnityEngine.PropertyName>
        {
            protected [__keep_incompatibility]: never;
            /** Indicates whether the specified PropertyName is an Empty string.
            */
            public static IsNullOrEmpty ($prop: UnityEngine.PropertyName) : boolean
            public static op_Equality ($lhs: UnityEngine.PropertyName, $rhs: UnityEngine.PropertyName) : boolean
            public static op_Inequality ($lhs: UnityEngine.PropertyName, $rhs: UnityEngine.PropertyName) : boolean
            /** Determines whether this instance and a specified object, which must also be a PropertyName object, have the same value.
            */
            public Equals ($other: any) : boolean
            public Equals ($other: UnityEngine.PropertyName) : boolean
            public static op_Implicit ($name: string) : UnityEngine.PropertyName
            public static op_Implicit ($id: number) : UnityEngine.PropertyName
            public constructor ($name: string)
            public constructor ($other: UnityEngine.PropertyName)
            public constructor ($id: number)
        }
        interface IExposedPropertyTable
        {
            /** Assigns a value for an ExposedReference.
            * @param $id Identifier of the ExposedReference.
            * @param $value The value to assigned to the ExposedReference.
            */
            SetReferenceValue ($id: UnityEngine.PropertyName, $value: UnityEngine.Object) : void
            /** Retrieves a value for the given identifier.
            * @param $id Identifier of the ExposedReference.
            * @param $idValid Is the identifier valid?
            * @returns The value stored in the table. 
            */
            GetReferenceValue ($id: UnityEngine.PropertyName, $idValid: $Ref<boolean>) : UnityEngine.Object
            /** Remove a value for the given reference.
            * @param $id Identifier of the ExposedReference.
            */
            ClearReferenceValue ($id: UnityEngine.PropertyName) : void
        }
        class EventProvider extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static WriteCustomEvent ($value: number, $text: string) : void
            public constructor ()
        }
        /** Evaluates simple math expressions; supports int  float and operators: + - *  % ^ ( ).
        */
        class ExpressionEvaluator extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Compression Levels relate to how much time should be spent compressing Assets into an Asset Bundle.
        */
        enum CompressionLevel
        { None = 0, Fastest = 1, Fast = 2, Normal = 3, High = 4, Maximum = 5 }
        /** Contains information about compression methods, compression levels and block sizes that are supported by Asset Bundle compression at build time and recompression at runtime.
        */
        class BuildCompression extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Uncompressed Asset Bundle.
            */
            public static Uncompressed : UnityEngine.BuildCompression
            /** LZ4HC "Chunk Based" Compression.
            */
            public static LZ4 : UnityEngine.BuildCompression
            /** LZMA Compression.
            */
            public static LZMA : UnityEngine.BuildCompression
            /** Uncompressed Asset Bundle.
            */
            public static UncompressedRuntime : UnityEngine.BuildCompression
            /** LZ4 Compression for runtime recompression.
            */
            public static LZ4Runtime : UnityEngine.BuildCompression
            public get compression(): UnityEngine.CompressionType;
            public get level(): UnityEngine.CompressionLevel;
            public get blockSize(): number;
        }
        /** Represents an axis aligned bounding box with all values as integers.
        */
        class BoundsInt extends System.ValueType implements System.IFormattable, System.IEquatable$1<UnityEngine.BoundsInt>
        {
            protected [__keep_incompatibility]: never;
            /** X value of the minimal point of the box.
            */
            public get x(): number;
            public set x(value: number);
            /** Y value of the minimal point of the box.
            */
            public get y(): number;
            public set y(value: number);
            /** Z value of the minimal point of the box.
            */
            public get z(): number;
            public set z(value: number);
            /** The center of the bounding box.
            */
            public get center(): UnityEngine.Vector3;
            /** The minimal point of the box.
            */
            public get min(): UnityEngine.Vector3Int;
            public set min(value: UnityEngine.Vector3Int);
            /** The maximal point of the box.
            */
            public get max(): UnityEngine.Vector3Int;
            public set max(value: UnityEngine.Vector3Int);
            /** The minimal x point of the box.
            */
            public get xMin(): number;
            public set xMin(value: number);
            /** The minimal y point of the box.
            */
            public get yMin(): number;
            public set yMin(value: number);
            /** The minimal z point of the box.
            */
            public get zMin(): number;
            public set zMin(value: number);
            /** The maximal x point of the box.
            */
            public get xMax(): number;
            public set xMax(value: number);
            /** The maximal y point of the box.
            */
            public get yMax(): number;
            public set yMax(value: number);
            /** The maximal z point of the box.
            */
            public get zMax(): number;
            public set zMax(value: number);
            /** The position of the bounding box.
            */
            public get position(): UnityEngine.Vector3Int;
            public set position(value: UnityEngine.Vector3Int);
            /** The total size of the box.
            */
            public get size(): UnityEngine.Vector3Int;
            public set size(value: UnityEngine.Vector3Int);
            /** A BoundsInt.PositionCollection that contains all positions within the BoundsInt.
            */
            public get allPositionsWithin(): UnityEngine.BoundsInt.PositionEnumerator;
            /** Sets the bounds to the min and max value of the box.
            */
            public SetMinMax ($minPosition: UnityEngine.Vector3Int, $maxPosition: UnityEngine.Vector3Int) : void
            /** Clamps the position and size of this bounding box to the given bounds.
            * @param $bounds Bounds to clamp to.
            */
            public ClampToBounds ($bounds: UnityEngine.BoundsInt) : void
            /** Is point contained in the bounding box?
            * @param $position Point to check.
            * @returns Is point contained in the bounding box? 
            */
            public Contains ($position: UnityEngine.Vector3Int) : boolean
            /** Returns a formatted string for the bounds.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString () : string
            /** Returns a formatted string for the bounds.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string) : string
            /** Returns a formatted string for the bounds.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            public static op_Equality ($lhs: UnityEngine.BoundsInt, $rhs: UnityEngine.BoundsInt) : boolean
            public static op_Inequality ($lhs: UnityEngine.BoundsInt, $rhs: UnityEngine.BoundsInt) : boolean
            public Equals ($other: any) : boolean
            public Equals ($other: UnityEngine.BoundsInt) : boolean
            public constructor ($xMin: number, $yMin: number, $zMin: number, $sizeX: number, $sizeY: number, $sizeZ: number)
            public constructor ($position: UnityEngine.Vector3Int, $size: UnityEngine.Vector3Int)
        }
        /** Representation of 3D vectors and points using integers.
        */
        class Vector3Int extends System.ValueType implements System.IFormattable, System.IEquatable$1<UnityEngine.Vector3Int>
        {
            protected [__keep_incompatibility]: never;
            /** X component of the vector.
            */
            public get x(): number;
            public set x(value: number);
            /** Y component of the vector.
            */
            public get y(): number;
            public set y(value: number);
            /** Z component of the vector.
            */
            public get z(): number;
            public set z(value: number);
            /** Returns the length of this vector (Read Only).
            */
            public get magnitude(): number;
            /** Returns the squared length of this vector (Read Only).
            */
            public get sqrMagnitude(): number;
            /** Shorthand for writing Vector3Int(0, 0, 0).
            */
            public static get zero(): UnityEngine.Vector3Int;
            /** Shorthand for writing Vector3Int(1, 1, 1).
            */
            public static get one(): UnityEngine.Vector3Int;
            /** Shorthand for writing Vector3Int(0, 1, 0).
            */
            public static get up(): UnityEngine.Vector3Int;
            /** Shorthand for writing Vector3Int(0, -1, 0).
            */
            public static get down(): UnityEngine.Vector3Int;
            /** Shorthand for writing Vector3Int(-1, 0, 0).
            */
            public static get left(): UnityEngine.Vector3Int;
            /** Shorthand for writing Vector3Int(1, 0, 0).
            */
            public static get right(): UnityEngine.Vector3Int;
            /** Shorthand for writing Vector3Int(0, 0, 1).
            */
            public static get forward(): UnityEngine.Vector3Int;
            /** Shorthand for writing Vector3Int(0, 0, -1).
            */
            public static get back(): UnityEngine.Vector3Int;
            /** Set x, y and z components of an existing Vector3Int.
            */
            public Set ($x: number, $y: number, $z: number) : void
            public get_Item ($index: number) : number
            public set_Item ($index: number, $value: number) : void
            /** Returns the distance between a and b.
            */
            public static Distance ($a: UnityEngine.Vector3Int, $b: UnityEngine.Vector3Int) : number
            /** Returns a vector that is made from the smallest components of two vectors.
            */
            public static Min ($lhs: UnityEngine.Vector3Int, $rhs: UnityEngine.Vector3Int) : UnityEngine.Vector3Int
            /** Returns a vector that is made from the largest components of two vectors.
            */
            public static Max ($lhs: UnityEngine.Vector3Int, $rhs: UnityEngine.Vector3Int) : UnityEngine.Vector3Int
            /** Multiplies two vectors component-wise.
            */
            public static Scale ($a: UnityEngine.Vector3Int, $b: UnityEngine.Vector3Int) : UnityEngine.Vector3Int
            /** Multiplies every component of this vector by the same component of scale.
            */
            public Scale ($scale: UnityEngine.Vector3Int) : void
            /** Clamps the Vector3Int to the bounds given by min and max.
            */
            public Clamp ($min: UnityEngine.Vector3Int, $max: UnityEngine.Vector3Int) : void
            public static op_Implicit ($v: UnityEngine.Vector3Int) : UnityEngine.Vector3
            public static op_Explicit ($v: UnityEngine.Vector3Int) : UnityEngine.Vector2Int
            /** Converts a  Vector3 to a Vector3Int by doing a Floor to each value.
            */
            public static FloorToInt ($v: UnityEngine.Vector3) : UnityEngine.Vector3Int
            /** Converts a  Vector3 to a Vector3Int by doing a Ceiling to each value.
            */
            public static CeilToInt ($v: UnityEngine.Vector3) : UnityEngine.Vector3Int
            /** Converts a  Vector3 to a Vector3Int by doing a Round to each value.
            */
            public static RoundToInt ($v: UnityEngine.Vector3) : UnityEngine.Vector3Int
            public static op_Addition ($a: UnityEngine.Vector3Int, $b: UnityEngine.Vector3Int) : UnityEngine.Vector3Int
            public static op_Subtraction ($a: UnityEngine.Vector3Int, $b: UnityEngine.Vector3Int) : UnityEngine.Vector3Int
            public static op_Multiply ($a: UnityEngine.Vector3Int, $b: UnityEngine.Vector3Int) : UnityEngine.Vector3Int
            public static op_UnaryNegation ($a: UnityEngine.Vector3Int) : UnityEngine.Vector3Int
            public static op_Multiply ($a: UnityEngine.Vector3Int, $b: number) : UnityEngine.Vector3Int
            public static op_Multiply ($a: number, $b: UnityEngine.Vector3Int) : UnityEngine.Vector3Int
            public static op_Division ($a: UnityEngine.Vector3Int, $b: number) : UnityEngine.Vector3Int
            public static op_Equality ($lhs: UnityEngine.Vector3Int, $rhs: UnityEngine.Vector3Int) : boolean
            public static op_Inequality ($lhs: UnityEngine.Vector3Int, $rhs: UnityEngine.Vector3Int) : boolean
            /** Returns true if the objects are equal.
            */
            public Equals ($other: any) : boolean
            public Equals ($other: UnityEngine.Vector3Int) : boolean
            /** Returns a formatted string for this vector.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString () : string
            /** Returns a formatted string for this vector.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string) : string
            /** Returns a formatted string for this vector.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            public constructor ($x: number, $y: number)
            public constructor ($x: number, $y: number, $z: number)
        }
        /** Utility class for common geometric functions.
        */
        class GeometryUtility extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Calculates frustum planes.
            * @param $camera The camera with the view frustum that you want to calculate planes from.
            * @returns The planes that form the camera's view frustum. 
            */
            public static CalculateFrustumPlanes ($camera: UnityEngine.Camera) : System.Array$1<UnityEngine.Plane>
            /** Calculates frustum planes.
            * @param $worldToProjectionMatrix A matrix that transforms from world space to projection space, from which the planes will be calculated.
            * @returns The planes that enclose the projection space described by the matrix. 
            */
            public static CalculateFrustumPlanes ($worldToProjectionMatrix: UnityEngine.Matrix4x4) : System.Array$1<UnityEngine.Plane>
            /** Calculates frustum planes.
            * @param $camera The camera with the view frustum that you want to calculate planes from.
            * @param $planes An array of 6 Planes that will be overwritten with the calculated plane values.
            */
            public static CalculateFrustumPlanes ($camera: UnityEngine.Camera, $planes: System.Array$1<UnityEngine.Plane>) : void
            /** Calculates frustum planes.
            * @param $worldToProjectionMatrix A matrix that transforms from world space to projection space, from which the planes will be calculated.
            * @param $planes An array of 6 Planes that will be overwritten with the calculated plane values.
            */
            public static CalculateFrustumPlanes ($worldToProjectionMatrix: UnityEngine.Matrix4x4, $planes: System.Array$1<UnityEngine.Plane>) : void
            /** Calculates the bounding box from the given array of positions and the transformation matrix.
            * @param $positions An array that stores the location of 3d positions.
            * @param $transform A matrix that changes the position, rotation and size of the bounds calculation.
            * @returns Calculates the axis-aligned bounding box. 
            */
            public static CalculateBounds ($positions: System.Array$1<UnityEngine.Vector3>, $transform: UnityEngine.Matrix4x4) : UnityEngine.Bounds
            /** GeometryUtility.TryCreatePlaneFromPolygon creates a plane from the given list of vertices that define the polygon, as long as they do not characterize a straight line or zero area.
            * @param $vertices An array of vertex positions that define the shape of a polygon.
            * @param $plane A valid plane that goes through the vertices.
            * @returns Returns true on success, false if Unity did not create a plane from the vertices. 
            */
            public static TryCreatePlaneFromPolygon ($vertices: System.Array$1<UnityEngine.Vector3>, $plane: $Ref<UnityEngine.Plane>) : boolean
            /** Returns true if bounds are inside the plane array.
            */
            public static TestPlanesAABB ($planes: System.Array$1<UnityEngine.Plane>, $bounds: UnityEngine.Bounds) : boolean
            public constructor ()
        }
        /** Representation of a plane in 3D space.
        */
        class Plane extends System.ValueType implements System.IFormattable
        {
            protected [__keep_incompatibility]: never;
            /** Normal vector of the plane.
            */
            public get normal(): UnityEngine.Vector3;
            public set normal(value: UnityEngine.Vector3);
            /** The distance measured from the Plane to the origin, along the Plane's normal.
            */
            public get distance(): number;
            public set distance(value: number);
            /** Returns a copy of the plane that faces in the opposite direction.
            */
            public get flipped(): UnityEngine.Plane;
            /** Sets a plane using a point that lies within it along with a normal to orient it.
            * @param $inNormal The plane's normal vector.
            * @param $inPoint A point that lies on the plane.
            */
            public SetNormalAndPosition ($inNormal: UnityEngine.Vector3, $inPoint: UnityEngine.Vector3) : void
            /** Sets a plane using three points that lie within it.  The points go around clockwise as you look down on the top surface of the plane.
            * @param $a First point in clockwise order.
            * @param $b Second point in clockwise order.
            * @param $c Third point in clockwise order.
            */
            public Set3Points ($a: UnityEngine.Vector3, $b: UnityEngine.Vector3, $c: UnityEngine.Vector3) : void
            /** Makes the plane face in the opposite direction.
            */
            public Flip () : void
            /** Moves the plane in space by the translation vector.
            * @param $translation The offset in space to move the plane with.
            */
            public Translate ($translation: UnityEngine.Vector3) : void
            /** Returns a copy of the given plane that is moved in space by the given translation.
            * @param $plane The plane to move in space.
            * @param $translation The offset in space to move the plane with.
            * @returns The translated plane. 
            */
            public static Translate ($plane: UnityEngine.Plane, $translation: UnityEngine.Vector3) : UnityEngine.Plane
            /** For a given point returns the closest point on the plane.
            * @param $point The point to project onto the plane.
            * @returns A point on the plane that is closest to point. 
            */
            public ClosestPointOnPlane ($point: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Returns a signed distance from plane to point.
            */
            public GetDistanceToPoint ($point: UnityEngine.Vector3) : number
            /** Is a point on the positive side of the plane?
            */
            public GetSide ($point: UnityEngine.Vector3) : boolean
            /** Are two points on the same side of the plane?
            */
            public SameSide ($inPt0: UnityEngine.Vector3, $inPt1: UnityEngine.Vector3) : boolean
            /** Intersects a ray with the plane.
            */
            public Raycast ($ray: UnityEngine.Ray, $enter: $Ref<number>) : boolean
            public ToString () : string
            public ToString ($format: string) : string
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            public constructor ($inNormal: UnityEngine.Vector3, $inPoint: UnityEngine.Vector3)
            public constructor ($inNormal: UnityEngine.Vector3, $d: number)
            public constructor ($a: UnityEngine.Vector3, $b: UnityEngine.Vector3, $c: UnityEngine.Vector3)
        }
        /** A ray in 2D space.
        */
        class Ray2D extends System.ValueType implements System.IFormattable
        {
            protected [__keep_incompatibility]: never;
            /** The starting point of the ray in world space.
            */
            public get origin(): UnityEngine.Vector2;
            public set origin(value: UnityEngine.Vector2);
            /** The direction of the ray in world space.
            */
            public get direction(): UnityEngine.Vector2;
            public set direction(value: UnityEngine.Vector2);
            /** Get a point that lies a given distance along a ray.
            * @param $distance Distance of the desired point along the path of the ray.
            */
            public GetPoint ($distance: number) : UnityEngine.Vector2
            /** Returns a formatted string for this 2D ray.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString () : string
            /** Returns a formatted string for this 2D ray.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string) : string
            /** Returns a formatted string for this 2D ray.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            public constructor ($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2)
        }
        /** A 2D Rectangle defined by x, y, width, height with integers.
        */
        class RectInt extends System.ValueType implements System.IFormattable, System.IEquatable$1<UnityEngine.RectInt>
        {
            protected [__keep_incompatibility]: never;
            /** Left coordinate of the rectangle.
            */
            public get x(): number;
            public set x(value: number);
            /** Top coordinate of the rectangle.
            */
            public get y(): number;
            public set y(value: number);
            /** Center coordinate of the rectangle.
            */
            public get center(): UnityEngine.Vector2;
            /** The lower left corner of the rectangle; which is the minimal position of the rectangle along the x- and y-axes, when it is aligned to both axes.
            */
            public get min(): UnityEngine.Vector2Int;
            public set min(value: UnityEngine.Vector2Int);
            /** The upper right corner of the rectangle; which is the maximal position of the rectangle along the x- and y-axes, when it is aligned to both axes.
            */
            public get max(): UnityEngine.Vector2Int;
            public set max(value: UnityEngine.Vector2Int);
            /** Width of the rectangle.
            */
            public get width(): number;
            public set width(value: number);
            /** Height of the rectangle.
            */
            public get height(): number;
            public set height(value: number);
            /** Shows the minimum X value of the RectInt.
            */
            public get xMin(): number;
            public set xMin(value: number);
            /** Show the minimum Y value of the RectInt.
            */
            public get yMin(): number;
            public set yMin(value: number);
            /** Shows the maximum X value of the RectInt.
            */
            public get xMax(): number;
            public set xMax(value: number);
            /** Shows the maximum Y value of the RectInt.
            */
            public get yMax(): number;
            public set yMax(value: number);
            /** Returns the position (x, y) of the RectInt.
            */
            public get position(): UnityEngine.Vector2Int;
            public set position(value: UnityEngine.Vector2Int);
            /** Returns the width and height of the RectInt.
            */
            public get size(): UnityEngine.Vector2Int;
            public set size(value: UnityEngine.Vector2Int);
            /** Shorthand for writing new RectInt(0,0,0,0).
            */
            public static get zero(): UnityEngine.RectInt;
            /** A RectInt.PositionCollection that contains all positions within the RectInt.
            */
            public get allPositionsWithin(): UnityEngine.RectInt.PositionEnumerator;
            /** Sets the bounds to the min and max value of the rect.
            */
            public SetMinMax ($minPosition: UnityEngine.Vector2Int, $maxPosition: UnityEngine.Vector2Int) : void
            /** Clamps the position and size of the RectInt to the given bounds.
            * @param $bounds Bounds to clamp the RectInt.
            */
            public ClampToBounds ($bounds: UnityEngine.RectInt) : void
            /** Returns true if the given position is within the RectInt.
            * @param $position Position to check.
            * @returns Whether the position is within the RectInt. 
            */
            public Contains ($position: UnityEngine.Vector2Int) : boolean
            /** RectInts overlap if each RectInt Contains a shared point.
            * @param $other Other rectangle to test overlapping with.
            * @returns True if the other rectangle overlaps this one. 
            */
            public Overlaps ($other: UnityEngine.RectInt) : boolean
            /** Returns the x, y, width and height of the RectInt.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString () : string
            /** Returns the x, y, width and height of the RectInt.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string) : string
            /** Returns the x, y, width and height of the RectInt.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            public static op_Inequality ($lhs: UnityEngine.RectInt, $rhs: UnityEngine.RectInt) : boolean
            public static op_Equality ($lhs: UnityEngine.RectInt, $rhs: UnityEngine.RectInt) : boolean
            public Equals ($other: any) : boolean
            /** Returns true if the given RectInt is equal to this RectInt.
            */
            public Equals ($other: UnityEngine.RectInt) : boolean
            public constructor ($xMin: number, $yMin: number, $width: number, $height: number)
            public constructor ($position: UnityEngine.Vector2Int, $size: UnityEngine.Vector2Int)
        }
        /** Representation of 2D vectors and points using integers.
        */
        class Vector2Int extends System.ValueType implements System.IFormattable, System.IEquatable$1<UnityEngine.Vector2Int>
        {
            protected [__keep_incompatibility]: never;
            /** X component of the vector.
            */
            public get x(): number;
            public set x(value: number);
            /** Y component of the vector.
            */
            public get y(): number;
            public set y(value: number);
            /** Returns the length of this vector (Read Only).
            */
            public get magnitude(): number;
            /** Returns the squared length of this vector (Read Only).
            */
            public get sqrMagnitude(): number;
            /** Shorthand for writing Vector2Int(0, 0).
            */
            public static get zero(): UnityEngine.Vector2Int;
            /** Shorthand for writing Vector2Int(1, 1).
            */
            public static get one(): UnityEngine.Vector2Int;
            /** Shorthand for writing Vector2Int(0, 1).
            */
            public static get up(): UnityEngine.Vector2Int;
            /** Shorthand for writing Vector2Int(0, -1).
            */
            public static get down(): UnityEngine.Vector2Int;
            /** Shorthand for writing Vector2Int(-1, 0).
            */
            public static get left(): UnityEngine.Vector2Int;
            /** Shorthand for writing Vector2Int(1, 0).
            */
            public static get right(): UnityEngine.Vector2Int;
            /** Set x and y components of an existing Vector2Int.
            */
            public Set ($x: number, $y: number) : void
            public get_Item ($index: number) : number
            public set_Item ($index: number, $value: number) : void
            /** Returns the distance between a and b.
            */
            public static Distance ($a: UnityEngine.Vector2Int, $b: UnityEngine.Vector2Int) : number
            /** Returns a vector that is made from the smallest components of two vectors.
            */
            public static Min ($lhs: UnityEngine.Vector2Int, $rhs: UnityEngine.Vector2Int) : UnityEngine.Vector2Int
            /** Returns a vector that is made from the largest components of two vectors.
            */
            public static Max ($lhs: UnityEngine.Vector2Int, $rhs: UnityEngine.Vector2Int) : UnityEngine.Vector2Int
            /** Multiplies two vectors component-wise.
            */
            public static Scale ($a: UnityEngine.Vector2Int, $b: UnityEngine.Vector2Int) : UnityEngine.Vector2Int
            /** Multiplies every component of this vector by the same component of scale.
            */
            public Scale ($scale: UnityEngine.Vector2Int) : void
            /** Clamps the Vector2Int to the bounds given by min and max.
            */
            public Clamp ($min: UnityEngine.Vector2Int, $max: UnityEngine.Vector2Int) : void
            public static op_Implicit ($v: UnityEngine.Vector2Int) : UnityEngine.Vector2
            public static op_Explicit ($v: UnityEngine.Vector2Int) : UnityEngine.Vector3Int
            /** Converts a Vector2 to a Vector2Int by doing a Floor to each value.
            */
            public static FloorToInt ($v: UnityEngine.Vector2) : UnityEngine.Vector2Int
            /** Converts a  Vector2 to a Vector2Int by doing a Ceiling to each value.
            */
            public static CeilToInt ($v: UnityEngine.Vector2) : UnityEngine.Vector2Int
            /** Converts a  Vector2 to a Vector2Int by doing a Round to each value.
            */
            public static RoundToInt ($v: UnityEngine.Vector2) : UnityEngine.Vector2Int
            public static op_UnaryNegation ($v: UnityEngine.Vector2Int) : UnityEngine.Vector2Int
            public static op_Addition ($a: UnityEngine.Vector2Int, $b: UnityEngine.Vector2Int) : UnityEngine.Vector2Int
            public static op_Subtraction ($a: UnityEngine.Vector2Int, $b: UnityEngine.Vector2Int) : UnityEngine.Vector2Int
            public static op_Multiply ($a: UnityEngine.Vector2Int, $b: UnityEngine.Vector2Int) : UnityEngine.Vector2Int
            public static op_Multiply ($a: number, $b: UnityEngine.Vector2Int) : UnityEngine.Vector2Int
            public static op_Multiply ($a: UnityEngine.Vector2Int, $b: number) : UnityEngine.Vector2Int
            public static op_Division ($a: UnityEngine.Vector2Int, $b: number) : UnityEngine.Vector2Int
            public static op_Equality ($lhs: UnityEngine.Vector2Int, $rhs: UnityEngine.Vector2Int) : boolean
            public static op_Inequality ($lhs: UnityEngine.Vector2Int, $rhs: UnityEngine.Vector2Int) : boolean
            /** Returns true if the objects are equal.
            */
            public Equals ($other: any) : boolean
            public Equals ($other: UnityEngine.Vector2Int) : boolean
            /** Returns a formatted string for this vector.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString () : string
            /** Returns a formatted string for this vector.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string) : string
            /** Returns a formatted string for this vector.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            public constructor ($x: number, $y: number)
        }
        /** Offsets for rectangles, borders, etc.
        */
        class RectOffset extends System.Object implements System.IFormattable
        {
            protected [__keep_incompatibility]: never;
            /** Left edge size.
            */
            public get left(): number;
            public set left(value: number);
            /** Right edge size.
            */
            public get right(): number;
            public set right(value: number);
            /** Top edge size.
            */
            public get top(): number;
            public set top(value: number);
            /** Bottom edge size.
            */
            public get bottom(): number;
            public set bottom(value: number);
            /** Shortcut for left + right. (Read Only)
            */
            public get horizontal(): number;
            /** Shortcut for top + bottom. (Read Only)
            */
            public get vertical(): number;
            /** Returns a formatted string for this RectOffset.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString () : string
            /** Returns a formatted string for this RectOffset.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string) : string
            /** Returns a formatted string for this RectOffset.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            /** Add the border offsets to a rect.
            */
            public Add ($rect: UnityEngine.Rect) : UnityEngine.Rect
            /** Remove the border offsets from a rect.
            */
            public Remove ($rect: UnityEngine.Rect) : UnityEngine.Rect
            public constructor ()
            public constructor ($left: number, $right: number, $top: number, $bottom: number)
        }
        /** Allows to control the dynamic Global Illumination.
        */
        class DynamicGI extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Allows for scaling the contribution coming from real-time & baked lightmaps.
            Note: this value can be set in the Lighting Window UI and it is serialized, that is not the case for other properties in this class.
            */
            public static get indirectScale(): number;
            public static set indirectScale(value: number);
            /** Determines the percentage change in lighting intensity that triggers Unity to recalculate the real-time lightmap.
            */
            public static get updateThreshold(): number;
            public static set updateThreshold(value: number);
            /** The number of milliseconds that can be spent on material updates.
            */
            public static get materialUpdateTimeSlice(): number;
            public static set materialUpdateTimeSlice(value: number);
            /** When enabled, new dynamic Global Illumination output is shown in each frame.
            */
            public static get synchronousMode(): boolean;
            public static set synchronousMode(value: boolean);
            /** Is precomputed Enlighten Realtime Global Illumination output converged?
            */
            public static get isConverged(): boolean;
            /** Allows to set an emissive color for a given renderer quickly, without the need to render the emissive input for the entire system.
            * @param $renderer The Renderer that should get a new color.
            * @param $color The emissive Color.
            */
            public static SetEmissive ($renderer: UnityEngine.Renderer, $color: UnityEngine.Color) : void
            /** Allows overriding the distant environment lighting for Enlighten Realtime Global Illumination, without changing the Skybox Material.
            * @param $input Array of float values to be used for Enlighten Realtime Global Illumination environment lighting.
            */
            public static SetEnvironmentData ($input: System.Array$1<number>) : void
            /** Schedules an update of the environment cubemap.
            */
            public static UpdateEnvironment () : void
            public constructor ()
        }
        /** General functionality for all renderers.
        */
        class Renderer extends UnityEngine.Component
        {
            protected [__keep_incompatibility]: never;
            /** The bounding box of the renderer in world space.
            */
            public get bounds(): UnityEngine.Bounds;
            public set bounds(value: UnityEngine.Bounds);
            /** The bounding box of the renderer in local space.
            */
            public get localBounds(): UnityEngine.Bounds;
            public set localBounds(value: UnityEngine.Bounds);
            /** Makes the rendered 3D object visible if enabled.
            */
            public get enabled(): boolean;
            public set enabled(value: boolean);
            /** Is this renderer visible in any camera? (Read Only)
            */
            public get isVisible(): boolean;
            /** Does this object cast shadows?
            */
            public get shadowCastingMode(): UnityEngine.Rendering.ShadowCastingMode;
            public set shadowCastingMode(value: UnityEngine.Rendering.ShadowCastingMode);
            /** Does this object receive shadows?
            */
            public get receiveShadows(): boolean;
            public set receiveShadows(value: boolean);
            /** Allows turning off rendering for a specific component.
            */
            public get forceRenderingOff(): boolean;
            public set forceRenderingOff(value: boolean);
            /** Is this renderer a static shadow caster?
            */
            public get staticShadowCaster(): boolean;
            public set staticShadowCaster(value: boolean);
            /** Specifies the mode for motion vector rendering.
            */
            public get motionVectorGenerationMode(): UnityEngine.MotionVectorGenerationMode;
            public set motionVectorGenerationMode(value: UnityEngine.MotionVectorGenerationMode);
            /** The light probe interpolation type.
            */
            public get lightProbeUsage(): UnityEngine.Rendering.LightProbeUsage;
            public set lightProbeUsage(value: UnityEngine.Rendering.LightProbeUsage);
            /** Should reflection probes be used for this Renderer?
            */
            public get reflectionProbeUsage(): UnityEngine.Rendering.ReflectionProbeUsage;
            public set reflectionProbeUsage(value: UnityEngine.Rendering.ReflectionProbeUsage);
            /** Determines which rendering layer this renderer lives on.
            */
            public get renderingLayerMask(): number;
            public set renderingLayerMask(value: number);
            /** This value sorts renderers by priority. Lower values are rendered first and higher values are rendered last.
            */
            public get rendererPriority(): number;
            public set rendererPriority(value: number);
            /** Describes how this renderer is updated for ray tracing.
            */
            public get rayTracingMode(): UnityEngine.Experimental.Rendering.RayTracingMode;
            public set rayTracingMode(value: UnityEngine.Experimental.Rendering.RayTracingMode);
            /** The flags Unity uses when it builds acceleration structures associated with geometry used by renderers.
            */
            public get rayTracingAccelerationStructureBuildFlags(): UnityEngine.Rendering.RayTracingAccelerationStructureBuildFlags;
            public set rayTracingAccelerationStructureBuildFlags(value: UnityEngine.Rendering.RayTracingAccelerationStructureBuildFlags);
            /** Whether to override the default build flags specified when creating a RayTracingAccelerationStructure.
            */
            public get rayTracingAccelerationStructureBuildFlagsOverride(): boolean;
            public set rayTracingAccelerationStructureBuildFlagsOverride(value: boolean);
            /** Name of the Renderer's sorting layer.
            */
            public get sortingLayerName(): string;
            public set sortingLayerName(value: string);
            /** Unique ID of the Renderer's sorting layer.
            */
            public get sortingLayerID(): number;
            public set sortingLayerID(value: number);
            /** Renderer's order within a sorting layer.
            */
            public get sortingOrder(): number;
            public set sortingOrder(value: number);
            /** Controls if dynamic occlusion culling should be performed for this renderer.
            */
            public get allowOcclusionWhenDynamic(): boolean;
            public set allowOcclusionWhenDynamic(value: boolean);
            /** Indicates whether the renderer is part of a with other renderers.
            */
            public get isPartOfStaticBatch(): boolean;
            /** Matrix that transforms a point from world space into local space (Read Only).
            */
            public get worldToLocalMatrix(): UnityEngine.Matrix4x4;
            /** Matrix that transforms a point from local space into world space (Read Only).
            */
            public get localToWorldMatrix(): UnityEngine.Matrix4x4;
            /** If set, the Renderer will use the Light Probe Proxy Volume component attached to the source GameObject.
            */
            public get lightProbeProxyVolumeOverride(): UnityEngine.GameObject;
            public set lightProbeProxyVolumeOverride(value: UnityEngine.GameObject);
            /** If set, Renderer will use this Transform's position to find the light or reflection probe.
            */
            public get probeAnchor(): UnityEngine.Transform;
            public set probeAnchor(value: UnityEngine.Transform);
            /** The index of the baked lightmap applied to this renderer.
            */
            public get lightmapIndex(): number;
            public set lightmapIndex(value: number);
            /** The index of the real-time lightmap applied to this renderer.
            */
            public get realtimeLightmapIndex(): number;
            public set realtimeLightmapIndex(value: number);
            /** The UV scale & offset used for a lightmap.
            */
            public get lightmapScaleOffset(): UnityEngine.Vector4;
            public set lightmapScaleOffset(value: UnityEngine.Vector4);
            /** The UV scale & offset used for a real-time lightmap.
            */
            public get realtimeLightmapScaleOffset(): UnityEngine.Vector4;
            public set realtimeLightmapScaleOffset(value: UnityEngine.Vector4);
            /** Returns all the instantiated materials of this object.
            */
            public get materials(): System.Array$1<UnityEngine.Material>;
            public set materials(value: System.Array$1<UnityEngine.Material>);
            /** Returns the first instantiated Material assigned to the renderer.
            */
            public get material(): UnityEngine.Material;
            public set material(value: UnityEngine.Material);
            /** The shared material of this object.
            */
            public get sharedMaterial(): UnityEngine.Material;
            public set sharedMaterial(value: UnityEngine.Material);
            /** All the shared materials of this object.
            */
            public get sharedMaterials(): System.Array$1<UnityEngine.Material>;
            public set sharedMaterials(value: System.Array$1<UnityEngine.Material>);
            /** Reset custom world space bounds.
            */
            public ResetBounds () : void
            /** Reset custom local space bounds.
            */
            public ResetLocalBounds () : void
            /** Returns true if the Renderer has a material property block attached via SetPropertyBlock.
            */
            public HasPropertyBlock () : boolean
            /** Lets you set or clear per-renderer or per-material parameter overrides.
            * @param $properties Property block with values you want to override.
            * @param $materialIndex The index of the Material you want to override the parameters of. The index ranges from 0 to Renderer.sharedMaterials.Length-1.
            */
            public SetPropertyBlock ($properties: UnityEngine.MaterialPropertyBlock) : void
            /** Lets you set or clear per-renderer or per-material parameter overrides.
            * @param $properties Property block with values you want to override.
            * @param $materialIndex The index of the Material you want to override the parameters of. The index ranges from 0 to Renderer.sharedMaterials.Length-1.
            */
            public SetPropertyBlock ($properties: UnityEngine.MaterialPropertyBlock, $materialIndex: number) : void
            /** Get per-Renderer or per-Material property block.
            * @param $properties Material parameters to retrieve.
            * @param $materialIndex The index of the Material you want to get overridden parameters from. The index ranges from 0 to Renderer.sharedMaterials.Length-1.
            */
            public GetPropertyBlock ($properties: UnityEngine.MaterialPropertyBlock) : void
            /** Get per-Renderer or per-Material property block.
            * @param $properties Material parameters to retrieve.
            * @param $materialIndex The index of the Material you want to get overridden parameters from. The index ranges from 0 to Renderer.sharedMaterials.Length-1.
            */
            public GetPropertyBlock ($properties: UnityEngine.MaterialPropertyBlock, $materialIndex: number) : void
            public GetMaterials ($m: System.Collections.Generic.List$1<UnityEngine.Material>) : void
            public SetSharedMaterials ($materials: System.Collections.Generic.List$1<UnityEngine.Material>) : void
            public SetMaterials ($materials: System.Collections.Generic.List$1<UnityEngine.Material>) : void
            public GetSharedMaterials ($m: System.Collections.Generic.List$1<UnityEngine.Material>) : void
            public GetClosestReflectionProbes ($result: System.Collections.Generic.List$1<UnityEngine.Rendering.ReflectionProbeBlendInfo>) : void
            public constructor ()
        }
        /** An object containing settings for precomputing lighting data, that Unity can serialize as a.
        */
        class LightingSettings extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** Whether to enable the Baked Global Illumination system for this Scene.
            */
            public get bakedGI(): boolean;
            public set bakedGI(value: boolean);
            /** Whether to enable the Enlighten Realtime Global Illumination system for this Scene.
            */
            public get realtimeGI(): boolean;
            public set realtimeGI(value: boolean);
            /** Determines the lightmap that Unity stores environment lighting in.
            */
            public get realtimeEnvironmentLighting(): boolean;
            public set realtimeEnvironmentLighting(value: boolean);
            /** Sets the MixedLightingMode that Unity uses for all Mixed Lights in the Scene. (Editor only).
            */
            public get mixedBakeMode(): UnityEngine.MixedLightingMode;
            public set mixedBakeMode(value: UnityEngine.MixedLightingMode);
            /** The intensity of surface albedo throughout the Scene when considered in lighting calculations. This value influences the energy of light at each bounce. (Editor only).
            */
            public get albedoBoost(): number;
            public set albedoBoost(value: number);
            /** Multiplies the intensity of of indirect lighting in lightmaps. (Editor only).
            */
            public get indirectScale(): number;
            public set indirectScale(value: number);
            /** Determines which backend to use for baking lightmaps in the Baked Global Illumination system. (Editor only).
            */
            public get lightmapper(): UnityEngine.LightingSettings.Lightmapper;
            public set lightmapper(value: UnityEngine.LightingSettings.Lightmapper);
            /** The maximum size in pixels of an individual lightmap texture. (Editor only).
            */
            public get lightmapMaxSize(): number;
            public set lightmapMaxSize(value: number);
            /** Defines the number of texels to use per world unit when generating lightmaps.
            */
            public get lightmapResolution(): number;
            public set lightmapResolution(value: number);
            /** Sets the distance (in texels) between separate UV tiles in lightmaps. (Editor only).
            */
            public get lightmapPadding(): number;
            public set lightmapPadding(value: number);
            /** The level of compression the Editor uses for lightmaps.
            */
            public get lightmapCompression(): UnityEngine.LightmapCompression;
            public set lightmapCompression(value: UnityEngine.LightmapCompression);
            /** Whether to apply ambient occlusion to lightmaps. (Editor only).
            */
            public get ao(): boolean;
            public set ao(value: boolean);
            /** The distance that a ray travels before Unity considers it to be unoccluded when calculating ambient occlusion in lightmaps. (Editor only).
            */
            public get aoMaxDistance(): number;
            public set aoMaxDistance(value: number);
            /** Sets the contrast of ambient occlusion that Unity applies to indirect lighting in lightmaps. (Editor only).
            */
            public get aoExponentIndirect(): number;
            public set aoExponentIndirect(value: number);
            /** Determines the degree to which direct lighting is considered when calculating ambient occlusion in lightmaps. (Editor only).
            */
            public get aoExponentDirect(): number;
            public set aoExponentDirect(value: number);
            /** Whether the Progressive Lightmapper extracts Ambient Occlusion to a separate lightmap. (Editor only).
            */
            public get extractAO(): boolean;
            public set extractAO(value: boolean);
            /** Determines whether the lightmapper should generate directional or non-directional lightmaps. (Editor only).
            */
            public get directionalityMode(): UnityEngine.LightmapsMode;
            public set directionalityMode(value: UnityEngine.LightmapsMode);
            /** Defines the number of texels that Enlighten Realtime Global Illumination uses per world unit when calculating indirect lighting. (Editor only).
            */
            public get indirectResolution(): number;
            public set indirectResolution(value: number);
            public get sampling(): UnityEngine.LightingSettings.Sampling;
            public set sampling(value: UnityEngine.LightingSettings.Sampling);
            /** Specifies the number of samples the Progressive Lightmapper uses for direct lighting calculations. (Editor only).
            */
            public get directSampleCount(): number;
            public set directSampleCount(value: number);
            /** Specifies the number of samples the Progressive Lightmapper uses for indirect lighting calculations. (Editor only).
            */
            public get indirectSampleCount(): number;
            public set indirectSampleCount(value: number);
            /** Stores the maximum number of bounces the Progressive Lightmapper computes for indirect lighting. (Editor only)
            */
            public get maxBounces(): number;
            public set maxBounces(value: number);
            /** Stores the minimum number of bounces the Progressive Lightmapper computes for indirect lighting. (Editor only)
            */
            public get minBounces(): number;
            public set minBounces(value: number);
            /** Whether the Progressive Lightmapper prioritizes baking visible texels within the frustum of the Scene view. (Editor only).
            */
            public get prioritizeView(): boolean;
            public set prioritizeView(value: boolean);
            /** Specifies the filter type that the Progressive Lightmapper uses for ambient occlusion. (Editor only).
            */
            public get filteringMode(): UnityEngine.LightingSettings.FilterMode;
            public set filteringMode(value: UnityEngine.LightingSettings.FilterMode);
            /** Determines the denoiser that the Progressive Lightmapper applies to direct lighting. (Editor only).
            */
            public get denoiserTypeDirect(): UnityEngine.LightingSettings.DenoiserType;
            public set denoiserTypeDirect(value: UnityEngine.LightingSettings.DenoiserType);
            /** Determines the denoiser that the Progressive Lightmapper applies to indirect lighting. (Editor only).
            */
            public get denoiserTypeIndirect(): UnityEngine.LightingSettings.DenoiserType;
            public set denoiserTypeIndirect(value: UnityEngine.LightingSettings.DenoiserType);
            /** Determines the type of denoising that the Progressive Lightmapper applies to ambient occlusion in lightmaps. (Editor only).
            */
            public get denoiserTypeAO(): UnityEngine.LightingSettings.DenoiserType;
            public set denoiserTypeAO(value: UnityEngine.LightingSettings.DenoiserType);
            /** Specifies the filter kernel that the Progressive Lightmapper uses for the direct lighting. (Editor only).
            */
            public get filterTypeDirect(): UnityEngine.LightingSettings.FilterType;
            public set filterTypeDirect(value: UnityEngine.LightingSettings.FilterType);
            /** Specifies whether the Editor calculates the final global illumination light bounce at the same resolution as the baked lightmap.
            */
            public get filterTypeIndirect(): UnityEngine.LightingSettings.FilterType;
            public set filterTypeIndirect(value: UnityEngine.LightingSettings.FilterType);
            /** Specifies the filter kernel that the Progressive Lightmapper uses for ambient occlusion. (Editor only).
            */
            public get filterTypeAO(): UnityEngine.LightingSettings.FilterType;
            public set filterTypeAO(value: UnityEngine.LightingSettings.FilterType);
            /** Specifies the radius the Progressive Lightmapper uses to filter the indirect lighting component of the lightmap when you use the Gaussian filter. (Editor only).
            */
            public get filteringGaussianRadiusDirect(): number;
            public set filteringGaussianRadiusDirect(value: number);
            /** Specifies the method that the Progressive Lightmapper uses to reduce noise in lightmaps. (Editor only).
            */
            public get filteringGaussianRadiusIndirect(): number;
            public set filteringGaussianRadiusIndirect(value: number);
            /** Specifies the radius the Progressive Lightmapper uses to filter the direct lighting component of the lightmap when you use the Gaussian filter. (Editor only).
            */
            public get filteringGaussianRadiusAO(): number;
            public set filteringGaussianRadiusAO(value: number);
            /** Specifies the threshold the Progressive Lightmapper uses to filter the indirect lighting component of the lightmap when using the A-Trous filter. (Editor only).
            */
            public get filteringAtrousPositionSigmaDirect(): number;
            public set filteringAtrousPositionSigmaDirect(value: number);
            /** Specifies the radius the Progressive Lightmapper uses to filter the ambient occlusion component in the lightmap when you use the Gaussian filter. (Editor only).
            */
            public get filteringAtrousPositionSigmaIndirect(): number;
            public set filteringAtrousPositionSigmaIndirect(value: number);
            /** Specifies the threshold the Progressive Lightmapper uses to filter direct light stored in the lightmap when using the A-Trous filter. (Editor only).
            */
            public get filteringAtrousPositionSigmaAO(): number;
            public set filteringAtrousPositionSigmaAO(value: number);
            /** Determines whether Progressive Lightmappers use importance sampling when they sample environment lighting while baking.
            */
            public get environmentImportanceSampling(): boolean;
            public set environmentImportanceSampling(value: boolean);
            /** Specifies the number of samples the Progressive Lightmapper uses when sampling indirect lighting from the skybox. (Editor only).
            */
            public get environmentSampleCount(): number;
            public set environmentSampleCount(value: number);
            /** Specifies the number of samples to use for Light Probes relative to the number of samples for lightmap texels. (Editor only).
            */
            public get lightProbeSampleCountMultiplier(): number;
            public set lightProbeSampleCountMultiplier(value: number);
            /** When Unity is precomputing or baking Global Illumination, respect the Scene Visibility setting of a [[GameObject] with a MeshRenderer or Terrain component.
            */
            public get respectSceneVisibilityWhenBakingGI(): boolean;
            public set respectSceneVisibilityWhenBakingGI(value: boolean);
            public constructor ()
        }
        /** Enum describing what lighting mode to be used with Mixed lights.
        */
        enum MixedLightingMode
        { IndirectOnly = 0, Shadowmask = 2, Subtractive = 1 }
        /** A set of options for the level of compression the Editor uses for lightmaps.
        */
        enum LightmapCompression
        { None = 0, LowQuality = 1, NormalQuality = 2, HighQuality = 3 }
        /** Lightmap (and lighting) configuration mode, controls how lightmaps interact with lighting and what kind of information they store.
        */
        enum LightmapsMode
        { NonDirectional = 0, CombinedDirectional = 1, SeparateDirectional = 2, Single = 0, Dual = 1, Directional = 2 }
        /** Gizmos are used to give visual debugging or setup aids in the Scene view.
        */
        class Gizmos extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Sets the Color of the gizmos that are drawn next.
            */
            public static get color(): UnityEngine.Color;
            public static set color(value: UnityEngine.Color);
            /** Sets the Matrix4x4 that the Unity Editor uses to draw Gizmos.
            */
            public static get matrix(): UnityEngine.Matrix4x4;
            public static set matrix(value: UnityEngine.Matrix4x4);
            /** Set a texture that contains the exposure correction for LightProbe gizmos. The value is sampled from the red channel in the middle of the texture.
            */
            public static get exposure(): UnityEngine.Texture;
            public static set exposure(value: UnityEngine.Texture);
            /** Set a scale for Light Probe gizmos. This scale will be used to render the spherical harmonic preview spheres.
            */
            public static get probeSize(): number;
            /** Draws a line starting at from towards to.
            */
            public static DrawLine ($from: UnityEngine.Vector3, $to: UnityEngine.Vector3) : void
            /** Draws a wireframe sphere with center and radius.
            */
            public static DrawWireSphere ($center: UnityEngine.Vector3, $radius: number) : void
            /** Draws a solid sphere with center and radius.
            */
            public static DrawSphere ($center: UnityEngine.Vector3, $radius: number) : void
            /** Draw a wireframe box with center and size.
            */
            public static DrawWireCube ($center: UnityEngine.Vector3, $size: UnityEngine.Vector3) : void
            /** Draw a solid box at center with size.
            */
            public static DrawCube ($center: UnityEngine.Vector3, $size: UnityEngine.Vector3) : void
            /** Draws a mesh.
            * @param $mesh Mesh to draw as a gizmo.
            * @param $position Position (default is zero).
            * @param $rotation Rotation (default is no rotation).
            * @param $scale Scale (default is no scale).
            * @param $submeshIndex Submesh to draw (default is -1, which draws whole mesh).
            */
            public static DrawMesh ($mesh: UnityEngine.Mesh, $submeshIndex: number, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $scale: UnityEngine.Vector3) : void
            /** Draws a wireframe mesh.
            * @param $mesh Mesh to draw as a gizmo.
            * @param $position Position (default is zero).
            * @param $rotation Rotation (default is no rotation).
            * @param $scale Scale (default is no scale).
            * @param $submeshIndex Submesh to draw (default is -1, which draws whole mesh).
            */
            public static DrawWireMesh ($mesh: UnityEngine.Mesh, $submeshIndex: number, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $scale: UnityEngine.Vector3) : void
            /** Draw an icon at a position in the Scene view.
            */
            public static DrawIcon ($center: UnityEngine.Vector3, $name: string, $allowScaling: boolean) : void
            public static DrawIcon ($center: UnityEngine.Vector3, $name: string, $allowScaling: boolean, $tint: UnityEngine.Color) : void
            /** Draw a texture in the Scene.
            * @param $screenRect The size and position of the texture on the "screen" defined by the XY plane.
            * @param $texture The texture to be displayed.
            * @param $mat An optional material to apply the texture.
            * @param $leftBorder Inset from the rectangle's left edge.
            * @param $rightBorder Inset from the rectangle's right edge.
            * @param $topBorder Inset from the rectangle's top edge.
            * @param $bottomBorder Inset from the rectangle's bottom edge.
            */
            public static DrawGUITexture ($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number, $mat: UnityEngine.Material) : void
            /** Draw a camera frustum using the currently set Gizmos.matrix for its location and rotation.
            * @param $center The apex of the truncated pyramid.
            * @param $fov Vertical field of view (ie, the angle at the apex in degrees).
            * @param $maxRange Distance of the frustum's far plane.
            * @param $minRange Distance of the frustum's near plane.
            * @param $aspect Width/height ratio.
            */
            public static DrawFrustum ($center: UnityEngine.Vector3, $fov: number, $maxRange: number, $minRange: number, $aspect: number) : void
            /** Determines the appropriate level of detail for a gizmo in the Scene view at a specified position with a specified radius.
            * @param $position The centre of the gizmo in world space.
            * @param $radius The maximum extent of the gizmo.
            * @returns Returns a value between 0 and 1 that represents the level of detail for the gizmo. 
            */
            public static CalculateLOD ($position: UnityEngine.Vector3, $radius: number) : number
            /** Draws a ray starting at from to from + direction.
            */
            public static DrawRay ($r: UnityEngine.Ray) : void
            /** Draws a ray starting at from to from + direction.
            */
            public static DrawRay ($from: UnityEngine.Vector3, $direction: UnityEngine.Vector3) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh) : void
            /** Draws a mesh.
            * @param $mesh Mesh to draw as a gizmo.
            * @param $position Position (default is zero).
            * @param $rotation Rotation (default is no rotation).
            * @param $scale Scale (default is no scale).
            * @param $submeshIndex Submesh to draw (default is -1, which draws whole mesh).
            */
            public static DrawMesh ($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $scale: UnityEngine.Vector3) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $submeshIndex: number, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $submeshIndex: number, $position: UnityEngine.Vector3) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $submeshIndex: number) : void
            public static DrawWireMesh ($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion) : void
            public static DrawWireMesh ($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3) : void
            public static DrawWireMesh ($mesh: UnityEngine.Mesh) : void
            /** Draws a wireframe mesh.
            * @param $mesh Mesh to draw as a gizmo.
            * @param $position Position (default is zero).
            * @param $rotation Rotation (default is no rotation).
            * @param $scale Scale (default is no scale).
            * @param $submeshIndex Submesh to draw (default is -1, which draws whole mesh).
            */
            public static DrawWireMesh ($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $scale: UnityEngine.Vector3) : void
            public static DrawWireMesh ($mesh: UnityEngine.Mesh, $submeshIndex: number, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion) : void
            public static DrawWireMesh ($mesh: UnityEngine.Mesh, $submeshIndex: number, $position: UnityEngine.Vector3) : void
            public static DrawWireMesh ($mesh: UnityEngine.Mesh, $submeshIndex: number) : void
            /** Draw an icon at a position in the Scene view.
            */
            public static DrawIcon ($center: UnityEngine.Vector3, $name: string) : void
            /** Draw a texture in the Scene.
            * @param $screenRect The size and position of the texture on the "screen" defined by the XY plane.
            * @param $texture The texture to be displayed.
            * @param $mat An optional material to apply the texture.
            * @param $leftBorder Inset from the rectangle's left edge.
            * @param $rightBorder Inset from the rectangle's right edge.
            * @param $topBorder Inset from the rectangle's top edge.
            * @param $bottomBorder Inset from the rectangle's bottom edge.
            */
            public static DrawGUITexture ($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture) : void
            /** Draw a texture in the Scene.
            * @param $screenRect The size and position of the texture on the "screen" defined by the XY plane.
            * @param $texture The texture to be displayed.
            * @param $mat An optional material to apply the texture.
            * @param $leftBorder Inset from the rectangle's left edge.
            * @param $rightBorder Inset from the rectangle's right edge.
            * @param $topBorder Inset from the rectangle's top edge.
            * @param $bottomBorder Inset from the rectangle's bottom edge.
            */
            public static DrawGUITexture ($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $mat: UnityEngine.Material) : void
            /** Draw a texture in the Scene.
            * @param $screenRect The size and position of the texture on the "screen" defined by the XY plane.
            * @param $texture The texture to be displayed.
            * @param $mat An optional material to apply the texture.
            * @param $leftBorder Inset from the rectangle's left edge.
            * @param $rightBorder Inset from the rectangle's right edge.
            * @param $topBorder Inset from the rectangle's top edge.
            * @param $bottomBorder Inset from the rectangle's bottom edge.
            */
            public static DrawGUITexture ($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number) : void
            public constructor ()
        }
        /** A class that allows you to create or modify meshes.
        */
        class Mesh extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** Format of the mesh index buffer data.
            */
            public get indexFormat(): UnityEngine.Rendering.IndexFormat;
            public set indexFormat(value: UnityEngine.Rendering.IndexFormat);
            /** Gets the number of vertex buffers present in the Mesh. (Read Only)
            */
            public get vertexBufferCount(): number;
            /** The intended target usage of the Mesh GPU vertex buffer.
            */
            public get vertexBufferTarget(): UnityEngine.GraphicsBuffer.Target;
            public set vertexBufferTarget(value: UnityEngine.GraphicsBuffer.Target);
            /** The intended target usage of the Mesh GPU index buffer.
            */
            public get indexBufferTarget(): UnityEngine.GraphicsBuffer.Target;
            public set indexBufferTarget(value: UnityEngine.GraphicsBuffer.Target);
            /** Returns BlendShape count on this mesh.
            */
            public get blendShapeCount(): number;
            /** The number of bind poses in the Mesh.
            */
            public get bindposeCount(): number;
            /** The bind poses. The bind pose at each index refers to the bone with the same index.
            */
            public get bindposes(): System.Array$1<UnityEngine.Matrix4x4>;
            public set bindposes(value: System.Array$1<UnityEngine.Matrix4x4>);
            /** Returns true if the Mesh is read/write enabled, or false if it is not.
            */
            public get isReadable(): boolean;
            /** Returns the number of vertices in the Mesh (Read Only).
            */
            public get vertexCount(): number;
            /** The number of sub-meshes inside the Mesh object.
            */
            public get subMeshCount(): number;
            public set subMeshCount(value: number);
            /** The bounding volume of the Mesh.
            */
            public get bounds(): UnityEngine.Bounds;
            public set bounds(value: UnityEngine.Bounds);
            /** Returns a copy of the vertex positions or assigns a new vertex positions array.
            */
            public get vertices(): System.Array$1<UnityEngine.Vector3>;
            public set vertices(value: System.Array$1<UnityEngine.Vector3>);
            /** The normals of the Mesh.
            */
            public get normals(): System.Array$1<UnityEngine.Vector3>;
            public set normals(value: System.Array$1<UnityEngine.Vector3>);
            /** The tangents of the Mesh.
            */
            public get tangents(): System.Array$1<UnityEngine.Vector4>;
            public set tangents(value: System.Array$1<UnityEngine.Vector4>);
            /** The texture coordinates (UVs) in the first channel.
            */
            public get uv(): System.Array$1<UnityEngine.Vector2>;
            public set uv(value: System.Array$1<UnityEngine.Vector2>);
            /** The texture coordinates (UVs) in the second channel.
            */
            public get uv2(): System.Array$1<UnityEngine.Vector2>;
            public set uv2(value: System.Array$1<UnityEngine.Vector2>);
            /** The texture coordinates (UVs) in the third channel.
            */
            public get uv3(): System.Array$1<UnityEngine.Vector2>;
            public set uv3(value: System.Array$1<UnityEngine.Vector2>);
            /** The texture coordinates (UVs) in the fourth channel.
            */
            public get uv4(): System.Array$1<UnityEngine.Vector2>;
            public set uv4(value: System.Array$1<UnityEngine.Vector2>);
            /** The texture coordinates (UVs) in the fifth channel.
            */
            public get uv5(): System.Array$1<UnityEngine.Vector2>;
            public set uv5(value: System.Array$1<UnityEngine.Vector2>);
            /** The texture coordinates (UVs) in the sixth channel.
            */
            public get uv6(): System.Array$1<UnityEngine.Vector2>;
            public set uv6(value: System.Array$1<UnityEngine.Vector2>);
            /** The texture coordinates (UVs) in the seventh channel.
            */
            public get uv7(): System.Array$1<UnityEngine.Vector2>;
            public set uv7(value: System.Array$1<UnityEngine.Vector2>);
            /** The texture coordinates (UVs) in the eighth channel.
            */
            public get uv8(): System.Array$1<UnityEngine.Vector2>;
            public set uv8(value: System.Array$1<UnityEngine.Vector2>);
            /** Vertex colors of the Mesh.
            */
            public get colors(): System.Array$1<UnityEngine.Color>;
            public set colors(value: System.Array$1<UnityEngine.Color>);
            /** Vertex colors of the Mesh.
            */
            public get colors32(): System.Array$1<UnityEngine.Color32>;
            public set colors32(value: System.Array$1<UnityEngine.Color32>);
            /** Returns the number of vertex attributes that the mesh has. (Read Only)
            */
            public get vertexAttributeCount(): number;
            /** An array containing all triangles in the Mesh.
            */
            public get triangles(): System.Array$1<number>;
            public set triangles(value: System.Array$1<number>);
            /** The BoneWeight for each vertex in the Mesh, which represents 4 bones per vertex.
            */
            public get boneWeights(): System.Array$1<UnityEngine.BoneWeight>;
            public set boneWeights(value: System.Array$1<UnityEngine.BoneWeight>);
            /** The dimension of data in the bone weight buffer.
            */
            public get skinWeightBufferLayout(): UnityEngine.SkinWeights;
            /** Sets the index buffer size and format.
            * @param $indexCount Size of index buffer.
            * @param $format Format of the indices.
            */
            public SetIndexBufferParams ($indexCount: number, $format: UnityEngine.Rendering.IndexFormat) : void
            /** Returns information about a vertex attribute based on its index.
            * @param $index The vertex attribute index (0 to vertexAttributeCount-1).
            * @returns Information about the vertex attribute. 
            */
            public GetVertexAttribute ($index: number) : UnityEngine.Rendering.VertexAttributeDescriptor
            /** Checks if a specific vertex data attribute exists on this Mesh.
            * @param $attr Vertex data attribute to check for.
            * @returns Returns true if the data attribute is present in the mesh. 
            */
            public HasVertexAttribute ($attr: UnityEngine.Rendering.VertexAttribute) : boolean
            /** Get dimension of a specific vertex data attribute on this Mesh.
            * @param $attr Vertex data attribute to check for.
            * @returns Dimensionality of the data attribute, or zero if it is not present. 
            */
            public GetVertexAttributeDimension ($attr: UnityEngine.Rendering.VertexAttribute) : number
            /** Get format of a specific vertex data attribute on this Mesh.
            * @param $attr Vertex data attribute to check for.
            * @returns Format of the data attribute. 
            */
            public GetVertexAttributeFormat ($attr: UnityEngine.Rendering.VertexAttribute) : UnityEngine.Rendering.VertexAttributeFormat
            /** Gets the vertex buffer stream index of a specific vertex data attribute on this Mesh.
            * @param $attr The vertex data attribute to check for.
            * @returns Stream index of the data attribute, or -1 if it is not present. 
            */
            public GetVertexAttributeStream ($attr: UnityEngine.Rendering.VertexAttribute) : number
            /** Get offset within a vertex buffer stream of a specific vertex data attribute on this Mesh.
            * @param $attr The vertex data attribute to check for.
            * @returns The byte offset within a atream of the data attribute, or -1 if it is not present. 
            */
            public GetVertexAttributeOffset ($attr: UnityEngine.Rendering.VertexAttribute) : number
            /** Get vertex buffer stream stride in bytes.
            * @param $stream Vertex data stream index to check for.
            * @returns Vertex data size in bytes in this stream, or zero if the stream is not present. 
            */
            public GetVertexBufferStride ($stream: number) : number
            /** Retrieves a native (underlying graphics API) pointer to the vertex buffer.
            * @param $index Which vertex buffer to get (some Meshes might have more than one). See vertexBufferCount.
            * @returns Pointer to the underlying graphics API vertex buffer. 
            */
            public GetNativeVertexBufferPtr ($index: number) : System.IntPtr
            /** Retrieves a native (underlying graphics API) pointer to the index buffer.
            * @returns Pointer to the underlying graphics API index buffer. 
            */
            public GetNativeIndexBufferPtr () : System.IntPtr
            /** Clears all blend shapes from Mesh.
            */
            public ClearBlendShapes () : void
            /** Returns name of BlendShape by given index.
            */
            public GetBlendShapeName ($shapeIndex: number) : string
            /** Returns index of BlendShape by given name.
            */
            public GetBlendShapeIndex ($blendShapeName: string) : number
            /** Returns the frame count for a blend shape.
            * @param $shapeIndex The shape index to get frame count from.
            */
            public GetBlendShapeFrameCount ($shapeIndex: number) : number
            /** Returns the weight of a blend shape frame.
            * @param $shapeIndex The shape index of the frame.
            * @param $frameIndex The frame index to get the weight from.
            */
            public GetBlendShapeFrameWeight ($shapeIndex: number, $frameIndex: number) : number
            /** Retreives deltaVertices, deltaNormals and deltaTangents of a blend shape frame.
            * @param $shapeIndex The shape index of the frame.
            * @param $frameIndex The frame index to get the weight from.
            * @param $deltaVertices Delta vertices output array for the frame being retreived.
            * @param $deltaNormals Delta normals output array for the frame being retreived.
            * @param $deltaTangents Delta tangents output array for the frame being retreived.
            */
            public GetBlendShapeFrameVertices ($shapeIndex: number, $frameIndex: number, $deltaVertices: System.Array$1<UnityEngine.Vector3>, $deltaNormals: System.Array$1<UnityEngine.Vector3>, $deltaTangents: System.Array$1<UnityEngine.Vector3>) : void
            /** Adds a new blend shape frame.
            * @param $shapeName Name of the blend shape to add a frame to.
            * @param $frameWeight Weight for the frame being added.
            * @param $deltaVertices Delta vertices for the frame being added.
            * @param $deltaNormals Delta normals for the frame being added.
            * @param $deltaTangents Delta tangents for the frame being added.
            */
            public AddBlendShapeFrame ($shapeName: string, $frameWeight: number, $deltaVertices: System.Array$1<UnityEngine.Vector3>, $deltaNormals: System.Array$1<UnityEngine.Vector3>, $deltaTangents: System.Array$1<UnityEngine.Vector3>) : void
            public SetBoneWeights ($bonesPerVertex: Unity.Collections.NativeArray$1<number>, $weights: Unity.Collections.NativeArray$1<UnityEngine.BoneWeight1>) : void
            /** Gets the bone weights for the Mesh.
            * @returns Returns all non-zero bone weights for the Mesh, in vertex index order. 
            */
            public GetAllBoneWeights () : Unity.Collections.NativeArray$1<UnityEngine.BoneWeight1>
            /** The number of non-zero bone weights for each vertex.
            * @returns Returns the number of non-zero bone weights for each vertex. 
            */
            public GetBonesPerVertex () : Unity.Collections.NativeArray$1<number>
            /** Gets the bind poses of the Mesh.
            * @returns The array of bind poses belonging to the Mesh. 
            */
            public GetBindposes () : Unity.Collections.NativeArray$1<UnityEngine.Matrix4x4>
            public SetBindposes ($poses: Unity.Collections.NativeArray$1<UnityEngine.Matrix4x4>) : void
            /** Sets the information about a sub-mesh of the Mesh.
            * @param $index Sub-mesh index. See subMeshCount. Out of range indices throw an exception.
            * @param $desc Sub-mesh data.
            * @param $flags Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public SetSubMesh ($index: number, $desc: UnityEngine.Rendering.SubMeshDescriptor, $flags?: UnityEngine.Rendering.MeshUpdateFlags) : void
            /** Get information about a sub-mesh of the Mesh.
            * @param $index Sub-mesh index. See subMeshCount. Out of range indices throw an exception.
            * @returns Sub-mesh data. 
            */
            public GetSubMesh ($index: number) : UnityEngine.Rendering.SubMeshDescriptor
            /** Notify Renderer components of mesh geometry change.
            */
            public MarkModified () : void
            /** The UV distribution metric can be used to calculate the desired mipmap level based on the position of the camera.
            * @param $uvSetIndex UV set index to return the UV distibution metric for. 0 for first.
            * @returns Average of triangle area / uv area. 
            */
            public GetUVDistributionMetric ($uvSetIndex: number) : number
            public GetVertices ($vertices: System.Collections.Generic.List$1<UnityEngine.Vector3>) : void
            public SetVertices ($inVertices: System.Collections.Generic.List$1<UnityEngine.Vector3>) : void
            public SetVertices ($inVertices: System.Collections.Generic.List$1<UnityEngine.Vector3>, $start: number, $length: number) : void
            public SetVertices ($inVertices: System.Collections.Generic.List$1<UnityEngine.Vector3>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags) : void
            /** Assigns a new vertex positions array.
            * @param $inVertices Per-vertex positions.
            */
            public SetVertices ($inVertices: System.Array$1<UnityEngine.Vector3>) : void
            /** Sets the vertex positions of the Mesh, using a part of the input array.
            * @param $inVertices Per-vertex positions.
            * @param $start Index of the first element to take from the input array.
            * @param $length Number of elements to take from the input array.
            * @param $flags Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public SetVertices ($inVertices: System.Array$1<UnityEngine.Vector3>, $start: number, $length: number) : void
            /** Sets the vertex positions of the Mesh, using a part of the input array.
            * @param $inVertices Per-vertex positions.
            * @param $start Index of the first element to take from the input array.
            * @param $length Number of elements to take from the input array.
            * @param $flags Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public SetVertices ($inVertices: System.Array$1<UnityEngine.Vector3>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags) : void
            public GetNormals ($normals: System.Collections.Generic.List$1<UnityEngine.Vector3>) : void
            public SetNormals ($inNormals: System.Collections.Generic.List$1<UnityEngine.Vector3>) : void
            public SetNormals ($inNormals: System.Collections.Generic.List$1<UnityEngine.Vector3>, $start: number, $length: number) : void
            public SetNormals ($inNormals: System.Collections.Generic.List$1<UnityEngine.Vector3>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags) : void
            /** Set the normals of the Mesh.
            * @param $inNormals Per-vertex normals.
            */
            public SetNormals ($inNormals: System.Array$1<UnityEngine.Vector3>) : void
            /** Sets the vertex normals of the Mesh, using a part of the input array.
            * @param $inNormals Per-vertex normals.
            * @param $start Index of the first element to take from the input array.
            * @param $length Number of elements to take from the input array.
            * @param $flags Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public SetNormals ($inNormals: System.Array$1<UnityEngine.Vector3>, $start: number, $length: number) : void
            /** Sets the vertex normals of the Mesh, using a part of the input array.
            * @param $inNormals Per-vertex normals.
            * @param $start Index of the first element to take from the input array.
            * @param $length Number of elements to take from the input array.
            * @param $flags Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public SetNormals ($inNormals: System.Array$1<UnityEngine.Vector3>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags) : void
            public GetTangents ($tangents: System.Collections.Generic.List$1<UnityEngine.Vector4>) : void
            public SetTangents ($inTangents: System.Collections.Generic.List$1<UnityEngine.Vector4>) : void
            public SetTangents ($inTangents: System.Collections.Generic.List$1<UnityEngine.Vector4>, $start: number, $length: number) : void
            public SetTangents ($inTangents: System.Collections.Generic.List$1<UnityEngine.Vector4>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags) : void
            /** Set the tangents of the Mesh.
            * @param $inTangents Per-vertex tangents.
            */
            public SetTangents ($inTangents: System.Array$1<UnityEngine.Vector4>) : void
            /** Sets the tangents of the Mesh, using a part of the input array.
            * @param $inTangents Per-vertex tangents.
            * @param $start Index of the first element to take from the input array.
            * @param $length Number of elements to take from the input array.
            * @param $flags Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public SetTangents ($inTangents: System.Array$1<UnityEngine.Vector4>, $start: number, $length: number) : void
            /** Sets the tangents of the Mesh, using a part of the input array.
            * @param $inTangents Per-vertex tangents.
            * @param $start Index of the first element to take from the input array.
            * @param $length Number of elements to take from the input array.
            * @param $flags Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public SetTangents ($inTangents: System.Array$1<UnityEngine.Vector4>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags) : void
            public GetColors ($colors: System.Collections.Generic.List$1<UnityEngine.Color>) : void
            public SetColors ($inColors: System.Collections.Generic.List$1<UnityEngine.Color>) : void
            public SetColors ($inColors: System.Collections.Generic.List$1<UnityEngine.Color>, $start: number, $length: number) : void
            public SetColors ($inColors: System.Collections.Generic.List$1<UnityEngine.Color>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags) : void
            /** Set the per-vertex colors of the Mesh.
            * @param $inColors Per-vertex colors.
            */
            public SetColors ($inColors: System.Array$1<UnityEngine.Color>) : void
            /** Sets the per-vertex colors of the Mesh, using a part of the input array.
            * @param $inColors Per-vertex colors.
            * @param $start Index of the first element to take from the input array.
            * @param $length Number of elements to take from the input array.
            * @param $flags Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public SetColors ($inColors: System.Array$1<UnityEngine.Color>, $start: number, $length: number) : void
            /** Sets the per-vertex colors of the Mesh, using a part of the input array.
            * @param $inColors Per-vertex colors.
            * @param $start Index of the first element to take from the input array.
            * @param $length Number of elements to take from the input array.
            * @param $flags Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public SetColors ($inColors: System.Array$1<UnityEngine.Color>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags) : void
            public GetColors ($colors: System.Collections.Generic.List$1<UnityEngine.Color32>) : void
            public SetColors ($inColors: System.Collections.Generic.List$1<UnityEngine.Color32>) : void
            public SetColors ($inColors: System.Collections.Generic.List$1<UnityEngine.Color32>, $start: number, $length: number) : void
            public SetColors ($inColors: System.Collections.Generic.List$1<UnityEngine.Color32>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags) : void
            /** Set the per-vertex colors of the Mesh.
            * @param $inColors Per-vertex colors.
            */
            public SetColors ($inColors: System.Array$1<UnityEngine.Color32>) : void
            /** Sets the per-vertex colors of the Mesh, using a part of the input array.
            * @param $inColors Per-vertex colors.
            * @param $start Index of the first element to take from the input array.
            * @param $length Number of elements to take from the input array.
            * @param $flags Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public SetColors ($inColors: System.Array$1<UnityEngine.Color32>, $start: number, $length: number) : void
            /** Sets the per-vertex colors of the Mesh, using a part of the input array.
            * @param $inColors Per-vertex colors.
            * @param $start Index of the first element to take from the input array.
            * @param $length Number of elements to take from the input array.
            * @param $flags Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public SetColors ($inColors: System.Array$1<UnityEngine.Color32>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags) : void
            public SetUVs ($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector2>) : void
            public SetUVs ($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector3>) : void
            public SetUVs ($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector4>) : void
            public SetUVs ($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector2>, $start: number, $length: number) : void
            public SetUVs ($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector2>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags) : void
            public SetUVs ($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector3>, $start: number, $length: number) : void
            public SetUVs ($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector3>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags) : void
            public SetUVs ($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector4>, $start: number, $length: number) : void
            public SetUVs ($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector4>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags) : void
            /** Sets the texture coordinates (UVs) stored in a given channel.
            * @param $channel The channel, in [0..7] range.
            * @param $uvs The UV data to set.
            */
            public SetUVs ($channel: number, $uvs: System.Array$1<UnityEngine.Vector2>) : void
            /** Sets the texture coordinates (UVs) stored in a given channel.
            * @param $channel The channel, in [0..7] range.
            * @param $uvs The UV data to set.
            */
            public SetUVs ($channel: number, $uvs: System.Array$1<UnityEngine.Vector3>) : void
            /** Sets the texture coordinates (UVs) stored in a given channel.
            * @param $channel The channel, in [0..7] range.
            * @param $uvs The UV data to set.
            */
            public SetUVs ($channel: number, $uvs: System.Array$1<UnityEngine.Vector4>) : void
            /** Sets the UVs of the Mesh, using a part of the input array.
            * @param $channel The UV channel, in [0..7] range.
            * @param $uvs UVs to set for the given index.
            * @param $start Index of the first element to take from the input array.
            * @param $length Number of elements to take from the input array.
            * @param $flags Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public SetUVs ($channel: number, $uvs: System.Array$1<UnityEngine.Vector2>, $start: number, $length: number) : void
            /** Sets the UVs of the Mesh, using a part of the input array.
            * @param $channel The UV channel, in [0..7] range.
            * @param $uvs UVs to set for the given index.
            * @param $start Index of the first element to take from the input array.
            * @param $length Number of elements to take from the input array.
            * @param $flags Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public SetUVs ($channel: number, $uvs: System.Array$1<UnityEngine.Vector2>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags) : void
            /** Sets the UVs of the Mesh, using a part of the input array.
            * @param $channel The UV channel, in [0..7] range.
            * @param $uvs UVs to set for the given index.
            * @param $start Index of the first element to take from the input array.
            * @param $length Number of elements to take from the input array.
            * @param $flags Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public SetUVs ($channel: number, $uvs: System.Array$1<UnityEngine.Vector3>, $start: number, $length: number) : void
            /** Sets the UVs of the Mesh, using a part of the input array.
            * @param $channel The UV channel, in [0..7] range.
            * @param $uvs UVs to set for the given index.
            * @param $start Index of the first element to take from the input array.
            * @param $length Number of elements to take from the input array.
            * @param $flags Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public SetUVs ($channel: number, $uvs: System.Array$1<UnityEngine.Vector3>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags) : void
            /** Sets the UVs of the Mesh, using a part of the input array.
            * @param $channel The UV channel, in [0..7] range.
            * @param $uvs UVs to set for the given index.
            * @param $start Index of the first element to take from the input array.
            * @param $length Number of elements to take from the input array.
            * @param $flags Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public SetUVs ($channel: number, $uvs: System.Array$1<UnityEngine.Vector4>, $start: number, $length: number) : void
            /** Sets the UVs of the Mesh, using a part of the input array.
            * @param $channel The UV channel, in [0..7] range.
            * @param $uvs UVs to set for the given index.
            * @param $start Index of the first element to take from the input array.
            * @param $length Number of elements to take from the input array.
            * @param $flags Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public SetUVs ($channel: number, $uvs: System.Array$1<UnityEngine.Vector4>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags) : void
            public GetUVs ($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector2>) : void
            public GetUVs ($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector3>) : void
            public GetUVs ($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector4>) : void
            /** Get information about vertex attributes of a Mesh.
            * @returns Array of vertex attribute information. 
            */
            public GetVertexAttributes () : System.Array$1<UnityEngine.Rendering.VertexAttributeDescriptor>
            /** Get information about vertex attributes of a Mesh, without memory allocations.
            * @param $attributes Collection of vertex attributes to receive the results.
            * @returns The number of vertex attributes returned in the attributes container. 
            */
            public GetVertexAttributes ($attributes: System.Array$1<UnityEngine.Rendering.VertexAttributeDescriptor>) : number
            public GetVertexAttributes ($attributes: System.Collections.Generic.List$1<UnityEngine.Rendering.VertexAttributeDescriptor>) : number
            /** Sets the vertex buffer size and layout.
            * @param $vertexCount The number of vertices in the Mesh.
            * @param $attributes Layout of the vertex data -- which attributes are present, their data types and so on.
            */
            public SetVertexBufferParams ($vertexCount: number, ...attributes: UnityEngine.Rendering.VertexAttributeDescriptor[]) : void
            public SetVertexBufferParams ($vertexCount: number, $attributes: Unity.Collections.NativeArray$1<UnityEngine.Rendering.VertexAttributeDescriptor>) : void
            /** Gets a snapshot of Mesh data for read-only access.
            * @param $mesh The input mesh.
            * @param $meshes The input meshes.
            * @returns Returns a MeshDataArray containing read-only MeshData structs. See Mesh.MeshDataArray and Mesh.MeshData. 
            */
            public static AcquireReadOnlyMeshData ($mesh: UnityEngine.Mesh) : UnityEngine.Mesh.MeshDataArray
            /** Gets a snapshot of Mesh data for read-only access.
            * @param $mesh The input mesh.
            * @param $meshes The input meshes.
            * @returns Returns a MeshDataArray containing read-only MeshData structs. See Mesh.MeshDataArray and Mesh.MeshData. 
            */
            public static AcquireReadOnlyMeshData ($meshes: System.Array$1<UnityEngine.Mesh>) : UnityEngine.Mesh.MeshDataArray
            public static AcquireReadOnlyMeshData ($meshes: System.Collections.Generic.List$1<UnityEngine.Mesh>) : UnityEngine.Mesh.MeshDataArray
            /** Allocates data structures for Mesh creation using C# Jobs.
            * @param $meshCount The amount of meshes that will be created.
            * @returns Returns a MeshDataArray containing writeable MeshData structs. See Mesh.MeshDataArray and Mesh.MeshData. 
            */
            public static AllocateWritableMeshData ($meshCount: number) : UnityEngine.Mesh.MeshDataArray
            public static AllocateWritableMeshData ($mesh: UnityEngine.Mesh) : UnityEngine.Mesh.MeshDataArray
            public static AllocateWritableMeshData ($meshes: System.Array$1<UnityEngine.Mesh>) : UnityEngine.Mesh.MeshDataArray
            public static AllocateWritableMeshData ($meshes: System.Collections.Generic.List$1<UnityEngine.Mesh>) : UnityEngine.Mesh.MeshDataArray
            public static ApplyAndDisposeWritableMeshData ($data: UnityEngine.Mesh.MeshDataArray, $mesh: UnityEngine.Mesh, $flags?: UnityEngine.Rendering.MeshUpdateFlags) : void
            public static ApplyAndDisposeWritableMeshData ($data: UnityEngine.Mesh.MeshDataArray, $meshes: System.Array$1<UnityEngine.Mesh>, $flags?: UnityEngine.Rendering.MeshUpdateFlags) : void
            public static ApplyAndDisposeWritableMeshData ($data: UnityEngine.Mesh.MeshDataArray, $meshes: System.Collections.Generic.List$1<UnityEngine.Mesh>, $flags?: UnityEngine.Rendering.MeshUpdateFlags) : void
            /** Retrieves a GraphicsBuffer that provides direct acces to the GPU vertex buffer.
            * @param $index Vertex data stream index to get the buffer for.
            * @returns The mesh vertex buffer as a GraphicsBuffer. 
            */
            public GetVertexBuffer ($index: number) : UnityEngine.GraphicsBuffer
            /** Retrieves a GraphicsBuffer to the GPU index buffer.
            * @returns The mesh index buffer as a GraphicsBuffer. 
            */
            public GetIndexBuffer () : UnityEngine.GraphicsBuffer
            /** Retrieves a GraphicsBuffer that provides direct read and write access to GPU bone weight data.
            * @param $layout Which buffer to access, based on maximum bones per vertex.
            * @returns The bone weight data as a GraphicsBuffer. 
            */
            public GetBoneWeightBuffer ($layout: UnityEngine.SkinWeights) : UnityEngine.GraphicsBuffer
            /** Retrieves a GraphicsBuffer that provides direct read and write access to GPU blend shape vertex data.
            * @param $layout Which buffer to access. The default value is Rendering.BlendShapeBufferLayout.PerShape.
            * @returns The blend shape vertex data as a GraphicsBuffer. 
            */
            public GetBlendShapeBuffer ($layout: UnityEngine.Rendering.BlendShapeBufferLayout) : UnityEngine.GraphicsBuffer
            /** Retrieves a GraphicsBuffer that provides direct read and write access to GPU blend shape vertex data.
            * @param $layout Which buffer to access. The default value is Rendering.BlendShapeBufferLayout.PerShape.
            * @returns The blend shape vertex data as a GraphicsBuffer. 
            */
            public GetBlendShapeBuffer () : UnityEngine.GraphicsBuffer
            /** Get the location of blend shape vertex data for a given blend shape.
            * @param $blendShapeIndex Which blend shape to locate the data for.
            * @returns A struct that describes the start and end index of the data for the given blend shape. 
            */
            public GetBlendShapeBufferRange ($blendShapeIndex: number) : UnityEngine.BlendShapeBufferRange
            /** Fetches the triangle list for the specified sub-mesh on this object.
            * @param $triangles A list of vertex indices to populate. Any existing items in the list are replaced.
            * @param $submesh The sub-mesh index. See subMeshCount.
            * @param $applyBaseVertex True (default value) will apply base vertex offset to returned indices.
            */
            public GetTriangles ($submesh: number) : System.Array$1<number>
            /** Fetches the triangle list for the specified sub-mesh on this object.
            * @param $triangles A list of vertex indices to populate. Any existing items in the list are replaced.
            * @param $submesh The sub-mesh index. See subMeshCount.
            * @param $applyBaseVertex True (default value) will apply base vertex offset to returned indices.
            */
            public GetTriangles ($submesh: number, $applyBaseVertex: boolean) : System.Array$1<number>
            public GetTriangles ($triangles: System.Collections.Generic.List$1<number>, $submesh: number) : void
            public GetTriangles ($triangles: System.Collections.Generic.List$1<number>, $submesh: number, $applyBaseVertex: boolean) : void
            public GetTriangles ($triangles: System.Collections.Generic.List$1<number>, $submesh: number, $applyBaseVertex?: boolean) : void
            /** Fetches the index list for the specified sub-mesh.
            * @param $submesh The sub-mesh index. See subMeshCount.
            * @param $applyBaseVertex True (default value) will apply base vertex offset to returned indices.
            * @returns Array with face indices. 
            */
            public GetIndices ($submesh: number) : System.Array$1<number>
            /** Fetches the index list for the specified sub-mesh.
            * @param $submesh The sub-mesh index. See subMeshCount.
            * @param $applyBaseVertex True (default value) will apply base vertex offset to returned indices.
            * @returns Array with face indices. 
            */
            public GetIndices ($submesh: number, $applyBaseVertex: boolean) : System.Array$1<number>
            public GetIndices ($indices: System.Collections.Generic.List$1<number>, $submesh: number) : void
            public GetIndices ($indices: System.Collections.Generic.List$1<number>, $submesh: number, $applyBaseVertex: boolean) : void
            public GetIndices ($indices: System.Collections.Generic.List$1<number>, $submesh: number, $applyBaseVertex?: boolean) : void
            /** Gets the starting index location within the Mesh's index buffer, for the given sub-mesh.
            */
            public GetIndexStart ($submesh: number) : number
            /** Gets the index count of the given sub-mesh.
            */
            public GetIndexCount ($submesh: number) : number
            /** Gets the base vertex index of the given sub-mesh.
            * @param $submesh The sub-mesh index. See subMeshCount.
            * @returns The offset applied to all vertex indices of this sub-mesh. 
            */
            public GetBaseVertex ($submesh: number) : number
            /** Sets the triangle list for the sub-mesh.
            * @param $triangles The list of indices that define the triangles.
            * @param $submesh The sub-mesh to modify.
            * @param $calculateBounds Calculate the bounding box of the Mesh after setting the triangles. This is done by default.
            Use false when you want to use the existing bounding box and reduce the CPU cost of setting the triangles.
            * @param $baseVertex Optional vertex offset that is added to all triangle vertex indices.
            */
            public SetTriangles ($triangles: System.Array$1<number>, $submesh: number) : void
            /** Sets the triangle list for the sub-mesh.
            * @param $triangles The list of indices that define the triangles.
            * @param $submesh The sub-mesh to modify.
            * @param $calculateBounds Calculate the bounding box of the Mesh after setting the triangles. This is done by default.
            Use false when you want to use the existing bounding box and reduce the CPU cost of setting the triangles.
            * @param $baseVertex Optional vertex offset that is added to all triangle vertex indices.
            */
            public SetTriangles ($triangles: System.Array$1<number>, $submesh: number, $calculateBounds: boolean) : void
            /** Sets the triangle list for the sub-mesh.
            * @param $triangles The list of indices that define the triangles.
            * @param $submesh The sub-mesh to modify.
            * @param $calculateBounds Calculate the bounding box of the Mesh after setting the triangles. This is done by default.
            Use false when you want to use the existing bounding box and reduce the CPU cost of setting the triangles.
            * @param $baseVertex Optional vertex offset that is added to all triangle vertex indices.
            */
            public SetTriangles ($triangles: System.Array$1<number>, $submesh: number, $calculateBounds: boolean, $baseVertex: number) : void
            /** Sets the triangle list of the Mesh, using a part of the input array.
            * @param $triangles The list of indices that define the triangles.
            * @param $trianglesStart Index of the first element to take from the input array.
            * @param $trianglesLength Number of elements to take from the input array.
            * @param $submesh The sub-mesh to modify.
            * @param $calculateBounds Calculate the bounding box of the Mesh after setting the triangles. This is done by default.
            Use false when you want to use the existing bounding box and reduce the CPU cost of setting the triangles.
            * @param $baseVertex Optional vertex offset that is added to all triangle vertex indices.
            */
            public SetTriangles ($triangles: System.Array$1<number>, $trianglesStart: number, $trianglesLength: number, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number) : void
            /** Sets the triangle list for the sub-mesh.
            * @param $triangles The list of indices that define the triangles.
            * @param $submesh The sub-mesh to modify.
            * @param $calculateBounds Calculate the bounding box of the Mesh after setting the triangles. This is done by default.
            Use false when you want to use the existing bounding box and reduce the CPU cost of setting the triangles.
            * @param $baseVertex Optional vertex offset that is added to all triangle vertex indices.
            */
            public SetTriangles ($triangles: System.Array$1<number>, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number) : void
            public SetTriangles ($triangles: System.Collections.Generic.List$1<number>, $submesh: number) : void
            public SetTriangles ($triangles: System.Collections.Generic.List$1<number>, $submesh: number, $calculateBounds: boolean) : void
            public SetTriangles ($triangles: System.Collections.Generic.List$1<number>, $submesh: number, $calculateBounds: boolean, $baseVertex: number) : void
            public SetTriangles ($triangles: System.Collections.Generic.List$1<number>, $trianglesStart: number, $trianglesLength: number, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number) : void
            public SetTriangles ($triangles: System.Collections.Generic.List$1<number>, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number) : void
            /** Sets the index buffer for the sub-mesh.
            * @param $indices The array of indices that define the mesh faces.
            * @param $topology The topology of the Mesh, e.g: Triangles, Lines, Quads, Points, etc. See MeshTopology.
            * @param $submesh The sub-mesh to modify.
            * @param $calculateBounds Calculate the bounding box of the sub-mesh after setting the indices. Unity does this by default.
            Use false when you want to use the existing bounding box and reduce the CPU cost of setting the indices.
            * @param $baseVertex Optional vertex offset that is added to all vertex indices.
            */
            public SetIndices ($indices: System.Array$1<number>, $topology: UnityEngine.MeshTopology, $submesh: number) : void
            /** Sets the index buffer for the sub-mesh.
            * @param $indices The array of indices that define the mesh faces.
            * @param $topology The topology of the Mesh, e.g: Triangles, Lines, Quads, Points, etc. See MeshTopology.
            * @param $submesh The sub-mesh to modify.
            * @param $calculateBounds Calculate the bounding box of the sub-mesh after setting the indices. Unity does this by default.
            Use false when you want to use the existing bounding box and reduce the CPU cost of setting the indices.
            * @param $baseVertex Optional vertex offset that is added to all vertex indices.
            */
            public SetIndices ($indices: System.Array$1<number>, $topology: UnityEngine.MeshTopology, $submesh: number, $calculateBounds: boolean) : void
            /** Sets the index buffer for the sub-mesh.
            * @param $indices The array of indices that define the mesh faces.
            * @param $topology The topology of the Mesh, e.g: Triangles, Lines, Quads, Points, etc. See MeshTopology.
            * @param $submesh The sub-mesh to modify.
            * @param $calculateBounds Calculate the bounding box of the sub-mesh after setting the indices. Unity does this by default.
            Use false when you want to use the existing bounding box and reduce the CPU cost of setting the indices.
            * @param $baseVertex Optional vertex offset that is added to all vertex indices.
            */
            public SetIndices ($indices: System.Array$1<number>, $topology: UnityEngine.MeshTopology, $submesh: number, $calculateBounds: boolean, $baseVertex: number) : void
            /** Sets the index buffer of a sub-mesh, using a part of the input array.
            * @param $indices The array of indices that define the mesh faces.
            * @param $indicesStart Index of the first element to take from the input array.
            * @param $indicesLength Number of elements to take from the input array.
            * @param $topology The topology of the Mesh, e.g: Triangles, Lines, Quads, Points, etc. See MeshTopology.
            * @param $submesh The sub-mesh to modify.
            * @param $calculateBounds Calculate the bounding box of the sub-mesh after setting the indices. Unity does this by default.
            Use false when you want to use the existing bounding box and reduce the CPU cost of setting the indices.
            * @param $baseVertex Optional vertex offset that is added to all vertex indices.
            */
            public SetIndices ($indices: System.Array$1<number>, $indicesStart: number, $indicesLength: number, $topology: UnityEngine.MeshTopology, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number) : void
            /** Sets the index buffer for the sub-mesh.
            * @param $indices The array of indices that define the mesh faces.
            * @param $topology The topology of the Mesh, e.g: Triangles, Lines, Quads, Points, etc. See MeshTopology.
            * @param $submesh The sub-mesh to modify.
            * @param $calculateBounds Calculate the bounding box of the sub-mesh after setting the indices. Unity does this by default.
            Use false when you want to use the existing bounding box and reduce the CPU cost of setting the indices.
            * @param $baseVertex Optional vertex offset that is added to all vertex indices.
            */
            public SetIndices ($indices: System.Array$1<number>, $topology: UnityEngine.MeshTopology, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number) : void
            public SetIndices ($indices: System.Collections.Generic.List$1<number>, $topology: UnityEngine.MeshTopology, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number) : void
            public SetIndices ($indices: System.Collections.Generic.List$1<number>, $indicesStart: number, $indicesLength: number, $topology: UnityEngine.MeshTopology, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number) : void
            /** Sets information defining all sub-meshes in this Mesh, replacing any existing sub-meshes.
            * @param $desc An array or list of sub-mesh data descriptors.
            * @param $start Index of the first element to take from the array or list in desc.
            * @param $count Number of elements to take from the array or list in desc.
            * @param $flags (Optional) Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public SetSubMeshes ($desc: System.Array$1<UnityEngine.Rendering.SubMeshDescriptor>, $start: number, $count: number, $flags?: UnityEngine.Rendering.MeshUpdateFlags) : void
            /** Sets information defining all sub-meshes in this Mesh, replacing any existing sub-meshes.
            * @param $desc An array or list of sub-mesh data descriptors.
            * @param $start Index of the first element to take from the array or list in desc.
            * @param $count Number of elements to take from the array or list in desc.
            * @param $flags (Optional) Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public SetSubMeshes ($desc: System.Array$1<UnityEngine.Rendering.SubMeshDescriptor>, $flags?: UnityEngine.Rendering.MeshUpdateFlags) : void
            public SetSubMeshes ($desc: System.Collections.Generic.List$1<UnityEngine.Rendering.SubMeshDescriptor>, $start: number, $count: number, $flags?: UnityEngine.Rendering.MeshUpdateFlags) : void
            public SetSubMeshes ($desc: System.Collections.Generic.List$1<UnityEngine.Rendering.SubMeshDescriptor>, $flags?: UnityEngine.Rendering.MeshUpdateFlags) : void
            public GetBindposes ($bindposes: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>) : void
            public GetBoneWeights ($boneWeights: System.Collections.Generic.List$1<UnityEngine.BoneWeight>) : void
            /** Clears all vertex data and all triangle indices.
            * @param $keepVertexLayout True if the existing Mesh data layout should be preserved.
            */
            public Clear ($keepVertexLayout: boolean) : void
            public Clear () : void
            public RecalculateBounds () : void
            public RecalculateNormals () : void
            public RecalculateTangents () : void
            /** Recalculate the bounding volume of the Mesh and all of its sub-meshes with the vertex data.
            * @param $flags Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public RecalculateBounds ($flags: UnityEngine.Rendering.MeshUpdateFlags) : void
            /** Recalculates the normals of the Mesh from the triangles and vertices.
            * @param $flags Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public RecalculateNormals ($flags: UnityEngine.Rendering.MeshUpdateFlags) : void
            /** Recalculates the tangents of the Mesh from the normals and texture coordinates.
            * @param $flags Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public RecalculateTangents ($flags: UnityEngine.Rendering.MeshUpdateFlags) : void
            /** Recalculates the UV distribution metric of the Mesh from the vertices and uv coordinates.
            * @param $uvSetIndex The UV set index to set the UV distibution metric for. Use 0 for first index.
            * @param $uvAreaThreshold The minimum UV area to consider. The default value is 1e-9f.
            */
            public RecalculateUVDistributionMetric ($uvSetIndex: number, $uvAreaThreshold?: number) : void
            /** Recalculates the UV distribution metrics of the Mesh from the vertices and uv coordinates.
            * @param $uvAreaThreshold The minimum UV area to consider. The default value is 1e-9f.
            */
            public RecalculateUVDistributionMetrics ($uvAreaThreshold?: number) : void
            /** Optimize mesh for frequent updates.
            */
            public MarkDynamic () : void
            /** Upload previously done Mesh modifications to the graphics API.
            * @param $markNoLongerReadable Frees up system memory copy of mesh data when set to true.
            */
            public UploadMeshData ($markNoLongerReadable: boolean) : void
            /** Optimizes the Mesh data to improve rendering performance.
            */
            public Optimize () : void
            /** Optimizes the geometry of the Mesh to improve rendering performance.
            */
            public OptimizeIndexBuffers () : void
            /** Optimizes the vertices of the Mesh to improve rendering performance.
            */
            public OptimizeReorderVertexBuffer () : void
            /** Gets the topology of a sub-mesh.
            */
            public GetTopology ($submesh: number) : UnityEngine.MeshTopology
            /** Combines several Meshes into this Mesh.
            * @param $combine Descriptions of the Meshes to combine.
            * @param $mergeSubMeshes Defines whether Meshes should be combined into a single sub-mesh.
            * @param $useMatrices Defines whether the transforms supplied in the CombineInstance array should be used or ignored.
            * @param $hasLightmapData Defines whether to transform the input Mesh lightmap UV data using the lightmap scale offset data in CombineInstance structs.
            */
            public CombineMeshes ($combine: System.Array$1<UnityEngine.CombineInstance>, $mergeSubMeshes: boolean, $useMatrices: boolean, $hasLightmapData: boolean) : void
            /** Combines several Meshes into this Mesh.
            * @param $combine Descriptions of the Meshes to combine.
            * @param $mergeSubMeshes Defines whether Meshes should be combined into a single sub-mesh.
            * @param $useMatrices Defines whether the transforms supplied in the CombineInstance array should be used or ignored.
            * @param $hasLightmapData Defines whether to transform the input Mesh lightmap UV data using the lightmap scale offset data in CombineInstance structs.
            */
            public CombineMeshes ($combine: System.Array$1<UnityEngine.CombineInstance>, $mergeSubMeshes: boolean, $useMatrices: boolean) : void
            /** Combines several Meshes into this Mesh.
            * @param $combine Descriptions of the Meshes to combine.
            * @param $mergeSubMeshes Defines whether Meshes should be combined into a single sub-mesh.
            * @param $useMatrices Defines whether the transforms supplied in the CombineInstance array should be used or ignored.
            * @param $hasLightmapData Defines whether to transform the input Mesh lightmap UV data using the lightmap scale offset data in CombineInstance structs.
            */
            public CombineMeshes ($combine: System.Array$1<UnityEngine.CombineInstance>, $mergeSubMeshes: boolean) : void
            /** Combines several Meshes into this Mesh.
            * @param $combine Descriptions of the Meshes to combine.
            * @param $mergeSubMeshes Defines whether Meshes should be combined into a single sub-mesh.
            * @param $useMatrices Defines whether the transforms supplied in the CombineInstance array should be used or ignored.
            * @param $hasLightmapData Defines whether to transform the input Mesh lightmap UV data using the lightmap scale offset data in CombineInstance structs.
            */
            public CombineMeshes ($combine: System.Array$1<UnityEngine.CombineInstance>) : void
            public constructor ()
        }
        /** Quaternions are used to represent rotations.
        */
        class Quaternion extends System.ValueType implements System.IFormattable, System.IEquatable$1<UnityEngine.Quaternion>
        {
            protected [__keep_incompatibility]: never;
            /** X component of the Quaternion. Don't modify this directly unless you know quaternions inside out.
            */
            public x : number
            /** Y component of the Quaternion. Don't modify this directly unless you know quaternions inside out.
            */
            public y : number
            /** Z component of the Quaternion. Don't modify this directly unless you know quaternions inside out.
            */
            public z : number
            /** W component of the Quaternion. Do not directly modify quaternions.
            */
            public w : number
            public static kEpsilon : number
            /** The identity rotation (Read Only).
            */
            public static get identity(): UnityEngine.Quaternion;
            /** Returns or sets the euler angle representation of the rotation in degree.
            */
            public get eulerAngles(): UnityEngine.Vector3;
            public set eulerAngles(value: UnityEngine.Vector3);
            /** Returns this quaternion with a magnitude of 1 (Read Only).
            */
            public get normalized(): UnityEngine.Quaternion;
            /** Creates a rotation from fromDirection to toDirection.
            * @param $fromDirection A non-unit or unit vector representing a direction axis to rotate.
            * @param $toDirection A non-unit or unit vector representing the target direction axis.
            * @returns A unit quaternion which rotates from fromDirection to toDirection. 
            */
            public static FromToRotation ($fromDirection: UnityEngine.Vector3, $toDirection: UnityEngine.Vector3) : UnityEngine.Quaternion
            /** Returns the Inverse of rotation.
            */
            public static Inverse ($rotation: UnityEngine.Quaternion) : UnityEngine.Quaternion
            /** Spherically linear interpolates between unit quaternions a and b by a ratio of t.
            * @param $a Start unit quaternion value, returned when t = 0.
            * @param $b End unit quaternion value, returned when t = 1.
            * @param $t Interpolation ratio. Value is clamped to the range [0, 1].
            * @returns A unit quaternion spherically interpolated between quaternions a and b. 
            */
            public static Slerp ($a: UnityEngine.Quaternion, $b: UnityEngine.Quaternion, $t: number) : UnityEngine.Quaternion
            /** Spherically linear interpolates between unit quaternions a and b by t.
            * @param $a Start unit quaternion value, returned when t = 0.
            * @param $b End unit quaternion value, returned when t = 1.
            * @param $t Interpolation ratio. Value is unclamped.
            * @returns A unit quaternion spherically interpolated between unit quaternions a and b. 
            */
            public static SlerpUnclamped ($a: UnityEngine.Quaternion, $b: UnityEngine.Quaternion, $t: number) : UnityEngine.Quaternion
            /** Interpolates between a and b by t and normalizes the result afterwards.
            * @param $a Start unit quaternion value, returned when t = 0.
            * @param $b End unit quaternion value, returned when t = 1.
            * @param $t Interpolation ratio. The value is clamped to the range [0, 1].
            * @returns A unit quaternion interpolated between quaternions a and b. 
            */
            public static Lerp ($a: UnityEngine.Quaternion, $b: UnityEngine.Quaternion, $t: number) : UnityEngine.Quaternion
            /** Interpolates between a and b by t and normalizes the result afterwards. The parameter t is not clamped.
            */
            public static LerpUnclamped ($a: UnityEngine.Quaternion, $b: UnityEngine.Quaternion, $t: number) : UnityEngine.Quaternion
            /** Creates a rotation which rotates angle degrees around axis.
            */
            public static AngleAxis ($angle: number, $axis: UnityEngine.Vector3) : UnityEngine.Quaternion
            /** Creates a rotation with the specified forward and upwards directions.
            * @param $forward The direction to look in.
            * @param $upwards The vector that defines in which direction up is.
            */
            public static LookRotation ($forward: UnityEngine.Vector3, $upwards: UnityEngine.Vector3) : UnityEngine.Quaternion
            /** Creates a rotation with the specified forward and upwards directions.
            * @param $forward The direction to look in.
            * @param $upwards The vector that defines in which direction up is.
            */
            public static LookRotation ($forward: UnityEngine.Vector3) : UnityEngine.Quaternion
            public get_Item ($index: number) : number
            public set_Item ($index: number, $value: number) : void
            /** Set x, y, z and w components of an existing Quaternion.
            */
            public Set ($newX: number, $newY: number, $newZ: number, $newW: number) : void
            public static op_Multiply ($lhs: UnityEngine.Quaternion, $rhs: UnityEngine.Quaternion) : UnityEngine.Quaternion
            public static op_Multiply ($rotation: UnityEngine.Quaternion, $point: UnityEngine.Vector3) : UnityEngine.Vector3
            public static op_Equality ($lhs: UnityEngine.Quaternion, $rhs: UnityEngine.Quaternion) : boolean
            public static op_Inequality ($lhs: UnityEngine.Quaternion, $rhs: UnityEngine.Quaternion) : boolean
            /** The dot product between two rotations.
            */
            public static Dot ($a: UnityEngine.Quaternion, $b: UnityEngine.Quaternion) : number
            /** Creates a rotation with the specified forward and upwards directions.
            * @param $view The direction to look in.
            * @param $up The vector that defines in which direction up is.
            */
            public SetLookRotation ($view: UnityEngine.Vector3) : void
            /** Creates a rotation with the specified forward and upwards directions.
            * @param $view The direction to look in.
            * @param $up The vector that defines in which direction up is.
            */
            public SetLookRotation ($view: UnityEngine.Vector3, $up: UnityEngine.Vector3) : void
            /** Returns the angle in degrees between two rotations a and b. The resulting angle ranges from 0 to 180.
            */
            public static Angle ($a: UnityEngine.Quaternion, $b: UnityEngine.Quaternion) : number
            /** Returns a rotation that rotates z degrees around the z axis, x degrees around the x axis, and y degrees around the y axis; applied in that order.
            */
            public static Euler ($x: number, $y: number, $z: number) : UnityEngine.Quaternion
            /** Returns a rotation that rotates z degrees around the z axis, x degrees around the x axis, and y degrees around the y axis.
            */
            public static Euler ($euler: UnityEngine.Vector3) : UnityEngine.Quaternion
            /** Converts a rotation to angle-axis representation (angles in degrees).
            */
            public ToAngleAxis ($angle: $Ref<number>, $axis: $Ref<UnityEngine.Vector3>) : void
            /** Creates a rotation which rotates from fromDirection to toDirection.
            */
            public SetFromToRotation ($fromDirection: UnityEngine.Vector3, $toDirection: UnityEngine.Vector3) : void
            /** Rotates a rotation from towards to.
            * @param $from The unit quaternion to be aligned with to.
            * @param $to The target unit quaternion.
            * @param $maxDegreesDelta The maximum angle in degrees allowed for this rotation.
            * @returns A unit quaternion rotated towards to by an angular step of maxDegreesDelta. 
            */
            public static RotateTowards ($from: UnityEngine.Quaternion, $to: UnityEngine.Quaternion, $maxDegreesDelta: number) : UnityEngine.Quaternion
            /** Converts this quaternion to one with the same orientation but with a magnitude of 1.
            */
            public static Normalize ($q: UnityEngine.Quaternion) : UnityEngine.Quaternion
            public Normalize () : void
            public Equals ($other: any) : boolean
            public Equals ($other: UnityEngine.Quaternion) : boolean
            /** Returns a formatted string for this quaternion.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString () : string
            /** Returns a formatted string for this quaternion.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string) : string
            /** Returns a formatted string for this quaternion.
            * @param $format A numeric format string.
            * @param $formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            public constructor ($x: number, $y: number, $z: number, $w: number)
        }
        /** The material class.
        */
        class Material extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** The shader used by the material.
            */
            public get shader(): UnityEngine.Shader;
            public set shader(value: UnityEngine.Shader);
            /** The main color of the Material.
            */
            public get color(): UnityEngine.Color;
            public set color(value: UnityEngine.Color);
            /** The main texture.
            */
            public get mainTexture(): UnityEngine.Texture;
            public set mainTexture(value: UnityEngine.Texture);
            /** The offset of the main texture.
            */
            public get mainTextureOffset(): UnityEngine.Vector2;
            public set mainTextureOffset(value: UnityEngine.Vector2);
            /** The scale of the main texture.
            */
            public get mainTextureScale(): UnityEngine.Vector2;
            public set mainTextureScale(value: UnityEngine.Vector2);
            /** Render queue of this material.
            */
            public get renderQueue(): number;
            public set renderQueue(value: number);
            /** An array containing the local shader keywords that are currently enabled for this material.
            */
            public get enabledKeywords(): System.Array$1<UnityEngine.Rendering.LocalKeyword>;
            public set enabledKeywords(value: System.Array$1<UnityEngine.Rendering.LocalKeyword>);
            /** Defines how the material should interact with lightmaps and lightprobes.
            */
            public get globalIlluminationFlags(): UnityEngine.MaterialGlobalIlluminationFlags;
            public set globalIlluminationFlags(value: UnityEngine.MaterialGlobalIlluminationFlags);
            /** Gets and sets whether the Double Sided Global Illumination setting is enabled for this material.
            */
            public get doubleSidedGI(): boolean;
            public set doubleSidedGI(value: boolean);
            /** Gets and sets whether GPU instancing is enabled for this material.
            */
            public get enableInstancing(): boolean;
            public set enableInstancing(value: boolean);
            /** How many passes are in this material (Read Only).
            */
            public get passCount(): number;
            /** An array containing names of the local shader keywords that are currently enabled for this material.
            */
            public get shaderKeywords(): System.Array$1<string>;
            public set shaderKeywords(value: System.Array$1<string>);
            /** Parent of this material.
            */
            public get parent(): UnityEngine.Material;
            public set parent(value: UnityEngine.Material);
            /** Returns true if this material is a material variant.
            * @returns True if the material is a variant. 
            */
            public get isVariant(): boolean;
            /** Checks if the ShaderLab file assigned to the Material has a property with the given name.
            * @param $nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @param $name The name of the property.
            * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
            */
            public HasProperty ($nameID: number) : boolean
            /** Checks if the ShaderLab file assigned to the Material has a property with the given name.
            * @param $nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @param $name The name of the property.
            * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
            */
            public HasProperty ($name: string) : boolean
            /** Checks if the ShaderLab file assigned to the Material has a Float property with the given name. This also works with the Float Array property.
            * @param $nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @param $name The name of the property.
            * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
            */
            public HasFloat ($name: string) : boolean
            /** Checks if the ShaderLab file assigned to the Material has a Float property with the given name. This also works with the Float Array property.
            * @param $nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @param $name The name of the property.
            * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
            */
            public HasFloat ($nameID: number) : boolean
            /** This method is deprecated. Use HasFloat or HasInteger instead.
            * @param $nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @param $name The name of the property.
            * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
            */
            public HasInt ($name: string) : boolean
            /** This method is deprecated. Use HasFloat or HasInteger instead.
            * @param $nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @param $name The name of the property.
            * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
            */
            public HasInt ($nameID: number) : boolean
            /** Checks if the ShaderLab file assigned to the Material has an Integer property with the given name.
            * @param $nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @param $name The name of the property.
            * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
            */
            public HasInteger ($name: string) : boolean
            /** Checks if the ShaderLab file assigned to the Material has an Integer property with the given name.
            * @param $nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @param $name The name of the property.
            * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
            */
            public HasInteger ($nameID: number) : boolean
            /** Checks if the ShaderLab file assigned to the Material has a Texture property with the given name.
            * @param $nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @param $name The name of the property.
            * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
            */
            public HasTexture ($name: string) : boolean
            /** Checks if the ShaderLab file assigned to the Material has a Texture property with the given name.
            * @param $nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @param $name The name of the property.
            * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
            */
            public HasTexture ($nameID: number) : boolean
            /** Checks if the ShaderLab file assigned to the Material has a Matrix property with the given name. This also works with the Matrix Array property.
            * @param $nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @param $name The name of the property.
            * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
            */
            public HasMatrix ($name: string) : boolean
            /** Checks if the ShaderLab file assigned to the Material has a Matrix property with the given name. This also works with the Matrix Array property.
            * @param $nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @param $name The name of the property.
            * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
            */
            public HasMatrix ($nameID: number) : boolean
            /** Checks if the ShaderLab file assigned to the Material has a Vector property with the given name. This also works with the Vector Array property.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
            */
            public HasVector ($name: string) : boolean
            /** Checks if the ShaderLab file assigned to the Material has a Vector property with the given name. This also works with the Vector Array property.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
            */
            public HasVector ($nameID: number) : boolean
            /** Checks if the ShaderLab file assigned to the Material has a Color property with the given name.
            * @param $nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @param $name The name of the property.
            * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
            */
            public HasColor ($name: string) : boolean
            /** Checks if the ShaderLab file assigned to the Material has a Color property with the given name.
            * @param $nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @param $name The name of the property.
            * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
            */
            public HasColor ($nameID: number) : boolean
            /** Checks if the ShaderLab file assigned to the Material has a ComputeBuffer property with the given name.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
            */
            public HasBuffer ($name: string) : boolean
            /** Checks if the ShaderLab file assigned to the Material has a ComputeBuffer property with the given name.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
            */
            public HasBuffer ($nameID: number) : boolean
            /** Checks if the ShaderLab file assigned to the Material has a ConstantBuffer property with the given name.
            * @param $nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @param $name The name of the property.
            * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
            */
            public HasConstantBuffer ($name: string) : boolean
            /** Checks if the ShaderLab file assigned to the Material has a ConstantBuffer property with the given name.
            * @param $nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @param $name The name of the property.
            * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
            */
            public HasConstantBuffer ($nameID: number) : boolean
            /** Enables a local shader keyword for this material.
            * @param $keyword The name of the Rendering.LocalKeyword to enable.
            */
            public EnableKeyword ($keyword: string) : void
            /** Disables a local shader keyword for this material.
            * @param $keyword The name of the Rendering.LocalKeyword to disable.
            */
            public DisableKeyword ($keyword: string) : void
            /** Checks whether a local shader keyword is enabled for this material.
            * @param $keyword The name of the Rendering.LocalKeyword to check.
            * @returns Returns true if a Rendering.LocalKeyword with the given name is enabled  for this material. 
            */
            public IsKeywordEnabled ($keyword: string) : boolean
            /** Enables a local shader keyword for this material.
            * @param $keyword The name of the Rendering.LocalKeyword to enable.
            */
            public EnableKeyword ($keyword: $Ref<UnityEngine.Rendering.LocalKeyword>) : void
            /** Disables a local shader keyword for this material.
            * @param $keyword The name of the Rendering.LocalKeyword to disable.
            */
            public DisableKeyword ($keyword: $Ref<UnityEngine.Rendering.LocalKeyword>) : void
            /** Sets the state of a local shader keyword for this material.
            * @param $keyword The Rendering.LocalKeyword to enable or disable.
            * @param $value The desired keyword state.
            */
            public SetKeyword ($keyword: $Ref<UnityEngine.Rendering.LocalKeyword>, $value: boolean) : void
            /** Checks whether a local shader keyword is enabled for this material.
            * @param $keyword The name of the Rendering.LocalKeyword to check.
            * @returns Returns true if a Rendering.LocalKeyword with the given name is enabled  for this material. 
            */
            public IsKeywordEnabled ($keyword: $Ref<UnityEngine.Rendering.LocalKeyword>) : boolean
            /** Enables or disables a Shader pass on a per-Material level.
            * @param $passName Shader pass name (case insensitive).
            * @param $enabled Flag indicating whether this Shader pass should be enabled.
            */
            public SetShaderPassEnabled ($passName: string, $enabled: boolean) : void
            /** Checks whether a given Shader pass is enabled on this Material.
            * @param $passName Shader pass name (case insensitive).
            * @returns True if the Shader pass is enabled. 
            */
            public GetShaderPassEnabled ($passName: string) : boolean
            /** Returns the name of the shader pass at index pass.
            */
            public GetPassName ($pass: number) : string
            /** Returns the index of the pass passName.
            */
            public FindPass ($passName: string) : number
            /** Sets an override tag/value on the material.
            * @param $tag Name of the tag to set.
            * @param $val Name of the value to set. Empty string to clear the override flag.
            */
            public SetOverrideTag ($tag: string, $val: string) : void
            /** Get the value of material's shader tag.
            */
            public GetTag ($tag: string, $searchFallbacks: boolean, $defaultValue: string) : string
            /** Get the value of material's shader tag.
            */
            public GetTag ($tag: string, $searchFallbacks: boolean) : string
            /** Interpolate properties between two materials.
            */
            public Lerp ($start: UnityEngine.Material, $end: UnityEngine.Material, $t: number) : void
            /** Activate the given pass for rendering.
            * @param $pass Shader pass number to setup.
            * @returns If false is returned, no rendering should be done. 
            */
            public SetPass ($pass: number) : boolean
            /** Copy properties from other material into this material.
            */
            public CopyPropertiesFromMaterial ($mat: UnityEngine.Material) : void
            /** Copies properties, keyword states and settings from mat to this material, but only if they exist in both materials.
            * @param $mat The Material to copy from.
            */
            public CopyMatchingPropertiesFromMaterial ($mat: UnityEngine.Material) : void
            /** Computes a CRC hash value from the content of the material.
            */
            public ComputeCRC () : number
            /** Returns the names of all texture properties exposed on this material.
            * @param $outNames Names of all texture properties exposed on this material.
            * @returns Names of all texture properties exposed on this material. 
            */
            public GetTexturePropertyNames () : System.Array$1<string>
            /** Return the name IDs of all texture properties exposed on this material.
            * @param $outNames IDs of all texture properties exposed on this material.
            * @returns IDs of all texture properties exposed on this material. 
            */
            public GetTexturePropertyNameIDs () : System.Array$1<number>
            public GetTexturePropertyNames ($outNames: System.Collections.Generic.List$1<string>) : void
            public GetTexturePropertyNameIDs ($outNames: System.Collections.Generic.List$1<number>) : void
            /** Returns True if the given material is an ancestor of this Material.
            * @param $ancestor The specific ancestor to find in the hierarchy.
            * @returns True if the given material is an ancestor of this Material. 
            */
            public IsChildOf ($ancestor: UnityEngine.Material) : boolean
            /** Removes all property overrides on this material.
            */
            public RevertAllPropertyOverrides () : void
            /** Checks whether a property is overriden by this material.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $name Property name, e.g. "_SrcBlend".
            * @returns Returns true if the property you pass in is overriden by this material. Otherwise, returns false. 
            */
            public IsPropertyOverriden ($nameID: number) : boolean
            /** Checks whether a property is locked by this material.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $name Property name, e.g. "_SrcBlend".
            * @returns Returns true if the property you pass in is locked by this material. Otherwise, returns false. 
            */
            public IsPropertyLocked ($nameID: number) : boolean
            /** Checks whether a property is locked by any of ancestor of this material.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $name Property name, e.g. "_SrcBlend".
            * @returns Returns true if the property you pass in is locked by any of ancestor of this material. Otherwise, returns false. 
            */
            public IsPropertyLockedByAncestor ($nameID: number) : boolean
            /** Checks whether a property is overriden by this material.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $name Property name, e.g. "_SrcBlend".
            * @returns Returns true if the property you pass in is overriden by this material. Otherwise, returns false. 
            */
            public IsPropertyOverriden ($name: string) : boolean
            /** Checks whether a property is locked by this material.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $name Property name, e.g. "_SrcBlend".
            * @returns Returns true if the property you pass in is locked by this material. Otherwise, returns false. 
            */
            public IsPropertyLocked ($name: string) : boolean
            /** Checks whether a property is locked by any of ancestor of this material.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $name Property name, e.g. "_SrcBlend".
            * @returns Returns true if the property you pass in is locked by any of ancestor of this material. Otherwise, returns false. 
            */
            public IsPropertyLockedByAncestor ($name: string) : boolean
            /** Sets the lock state of a property for this material.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $name Property name, e.g. "_SrcBlend".
            * @param $value The desired lock state.
            */
            public SetPropertyLock ($nameID: number, $value: boolean) : void
            /** Applies an override associated with a Material Variant to a target.
            * @param $destination The Material to which the Editor applies the override.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $name Property name, e.g. "_SrcBlend".
            * @param $recordUndo Wheter the editor should record an undo operation for this action.
            */
            public ApplyPropertyOverride ($destination: UnityEngine.Material, $nameID: number, $recordUndo?: boolean) : void
            /** Removes the override on a property.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $name Property name, e.g. "_SrcBlend".
            */
            public RevertPropertyOverride ($nameID: number) : void
            /** Sets the lock state of a property for this material.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $name Property name, e.g. "_SrcBlend".
            * @param $value The desired lock state.
            */
            public SetPropertyLock ($name: string, $value: boolean) : void
            /** Applies an override associated with a Material Variant to a target.
            * @param $destination The Material to which the Editor applies the override.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $name Property name, e.g. "_SrcBlend".
            * @param $recordUndo Wheter the editor should record an undo operation for this action.
            */
            public ApplyPropertyOverride ($destination: UnityEngine.Material, $name: string, $recordUndo?: boolean) : void
            /** Removes the override on a property.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $name Property name, e.g. "_SrcBlend".
            */
            public RevertPropertyOverride ($name: string) : void
            /** This method is deprecated. Use SetFloat or SetInteger instead.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $value Integer value to set.
            * @param $name Property name, e.g. "_SrcBlend".
            */
            public SetInt ($name: string, $value: number) : void
            /** This method is deprecated. Use SetFloat or SetInteger instead.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $value Integer value to set.
            * @param $name Property name, e.g. "_SrcBlend".
            */
            public SetInt ($nameID: number, $value: number) : void
            /** Sets a named float value.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $value Float value to set.
            * @param $name Property name, e.g. "_Glossiness".
            */
            public SetFloat ($name: string, $value: number) : void
            /** Sets a named float value.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $value Float value to set.
            * @param $name Property name, e.g. "_Glossiness".
            */
            public SetFloat ($nameID: number, $value: number) : void
            /** Sets a named integer value.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $value Integer value to set.
            * @param $name Property name, e.g. "_SrcBlend".
            */
            public SetInteger ($name: string, $value: number) : void
            /** Sets a named integer value.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $value Integer value to set.
            * @param $name Property name, e.g. "_SrcBlend".
            */
            public SetInteger ($nameID: number, $value: number) : void
            /** Sets a color value.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $name Property name. For example, "_Color" in Built-in Render Pipeline, "_BaseColor" in URP.
            * @param $value Color value to set.
            */
            public SetColor ($name: string, $value: UnityEngine.Color) : void
            /** Sets a color value.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $name Property name. For example, "_Color" in Built-in Render Pipeline, "_BaseColor" in URP.
            * @param $value Color value to set.
            */
            public SetColor ($nameID: number, $value: UnityEngine.Color) : void
            /** Sets a named vector value.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $name Property name, e.g. "_WaveAndDistance".
            * @param $value Vector value to set.
            */
            public SetVector ($name: string, $value: UnityEngine.Vector4) : void
            /** Sets a named vector value.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $name Property name, e.g. "_WaveAndDistance".
            * @param $value Vector value to set.
            */
            public SetVector ($nameID: number, $value: UnityEngine.Vector4) : void
            /** Sets a named matrix for the shader.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $name Property name, e.g. "_CubemapRotation".
            * @param $value Matrix value to set.
            */
            public SetMatrix ($name: string, $value: UnityEngine.Matrix4x4) : void
            /** Sets a named matrix for the shader.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $name Property name, e.g. "_CubemapRotation".
            * @param $value Matrix value to set.
            */
            public SetMatrix ($nameID: number, $value: UnityEngine.Matrix4x4) : void
            /** Sets a named texture.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $name Property name, e.g. "_MainTex".
            * @param $value Texture to set.
            * @param $element Optional parameter that specifies the type of data to set from the RenderTexture.
            */
            public SetTexture ($name: string, $value: UnityEngine.Texture) : void
            /** Sets a named texture.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $name Property name, e.g. "_MainTex".
            * @param $value Texture to set.
            * @param $element Optional parameter that specifies the type of data to set from the RenderTexture.
            */
            public SetTexture ($nameID: number, $value: UnityEngine.Texture) : void
            /** Sets a named texture.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $name Property name, e.g. "_MainTex".
            * @param $value Texture to set.
            * @param $element Optional parameter that specifies the type of data to set from the RenderTexture.
            */
            public SetTexture ($name: string, $value: UnityEngine.RenderTexture, $element: UnityEngine.Rendering.RenderTextureSubElement) : void
            /** Sets a named texture.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $name Property name, e.g. "_MainTex".
            * @param $value Texture to set.
            * @param $element Optional parameter that specifies the type of data to set from the RenderTexture.
            */
            public SetTexture ($nameID: number, $value: UnityEngine.RenderTexture, $element: UnityEngine.Rendering.RenderTextureSubElement) : void
            /** Sets a named buffer value.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $name Property name.
            * @param $value The ComputeBuffer or GraphicsBuffer value to set.
            */
            public SetBuffer ($name: string, $value: UnityEngine.ComputeBuffer) : void
            /** Sets a named buffer value.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $name Property name.
            * @param $value The ComputeBuffer or GraphicsBuffer value to set.
            */
            public SetBuffer ($nameID: number, $value: UnityEngine.ComputeBuffer) : void
            /** Sets a named buffer value.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $name Property name.
            * @param $value The ComputeBuffer or GraphicsBuffer value to set.
            */
            public SetBuffer ($name: string, $value: UnityEngine.GraphicsBuffer) : void
            /** Sets a named buffer value.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $name Property name.
            * @param $value The ComputeBuffer or GraphicsBuffer value to set.
            */
            public SetBuffer ($nameID: number, $value: UnityEngine.GraphicsBuffer) : void
            /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the material.
            * @param $name The name of the constant buffer to override.
            * @param $value The ComputeBuffer to override the constant buffer values with, or null to remove binding.
            * @param $offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
            * @param $size The number of bytes to bind.
            * @param $nameID The shader property ID of the constant buffer to override.
            */
            public SetConstantBuffer ($name: string, $value: UnityEngine.ComputeBuffer, $offset: number, $size: number) : void
            /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the material.
            * @param $name The name of the constant buffer to override.
            * @param $value The ComputeBuffer to override the constant buffer values with, or null to remove binding.
            * @param $offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
            * @param $size The number of bytes to bind.
            * @param $nameID The shader property ID of the constant buffer to override.
            */
            public SetConstantBuffer ($nameID: number, $value: UnityEngine.ComputeBuffer, $offset: number, $size: number) : void
            /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the material.
            * @param $name The name of the constant buffer to override.
            * @param $value The ComputeBuffer to override the constant buffer values with, or null to remove binding.
            * @param $offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
            * @param $size The number of bytes to bind.
            * @param $nameID The shader property ID of the constant buffer to override.
            */
            public SetConstantBuffer ($name: string, $value: UnityEngine.GraphicsBuffer, $offset: number, $size: number) : void
            /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the material.
            * @param $name The name of the constant buffer to override.
            * @param $value The ComputeBuffer to override the constant buffer values with, or null to remove binding.
            * @param $offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
            * @param $size The number of bytes to bind.
            * @param $nameID The shader property ID of the constant buffer to override.
            */
            public SetConstantBuffer ($nameID: number, $value: UnityEngine.GraphicsBuffer, $offset: number, $size: number) : void
            public SetFloatArray ($name: string, $values: System.Collections.Generic.List$1<number>) : void
            public SetFloatArray ($nameID: number, $values: System.Collections.Generic.List$1<number>) : void
            /** Sets a float array property.
            * @param $name Property name.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $values Array of values to set.
            */
            public SetFloatArray ($name: string, $values: System.Array$1<number>) : void
            /** Sets a float array property.
            * @param $name Property name.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $values Array of values to set.
            */
            public SetFloatArray ($nameID: number, $values: System.Array$1<number>) : void
            public SetColorArray ($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Color>) : void
            public SetColorArray ($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Color>) : void
            /** Sets a color array property.
            * @param $name Property name.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $values Array of values to set.
            */
            public SetColorArray ($name: string, $values: System.Array$1<UnityEngine.Color>) : void
            /** Sets a color array property.
            * @param $name Property name.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $values Array of values to set.
            */
            public SetColorArray ($nameID: number, $values: System.Array$1<UnityEngine.Color>) : void
            public SetVectorArray ($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>) : void
            public SetVectorArray ($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>) : void
            /** Sets a vector array property.
            * @param $name Property name.
            * @param $values Array of values to set.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            */
            public SetVectorArray ($name: string, $values: System.Array$1<UnityEngine.Vector4>) : void
            /** Sets a vector array property.
            * @param $name Property name.
            * @param $values Array of values to set.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            */
            public SetVectorArray ($nameID: number, $values: System.Array$1<UnityEngine.Vector4>) : void
            public SetMatrixArray ($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>) : void
            public SetMatrixArray ($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>) : void
            /** Sets a matrix array property.
            * @param $name Property name.
            * @param $values Array of values to set.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            */
            public SetMatrixArray ($name: string, $values: System.Array$1<UnityEngine.Matrix4x4>) : void
            /** Sets a matrix array property.
            * @param $name Property name.
            * @param $values Array of values to set.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            */
            public SetMatrixArray ($nameID: number, $values: System.Array$1<UnityEngine.Matrix4x4>) : void
            /** This method is deprecated. Use GetFloat or GetInteger instead.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public GetInt ($name: string) : number
            /** This method is deprecated. Use GetFloat or GetInteger instead.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public GetInt ($nameID: number) : number
            /** Get a named float value.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public GetFloat ($name: string) : number
            /** Get a named float value.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public GetFloat ($nameID: number) : number
            /** Get a named integer value.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public GetInteger ($name: string) : number
            /** Get a named integer value.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public GetInteger ($nameID: number) : number
            /** Get a named color value.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public GetColor ($name: string) : UnityEngine.Color
            /** Get a named color value.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public GetColor ($nameID: number) : UnityEngine.Color
            /** Get a named vector value.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public GetVector ($name: string) : UnityEngine.Vector4
            /** Get a named vector value.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public GetVector ($nameID: number) : UnityEngine.Vector4
            /** Get a named matrix value from the shader.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public GetMatrix ($name: string) : UnityEngine.Matrix4x4
            /** Get a named matrix value from the shader.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public GetMatrix ($nameID: number) : UnityEngine.Matrix4x4
            /** Get a named texture.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public GetTexture ($name: string) : UnityEngine.Texture
            /** Get a named texture.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public GetTexture ($nameID: number) : UnityEngine.Texture
            /** Get a named Graphics Buffer value.
            * @param $name The name of the graphics buffer resource property to return.
            * @returns Returns the handle of the graphics buffer resource property. 
            */
            public GetBuffer ($name: string) : UnityEngine.GraphicsBufferHandle
            /** Get a named Constant Buffer value.
            * @param $name The name of the constant buffer property to return.
            * @returns Returns the handle of the constant buffer graphics resource. 
            */
            public GetConstantBuffer ($name: string) : UnityEngine.GraphicsBufferHandle
            /** Get a named float array.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            */
            public GetFloatArray ($name: string) : System.Array$1<number>
            /** Get a named float array.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            */
            public GetFloatArray ($nameID: number) : System.Array$1<number>
            /** Get a named color array.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public GetColorArray ($name: string) : System.Array$1<UnityEngine.Color>
            /** Get a named color array.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public GetColorArray ($nameID: number) : System.Array$1<UnityEngine.Color>
            /** Get a named vector array.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            */
            public GetVectorArray ($name: string) : System.Array$1<UnityEngine.Vector4>
            /** Get a named vector array.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            */
            public GetVectorArray ($nameID: number) : System.Array$1<UnityEngine.Vector4>
            /** Get a named matrix array.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            */
            public GetMatrixArray ($name: string) : System.Array$1<UnityEngine.Matrix4x4>
            /** Get a named matrix array.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            */
            public GetMatrixArray ($nameID: number) : System.Array$1<UnityEngine.Matrix4x4>
            public GetFloatArray ($name: string, $values: System.Collections.Generic.List$1<number>) : void
            public GetFloatArray ($nameID: number, $values: System.Collections.Generic.List$1<number>) : void
            public GetColorArray ($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Color>) : void
            public GetColorArray ($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Color>) : void
            public GetVectorArray ($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>) : void
            public GetVectorArray ($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>) : void
            public GetMatrixArray ($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>) : void
            public GetMatrixArray ($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>) : void
            /** Sets the placement offset of a given texture. The name parameter is defined in the shader. This method creates a new Material instance.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $name The name of the texture property as defined in the shader. For example: "_MainTex".
            * @param $value Texture placement offset.
            */
            public SetTextureOffset ($name: string, $value: UnityEngine.Vector2) : void
            /** Sets the placement offset of a given texture. The name parameter is defined in the shader. This method creates a new Material instance.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $name The name of the texture property as defined in the shader. For example: "_MainTex".
            * @param $value Texture placement offset.
            */
            public SetTextureOffset ($nameID: number, $value: UnityEngine.Vector2) : void
            /** Sets the placement scale of texture propertyName.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $name Property name, e.g. "_MainTex".
            * @param $value Texture placement scale.
            */
            public SetTextureScale ($name: string, $value: UnityEngine.Vector2) : void
            /** Sets the placement scale of texture propertyName.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $name Property name, e.g. "_MainTex".
            * @param $value Texture placement scale.
            */
            public SetTextureScale ($nameID: number, $value: UnityEngine.Vector2) : void
            /** Gets the placement offset of texture propertyName.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public GetTextureOffset ($name: string) : UnityEngine.Vector2
            /** Gets the placement offset of texture propertyName.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public GetTextureOffset ($nameID: number) : UnityEngine.Vector2
            /** Gets the placement scale of texture propertyName.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public GetTextureScale ($name: string) : UnityEngine.Vector2
            /** Gets the placement scale of texture propertyName.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public GetTextureScale ($nameID: number) : UnityEngine.Vector2
            /** Retrieves a list of the named properties in the material that match the input property type.
            * @param $type The type to use to query the material for named properties.
            */
            public GetPropertyNames ($type: UnityEngine.MaterialPropertyType) : System.Array$1<string>
            public constructor ($shader: UnityEngine.Shader)
            public constructor ($source: UnityEngine.Material)
            public constructor ()
        }
        /** Use this BeforeRenderOrderAttribute when you need to specify a custom callback order for Application.onBeforeRender.
        */
        class BeforeRenderOrderAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            /** The order, lowest to highest, that the Application.onBeforeRender event recievers will be called in.
            */
            public get order(): number;
            public constructor ($order: number)
        }
        /** BillboardAsset describes how a billboard is rendered.
        */
        class BillboardAsset extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** Width of the billboard.
            */
            public get width(): number;
            public set width(value: number);
            /** Height of the billboard.
            */
            public get height(): number;
            public set height(value: number);
            /** Height of the billboard that is below ground.
            */
            public get bottom(): number;
            public set bottom(value: number);
            /** Number of pre-rendered images that can be switched when the billboard is viewed from different angles.
            */
            public get imageCount(): number;
            /** Number of vertices in the billboard mesh.
            */
            public get vertexCount(): number;
            /** Number of indices in the billboard mesh.
            */
            public get indexCount(): number;
            /** The material used for rendering.
            */
            public get material(): UnityEngine.Material;
            public set material(value: UnityEngine.Material);
            public GetImageTexCoords ($imageTexCoords: System.Collections.Generic.List$1<UnityEngine.Vector4>) : void
            /** Get the array of billboard image texture coordinate data.
            * @param $imageTexCoords The list that receives the array.
            */
            public GetImageTexCoords () : System.Array$1<UnityEngine.Vector4>
            public SetImageTexCoords ($imageTexCoords: System.Collections.Generic.List$1<UnityEngine.Vector4>) : void
            /** Set the array of billboard image texture coordinate data.
            * @param $imageTexCoords The array of data to set.
            */
            public SetImageTexCoords ($imageTexCoords: System.Array$1<UnityEngine.Vector4>) : void
            public GetVertices ($vertices: System.Collections.Generic.List$1<UnityEngine.Vector2>) : void
            /** Get the vertices of the billboard mesh.
            * @param $vertices The list that receives the array.
            */
            public GetVertices () : System.Array$1<UnityEngine.Vector2>
            public SetVertices ($vertices: System.Collections.Generic.List$1<UnityEngine.Vector2>) : void
            /** Set the vertices of the billboard mesh.
            * @param $vertices The array of data to set.
            */
            public SetVertices ($vertices: System.Array$1<UnityEngine.Vector2>) : void
            public GetIndices ($indices: System.Collections.Generic.List$1<number>) : void
            /** Get the indices of the billboard mesh.
            * @param $indices The list that receives the array.
            */
            public GetIndices () : System.Array$1<number>
            public SetIndices ($indices: System.Collections.Generic.List$1<number>) : void
            /** Set the indices of the billboard mesh.
            * @param $indices The array of data to set.
            */
            public SetIndices ($indices: System.Array$1<number>) : void
            public constructor ()
        }
        /** Renders a billboard from a BillboardAsset.
        */
        class BillboardRenderer extends UnityEngine.Renderer
        {
            protected [__keep_incompatibility]: never;
            /** The BillboardAsset to render.
            */
            public get billboard(): UnityEngine.BillboardAsset;
            public set billboard(value: UnityEngine.BillboardAsset);
            public constructor ()
        }
        /** Custom Render Texture Manager.
        */
        class CustomRenderTextureManager extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static add_textureLoaded ($value: System.Action$1<UnityEngine.CustomRenderTexture>) : void
            public static remove_textureLoaded ($value: System.Action$1<UnityEngine.CustomRenderTexture>) : void
            public static add_textureUnloaded ($value: System.Action$1<UnityEngine.CustomRenderTexture>) : void
            public static remove_textureUnloaded ($value: System.Action$1<UnityEngine.CustomRenderTexture>) : void
            public static GetAllCustomRenderTextures ($currentCustomRenderTextures: System.Collections.Generic.List$1<UnityEngine.CustomRenderTexture>) : void
            public static add_updateTriggered ($value: System.Action$2<UnityEngine.CustomRenderTexture, number>) : void
            public static remove_updateTriggered ($value: System.Action$2<UnityEngine.CustomRenderTexture, number>) : void
            public static add_initializeTriggered ($value: System.Action$1<UnityEngine.CustomRenderTexture>) : void
            public static remove_initializeTriggered ($value: System.Action$1<UnityEngine.CustomRenderTexture>) : void
        }
        /** Custom Render Textures are an extension to Render Textures that allow you to render directly to the Texture using a Shader.
        */
        class CustomRenderTexture extends UnityEngine.RenderTexture
        {
            protected [__keep_incompatibility]: never;
            /** The Material that Unity uses to initialize the content of a Custom Render Texture.
            */
            public get material(): UnityEngine.Material;
            public set material(value: UnityEngine.Material);
            /** The Material that Unity uses to initialize a Custom Render Texture. Initialization texture and color are ignored if you have set this parameter.
            */
            public get initializationMaterial(): UnityEngine.Material;
            public set initializationMaterial(value: UnityEngine.Material);
            /** The Texture that Unity uses to initialize a Custom Render Texture, multiplied by the initialization color. Unity ignores this parameter if an initializationMaterial is set.
            */
            public get initializationTexture(): UnityEngine.Texture;
            public set initializationTexture(value: UnityEngine.Texture);
            /** Determine if Unity initializes the Custom Render Texture with a Texture and a Color or a Material.
            */
            public get initializationSource(): UnityEngine.CustomRenderTextureInitializationSource;
            public set initializationSource(value: UnityEngine.CustomRenderTextureInitializationSource);
            /** The color that Unity uses to initialize a Custom Render Texture. Unity ignores this parameter if an initializationMaterial is set.
            */
            public get initializationColor(): UnityEngine.Color;
            public set initializationColor(value: UnityEngine.Color);
            /** Determine how Unity updates the Custom Render Texture.
            */
            public get updateMode(): UnityEngine.CustomRenderTextureUpdateMode;
            public set updateMode(value: UnityEngine.CustomRenderTextureUpdateMode);
            /** Determine how Unity initializes a texture.
            */
            public get initializationMode(): UnityEngine.CustomRenderTextureUpdateMode;
            public set initializationMode(value: UnityEngine.CustomRenderTextureUpdateMode);
            /** The space in which Unity expresses update zones. You can set this to Normalized or Pixel space.
            */
            public get updateZoneSpace(): UnityEngine.CustomRenderTextureUpdateZoneSpace;
            public set updateZoneSpace(value: UnityEngine.CustomRenderTextureUpdateZoneSpace);
            /** The Shader Pass Unity uses to update the Custom Render Texture.
            */
            public get shaderPass(): number;
            public set shaderPass(value: number);
            /** The bit field that you can use to enable or disable update on each of the cubemap faces. The bit order from least to most significant bit is as follows: +X, -X, +Y, -Y, +Z, -Z.
            */
            public get cubemapFaceMask(): number;
            public set cubemapFaceMask(value: number);
            /** When this parameter is set to true, Unity double-buffers the Custom Render Texture so that you can access it during its own update.
            */
            public get doubleBuffered(): boolean;
            public set doubleBuffered(value: boolean);
            /** When this parameter is set to true, Unity wraps Update zones around the border of the Custom Render Texture. Otherwise, Unity clamps Update zones at the border of the Custom Render Texture.
            */
            public get wrapUpdateZones(): boolean;
            public set wrapUpdateZones(value: boolean);
            /** The period in seconds that Unity updates real-time Custom Render Textures. A value of 0.0 means Unity updates real-time Custom Render Textures every frame.
            */
            public get updatePeriod(): number;
            public set updatePeriod(value: number);
            /** Triggers an update of the Custom Render Texture.
            * @param $count Number of upate pass to perform. The default value of this count parameter is 1.
            */
            public Update ($count: number) : void
            public Update () : void
            /** Initializes the Custom Render Texture at the start of the next frame. Unity calls Initialise() before CustomRenderTexture.Update.
            */
            public Initialize () : void
            /** Clear all Update Zones.
            */
            public ClearUpdateZones () : void
            public GetUpdateZones ($updateZones: System.Collections.Generic.List$1<UnityEngine.CustomRenderTextureUpdateZone>) : void
            /** Gets the Render Texture that this Custom Render Texture uses for double buffering.
            * @returns If CustomRenderTexture. doubleBuffered is true, this returns the Render Texture that this Custom Render Texture uses for double buffering. If CustomRenderTexture. doubleBuffered is false, this returns null. 
            */
            public GetDoubleBufferRenderTexture () : UnityEngine.RenderTexture
            /** Updates the internal Render Texture that a Custom Render Texture uses for double buffering, so that it matches the size and format of the Custom Render Texture.
            */
            public EnsureDoubleBufferConsistency () : void
            /** Setup the list of Update Zones for the Custom Render Texture.
            */
            public SetUpdateZones ($updateZones: System.Array$1<UnityEngine.CustomRenderTextureUpdateZone>) : void
            public constructor ($width: number, $height: number, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite)
            public constructor ($width: number, $height: number, $format: UnityEngine.RenderTextureFormat)
            public constructor ($width: number, $height: number)
            public constructor ($width: number, $height: number, $defaultFormat: UnityEngine.Experimental.Rendering.DefaultFormat)
            public constructor ($width: number, $height: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat)
            public constructor ($desc: UnityEngine.RenderTextureDescriptor)
            public constructor ($textureToCopy: UnityEngine.RenderTexture)
            public constructor ($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat)
            public constructor ($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat)
            public constructor ($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $mipCount: number)
            public constructor ($width: number, $height: number, $colorFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $depthStencilFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $mipCount: number)
            public constructor ($width: number, $height: number, $colorFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $depthStencilFormat: UnityEngine.Experimental.Rendering.GraphicsFormat)
            public constructor ($width: number, $height: number, $depth: number, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite)
            public constructor ($width: number, $height: number, $depth: number, $format: UnityEngine.RenderTextureFormat)
            public constructor ($width: number, $height: number, $depth: number)
            public constructor ($width: number, $height: number, $depth: number, $format: UnityEngine.RenderTextureFormat, $mipCount: number)
            public constructor ()
        }
        /** Provides access to a display / screen for rendering operations.
        */
        class Display extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** The list of connected displays.
            */
            public static displays : System.Array$1<UnityEngine.Display>
            /** Horizontal resolution that the display is rendering at in the viewport.
            */
            public get renderingWidth(): number;
            /** Vertical resolution that the display is rendering at.
            */
            public get renderingHeight(): number;
            /** Horizontal native display resolution.
            */
            public get systemWidth(): number;
            /** Vertical native display resolution.
            */
            public get systemHeight(): number;
            /** Color RenderBuffer.
            */
            public get colorBuffer(): UnityEngine.RenderBuffer;
            /** Depth RenderBuffer.
            */
            public get depthBuffer(): UnityEngine.RenderBuffer;
            /** Gets the state of the display and returns true if the display is active and false if otherwise.
            */
            public get active(): boolean;
            /** True when the back buffer requires an intermediate texture to render.
            */
            public get requiresBlitToBackbuffer(): boolean;
            /** True when doing a blit to the back buffer requires manual color space conversion.
            */
            public get requiresSrgbBlitToBackbuffer(): boolean;
            /** Main Display.
            */
            public static get main(): UnityEngine.Display;
            /** Get the Editors active GameView display target.
            */
            public static get activeEditorGameViewTarget(): number;
            /** Activates an external display. For example, a secondary monitor connected to the system.
            */
            public Activate () : void
            /** Windows platforms only. Activates an external display with a specific width, height and refresh rate. For example, a secondary monitor connected to the system.
            * @param $width Windows platforms only. Width of the window to open.
            * @param $height Windows platforms only. Height of the window to open.
            * @param $refreshRate Refresh Rate of the window to open.
            */
            public Activate ($width: number, $height: number, $refreshRate: UnityEngine.RefreshRate) : void
            /** Windows platforms only. Sets rendering size and position on screen.
            * @param $width Windows platforms only. The width of the window.
            * @param $height Windows platforms only. The height of the window.
            * @param $x Windows platforms only. The x position of the window.
            * @param $y Windows platforms only. The y position of the window.
            */
            public SetParams ($width: number, $height: number, $x: number, $y: number) : void
            /** Sets rendering resolution for the display.
            * @param $w The rendering width in pixels.
            * @param $h The rendering height in pixels.
            */
            public SetRenderingResolution ($w: number, $h: number) : void
            /** Query relative mouse coordinates.
            * @param $inputMouseCoordinates Mouse Input Position as Coordinates.
            */
            public static RelativeMouseAt ($inputMouseCoordinates: UnityEngine.Vector3) : UnityEngine.Vector3
            public static add_onDisplaysUpdated ($value: UnityEngine.Display.DisplaysUpdatedDelegate) : void
            public static remove_onDisplaysUpdated ($value: UnityEngine.Display.DisplaysUpdatedDelegate) : void
        }
        /** Represents the display refresh rate. This is how many frames the display can show per second.
        */
        class RefreshRate extends System.ValueType implements System.IComparable$1<UnityEngine.RefreshRate>, System.IEquatable$1<UnityEngine.RefreshRate>
        {
            protected [__keep_incompatibility]: never;
            /** Numerator of the refresh rate fraction.
            */
            public numerator : number
            /** Denominator of the refresh rate fraction.
            */
            public denominator : number
            /** The numerical value of the refresh rate in hertz.
            */
            public get value(): number;
            public Equals ($other: UnityEngine.RefreshRate) : boolean
            public CompareTo ($other: UnityEngine.RefreshRate) : number
        }
        /** Thread-safe struct for batch sampling Light Probes in a Scene.
        */
        class LightProbesQuery extends System.ValueType implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            /** This property indicates whether target query data is valid.
            */
            public get IsCreated(): boolean;
            public Dispose () : void
            /** Use this method to clean up the memory this query references.
            */
            public Dispose ($inputDeps: Unity.Jobs.JobHandle) : Unity.Jobs.JobHandle
            /** Calculate light probe and occlusion probe at the given world space position.
            * @param $position The world space position used to evaluate the probe.
            * @param $tetrahedronIndex Tetrahedron index that guides interpolation. Start with a value of 0 and reuse results between frames for faster lookup.
            * @param $lightProbe The light probe where the resulting lighting is written to.
            * @param $occlusionProbe The occlusion probe where the resulting occlusion is written to.
            */
            public CalculateInterpolatedLightAndOcclusionProbe ($position: UnityEngine.Vector3, $tetrahedronIndex: $Ref<number>, $lightProbe: $Ref<UnityEngine.Rendering.SphericalHarmonicsL2>, $occlusionProbe: $Ref<UnityEngine.Vector4>) : void
            public CalculateInterpolatedLightAndOcclusionProbes ($positions: Unity.Collections.NativeArray$1<UnityEngine.Vector3>, $tetrahedronIndices: Unity.Collections.NativeArray$1<number>, $lightProbes: Unity.Collections.NativeArray$1<UnityEngine.Rendering.SphericalHarmonicsL2>, $occlusionProbes: Unity.Collections.NativeArray$1<UnityEngine.Vector4>) : void
            public constructor ($allocator: Unity.Collections.Allocator)
        }
        /** Sets the full-screen mode. See the description of each mode for information on platform compatibility.
        */
        enum FullScreenMode
        { ExclusiveFullScreen = 0, FullScreenWindow = 1, MaximizedWindow = 2, Windowed = 3 }
        /** Represents a connected display.
        */
        class DisplayInfo extends System.ValueType implements System.IEquatable$1<UnityEngine.DisplayInfo>
        {
            protected [__keep_incompatibility]: never;
            /** The display width in pixels.
            */
            public width : number
            /** The display height in pixels.
            */
            public height : number
            /** The current refresh rate of the display.
            */
            public refreshRate : UnityEngine.RefreshRate
            /** Specifies the work area rectangle of the display relative to the top left corner. For example, it excludes the area covered by the macOS Dock or the Windows Taskbar.
            */
            public workArea : UnityEngine.RectInt
            /** Human-friendly display name.
            */
            public name : string
            public Equals ($other: UnityEngine.DisplayInfo) : boolean
        }
        /** Constants for special values of Screen.sleepTimeout.
        */
        class SleepTimeout extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Prevent screen dimming.
            */
            public static NeverSleep : number
            /** Set the sleep timeout to whatever the user has specified in the system settings.
            */
            public static SystemSetting : number
            public constructor ()
        }
        /** Provides access to display information.
        */
        class Screen extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** The current width of the screen window in pixels (Read Only).
            */
            public static get width(): number;
            /** The current height of the screen window in pixels (Read Only).
            */
            public static get height(): number;
            /** The current DPI of the screen / device (Read Only).
            */
            public static get dpi(): number;
            /** The current screen resolution (Read Only).
            */
            public static get currentResolution(): UnityEngine.Resolution;
            /** Returns all full-screen resolutions that the monitor supports (Read Only).
            */
            public static get resolutions(): System.Array$1<UnityEngine.Resolution>;
            /** Get the requested MSAA sample count of the screen buffer.
            */
            public static get msaaSamples(): number;
            /** Enables full-screen mode for the application.
            */
            public static get fullScreen(): boolean;
            public static set fullScreen(value: boolean);
            /** Set this property to one of the values in FullScreenMode to change the display mode of your application.
            */
            public static get fullScreenMode(): UnityEngine.FullScreenMode;
            public static set fullScreenMode(value: UnityEngine.FullScreenMode);
            /** Returns the safe area of the screen in pixels (Read Only).
            */
            public static get safeArea(): UnityEngine.Rect;
            /** Returns a list of screen areas that are not functional for displaying content (Read Only).
            */
            public static get cutouts(): System.Array$1<UnityEngine.Rect>;
            /** Enables auto-rotation to portrait.
            */
            public static get autorotateToPortrait(): boolean;
            public static set autorotateToPortrait(value: boolean);
            /** Enables auto-rotation to portrait, upside down.
            */
            public static get autorotateToPortraitUpsideDown(): boolean;
            public static set autorotateToPortraitUpsideDown(value: boolean);
            /** Enables auto-rotation to landscape left.
            */
            public static get autorotateToLandscapeLeft(): boolean;
            public static set autorotateToLandscapeLeft(value: boolean);
            /** Enables auto-rotation to landscape right.
            */
            public static get autorotateToLandscapeRight(): boolean;
            public static set autorotateToLandscapeRight(value: boolean);
            /** Specifies logical orientation of the screen.
            */
            public static get orientation(): UnityEngine.ScreenOrientation;
            public static set orientation(value: UnityEngine.ScreenOrientation);
            /** A power saving setting, allowing the screen to dim some time after the last active user interaction.
            */
            public static get sleepTimeout(): number;
            public static set sleepTimeout(value: number);
            /** Indicates the current brightness of the screen.
            */
            public static get brightness(): number;
            public static set brightness(value: number);
            /** The position of the top left corner of the main window relative to the top left corner of the display.
            */
            public static get mainWindowPosition(): UnityEngine.Vector2Int;
            /** The display information associated with the display that the main application window is on.
            */
            public static get mainWindowDisplayInfo(): UnityEngine.DisplayInfo;
            /** Switches the screen resolution.
            */
            public static SetResolution ($width: number, $height: number, $fullscreenMode: UnityEngine.FullScreenMode, $preferredRefreshRate: UnityEngine.RefreshRate) : void
            /** Switches the screen resolution.
            */
            public static SetResolution ($width: number, $height: number, $fullscreenMode: UnityEngine.FullScreenMode) : void
            /** Switches the screen resolution.
            */
            public static SetResolution ($width: number, $height: number, $fullscreen: boolean) : void
            /** Switches the number of MSAA samples of the Unity swapchain.
            */
            public static SetMSAASamples ($numSamples: number) : void
            public static GetDisplayLayout ($displayLayout: System.Collections.Generic.List$1<UnityEngine.DisplayInfo>) : void
            /** Moves the main window to the specified position relative to the top left corner of the specified display. Position value is represented in pixels. Moving the window is an asynchronous operation, which can take multiple frames.
            * @param $display The target display where the window should move to.
            * @param $position The position the window moves to. Relative to the top left corner of the specified display in pixels.
            * @returns Returns AsyncOperation that represents moving the window. 
            */
            public static MoveMainWindowTo ($display: $Ref<UnityEngine.DisplayInfo>, $position: UnityEngine.Vector2Int) : UnityEngine.AsyncOperation
            public constructor ()
        }
        /** Represents a display resolution.
        */
        class Resolution extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Resolution width in pixels.
            */
            public get width(): number;
            public set width(value: number);
            /** Resolution height in pixels.
            */
            public get height(): number;
            public set height(value: number);
            /** Resolution's vertical refresh rate in Hz.
            */
            public get refreshRateRatio(): UnityEngine.RefreshRate;
            public set refreshRateRatio(value: UnityEngine.RefreshRate);
        }
        /** Describes screen orientation.
        */
        enum ScreenOrientation
        { Portrait = 1, PortraitUpsideDown = 2, LandscapeLeft = 3, LandscapeRight = 4, AutoRotation = 5, Unknown = 0, Landscape = 3 }
        /** Intended usage of the buffer.
        */
        enum ComputeBufferMode
        { Immutable = 0, Dynamic = 1, Circular = 2, StreamOut = 3, SubUpdates = 4 }
        /** Raw interface to Unity's drawing functions.
        */
        class Graphics extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Returns the currently active color gamut.
            */
            public static get activeColorGamut(): UnityEngine.ColorGamut;
            /** The GraphicsTier for the current device.
            */
            public static get activeTier(): UnityEngine.Rendering.GraphicsTier;
            public static set activeTier(value: UnityEngine.Rendering.GraphicsTier);
            /** True when rendering over native UI is enabled in Player Settings (readonly).
            */
            public static get preserveFramebufferAlpha(): boolean;
            /** The minimum OpenGL ES version. The value is specified in PlayerSettings.
            */
            public static get minOpenGLESVersion(): UnityEngine.Rendering.OpenGLESVersion;
            /** Currently active color buffer (Read Only).
            */
            public static get activeColorBuffer(): UnityEngine.RenderBuffer;
            /** Currently active depth/stencil buffer (Read Only).
            */
            public static get activeDepthBuffer(): UnityEngine.RenderBuffer;
            /** Clear random write targets for level pixel shaders.
            */
            public static ClearRandomWriteTargets () : void
            /** Execute a command buffer.
            * @param $buffer The buffer to execute.
            */
            public static ExecuteCommandBuffer ($buffer: UnityEngine.Rendering.CommandBuffer) : void
            /** Executes a command buffer on an async compute queue with the queue selected based on the ComputeQueueType parameter passed.
            * @param $buffer The CommandBuffer to be executed.
            * @param $queueType Describes the desired async compute queue the supplied CommandBuffer should be executed on.
            */
            public static ExecuteCommandBufferAsync ($buffer: UnityEngine.Rendering.CommandBuffer, $queueType: UnityEngine.Rendering.ComputeQueueType) : void
            /** Sets current render target.
            * @param $rt RenderTexture or GraphicsTexture to set as active render target.
            * @param $mipLevel Mipmap level to render into (use 0 if not mipmapped).
            * @param $face Cubemap face to render into (use Unknown if not a cubemap).
            * @param $depthSlice Depth slice to render into (use 0 if not a 3D or 2DArray render target).
            * @param $colorBuffer Color buffer to render into.
            * @param $depthBuffer Depth buffer to render into.
            * @param $colorBuffers Color buffers to render into (for multiple render target effects).
            * @param $setup Full render target setup information.
            */
            public static SetRenderTarget ($rt: UnityEngine.RenderTexture, $mipLevel: number, $face: UnityEngine.CubemapFace, $depthSlice: number) : void
            /** Sets current render target.
            * @param $rt RenderTexture or GraphicsTexture to set as active render target.
            * @param $mipLevel Mipmap level to render into (use 0 if not mipmapped).
            * @param $face Cubemap face to render into (use Unknown if not a cubemap).
            * @param $depthSlice Depth slice to render into (use 0 if not a 3D or 2DArray render target).
            * @param $colorBuffer Color buffer to render into.
            * @param $depthBuffer Depth buffer to render into.
            * @param $colorBuffers Color buffers to render into (for multiple render target effects).
            * @param $setup Full render target setup information.
            */
            public static SetRenderTarget ($rt: UnityEngine.Rendering.GraphicsTexture, $mipLevel: number, $face: UnityEngine.CubemapFace, $depthSlice: number) : void
            /** Sets current render target.
            * @param $rt RenderTexture or GraphicsTexture to set as active render target.
            * @param $mipLevel Mipmap level to render into (use 0 if not mipmapped).
            * @param $face Cubemap face to render into (use Unknown if not a cubemap).
            * @param $depthSlice Depth slice to render into (use 0 if not a 3D or 2DArray render target).
            * @param $colorBuffer Color buffer to render into.
            * @param $depthBuffer Depth buffer to render into.
            * @param $colorBuffers Color buffers to render into (for multiple render target effects).
            * @param $setup Full render target setup information.
            */
            public static SetRenderTarget ($colorBuffer: UnityEngine.RenderBuffer, $depthBuffer: UnityEngine.RenderBuffer, $mipLevel: number, $face: UnityEngine.CubemapFace, $depthSlice: number) : void
            /** Sets current render target.
            * @param $rt RenderTexture or GraphicsTexture to set as active render target.
            * @param $mipLevel Mipmap level to render into (use 0 if not mipmapped).
            * @param $face Cubemap face to render into (use Unknown if not a cubemap).
            * @param $depthSlice Depth slice to render into (use 0 if not a 3D or 2DArray render target).
            * @param $colorBuffer Color buffer to render into.
            * @param $depthBuffer Depth buffer to render into.
            * @param $colorBuffers Color buffers to render into (for multiple render target effects).
            * @param $setup Full render target setup information.
            */
            public static SetRenderTarget ($colorBuffers: System.Array$1<UnityEngine.RenderBuffer>, $depthBuffer: UnityEngine.RenderBuffer) : void
            /** Sets current render target.
            * @param $rt RenderTexture or GraphicsTexture to set as active render target.
            * @param $mipLevel Mipmap level to render into (use 0 if not mipmapped).
            * @param $face Cubemap face to render into (use Unknown if not a cubemap).
            * @param $depthSlice Depth slice to render into (use 0 if not a 3D or 2DArray render target).
            * @param $colorBuffer Color buffer to render into.
            * @param $depthBuffer Depth buffer to render into.
            * @param $colorBuffers Color buffers to render into (for multiple render target effects).
            * @param $setup Full render target setup information.
            */
            public static SetRenderTarget ($setup: UnityEngine.RenderTargetSetup) : void
            /** Set random write target for level pixel shaders.
            * @param $index Index of the random write target in the shader.
            * @param $uav Buffer or texture to set as the write target.
            * @param $preserveCounterValue Whether to leave the append/consume counter value unchanged.
            */
            public static SetRandomWriteTarget ($index: number, $uav: UnityEngine.RenderTexture) : void
            /** Set random write target for level pixel shaders.
            * @param $index Index of the random write target in the shader.
            * @param $uav Buffer or texture to set as the write target.
            * @param $preserveCounterValue Whether to leave the append/consume counter value unchanged.
            */
            public static SetRandomWriteTarget ($index: number, $uav: UnityEngine.ComputeBuffer, $preserveCounterValue: boolean) : void
            /** Set random write target for level pixel shaders.
            * @param $index Index of the random write target in the shader.
            * @param $uav Buffer or texture to set as the write target.
            * @param $preserveCounterValue Whether to leave the append/consume counter value unchanged.
            */
            public static SetRandomWriteTarget ($index: number, $uav: UnityEngine.GraphicsBuffer, $preserveCounterValue: boolean) : void
            /** Copies pixel data from one texture to another.
            * @param $src The source texture.
            * @param $dst The destination texture.
            * @param $srcElement The element in the source texture to copy from. For example, the CubemapFace in a Cubemap or the slice in a texture array. Set the value to 0 if src is a 2D texture.
            * @param $srcMip The mipmap level to copy from. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @param $dstElement The element in the source texture to copy to. For example, the CubemapFace in a Cubemap or the slice in a texture array. Set the value to 0 if `dst` is a 2D texture.
            * @param $dstMip The mipmap level to write to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @param $srcX The starting x coordinate of src to copy from. 0 is the left of the texture.
            * @param $srcY The starting y coordinate of src to copy from. 0 is the bottom of the texture.
            * @param $srcWidth The width of src to copy.
            * @param $srcHeight The height of src to copy.
            * @param $dstX The x coordinate of dst to copy to.
            * @param $dstY The y coordinate to dst to copy to.
            */
            public static CopyTexture ($src: UnityEngine.Texture, $dst: UnityEngine.Texture) : void
            public static CopyTexture ($src: UnityEngine.Texture, $srcElement: number, $dst: UnityEngine.Texture, $dstElement: number) : void
            /** Copies pixel data from one texture to another.
            * @param $src The source texture.
            * @param $dst The destination texture.
            * @param $srcElement The element in the source texture to copy from. For example, the CubemapFace in a Cubemap or the slice in a texture array. Set the value to 0 if src is a 2D texture.
            * @param $srcMip The mipmap level to copy from. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @param $dstElement The element in the source texture to copy to. For example, the CubemapFace in a Cubemap or the slice in a texture array. Set the value to 0 if `dst` is a 2D texture.
            * @param $dstMip The mipmap level to write to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @param $srcX The starting x coordinate of src to copy from. 0 is the left of the texture.
            * @param $srcY The starting y coordinate of src to copy from. 0 is the bottom of the texture.
            * @param $srcWidth The width of src to copy.
            * @param $srcHeight The height of src to copy.
            * @param $dstX The x coordinate of dst to copy to.
            * @param $dstY The y coordinate to dst to copy to.
            */
            public static CopyTexture ($src: UnityEngine.Texture, $srcElement: number, $srcMip: number, $dst: UnityEngine.Texture, $dstElement: number, $dstMip: number) : void
            /** Copies pixel data from one texture to another.
            * @param $src The source texture.
            * @param $dst The destination texture.
            * @param $srcElement The element in the source texture to copy from. For example, the CubemapFace in a Cubemap or the slice in a texture array. Set the value to 0 if src is a 2D texture.
            * @param $srcMip The mipmap level to copy from. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @param $dstElement The element in the source texture to copy to. For example, the CubemapFace in a Cubemap or the slice in a texture array. Set the value to 0 if `dst` is a 2D texture.
            * @param $dstMip The mipmap level to write to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @param $srcX The starting x coordinate of src to copy from. 0 is the left of the texture.
            * @param $srcY The starting y coordinate of src to copy from. 0 is the bottom of the texture.
            * @param $srcWidth The width of src to copy.
            * @param $srcHeight The height of src to copy.
            * @param $dstX The x coordinate of dst to copy to.
            * @param $dstY The y coordinate to dst to copy to.
            */
            public static CopyTexture ($src: UnityEngine.Texture, $srcElement: number, $srcMip: number, $srcX: number, $srcY: number, $srcWidth: number, $srcHeight: number, $dst: UnityEngine.Texture, $dstElement: number, $dstMip: number, $dstX: number, $dstY: number) : void
            /** Copies the pixel data from one texture, converts the data into a different format, and copies it into another texture.
            * @param $src The source texture. The texture must be a Texture2D or Cubemap.
            * @param $dst The destination texture. The texture must be a Texture2D, Texture2DArray, Cubemap, or CubemapArray. The texture must also be uncompressed and correspond to a supported RenderTextureFormat.
            * @param $srcElement The element in the source texture to copy from. Use CubemapFace if src is a Cubemap. Set the value to 0 if src is a 2D texture.
            * @param $dstElement The element in the source texture to copy to. For example, the CubemapFace in a Cubemap or the slice in a texture array. Set the value to 0 if `dst` is a 2D texture.
            * @returns true if the method succeeded. 
            */
            public static ConvertTexture ($src: UnityEngine.Texture, $dst: UnityEngine.Texture) : boolean
            /** Copies the pixel data from one texture, converts the data into a different format, and copies it into another texture.
            * @param $src The source texture. The texture must be a Texture2D or Cubemap.
            * @param $dst The destination texture. The texture must be a Texture2D, Texture2DArray, Cubemap, or CubemapArray. The texture must also be uncompressed and correspond to a supported RenderTextureFormat.
            * @param $srcElement The element in the source texture to copy from. Use CubemapFace if src is a Cubemap. Set the value to 0 if src is a 2D texture.
            * @param $dstElement The element in the source texture to copy to. For example, the CubemapFace in a Cubemap or the slice in a texture array. Set the value to 0 if `dst` is a 2D texture.
            * @returns true if the method succeeded. 
            */
            public static ConvertTexture ($src: UnityEngine.Texture, $srcElement: number, $dst: UnityEngine.Texture, $dstElement: number) : boolean
            /** Shortcut for calling Graphics.CreateGraphicsFence with Rendering.GraphicsFenceType.AsyncQueueSynchronisation as the first parameter.
            * @param $stage Which SynchronisationStage to insert the fence after.
            * @returns Returns a new GraphicsFence. 
            */
            public static CreateAsyncGraphicsFence ($stage: UnityEngine.Rendering.SynchronisationStage) : UnityEngine.Rendering.GraphicsFence
            /** Shortcut for calling Graphics.CreateGraphicsFence with Rendering.GraphicsFenceType.AsyncQueueSynchronisation as the first parameter.
            * @param $stage Which SynchronisationStage to insert the fence after.
            * @returns Returns a new GraphicsFence. 
            */
            public static CreateAsyncGraphicsFence () : UnityEngine.Rendering.GraphicsFence
            /** Creates a GraphicsFence.
            * @param $fenceType The Rendering.GraphicsFenceType to create. Currently the only supported value is Rendering.GraphicsFenceType.AsyncQueueSynchronisation.
            * @param $stage Which SynchronisationStage to insert the fence after.
            * @returns Returns a new GraphicsFence. 
            */
            public static CreateGraphicsFence ($fenceType: UnityEngine.Rendering.GraphicsFenceType, $stage: UnityEngine.Rendering.SynchronisationStageFlags) : UnityEngine.Rendering.GraphicsFence
            /** Instructs the GPU to pause processing of the queue until it passes through the GraphicsFence fence.
            * @param $fence The GraphicsFence the GPU waits for. The fenceType of the graphics fence must be Rendering.GraphicsFenceType.AsyncQueueSynchronisation.
            * @param $stage Which SynchronisationStage to wait for.
            */
            public static WaitOnAsyncGraphicsFence ($fence: UnityEngine.Rendering.GraphicsFence) : void
            /** Instructs the GPU to pause processing of the queue until it passes through the GraphicsFence fence.
            * @param $fence The GraphicsFence the GPU waits for. The fenceType of the graphics fence must be Rendering.GraphicsFenceType.AsyncQueueSynchronisation.
            * @param $stage Which SynchronisationStage to wait for.
            */
            public static WaitOnAsyncGraphicsFence ($fence: UnityEngine.Rendering.GraphicsFence, $stage: UnityEngine.Rendering.SynchronisationStage) : void
            /** Copies the contents of one GraphicsBuffer into another.
            * @param $source The source buffer.
            * @param $dest The destination buffer.
            */
            public static CopyBuffer ($source: UnityEngine.GraphicsBuffer, $dest: UnityEngine.GraphicsBuffer) : void
            /** Draw a texture in screen coordinates.
            * @param $screenRect Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.
            * @param $texture Texture to draw.
            * @param $sourceRect Region of the texture to use. In normalized coordinates with (0,0) in the bottom-left corner.
            * @param $leftBorder Number of pixels from the left that are not affected by scale.
            * @param $rightBorder Number of pixels from the right that are not affected by scale.
            * @param $topBorder Number of pixels from the top that are not affected by scale.
            * @param $bottomBorder Number of pixels from the bottom that are not affected by scale.
            * @param $color Color that modulates the output. The neutral value is (0.5, 0.5, 0.5, 0.5). Set as vertex color for the shader.
            * @param $mat Custom Material that can be used to draw the texture. If null is passed, a default material with the Internal-GUITexture.shader is used.
            * @param $pass If -1 (default), draws all passes in the material. Otherwise, draws given pass only.
            */
            public static DrawTexture ($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $sourceRect: UnityEngine.Rect, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number, $color: UnityEngine.Color, $mat: UnityEngine.Material, $pass: number) : void
            /** Draw a texture in screen coordinates.
            * @param $screenRect Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.
            * @param $texture Texture to draw.
            * @param $sourceRect Region of the texture to use. In normalized coordinates with (0,0) in the bottom-left corner.
            * @param $leftBorder Number of pixels from the left that are not affected by scale.
            * @param $rightBorder Number of pixels from the right that are not affected by scale.
            * @param $topBorder Number of pixels from the top that are not affected by scale.
            * @param $bottomBorder Number of pixels from the bottom that are not affected by scale.
            * @param $color Color that modulates the output. The neutral value is (0.5, 0.5, 0.5, 0.5). Set as vertex color for the shader.
            * @param $mat Custom Material that can be used to draw the texture. If null is passed, a default material with the Internal-GUITexture.shader is used.
            * @param $pass If -1 (default), draws all passes in the material. Otherwise, draws given pass only.
            */
            public static DrawTexture ($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $sourceRect: UnityEngine.Rect, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number, $mat: UnityEngine.Material, $pass: number) : void
            /** Draw a texture in screen coordinates.
            * @param $screenRect Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.
            * @param $texture Texture to draw.
            * @param $sourceRect Region of the texture to use. In normalized coordinates with (0,0) in the bottom-left corner.
            * @param $leftBorder Number of pixels from the left that are not affected by scale.
            * @param $rightBorder Number of pixels from the right that are not affected by scale.
            * @param $topBorder Number of pixels from the top that are not affected by scale.
            * @param $bottomBorder Number of pixels from the bottom that are not affected by scale.
            * @param $color Color that modulates the output. The neutral value is (0.5, 0.5, 0.5, 0.5). Set as vertex color for the shader.
            * @param $mat Custom Material that can be used to draw the texture. If null is passed, a default material with the Internal-GUITexture.shader is used.
            * @param $pass If -1 (default), draws all passes in the material. Otherwise, draws given pass only.
            */
            public static DrawTexture ($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number, $mat: UnityEngine.Material, $pass: number) : void
            /** Draw a texture in screen coordinates.
            * @param $screenRect Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.
            * @param $texture Texture to draw.
            * @param $sourceRect Region of the texture to use. In normalized coordinates with (0,0) in the bottom-left corner.
            * @param $leftBorder Number of pixels from the left that are not affected by scale.
            * @param $rightBorder Number of pixels from the right that are not affected by scale.
            * @param $topBorder Number of pixels from the top that are not affected by scale.
            * @param $bottomBorder Number of pixels from the bottom that are not affected by scale.
            * @param $color Color that modulates the output. The neutral value is (0.5, 0.5, 0.5, 0.5). Set as vertex color for the shader.
            * @param $mat Custom Material that can be used to draw the texture. If null is passed, a default material with the Internal-GUITexture.shader is used.
            * @param $pass If -1 (default), draws all passes in the material. Otherwise, draws given pass only.
            */
            public static DrawTexture ($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $mat: UnityEngine.Material, $pass: number) : void
            public static RenderMesh ($rparams: $Ref<UnityEngine.RenderParams>, $mesh: UnityEngine.Mesh, $submeshIndex: number, $objectToWorld: UnityEngine.Matrix4x4, $prevObjectToWorld?: UnityEngine.Matrix4x4 | null) : void
            /** Renders multiple instances of a mesh using GPU instancing and rendering command arguments from commandBuffer.
            * @param $rparams The parameters Unity uses to render the mesh.
            * @param $mesh The Mesh to render.
            * @param $commandBuffer A command buffer that provides rendering command arguments (see GraphicsBuffer.IndirectDrawIndexedArgs).
            * @param $commandCount The number of rendering commands to execute in the commandBuffer.
            * @param $startCommand The first command to execute in the commandBuffer.
            */
            public static RenderMeshIndirect ($rparams: $Ref<UnityEngine.RenderParams>, $mesh: UnityEngine.Mesh, $commandBuffer: UnityEngine.GraphicsBuffer, $commandCount?: number, $startCommand?: number) : void
            /** Renders multiple instances of a Mesh using GPU instancing and a custom shader.
            * @param $rparams The parameters Unity uses to render the Mesh primitives.
            * @param $mesh The Mesh to render.
            * @param $submeshIndex The index of a submesh Unity renders when the Mesh contains multiple Materials (submeshes). For a Mesh with a single Material, use value 0.
            * @param $instanceCount The number of instances to render.
            */
            public static RenderMeshPrimitives ($rparams: $Ref<UnityEngine.RenderParams>, $mesh: UnityEngine.Mesh, $submeshIndex: number, $instanceCount?: number) : void
            /** Renders non-indexed primitives with GPU instancing and a custom shader.
            * @param $rparams The parameters Unity uses to render the primitives.
            * @param $topology Primitive topology (for example, triangles or lines).
            * @param $vertexCount The number of vertices per instance.
            * @param $instanceCount The number of instances to render.
            */
            public static RenderPrimitives ($rparams: $Ref<UnityEngine.RenderParams>, $topology: UnityEngine.MeshTopology, $vertexCount: number, $instanceCount?: number) : void
            /** Renders indexed primitives with GPU instancing and a custom shader.
            * @param $rparams The parameters Unity uses to render the primitives.
            * @param $topology Primitive topology (for example, triangles or lines).
            * @param $indexBuffer The index buffer for the rendered primitives.
            * @param $indexCount The number of indices per instance.
            * @param $startIndex The first index in the indexBuffer.
            * @param $instanceCount The number of instances to render.
            */
            public static RenderPrimitivesIndexed ($rparams: $Ref<UnityEngine.RenderParams>, $topology: UnityEngine.MeshTopology, $indexBuffer: UnityEngine.GraphicsBuffer, $indexCount: number, $startIndex?: number, $instanceCount?: number) : void
            /** Renders primitives with GPU instancing and a custom shader using rendering command arguments from commandBuffer.
            * @param $rparams The parameters Unity uses to render the primitives.
            * @param $topology Primitive topology (for example, triangles or lines).
            * @param $commandBuffer A command buffer that provides rendering command arguments (see GraphicsBuffer.IndirectDrawArgs).
            * @param $commandCount The number of rendering commands to execute in the commandBuffer.
            * @param $startCommand The first command to execute in the commandBuffer.
            */
            public static RenderPrimitivesIndirect ($rparams: $Ref<UnityEngine.RenderParams>, $topology: UnityEngine.MeshTopology, $commandBuffer: UnityEngine.GraphicsBuffer, $commandCount?: number, $startCommand?: number) : void
            /** Renders indexed primitives with GPU instancing and a custom shader with rendering command arguments from commandBuffer.
            * @param $rparams The parameters Unity uses to render the primitives.
            * @param $topology Primitive topology (for example, triangles or lines).
            * @param $indexBuffer Index buffer for the rendered primitives.
            * @param $commandBuffer A command buffer that provides rendering command arguments (see GraphicsBuffer.IndirectDrawIndexedArgs).
            * @param $commandCount The number of rendering commands to execute in the commandBuffer.
            * @param $startCommand The first command to execute in the commandBuffer.
            */
            public static RenderPrimitivesIndexedIndirect ($rparams: $Ref<UnityEngine.RenderParams>, $topology: UnityEngine.MeshTopology, $indexBuffer: UnityEngine.GraphicsBuffer, $commandBuffer: UnityEngine.GraphicsBuffer, $commandCount?: number, $startCommand?: number) : void
            /** Draw a mesh immediately.
            * @param $mesh The Mesh to draw.
            * @param $position Position of the mesh.
            * @param $rotation Rotation of the mesh.
            * @param $matrix The transformation matrix of the mesh (combines position, rotation and other transformations).
            * @param $materialIndex Subset of the mesh to draw.
            */
            public static DrawMeshNow ($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $materialIndex: number) : void
            /** Draw a mesh immediately.
            * @param $mesh The Mesh to draw.
            * @param $position Position of the mesh.
            * @param $rotation Rotation of the mesh.
            * @param $matrix The transformation matrix of the mesh (combines position, rotation and other transformations).
            * @param $materialIndex Subset of the mesh to draw.
            */
            public static DrawMeshNow ($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $materialIndex: number) : void
            /** Draw a mesh immediately.
            * @param $mesh The Mesh to draw.
            * @param $position Position of the mesh.
            * @param $rotation Rotation of the mesh.
            * @param $matrix The transformation matrix of the mesh (combines position, rotation and other transformations).
            * @param $materialIndex Subset of the mesh to draw.
            */
            public static DrawMeshNow ($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion) : void
            /** Draw a mesh immediately.
            * @param $mesh The Mesh to draw.
            * @param $position Position of the mesh.
            * @param $rotation Rotation of the mesh.
            * @param $matrix The transformation matrix of the mesh (combines position, rotation and other transformations).
            * @param $materialIndex Subset of the mesh to draw.
            */
            public static DrawMeshNow ($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4) : void
            /** Draw a mesh.
            * @param $mesh The Mesh to draw.
            * @param $position Position of the mesh.
            * @param $rotation Rotation of the mesh.
            * @param $matrix Transformation matrix of the mesh (combines position, rotation and other transformations).
            * @param $material Material to use.
            * @param $layer  the mesh is drawn on.
            * @param $camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
            * @param $submeshIndex Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.
            * @param $properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
            * @param $castShadows Determines whether the mesh can cast shadows.
            * @param $receiveShadows Determines whether the mesh can receive shadows.
            * @param $useLightProbes Should the mesh use light probes?
            * @param $probeAnchor If used, the mesh will use this Transform's position to sample light probes and find the matching reflection probe.
            * @param $lightProbeUsage LightProbeUsage for the mesh.
            */
            public static DrawMesh ($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: boolean, $receiveShadows: boolean, $useLightProbes: boolean) : void
            /** Draw a mesh.
            * @param $mesh The Mesh to draw.
            * @param $position Position of the mesh.
            * @param $rotation Rotation of the mesh.
            * @param $matrix Transformation matrix of the mesh (combines position, rotation and other transformations).
            * @param $material Material to use.
            * @param $layer  the mesh is drawn on.
            * @param $camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
            * @param $submeshIndex Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.
            * @param $properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
            * @param $castShadows Determines whether the mesh can cast shadows.
            * @param $receiveShadows Determines whether the mesh can receive shadows.
            * @param $useLightProbes Should the mesh use light probes?
            * @param $probeAnchor If used, the mesh will use this Transform's position to sample light probes and find the matching reflection probe.
            * @param $lightProbeUsage LightProbeUsage for the mesh.
            */
            public static DrawMesh ($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $probeAnchor: UnityEngine.Transform, $useLightProbes: boolean) : void
            /** Draw a mesh.
            * @param $mesh The Mesh to draw.
            * @param $position Position of the mesh.
            * @param $rotation Rotation of the mesh.
            * @param $matrix Transformation matrix of the mesh (combines position, rotation and other transformations).
            * @param $material Material to use.
            * @param $layer  the mesh is drawn on.
            * @param $camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
            * @param $submeshIndex Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.
            * @param $properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
            * @param $castShadows Determines whether the mesh can cast shadows.
            * @param $receiveShadows Determines whether the mesh can receive shadows.
            * @param $useLightProbes Should the mesh use light probes?
            * @param $probeAnchor If used, the mesh will use this Transform's position to sample light probes and find the matching reflection probe.
            * @param $lightProbeUsage LightProbeUsage for the mesh.
            */
            public static DrawMesh ($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: boolean, $receiveShadows: boolean, $useLightProbes: boolean) : void
            /** Draw a mesh.
            * @param $mesh The Mesh to draw.
            * @param $position Position of the mesh.
            * @param $rotation Rotation of the mesh.
            * @param $matrix Transformation matrix of the mesh (combines position, rotation and other transformations).
            * @param $material Material to use.
            * @param $layer  the mesh is drawn on.
            * @param $camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
            * @param $submeshIndex Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.
            * @param $properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
            * @param $castShadows Determines whether the mesh can cast shadows.
            * @param $receiveShadows Determines whether the mesh can receive shadows.
            * @param $useLightProbes Should the mesh use light probes?
            * @param $probeAnchor If used, the mesh will use this Transform's position to sample light probes and find the matching reflection probe.
            * @param $lightProbeUsage LightProbeUsage for the mesh.
            */
            public static DrawMesh ($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $probeAnchor: UnityEngine.Transform, $lightProbeUsage: UnityEngine.Rendering.LightProbeUsage, $lightProbeProxyVolume: UnityEngine.LightProbeProxyVolume) : void
            /** Draws the same mesh multiple times using GPU instancing.
            * @param $mesh The Mesh to draw.
            * @param $submeshIndex Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.
            * @param $material Material to use.
            * @param $matrices The array of object transformation matrices.
            * @param $count The number of instances to be drawn.
            * @param $properties Additional material properties to apply. See MaterialPropertyBlock.
            * @param $castShadows Determines whether the Meshes should cast shadows.
            * @param $receiveShadows Determines whether the Meshes should receive shadows.
            * @param $layer  to use.
            * @param $camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be drawn in the given Camera only.
            * @param $lightProbeUsage LightProbeUsage for the instances.
            */
            public static DrawMeshInstanced ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Array$1<UnityEngine.Matrix4x4>, $count: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number, $camera: UnityEngine.Camera, $lightProbeUsage: UnityEngine.Rendering.LightProbeUsage, $lightProbeProxyVolume: UnityEngine.LightProbeProxyVolume) : void
            public static DrawMeshInstanced ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number, $camera: UnityEngine.Camera, $lightProbeUsage: UnityEngine.Rendering.LightProbeUsage, $lightProbeProxyVolume: UnityEngine.LightProbeProxyVolume) : void
            /** This function is now obsolete. Use Graphics.RenderMeshPrimitives instead. Draws the same mesh multiple times using GPU instancing.
            This is similar to Graphics.DrawMeshInstancedIndirect, except that when the instance count is known from script, it can be supplied directly using this method, rather than via a ComputeBuffer.
            * @param $mesh The Mesh to draw.
            * @param $submeshIndex Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.
            * @param $material Material to use.
            * @param $bounds The bounding volume surrounding the instances you intend to draw.
            * @param $count The number of instances to be drawn.
            * @param $properties Additional material properties to apply. See MaterialPropertyBlock.
            * @param $castShadows Determines whether the Meshes should cast shadows.
            * @param $receiveShadows Determines whether the Meshes should receive shadows.
            * @param $layer  to use.
            * @param $camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be drawn in the given Camera only.
            * @param $lightProbeUsage LightProbeUsage for the instances.
            */
            public static DrawMeshInstancedProcedural ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $bounds: UnityEngine.Bounds, $count: number, $properties?: UnityEngine.MaterialPropertyBlock, $castShadows?: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: number, $camera?: UnityEngine.Camera, $lightProbeUsage?: UnityEngine.Rendering.LightProbeUsage, $lightProbeProxyVolume?: UnityEngine.LightProbeProxyVolume) : void
            /** This function is now obsolete. Use Graphics.RenderMeshIndirect instead. Draws the same mesh multiple times using GPU instancing.
            * @param $mesh The Mesh to draw.
            * @param $submeshIndex Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.
            * @param $material Material to use.
            * @param $bounds The bounding volume surrounding the instances you intend to draw.
            * @param $bufferWithArgs The GPU buffer containing the arguments for how many instances of this mesh to draw.
            * @param $argsOffset The byte offset into the buffer, where the draw arguments start.
            * @param $properties Additional material properties to apply. See MaterialPropertyBlock.
            * @param $castShadows Determines whether the mesh can cast shadows.
            * @param $receiveShadows Determines whether the mesh can receive shadows.
            * @param $layer  to use.
            * @param $camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be drawn in the given Camera only.
            * @param $lightProbeUsage LightProbeUsage for the instances.
            */
            public static DrawMeshInstancedIndirect ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $bounds: UnityEngine.Bounds, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number, $camera: UnityEngine.Camera, $lightProbeUsage: UnityEngine.Rendering.LightProbeUsage, $lightProbeProxyVolume: UnityEngine.LightProbeProxyVolume) : void
            /** This function is now obsolete. Use Graphics.RenderMeshIndirect instead. Draws the same mesh multiple times using GPU instancing.
            * @param $mesh The Mesh to draw.
            * @param $submeshIndex Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.
            * @param $material Material to use.
            * @param $bounds The bounding volume surrounding the instances you intend to draw.
            * @param $bufferWithArgs The GPU buffer containing the arguments for how many instances of this mesh to draw.
            * @param $argsOffset The byte offset into the buffer, where the draw arguments start.
            * @param $properties Additional material properties to apply. See MaterialPropertyBlock.
            * @param $castShadows Determines whether the mesh can cast shadows.
            * @param $receiveShadows Determines whether the mesh can receive shadows.
            * @param $layer  to use.
            * @param $camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be drawn in the given Camera only.
            * @param $lightProbeUsage LightProbeUsage for the instances.
            */
            public static DrawMeshInstancedIndirect ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $bounds: UnityEngine.Bounds, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number, $camera: UnityEngine.Camera, $lightProbeUsage: UnityEngine.Rendering.LightProbeUsage, $lightProbeProxyVolume: UnityEngine.LightProbeProxyVolume) : void
            /** Draws procedural geometry on the GPU.
            * @param $topology Topology of the procedural geometry.
            * @param $vertexCount Vertex count to render.
            * @param $instanceCount Instance count to render.
            */
            public static DrawProceduralNow ($topology: UnityEngine.MeshTopology, $vertexCount: number, $instanceCount?: number) : void
            /** Draws procedural geometry on the GPU.
            * @param $topology Topology of the procedural geometry.
            * @param $indexCount Index count to render.
            * @param $instanceCount Instance count to render.
            * @param $indexBuffer Index buffer used to submit vertices to the GPU.
            */
            public static DrawProceduralNow ($topology: UnityEngine.MeshTopology, $indexBuffer: UnityEngine.GraphicsBuffer, $indexCount: number, $instanceCount?: number) : void
            /** Draws procedural geometry on the GPU.
            * @param $topology Topology of the procedural geometry.
            * @param $bufferWithArgs Buffer with draw arguments.
            * @param $argsOffset Byte offset where in the buffer the draw arguments are.
            */
            public static DrawProceduralIndirectNow ($topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset?: number) : void
            /** Draws procedural geometry on the GPU.
            * @param $topology Topology of the procedural geometry.
            * @param $indexBuffer Index buffer used to submit vertices to the GPU.
            * @param $bufferWithArgs Buffer with draw arguments.
            * @param $argsOffset Byte offset where in the buffer the draw arguments are.
            */
            public static DrawProceduralIndirectNow ($topology: UnityEngine.MeshTopology, $indexBuffer: UnityEngine.GraphicsBuffer, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset?: number) : void
            /** Draws procedural geometry on the GPU.
            * @param $topology Topology of the procedural geometry.
            * @param $bufferWithArgs Buffer with draw arguments.
            * @param $argsOffset Byte offset where in the buffer the draw arguments are.
            */
            public static DrawProceduralIndirectNow ($topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset?: number) : void
            /** Draws procedural geometry on the GPU.
            * @param $topology Topology of the procedural geometry.
            * @param $indexBuffer Index buffer used to submit vertices to the GPU.
            * @param $bufferWithArgs Buffer with draw arguments.
            * @param $argsOffset Byte offset where in the buffer the draw arguments are.
            */
            public static DrawProceduralIndirectNow ($topology: UnityEngine.MeshTopology, $indexBuffer: UnityEngine.GraphicsBuffer, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset?: number) : void
            /** This function is now obsolete. For non-indexed rendering, use Graphics.RenderPrimitives instead.
            For indexed rendering, use Graphics.RenderPrimitivesIndexed. Draws procedural geometry on the GPU.
            * @param $material Material to use.
            * @param $bounds The bounding volume surrounding the instances you intend to draw.
            * @param $topology Topology of the procedural geometry.
            * @param $vertexCount Vertex count to render.
            * @param $instanceCount Instance count to render.
            * @param $camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
            * @param $properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
            * @param $castShadows Determines whether the mesh can cast shadows.
            * @param $receiveShadows Determines whether the mesh can receive shadows.
            * @param $layer  to use.
            */
            public static DrawProcedural ($material: UnityEngine.Material, $bounds: UnityEngine.Bounds, $topology: UnityEngine.MeshTopology, $vertexCount: number, $instanceCount?: number, $camera?: UnityEngine.Camera, $properties?: UnityEngine.MaterialPropertyBlock, $castShadows?: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: number) : void
            /** Draws procedural geometry on the GPU, with an index buffer.
            * @param $material Material to use.
            * @param $bounds The bounding volume surrounding the instances you intend to draw.
            * @param $topology Topology of the procedural geometry.
            * @param $indexBuffer Index buffer used to submit vertices to the GPU.
            * @param $instanceCount Instance count to render.
            * @param $indexCount Index count to render.
            * @param $camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
            * @param $properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
            * @param $castShadows Determines whether the mesh can cast shadows.
            * @param $receiveShadows Determines whether the mesh can receive shadows.
            * @param $layer  to use.
            */
            public static DrawProcedural ($material: UnityEngine.Material, $bounds: UnityEngine.Bounds, $topology: UnityEngine.MeshTopology, $indexBuffer: UnityEngine.GraphicsBuffer, $indexCount: number, $instanceCount?: number, $camera?: UnityEngine.Camera, $properties?: UnityEngine.MaterialPropertyBlock, $castShadows?: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: number) : void
            /** Draws procedural geometry on the GPU.
            * @param $material Material to use.
            * @param $bounds The bounding volume surrounding the instances you intend to draw.
            * @param $topology Topology of the procedural geometry.
            * @param $camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
            * @param $bufferWithArgs Buffer with draw arguments.
            * @param $argsOffset Byte offset where in the buffer the draw arguments are.
            * @param $properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
            * @param $castShadows Determines whether the mesh can cast shadows.
            * @param $receiveShadows Determines whether the mesh can receive shadows.
            * @param $layer  to use.
            */
            public static DrawProceduralIndirect ($material: UnityEngine.Material, $bounds: UnityEngine.Bounds, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset?: number, $camera?: UnityEngine.Camera, $properties?: UnityEngine.MaterialPropertyBlock, $castShadows?: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: number) : void
            /** Draws procedural geometry on the GPU.
            * @param $material Material to use.
            * @param $bounds The bounding volume surrounding the instances you intend to draw.
            * @param $topology Topology of the procedural geometry.
            * @param $camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
            * @param $bufferWithArgs Buffer with draw arguments.
            * @param $argsOffset Byte offset where in the buffer the draw arguments are.
            * @param $properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
            * @param $castShadows Determines whether the mesh can cast shadows.
            * @param $receiveShadows Determines whether the mesh can receive shadows.
            * @param $layer  to use.
            */
            public static DrawProceduralIndirect ($material: UnityEngine.Material, $bounds: UnityEngine.Bounds, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset?: number, $camera?: UnityEngine.Camera, $properties?: UnityEngine.MaterialPropertyBlock, $castShadows?: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: number) : void
            /** Draws procedural geometry on the GPU.
            * @param $material Material to use.
            * @param $bounds The bounding volume surrounding the instances you intend to draw.
            * @param $topology Topology of the procedural geometry.
            * @param $indexBuffer Index buffer used to submit vertices to the GPU.
            * @param $camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
            * @param $bufferWithArgs Buffer with draw arguments.
            * @param $argsOffset Byte offset where in the buffer the draw arguments are.
            * @param $properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
            * @param $castShadows Determines whether the mesh can cast shadows.
            * @param $receiveShadows Determines whether the mesh can receive shadows.
            * @param $layer  to use.
            */
            public static DrawProceduralIndirect ($material: UnityEngine.Material, $bounds: UnityEngine.Bounds, $topology: UnityEngine.MeshTopology, $indexBuffer: UnityEngine.GraphicsBuffer, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset?: number, $camera?: UnityEngine.Camera, $properties?: UnityEngine.MaterialPropertyBlock, $castShadows?: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: number) : void
            /** Draws procedural geometry on the GPU.
            * @param $material Material to use.
            * @param $bounds The bounding volume surrounding the instances you intend to draw.
            * @param $topology Topology of the procedural geometry.
            * @param $indexBuffer Index buffer used to submit vertices to the GPU.
            * @param $camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
            * @param $bufferWithArgs Buffer with draw arguments.
            * @param $argsOffset Byte offset where in the buffer the draw arguments are.
            * @param $properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
            * @param $castShadows Determines whether the mesh can cast shadows.
            * @param $receiveShadows Determines whether the mesh can receive shadows.
            * @param $layer  to use.
            */
            public static DrawProceduralIndirect ($material: UnityEngine.Material, $bounds: UnityEngine.Bounds, $topology: UnityEngine.MeshTopology, $indexBuffer: UnityEngine.GraphicsBuffer, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset?: number, $camera?: UnityEngine.Camera, $properties?: UnityEngine.MaterialPropertyBlock, $castShadows?: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: number) : void
            /** Uses a shader to copy the pixel data from a texture into a render target.
            * @param $source The source texture.
            * @param $dest The destination RenderTexture or GraphicsTexture.
            * @param $mat The material to use. If you don't provide mat, Unity uses a default material.
            * @param $pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
            * @param $scale The scale to apply.
            * @param $offset The offset to apply.
            * @param $sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
            * @param $destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
            */
            public static Blit ($source: UnityEngine.Texture, $dest: UnityEngine.RenderTexture) : void
            /** Uses a shader to copy the pixel data from a texture into a render target.
            * @param $source The source texture.
            * @param $dest The destination RenderTexture or GraphicsTexture.
            * @param $mat The material to use. If you don't provide mat, Unity uses a default material.
            * @param $pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
            * @param $scale The scale to apply.
            * @param $offset The offset to apply.
            * @param $sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
            * @param $destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
            */
            public static Blit ($source: UnityEngine.Texture, $dest: UnityEngine.RenderTexture, $sourceDepthSlice: number, $destDepthSlice: number) : void
            /** Uses a shader to copy the pixel data from a texture into a render target.
            * @param $source The source texture.
            * @param $dest The destination RenderTexture or GraphicsTexture.
            * @param $mat The material to use. If you don't provide mat, Unity uses a default material.
            * @param $pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
            * @param $scale The scale to apply.
            * @param $offset The offset to apply.
            * @param $sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
            * @param $destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
            */
            public static Blit ($source: UnityEngine.Texture, $dest: UnityEngine.RenderTexture, $scale: UnityEngine.Vector2, $offset: UnityEngine.Vector2) : void
            /** Uses a shader to copy the pixel data from a texture into a render target.
            * @param $source The source texture.
            * @param $dest The destination RenderTexture or GraphicsTexture.
            * @param $mat The material to use. If you don't provide mat, Unity uses a default material.
            * @param $pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
            * @param $scale The scale to apply.
            * @param $offset The offset to apply.
            * @param $sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
            * @param $destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
            */
            public static Blit ($source: UnityEngine.Texture, $dest: UnityEngine.RenderTexture, $scale: UnityEngine.Vector2, $offset: UnityEngine.Vector2, $sourceDepthSlice: number, $destDepthSlice: number) : void
            /** Uses a shader to copy the pixel data from a texture into a render target.
            * @param $source The source texture.
            * @param $dest The destination RenderTexture or GraphicsTexture.
            * @param $mat The material to use. If you don't provide mat, Unity uses a default material.
            * @param $pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
            * @param $scale The scale to apply.
            * @param $offset The offset to apply.
            * @param $sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
            * @param $destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
            */
            public static Blit ($source: UnityEngine.Texture, $dest: UnityEngine.RenderTexture, $mat: UnityEngine.Material, $pass: number) : void
            public static Blit ($source: UnityEngine.Texture, $dest: UnityEngine.RenderTexture, $mat: UnityEngine.Material, $pass: number, $destDepthSlice: number) : void
            public static Blit ($source: UnityEngine.Texture, $dest: UnityEngine.RenderTexture, $mat: UnityEngine.Material) : void
            /** Uses a shader to copy the pixel data from a texture into a render target.
            * @param $source The source texture.
            * @param $dest The destination RenderTexture or GraphicsTexture.
            * @param $mat The material to use. If you don't provide mat, Unity uses a default material.
            * @param $pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
            * @param $scale The scale to apply.
            * @param $offset The offset to apply.
            * @param $sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
            * @param $destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
            */
            public static Blit ($source: UnityEngine.Texture, $mat: UnityEngine.Material, $pass: number) : void
            /** Uses a shader to copy the pixel data from a texture into a render target.
            * @param $source The source texture.
            * @param $dest The destination RenderTexture or GraphicsTexture.
            * @param $mat The material to use. If you don't provide mat, Unity uses a default material.
            * @param $pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
            * @param $scale The scale to apply.
            * @param $offset The offset to apply.
            * @param $sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
            * @param $destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
            */
            public static Blit ($source: UnityEngine.Texture, $mat: UnityEngine.Material, $pass: number, $destDepthSlice: number) : void
            public static Blit ($source: UnityEngine.Texture, $mat: UnityEngine.Material) : void
            /** Copies source texture into destination, for multi-tap shader.
            * @param $source Source texture.
            * @param $dest Destination RenderTexture, GraphicsTexture, or null to blit directly to screen.
            * @param $mat Material to use for copying. Material's shader should do some post-processing effect.
            * @param $offsets Variable number of filtering offsets. Offsets are given in pixels.
            * @param $destDepthSlice The texture array destination slice to blit to.
            */
            public static BlitMultiTap ($source: UnityEngine.Texture, $dest: UnityEngine.RenderTexture, $mat: UnityEngine.Material, ...offsets: UnityEngine.Vector2[]) : void
            /** Copies source texture into destination, for multi-tap shader.
            * @param $source Source texture.
            * @param $dest Destination RenderTexture, GraphicsTexture, or null to blit directly to screen.
            * @param $mat Material to use for copying. Material's shader should do some post-processing effect.
            * @param $offsets Variable number of filtering offsets. Offsets are given in pixels.
            * @param $destDepthSlice The texture array destination slice to blit to.
            */
            public static BlitMultiTap ($source: UnityEngine.Texture, $dest: UnityEngine.RenderTexture, $mat: UnityEngine.Material, $destDepthSlice: number, ...offsets: UnityEngine.Vector2[]) : void
            /** Uses a shader to copy the pixel data from a texture into a render target.
            * @param $source The source texture.
            * @param $dest The destination RenderTexture or GraphicsTexture.
            * @param $mat The material to use. If you don't provide mat, Unity uses a default material.
            * @param $pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
            * @param $scale The scale to apply.
            * @param $offset The offset to apply.
            * @param $sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
            * @param $destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
            */
            public static Blit ($source: UnityEngine.Texture, $dest: UnityEngine.Rendering.GraphicsTexture) : void
            /** Uses a shader to copy the pixel data from a texture into a render target.
            * @param $source The source texture.
            * @param $dest The destination RenderTexture or GraphicsTexture.
            * @param $mat The material to use. If you don't provide mat, Unity uses a default material.
            * @param $pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
            * @param $scale The scale to apply.
            * @param $offset The offset to apply.
            * @param $sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
            * @param $destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
            */
            public static Blit ($source: UnityEngine.Texture, $dest: UnityEngine.Rendering.GraphicsTexture, $sourceDepthSlice: number, $destDepthSlice: number) : void
            /** Uses a shader to copy the pixel data from a texture into a render target.
            * @param $source The source texture.
            * @param $dest The destination RenderTexture or GraphicsTexture.
            * @param $mat The material to use. If you don't provide mat, Unity uses a default material.
            * @param $pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
            * @param $scale The scale to apply.
            * @param $offset The offset to apply.
            * @param $sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
            * @param $destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
            */
            public static Blit ($source: UnityEngine.Texture, $dest: UnityEngine.Rendering.GraphicsTexture, $scale: UnityEngine.Vector2, $offset: UnityEngine.Vector2) : void
            /** Uses a shader to copy the pixel data from a texture into a render target.
            * @param $source The source texture.
            * @param $dest The destination RenderTexture or GraphicsTexture.
            * @param $mat The material to use. If you don't provide mat, Unity uses a default material.
            * @param $pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
            * @param $scale The scale to apply.
            * @param $offset The offset to apply.
            * @param $sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
            * @param $destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
            */
            public static Blit ($source: UnityEngine.Texture, $dest: UnityEngine.Rendering.GraphicsTexture, $scale: UnityEngine.Vector2, $offset: UnityEngine.Vector2, $sourceDepthSlice: number, $destDepthSlice: number) : void
            /** Uses a shader to copy the pixel data from a texture into a render target.
            * @param $source The source texture.
            * @param $dest The destination RenderTexture or GraphicsTexture.
            * @param $mat The material to use. If you don't provide mat, Unity uses a default material.
            * @param $pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
            * @param $scale The scale to apply.
            * @param $offset The offset to apply.
            * @param $sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
            * @param $destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
            */
            public static Blit ($source: UnityEngine.Texture, $dest: UnityEngine.Rendering.GraphicsTexture, $mat: UnityEngine.Material, $pass: number) : void
            public static Blit ($source: UnityEngine.Texture, $dest: UnityEngine.Rendering.GraphicsTexture, $mat: UnityEngine.Material, $pass: number, $destDepthSlice: number) : void
            public static Blit ($source: UnityEngine.Texture, $dest: UnityEngine.Rendering.GraphicsTexture, $mat: UnityEngine.Material) : void
            /** Copies source texture into destination, for multi-tap shader.
            * @param $source Source texture.
            * @param $dest Destination RenderTexture, GraphicsTexture, or null to blit directly to screen.
            * @param $mat Material to use for copying. Material's shader should do some post-processing effect.
            * @param $offsets Variable number of filtering offsets. Offsets are given in pixels.
            * @param $destDepthSlice The texture array destination slice to blit to.
            */
            public static BlitMultiTap ($source: UnityEngine.Texture, $dest: UnityEngine.Rendering.GraphicsTexture, $mat: UnityEngine.Material, ...offsets: UnityEngine.Vector2[]) : void
            /** Copies source texture into destination, for multi-tap shader.
            * @param $source Source texture.
            * @param $dest Destination RenderTexture, GraphicsTexture, or null to blit directly to screen.
            * @param $mat Material to use for copying. Material's shader should do some post-processing effect.
            * @param $offsets Variable number of filtering offsets. Offsets are given in pixels.
            * @param $destDepthSlice The texture array destination slice to blit to.
            */
            public static BlitMultiTap ($source: UnityEngine.Texture, $dest: UnityEngine.Rendering.GraphicsTexture, $mat: UnityEngine.Material, $destDepthSlice: number, ...offsets: UnityEngine.Vector2[]) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $material: UnityEngine.Material, $layer: number) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: boolean) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: boolean, $receiveShadows: boolean) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $probeAnchor: UnityEngine.Transform) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: boolean) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: boolean, $receiveShadows: boolean) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $probeAnchor: UnityEngine.Transform) : void
            /** Draw a mesh.
            * @param $mesh The Mesh to draw.
            * @param $position Position of the mesh.
            * @param $rotation Rotation of the mesh.
            * @param $matrix Transformation matrix of the mesh (combines position, rotation and other transformations).
            * @param $material Material to use.
            * @param $layer  the mesh is drawn on.
            * @param $camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
            * @param $submeshIndex Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.
            * @param $properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
            * @param $castShadows Determines whether the mesh can cast shadows.
            * @param $receiveShadows Determines whether the mesh can receive shadows.
            * @param $useLightProbes Should the mesh use light probes?
            * @param $probeAnchor If used, the mesh will use this Transform's position to sample light probes and find the matching reflection probe.
            * @param $lightProbeUsage LightProbeUsage for the mesh.
            */
            public static DrawMesh ($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $probeAnchor: UnityEngine.Transform, $useLightProbes: boolean) : void
            /** Draw a mesh.
            * @param $mesh The Mesh to draw.
            * @param $position Position of the mesh.
            * @param $rotation Rotation of the mesh.
            * @param $matrix Transformation matrix of the mesh (combines position, rotation and other transformations).
            * @param $material Material to use.
            * @param $layer  the mesh is drawn on.
            * @param $camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
            * @param $submeshIndex Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.
            * @param $properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
            * @param $castShadows Determines whether the mesh can cast shadows.
            * @param $receiveShadows Determines whether the mesh can receive shadows.
            * @param $useLightProbes Should the mesh use light probes?
            * @param $probeAnchor If used, the mesh will use this Transform's position to sample light probes and find the matching reflection probe.
            * @param $lightProbeUsage LightProbeUsage for the mesh.
            */
            public static DrawMesh ($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $probeAnchor: UnityEngine.Transform, $lightProbeUsage: UnityEngine.Rendering.LightProbeUsage) : void
            public static DrawMeshInstanced ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Array$1<UnityEngine.Matrix4x4>) : void
            public static DrawMeshInstanced ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Array$1<UnityEngine.Matrix4x4>, $count: number) : void
            public static DrawMeshInstanced ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Array$1<UnityEngine.Matrix4x4>, $count: number, $properties: UnityEngine.MaterialPropertyBlock) : void
            public static DrawMeshInstanced ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Array$1<UnityEngine.Matrix4x4>, $count: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode) : void
            public static DrawMeshInstanced ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Array$1<UnityEngine.Matrix4x4>, $count: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean) : void
            public static DrawMeshInstanced ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Array$1<UnityEngine.Matrix4x4>, $count: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number) : void
            public static DrawMeshInstanced ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Array$1<UnityEngine.Matrix4x4>, $count: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number, $camera: UnityEngine.Camera) : void
            public static DrawMeshInstanced ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Array$1<UnityEngine.Matrix4x4>, $count: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number, $camera: UnityEngine.Camera, $lightProbeUsage: UnityEngine.Rendering.LightProbeUsage) : void
            public static DrawMeshInstanced ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>) : void
            public static DrawMeshInstanced ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>, $properties: UnityEngine.MaterialPropertyBlock) : void
            public static DrawMeshInstanced ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode) : void
            public static DrawMeshInstanced ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean) : void
            public static DrawMeshInstanced ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number) : void
            public static DrawMeshInstanced ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number, $camera: UnityEngine.Camera) : void
            public static DrawMeshInstanced ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number, $camera: UnityEngine.Camera, $lightProbeUsage: UnityEngine.Rendering.LightProbeUsage) : void
            public static DrawMeshInstancedIndirect ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $bounds: UnityEngine.Bounds, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset?: number, $properties?: UnityEngine.MaterialPropertyBlock, $castShadows?: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: number, $camera?: UnityEngine.Camera, $lightProbeUsage?: UnityEngine.Rendering.LightProbeUsage) : void
            public static DrawMeshInstancedIndirect ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $bounds: UnityEngine.Bounds, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset?: number, $properties?: UnityEngine.MaterialPropertyBlock, $castShadows?: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: number, $camera?: UnityEngine.Camera, $lightProbeUsage?: UnityEngine.Rendering.LightProbeUsage) : void
            /** Draw a texture in screen coordinates.
            * @param $screenRect Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.
            * @param $texture Texture to draw.
            * @param $sourceRect Region of the texture to use. In normalized coordinates with (0,0) in the bottom-left corner.
            * @param $leftBorder Number of pixels from the left that are not affected by scale.
            * @param $rightBorder Number of pixels from the right that are not affected by scale.
            * @param $topBorder Number of pixels from the top that are not affected by scale.
            * @param $bottomBorder Number of pixels from the bottom that are not affected by scale.
            * @param $color Color that modulates the output. The neutral value is (0.5, 0.5, 0.5, 0.5). Set as vertex color for the shader.
            * @param $mat Custom Material that can be used to draw the texture. If null is passed, a default material with the Internal-GUITexture.shader is used.
            * @param $pass If -1 (default), draws all passes in the material. Otherwise, draws given pass only.
            */
            public static DrawTexture ($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $sourceRect: UnityEngine.Rect, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number, $color: UnityEngine.Color, $mat: UnityEngine.Material) : void
            public static DrawTexture ($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $sourceRect: UnityEngine.Rect, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number, $color: UnityEngine.Color) : void
            /** Draw a texture in screen coordinates.
            * @param $screenRect Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.
            * @param $texture Texture to draw.
            * @param $sourceRect Region of the texture to use. In normalized coordinates with (0,0) in the bottom-left corner.
            * @param $leftBorder Number of pixels from the left that are not affected by scale.
            * @param $rightBorder Number of pixels from the right that are not affected by scale.
            * @param $topBorder Number of pixels from the top that are not affected by scale.
            * @param $bottomBorder Number of pixels from the bottom that are not affected by scale.
            * @param $color Color that modulates the output. The neutral value is (0.5, 0.5, 0.5, 0.5). Set as vertex color for the shader.
            * @param $mat Custom Material that can be used to draw the texture. If null is passed, a default material with the Internal-GUITexture.shader is used.
            * @param $pass If -1 (default), draws all passes in the material. Otherwise, draws given pass only.
            */
            public static DrawTexture ($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $sourceRect: UnityEngine.Rect, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number, $mat: UnityEngine.Material) : void
            public static DrawTexture ($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $sourceRect: UnityEngine.Rect, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number) : void
            /** Draw a texture in screen coordinates.
            * @param $screenRect Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.
            * @param $texture Texture to draw.
            * @param $sourceRect Region of the texture to use. In normalized coordinates with (0,0) in the bottom-left corner.
            * @param $leftBorder Number of pixels from the left that are not affected by scale.
            * @param $rightBorder Number of pixels from the right that are not affected by scale.
            * @param $topBorder Number of pixels from the top that are not affected by scale.
            * @param $bottomBorder Number of pixels from the bottom that are not affected by scale.
            * @param $color Color that modulates the output. The neutral value is (0.5, 0.5, 0.5, 0.5). Set as vertex color for the shader.
            * @param $mat Custom Material that can be used to draw the texture. If null is passed, a default material with the Internal-GUITexture.shader is used.
            * @param $pass If -1 (default), draws all passes in the material. Otherwise, draws given pass only.
            */
            public static DrawTexture ($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number, $mat: UnityEngine.Material) : void
            public static DrawTexture ($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number) : void
            /** Draw a texture in screen coordinates.
            * @param $screenRect Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.
            * @param $texture Texture to draw.
            * @param $sourceRect Region of the texture to use. In normalized coordinates with (0,0) in the bottom-left corner.
            * @param $leftBorder Number of pixels from the left that are not affected by scale.
            * @param $rightBorder Number of pixels from the right that are not affected by scale.
            * @param $topBorder Number of pixels from the top that are not affected by scale.
            * @param $bottomBorder Number of pixels from the bottom that are not affected by scale.
            * @param $color Color that modulates the output. The neutral value is (0.5, 0.5, 0.5, 0.5). Set as vertex color for the shader.
            * @param $mat Custom Material that can be used to draw the texture. If null is passed, a default material with the Internal-GUITexture.shader is used.
            * @param $pass If -1 (default), draws all passes in the material. Otherwise, draws given pass only.
            */
            public static DrawTexture ($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $mat: UnityEngine.Material) : void
            public static DrawTexture ($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture) : void
            public static SetRenderTarget ($rt: UnityEngine.RenderTexture) : void
            public static SetRenderTarget ($rt: UnityEngine.RenderTexture, $mipLevel: number) : void
            public static SetRenderTarget ($rt: UnityEngine.RenderTexture, $mipLevel: number, $face: UnityEngine.CubemapFace) : void
            public static SetRenderTarget ($colorBuffer: UnityEngine.RenderBuffer, $depthBuffer: UnityEngine.RenderBuffer) : void
            public static SetRenderTarget ($colorBuffer: UnityEngine.RenderBuffer, $depthBuffer: UnityEngine.RenderBuffer, $mipLevel: number) : void
            public static SetRenderTarget ($colorBuffer: UnityEngine.RenderBuffer, $depthBuffer: UnityEngine.RenderBuffer, $mipLevel: number, $face: UnityEngine.CubemapFace) : void
            public static SetRandomWriteTarget ($index: number, $uav: UnityEngine.ComputeBuffer) : void
            public static SetRandomWriteTarget ($index: number, $uav: UnityEngine.GraphicsBuffer) : void
            public constructor ()
        }
        /** Represents a color gamut.
        */
        enum ColorGamut
        { sRGB = 0, Rec709 = 1, Rec2020 = 2, DisplayP3 = 3, HDR10 = 4, DolbyHDR = 5, P3D65G22 = 6 }
        /** Cubemap face.
        */
        enum CubemapFace
        { Unknown = -1, PositiveX = 0, NegativeX = 1, PositiveY = 2, NegativeY = 3, PositiveZ = 4, NegativeZ = 5 }
        /** Fully describes setup of RenderTarget.
        */
        class RenderTargetSetup extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Color Buffers to set.
            */
            public color : System.Array$1<UnityEngine.RenderBuffer>
            /** Depth Buffer to set.
            */
            public depth : UnityEngine.RenderBuffer
            /** Mip Level to render to.
            */
            public mipLevel : number
            /** Cubemap face to render to.
            */
            public cubemapFace : UnityEngine.CubemapFace
            /** Slice of a Texture3D or Texture2DArray to set as a render target.
            */
            public depthSlice : number
            /** Load Actions for Color Buffers. It will override any actions set on RenderBuffers themselves.
            */
            public colorLoad : System.Array$1<UnityEngine.Rendering.RenderBufferLoadAction>
            /** Store Actions for Color Buffers. It will override any actions set on RenderBuffers themselves.
            */
            public colorStore : System.Array$1<UnityEngine.Rendering.RenderBufferStoreAction>
            /** Load Action for Depth Buffer. It will override any actions set on RenderBuffer itself.
            */
            public depthLoad : UnityEngine.Rendering.RenderBufferLoadAction
            /** Store Actions for Depth Buffer. It will override any actions set on RenderBuffer itself.
            */
            public depthStore : UnityEngine.Rendering.RenderBufferStoreAction
            public constructor ($color: System.Array$1<UnityEngine.RenderBuffer>, $depth: UnityEngine.RenderBuffer, $mip: number, $face: UnityEngine.CubemapFace, $colorLoad: System.Array$1<UnityEngine.Rendering.RenderBufferLoadAction>, $colorStore: System.Array$1<UnityEngine.Rendering.RenderBufferStoreAction>, $depthLoad: UnityEngine.Rendering.RenderBufferLoadAction, $depthStore: UnityEngine.Rendering.RenderBufferStoreAction)
            public constructor ($color: UnityEngine.RenderBuffer, $depth: UnityEngine.RenderBuffer)
            public constructor ($color: UnityEngine.RenderBuffer, $depth: UnityEngine.RenderBuffer, $mipLevel: number)
            public constructor ($color: UnityEngine.RenderBuffer, $depth: UnityEngine.RenderBuffer, $mipLevel: number, $face: UnityEngine.CubemapFace)
            public constructor ($color: UnityEngine.RenderBuffer, $depth: UnityEngine.RenderBuffer, $mipLevel: number, $face: UnityEngine.CubemapFace, $depthSlice: number)
            public constructor ($color: System.Array$1<UnityEngine.RenderBuffer>, $depth: UnityEngine.RenderBuffer)
            public constructor ($color: System.Array$1<UnityEngine.RenderBuffer>, $depth: UnityEngine.RenderBuffer, $mipLevel: number)
            public constructor ($color: System.Array$1<UnityEngine.RenderBuffer>, $depth: UnityEngine.RenderBuffer, $mip: number, $face: UnityEngine.CubemapFace)
        }
        /** GPU data buffer, mostly for use with compute shaders.
        */
        class ComputeBuffer extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            /** Number of elements in the buffer (Read Only).
            */
            public get count(): number;
            /** Size of one element in the buffer in bytes (Read Only).
            */
            public get stride(): number;
            public set name(value: string);
            public Dispose () : void
            /** Release a Compute Buffer.
            */
            public Release () : void
            /** Returns true if this compute buffer is valid and false otherwise.
            */
            public IsValid () : boolean
            /** Set the buffer with values from an array.
            * @param $data Array of values to fill the buffer.
            */
            public SetData ($data: System.Array) : void
            /** Partial copy of data values from an array into the buffer.
            * @param $data Array of values to fill the buffer.
            * @param $managedBufferStartIndex The first element index in data to copy to the compute buffer.
            * @param $computeBufferStartIndex The first element index in compute buffer to receive the data.
            * @param $count The number of elements to copy.
            */
            public SetData ($data: System.Array, $managedBufferStartIndex: number, $computeBufferStartIndex: number, $count: number) : void
            /** Read data values from the buffer into an array. The array can only use <a href="https:docs.microsoft.comen-usdotnetframeworkinteropblittable-and-non-blittable-types">blittable<a> types.
            * @param $data An array to receive the data.
            */
            public GetData ($data: System.Array) : void
            /** Partial read of data values from the buffer into an array.
            * @param $data An array to receive the data.
            * @param $managedBufferStartIndex The first element index in data where retrieved elements are copied.
            * @param $computeBufferStartIndex The first element index of the compute buffer from which elements are read.
            * @param $count The number of elements to retrieve.
            */
            public GetData ($data: System.Array, $managedBufferStartIndex: number, $computeBufferStartIndex: number, $count: number) : void
            /** Sets counter value of append/consume buffer.
            * @param $counterValue Value of the append/consume counter.
            */
            public SetCounterValue ($counterValue: number) : void
            /** Copy counter value of append/consume buffer into another buffer.
            * @param $src Append/consume buffer to copy the counter from.
            * @param $dst A buffer to copy the counter to.
            * @param $dstOffsetBytes Target byte offset in dst.
            */
            public static CopyCount ($src: UnityEngine.ComputeBuffer, $dst: UnityEngine.ComputeBuffer, $dstOffsetBytes: number) : void
            /** Retrieve a native (underlying graphics API) pointer to the buffer.
            * @returns Pointer to the underlying graphics API buffer. 
            */
            public GetNativeBufferPtr () : System.IntPtr
            public constructor ($count: number, $stride: number)
            public constructor ($count: number, $stride: number, $type: UnityEngine.ComputeBufferType)
            public constructor ($count: number, $stride: number, $type: UnityEngine.ComputeBufferType, $usage: UnityEngine.ComputeBufferMode)
        }
        /** GPU graphics data buffer, for working with geometry or compute shader data.
        */
        class GraphicsBuffer extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            /** Number of elements in the buffer (Read Only).
            */
            public get count(): number;
            /** Size of one element in the buffer. For index buffers, this must be either 2 or 4 bytes (Read Only).
            */
            public get stride(): number;
            /** Target, which specifies the intended target(s) of this GraphicsBuffer (Read Only).
            */
            public get target(): UnityEngine.GraphicsBuffer.Target;
            /** The flags that specify how this GraphicsBuffer can be used or updated (Read Only).
            */
            public get usageFlags(): UnityEngine.GraphicsBuffer.UsageFlags;
            /** The internal handle of this GraphicsBuffer. Only valid until the buffer is disposed of. (Read Only)
            */
            public get bufferHandle(): UnityEngine.GraphicsBufferHandle;
            public set name(value: string);
            public Dispose () : void
            /** Release a Graphics Buffer.
            */
            public Release () : void
            /** Returns true if this graphics buffer is valid, or false otherwise.
            */
            public IsValid () : boolean
            /** Set the buffer with values from an array.
            * @param $data Array of values to fill the buffer.
            */
            public SetData ($data: System.Array) : void
            /** Partial copy of data values from an array into the buffer.
            * @param $data Array of values to fill the buffer.
            * @param $managedBufferStartIndex The first element index in data to copy to the graphics buffer.
            * @param $count The number of elements to copy.
            * @param $graphicsBufferStartIndex The first element index in the graphics buffer to receive the data.
            */
            public SetData ($data: System.Array, $managedBufferStartIndex: number, $graphicsBufferStartIndex: number, $count: number) : void
            /** Read data values from the buffer into an array. The array can only use <a href="https:docs.microsoft.comen-usdotnetframeworkinteropblittable-and-non-blittable-types">blittable<a> types.
            * @param $data An array to receive the data.
            * @param $managedBufferStartIndex The first element index in data where retrieved elements are copied.
            * @param $computeBufferStartIndex The first element index of the buffer from which elements are read.
            * @param $count The number of elements to retrieve.
            */
            public GetData ($data: System.Array) : void
            /** Read data values from the buffer into an array. The array can only use <a href="https:docs.microsoft.comen-usdotnetframeworkinteropblittable-and-non-blittable-types">blittable<a> types.
            * @param $data An array to receive the data.
            * @param $managedBufferStartIndex The first element index in data where retrieved elements are copied.
            * @param $computeBufferStartIndex The first element index of the buffer from which elements are read.
            * @param $count The number of elements to retrieve.
            */
            public GetData ($data: System.Array, $managedBufferStartIndex: number, $computeBufferStartIndex: number, $count: number) : void
            /** Retrieve a native (underlying graphics API) pointer to the buffer.
            * @returns Pointer to the underlying graphics API buffer. 
            */
            public GetNativeBufferPtr () : System.IntPtr
            /** Sets counter value of append/consume buffer.
            * @param $counterValue Value of the append/consume counter.
            */
            public SetCounterValue ($counterValue: number) : void
            /** Copy the counter value of a GraphicsBuffer into another buffer.
            * @param $src The source GraphicsBuffer.
            * @param $dst The destination GraphicsBuffer.
            * @param $dstOffsetBytes The destination buffer offset in bytes.
            */
            public static CopyCount ($src: UnityEngine.ComputeBuffer, $dst: UnityEngine.ComputeBuffer, $dstOffsetBytes: number) : void
            /** Copy the counter value of a GraphicsBuffer into another buffer.
            * @param $src The source GraphicsBuffer.
            * @param $dst The destination GraphicsBuffer.
            * @param $dstOffsetBytes The destination buffer offset in bytes.
            */
            public static CopyCount ($src: UnityEngine.GraphicsBuffer, $dst: UnityEngine.ComputeBuffer, $dstOffsetBytes: number) : void
            /** Copy the counter value of a GraphicsBuffer into another buffer.
            * @param $src The source GraphicsBuffer.
            * @param $dst The destination GraphicsBuffer.
            * @param $dstOffsetBytes The destination buffer offset in bytes.
            */
            public static CopyCount ($src: UnityEngine.ComputeBuffer, $dst: UnityEngine.GraphicsBuffer, $dstOffsetBytes: number) : void
            /** Copy the counter value of a GraphicsBuffer into another buffer.
            * @param $src The source GraphicsBuffer.
            * @param $dst The destination GraphicsBuffer.
            * @param $dstOffsetBytes The destination buffer offset in bytes.
            */
            public static CopyCount ($src: UnityEngine.GraphicsBuffer, $dst: UnityEngine.GraphicsBuffer, $dstOffsetBytes: number) : void
            public constructor ($target: UnityEngine.GraphicsBuffer.Target, $count: number, $stride: number)
            public constructor ($target: UnityEngine.GraphicsBuffer.Target, $usageFlags: UnityEngine.GraphicsBuffer.UsageFlags, $count: number, $stride: number)
        }
        /** Rendering parameters used by various rendering functions.
        */
        class RenderParams extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Layer used for rendering. to use.
            */
            public get layer(): number;
            public set layer(value: number);
            /** Renderer layer mask used for rendering.
            */
            public get renderingLayerMask(): number;
            public set renderingLayerMask(value: number);
            /** Renderer priority.
            */
            public get rendererPriority(): number;
            public set rendererPriority(value: number);
            /** The instance ID of the GameObject that issues the draw. Provide an instanceID to make a rendered GameObject pickable in the scene view when you click on it. The default value is 0, which means that you can't pick or outline the procedural GameObject in the scene view.
            */
            public get instanceID(): number;
            public set instanceID(value: number);
            /** Defines world space bounds for the geometry. Used to cull and sort the rendered geometry.
            */
            public get worldBounds(): UnityEngine.Bounds;
            public set worldBounds(value: UnityEngine.Bounds);
            /** The camera used for rendering. If set to null (default) renders for all cameras.
            */
            public get camera(): UnityEngine.Camera;
            public set camera(value: UnityEngine.Camera);
            /** Motion vector mode used for rendering.
            */
            public get motionVectorMode(): UnityEngine.MotionVectorGenerationMode;
            public set motionVectorMode(value: UnityEngine.MotionVectorGenerationMode);
            /** The type of reflection probe used for rendering.
            */
            public get reflectionProbeUsage(): UnityEngine.Rendering.ReflectionProbeUsage;
            public set reflectionProbeUsage(value: UnityEngine.Rendering.ReflectionProbeUsage);
            /** Material used for rendering.
            */
            public get material(): UnityEngine.Material;
            public set material(value: UnityEngine.Material);
            /** Material properties used for rendering.
            */
            public get matProps(): UnityEngine.MaterialPropertyBlock;
            public set matProps(value: UnityEngine.MaterialPropertyBlock);
            /** Describes if geometry should cast shadows.
            */
            public get shadowCastingMode(): UnityEngine.Rendering.ShadowCastingMode;
            public set shadowCastingMode(value: UnityEngine.Rendering.ShadowCastingMode);
            /** Descripes if the rendered geometry should receive shadows.
            */
            public get receiveShadows(): boolean;
            public set receiveShadows(value: boolean);
            /** The type of light probe usage.
            */
            public get lightProbeUsage(): UnityEngine.Rendering.LightProbeUsage;
            public set lightProbeUsage(value: UnityEngine.Rendering.LightProbeUsage);
            /** Light Probe Proxy Volume (LPPV) used for rendering.
            */
            public get lightProbeProxyVolume(): UnityEngine.LightProbeProxyVolume;
            public set lightProbeProxyVolume(value: UnityEngine.LightProbeProxyVolume);
            /** Uses the RenderParams.sceneCullingMask property to specify a custom SceneManagement.SceneCullingMasks. This property is only available in the Editor, you can still access it in a Player but it'll be ignored.
            */
            public get overrideSceneCullingMask(): boolean;
            public set overrideSceneCullingMask(value: boolean);
            /** Overrides the scene culling mask for the rendered object. This can help you control prefab stage visibility or entities sub-scene visibiliy. This property is only available in the Editor, you can still access it in a Player but it'll be ignored..
            */
            public get sceneCullingMask(): bigint;
            public set sceneCullingMask(value: bigint);
            public constructor ($mat: UnityEngine.Material)
        }
        /** Topology of Mesh faces.
        */
        enum MeshTopology
        { Triangles = 0, Quads = 2, Lines = 3, LineStrip = 4, Points = 5 }
        /** A block of material values to apply.
        */
        class MaterialPropertyBlock extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Is the material property block empty? (Read Only)
            */
            public get isEmpty(): boolean;
            /** Clear material property values.
            */
            public Clear () : void
            /** This method is deprecated. Use SetFloat or SetInteger instead.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $value The int value to set.
            */
            public SetInt ($name: string, $value: number) : void
            /** This method is deprecated. Use SetFloat or SetInteger instead.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $value The int value to set.
            */
            public SetInt ($nameID: number, $value: number) : void
            /** Set a float property.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $value The float value to set.
            */
            public SetFloat ($name: string, $value: number) : void
            /** Set a float property.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $value The float value to set.
            */
            public SetFloat ($nameID: number, $value: number) : void
            /** Adds a property to the block. If an integer property with the given name already exists, the old value is replaced.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $value The integer value to set.
            */
            public SetInteger ($name: string, $value: number) : void
            /** Adds a property to the block. If an integer property with the given name already exists, the old value is replaced.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $value The integer value to set.
            */
            public SetInteger ($nameID: number, $value: number) : void
            /** Set a vector property.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $value The Vector4 value to set.
            */
            public SetVector ($name: string, $value: UnityEngine.Vector4) : void
            /** Set a vector property.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $value The Vector4 value to set.
            */
            public SetVector ($nameID: number, $value: UnityEngine.Vector4) : void
            /** Set a color property.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $value The Color value to set.
            */
            public SetColor ($name: string, $value: UnityEngine.Color) : void
            /** Set a color property.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $value The Color value to set.
            */
            public SetColor ($nameID: number, $value: UnityEngine.Color) : void
            /** Set a matrix property.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $value The matrix value to set.
            */
            public SetMatrix ($name: string, $value: UnityEngine.Matrix4x4) : void
            /** Set a matrix property.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $value The matrix value to set.
            */
            public SetMatrix ($nameID: number, $value: UnityEngine.Matrix4x4) : void
            /** Set a buffer property.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $value The ComputeBuffer or GraphicsBuffer to set.
            */
            public SetBuffer ($name: string, $value: UnityEngine.ComputeBuffer) : void
            /** Set a buffer property.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $value The ComputeBuffer or GraphicsBuffer to set.
            */
            public SetBuffer ($nameID: number, $value: UnityEngine.ComputeBuffer) : void
            /** Set a buffer property.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $value The ComputeBuffer or GraphicsBuffer to set.
            */
            public SetBuffer ($name: string, $value: UnityEngine.GraphicsBuffer) : void
            /** Set a buffer property.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $value The ComputeBuffer or GraphicsBuffer to set.
            */
            public SetBuffer ($nameID: number, $value: UnityEngine.GraphicsBuffer) : void
            /** Set a texture property.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $value The Texture to set.
            * @param $element Optional parameter that specifies the type of data to set from the RenderTexture.
            */
            public SetTexture ($name: string, $value: UnityEngine.Texture) : void
            /** Set a texture property.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $value The Texture to set.
            * @param $element Optional parameter that specifies the type of data to set from the RenderTexture.
            */
            public SetTexture ($nameID: number, $value: UnityEngine.Texture) : void
            /** Set a texture property.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $value The Texture to set.
            * @param $element Optional parameter that specifies the type of data to set from the RenderTexture.
            */
            public SetTexture ($name: string, $value: UnityEngine.RenderTexture, $element: UnityEngine.Rendering.RenderTextureSubElement) : void
            /** Set a texture property.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $value The Texture to set.
            * @param $element Optional parameter that specifies the type of data to set from the RenderTexture.
            */
            public SetTexture ($nameID: number, $value: UnityEngine.RenderTexture, $element: UnityEngine.Rendering.RenderTextureSubElement) : void
            /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the MaterialPropertyBlock.
            * @param $name The name of the constant buffer to override.
            * @param $value The buffer to override the constant buffer values with.
            * @param $offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
            * @param $size The number of bytes to bind.
            * @param $nameID The shader property ID of the constant buffer to override.
            */
            public SetConstantBuffer ($name: string, $value: UnityEngine.ComputeBuffer, $offset: number, $size: number) : void
            /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the MaterialPropertyBlock.
            * @param $name The name of the constant buffer to override.
            * @param $value The buffer to override the constant buffer values with.
            * @param $offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
            * @param $size The number of bytes to bind.
            * @param $nameID The shader property ID of the constant buffer to override.
            */
            public SetConstantBuffer ($nameID: number, $value: UnityEngine.ComputeBuffer, $offset: number, $size: number) : void
            /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the MaterialPropertyBlock.
            * @param $name The name of the constant buffer to override.
            * @param $value The buffer to override the constant buffer values with.
            * @param $offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
            * @param $size The number of bytes to bind.
            * @param $nameID The shader property ID of the constant buffer to override.
            */
            public SetConstantBuffer ($name: string, $value: UnityEngine.GraphicsBuffer, $offset: number, $size: number) : void
            /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the MaterialPropertyBlock.
            * @param $name The name of the constant buffer to override.
            * @param $value The buffer to override the constant buffer values with.
            * @param $offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
            * @param $size The number of bytes to bind.
            * @param $nameID The shader property ID of the constant buffer to override.
            */
            public SetConstantBuffer ($nameID: number, $value: UnityEngine.GraphicsBuffer, $offset: number, $size: number) : void
            public SetFloatArray ($name: string, $values: System.Collections.Generic.List$1<number>) : void
            public SetFloatArray ($nameID: number, $values: System.Collections.Generic.List$1<number>) : void
            /** Set a float array property.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $values The array to set.
            */
            public SetFloatArray ($name: string, $values: System.Array$1<number>) : void
            /** Set a float array property.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $values The array to set.
            */
            public SetFloatArray ($nameID: number, $values: System.Array$1<number>) : void
            public SetVectorArray ($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>) : void
            public SetVectorArray ($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>) : void
            /** Set a vector array property.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $values The array to set.
            * @param $name The name of the property.
            */
            public SetVectorArray ($name: string, $values: System.Array$1<UnityEngine.Vector4>) : void
            /** Set a vector array property.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $values The array to set.
            * @param $name The name of the property.
            */
            public SetVectorArray ($nameID: number, $values: System.Array$1<UnityEngine.Vector4>) : void
            public SetMatrixArray ($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>) : void
            public SetMatrixArray ($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>) : void
            /** Set a matrix array property.
            * @param $name The name of the property.
            * @param $values The name ID of the property retrieved by Shader.PropertyToID.
            * @param $nameID The array to set.
            */
            public SetMatrixArray ($name: string, $values: System.Array$1<UnityEngine.Matrix4x4>) : void
            /** Set a matrix array property.
            * @param $name The name of the property.
            * @param $values The name ID of the property retrieved by Shader.PropertyToID.
            * @param $nameID The array to set.
            */
            public SetMatrixArray ($nameID: number, $values: System.Array$1<UnityEngine.Matrix4x4>) : void
            /** Checks if MaterialPropertyBlock has the property with the given name or name ID. To set the property, use one of the Set methods for MaterialPropertyBlock.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @returns Returns true if MaterialPropertyBlock has this property. 
            */
            public HasProperty ($name: string) : boolean
            /** Checks if MaterialPropertyBlock has the property with the given name or name ID. To set the property, use one of the Set methods for MaterialPropertyBlock.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @returns Returns true if MaterialPropertyBlock has this property. 
            */
            public HasProperty ($nameID: number) : boolean
            /** This method is deprecated. Use HasFloat or HasInteger instead.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @returns Returns true if MaterialPropertyBlock has this property. 
            */
            public HasInt ($name: string) : boolean
            /** This method is deprecated. Use HasFloat or HasInteger instead.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @returns Returns true if MaterialPropertyBlock has this property. 
            */
            public HasInt ($nameID: number) : boolean
            /** Checks if MaterialPropertyBlock has the Float property with the given name or name ID. To set the property, use SetFloat.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @returns Returns true if MaterialPropertyBlock has this property. 
            */
            public HasFloat ($name: string) : boolean
            /** Checks if MaterialPropertyBlock has the Float property with the given name or name ID. To set the property, use SetFloat.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @returns Returns true if MaterialPropertyBlock has this property. 
            */
            public HasFloat ($nameID: number) : boolean
            /** Checks if MaterialPropertyBlock has the Integer property with the given name or name ID. To set the property, use SetInteger.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @returns Returns true if MaterialPropertyBlock has this property. 
            */
            public HasInteger ($name: string) : boolean
            /** Checks if MaterialPropertyBlock has the Integer property with the given name or name ID. To set the property, use SetInteger.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @returns Returns true if MaterialPropertyBlock has this property. 
            */
            public HasInteger ($nameID: number) : boolean
            /** Checks if MaterialPropertyBlock has the Texture property with the given name or name ID. To set the property, use SetTexture.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @returns Returns true if MaterialPropertyBlock has this property. 
            */
            public HasTexture ($name: string) : boolean
            /** Checks if MaterialPropertyBlock has the Texture property with the given name or name ID. To set the property, use SetTexture.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @returns Returns true if MaterialPropertyBlock has this property. 
            */
            public HasTexture ($nameID: number) : boolean
            /** Checks if MaterialPropertyBlock has the Matrix property with the given name or name ID. This also works with the Matrix Array property. To set the property, use SetMatrix.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @returns Returns true if MaterialPropertyBlock has this property. 
            */
            public HasMatrix ($name: string) : boolean
            /** Checks if MaterialPropertyBlock has the Matrix property with the given name or name ID. This also works with the Matrix Array property. To set the property, use SetMatrix.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @returns Returns true if MaterialPropertyBlock has this property. 
            */
            public HasMatrix ($nameID: number) : boolean
            /** Checks if MaterialPropertyBlock has the Vector property with the given name or name ID. This also works with the Vector Array property. To set the property, use SetVector.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @returns Returns true if MaterialPropertyBlock has this property. 
            */
            public HasVector ($name: string) : boolean
            /** Checks if MaterialPropertyBlock has the Vector property with the given name or name ID. This also works with the Vector Array property. To set the property, use SetVector.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @returns Returns true if MaterialPropertyBlock has this property. 
            */
            public HasVector ($nameID: number) : boolean
            /** Checks if MaterialPropertyBlock has the Color property with the given name or name ID. To set the property, use SetColor.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @returns Returns true if MaterialPropertyBlock has this property. 
            */
            public HasColor ($name: string) : boolean
            /** Checks if MaterialPropertyBlock has the Color property with the given name or name ID. To set the property, use SetColor.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @returns Returns true if MaterialPropertyBlock has this property. 
            */
            public HasColor ($nameID: number) : boolean
            /** Checks if MaterialPropertyBlock has the ComputeBuffer property with the given name or name ID. To set the property, use SetBuffer.
            * @param $nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @param $name The name of the property.
            * @returns Returns true if MaterialPropertyBlock has this property. 
            */
            public HasBuffer ($name: string) : boolean
            /** Checks if MaterialPropertyBlock has the ComputeBuffer property with the given name or name ID. To set the property, use SetBuffer.
            * @param $nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @param $name The name of the property.
            * @returns Returns true if MaterialPropertyBlock has this property. 
            */
            public HasBuffer ($nameID: number) : boolean
            /** Checks if MaterialPropertyBlock has the ConstantBuffer property with the given name or name ID. To set the property, use SetConstantBuffer.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @returns Returns true if MaterialPropertyBlock has this property. 
            */
            public HasConstantBuffer ($name: string) : boolean
            /** Checks if MaterialPropertyBlock has the ConstantBuffer property with the given name or name ID. To set the property, use SetConstantBuffer.
            * @param $name The name of the property.
            * @param $nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @returns Returns true if MaterialPropertyBlock has this property. 
            */
            public HasConstantBuffer ($nameID: number) : boolean
            /** Get a float from the property block.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public GetFloat ($name: string) : number
            /** Get a float from the property block.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public GetFloat ($nameID: number) : number
            /** This method is deprecated. Use GetFloat or GetInteger instead.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public GetInt ($name: string) : number
            /** This method is deprecated. Use GetFloat or GetInteger instead.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public GetInt ($nameID: number) : number
            /** Get an integer from the property block.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public GetInteger ($name: string) : number
            /** Get an integer from the property block.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public GetInteger ($nameID: number) : number
            /** Get a vector from the property block.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public GetVector ($name: string) : UnityEngine.Vector4
            /** Get a vector from the property block.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public GetVector ($nameID: number) : UnityEngine.Vector4
            /** Get a color from the property block.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public GetColor ($name: string) : UnityEngine.Color
            /** Get a color from the property block.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public GetColor ($nameID: number) : UnityEngine.Color
            /** Get a matrix from the property block.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public GetMatrix ($name: string) : UnityEngine.Matrix4x4
            /** Get a matrix from the property block.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public GetMatrix ($nameID: number) : UnityEngine.Matrix4x4
            /** Get a texture from the property block.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public GetTexture ($name: string) : UnityEngine.Texture
            /** Get a texture from the property block.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public GetTexture ($nameID: number) : UnityEngine.Texture
            /** Get a float array from the property block.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public GetFloatArray ($name: string) : System.Array$1<number>
            /** Get a float array from the property block.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public GetFloatArray ($nameID: number) : System.Array$1<number>
            /** Get a vector array from the property block.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public GetVectorArray ($name: string) : System.Array$1<UnityEngine.Vector4>
            /** Get a vector array from the property block.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public GetVectorArray ($nameID: number) : System.Array$1<UnityEngine.Vector4>
            /** Get a matrix array from the property block.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public GetMatrixArray ($name: string) : System.Array$1<UnityEngine.Matrix4x4>
            /** Get a matrix array from the property block.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            */
            public GetMatrixArray ($nameID: number) : System.Array$1<UnityEngine.Matrix4x4>
            public GetFloatArray ($name: string, $values: System.Collections.Generic.List$1<number>) : void
            public GetFloatArray ($nameID: number, $values: System.Collections.Generic.List$1<number>) : void
            public GetVectorArray ($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>) : void
            public GetVectorArray ($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>) : void
            public GetMatrixArray ($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>) : void
            public GetMatrixArray ($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>) : void
            public CopySHCoefficientArraysFrom ($lightProbes: System.Collections.Generic.List$1<UnityEngine.Rendering.SphericalHarmonicsL2>) : void
            /** This function converts and copies the entire source array into 7 Vector4 property arrays named unity_SHAr, unity_SHAg, unity_SHAb, unity_SHBr, unity_SHBg, unity_SHBb and unity_SHC for use with instanced rendering.
            * @param $lightProbes The array of SH values to copy from.
            */
            public CopySHCoefficientArraysFrom ($lightProbes: System.Array$1<UnityEngine.Rendering.SphericalHarmonicsL2>) : void
            public CopySHCoefficientArraysFrom ($lightProbes: System.Collections.Generic.List$1<UnityEngine.Rendering.SphericalHarmonicsL2>, $sourceStart: number, $destStart: number, $count: number) : void
            /** This function converts and copies the source array into 7 Vector4 property arrays named unity_SHAr, unity_SHAg, unity_SHAb, unity_SHBr, unity_SHBg, unity_SHBb and unity_SHC with the specified source and destination range for use with instanced rendering.
            * @param $lightProbes The array of SH values to copy from.
            * @param $sourceStart The index of the first element in the source array to copy from.
            * @param $destStart The index of the first element in the destination MaterialPropertyBlock array to copy to.
            * @param $count The number of elements to copy.
            */
            public CopySHCoefficientArraysFrom ($lightProbes: System.Array$1<UnityEngine.Rendering.SphericalHarmonicsL2>, $sourceStart: number, $destStart: number, $count: number) : void
            public CopyProbeOcclusionArrayFrom ($occlusionProbes: System.Collections.Generic.List$1<UnityEngine.Vector4>) : void
            /** This function copies the entire source array into a Vector4 property array named unity_ProbesOcclusion for use with instanced rendering.
            * @param $occlusionProbes The array of probe occlusion values to copy from.
            */
            public CopyProbeOcclusionArrayFrom ($occlusionProbes: System.Array$1<UnityEngine.Vector4>) : void
            public CopyProbeOcclusionArrayFrom ($occlusionProbes: System.Collections.Generic.List$1<UnityEngine.Vector4>, $sourceStart: number, $destStart: number, $count: number) : void
            /** This function copies the source array into a Vector4 property array named unity_ProbesOcclusion with the specified source and destination range for use with instanced rendering.
            * @param $occlusionProbes The array of probe occlusion values to copy from.
            * @param $sourceStart The index of the first element in the source array to copy from.
            * @param $destStart The index of the first element in the destination MaterialPropertyBlock array to copy to.
            * @param $count The number of elements to copy.
            */
            public CopyProbeOcclusionArrayFrom ($occlusionProbes: System.Array$1<UnityEngine.Vector4>, $sourceStart: number, $destStart: number, $count: number) : void
            public constructor ()
        }
        /** The Light Probe Proxy Volume component offers the possibility to use higher resolution lighting for large non-static GameObjects.
        */
        class LightProbeProxyVolume extends UnityEngine.Behaviour
        {
            protected [__keep_incompatibility]: never;
            /** Checks if Light Probe Proxy Volumes are supported.
            */
            public static get isFeatureSupported(): boolean;
            /** The world-space bounding box in which the 3D grid of interpolated Light Probes is generated.
            */
            public get boundsGlobal(): UnityEngine.Bounds;
            /** The size of the bounding box in which the 3D grid of interpolated Light Probes is generated.
            */
            public get sizeCustom(): UnityEngine.Vector3;
            public set sizeCustom(value: UnityEngine.Vector3);
            /** The local-space origin of the bounding box in which the 3D grid of interpolated Light Probes is generated.
            */
            public get originCustom(): UnityEngine.Vector3;
            public set originCustom(value: UnityEngine.Vector3);
            /** Interpolated Light Probe density.
            */
            public get probeDensity(): number;
            public set probeDensity(value: number);
            /** The 3D grid resolution on the x-axis.
            */
            public get gridResolutionX(): number;
            public set gridResolutionX(value: number);
            /** The 3D grid resolution on the y-axis.
            */
            public get gridResolutionY(): number;
            public set gridResolutionY(value: number);
            /** The 3D grid resolution on the z-axis.
            */
            public get gridResolutionZ(): number;
            public set gridResolutionZ(value: number);
            /** The bounding box mode for generating the 3D grid of interpolated Light Probes.
            */
            public get boundingBoxMode(): UnityEngine.LightProbeProxyVolume.BoundingBoxMode;
            public set boundingBoxMode(value: UnityEngine.LightProbeProxyVolume.BoundingBoxMode);
            /** The resolution mode for generating the grid of interpolated Light Probes.
            */
            public get resolutionMode(): UnityEngine.LightProbeProxyVolume.ResolutionMode;
            public set resolutionMode(value: UnityEngine.LightProbeProxyVolume.ResolutionMode);
            /** The mode in which the interpolated Light Probe positions are generated.
            */
            public get probePositionMode(): UnityEngine.LightProbeProxyVolume.ProbePositionMode;
            public set probePositionMode(value: UnityEngine.LightProbeProxyVolume.ProbePositionMode);
            /** Sets the way the Light Probe Proxy Volume refreshes.
            */
            public get refreshMode(): UnityEngine.LightProbeProxyVolume.RefreshMode;
            public set refreshMode(value: UnityEngine.LightProbeProxyVolume.RefreshMode);
            /** Determines how many Spherical Harmonics bands will be evaluated to compute the ambient color.
            */
            public get qualityMode(): UnityEngine.LightProbeProxyVolume.QualityMode;
            public set qualityMode(value: UnityEngine.LightProbeProxyVolume.QualityMode);
            /** The texture data format used by the Light Probe Proxy Volume 3D texture.
            */
            public get dataFormat(): UnityEngine.LightProbeProxyVolume.DataFormat;
            public set dataFormat(value: UnityEngine.LightProbeProxyVolume.DataFormat);
            /** Triggers an update of the Light Probe Proxy Volume.
            */
            public Update () : void
            public constructor ()
        }
        /** Low-level graphics library.
        */
        class GL extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Mode for Begin: draw triangles.
            */
            public static TRIANGLES : number
            /** Mode for Begin: draw triangle strip.
            */
            public static TRIANGLE_STRIP : number
            /** Mode for Begin: draw quads.
            */
            public static QUADS : number
            /** Mode for Begin: draw lines.
            */
            public static LINES : number
            /** Mode for Begin: draw line strip.
            */
            public static LINE_STRIP : number
            /** Should rendering be done in wireframe?
            */
            public static get wireframe(): boolean;
            public static set wireframe(value: boolean);
            /** Controls whether Linear-to-sRGB color conversion is performed while rendering.
            */
            public static get sRGBWrite(): boolean;
            public static set sRGBWrite(value: boolean);
            /** Select whether to invert the backface culling (true) or not (false).
            */
            public static get invertCulling(): boolean;
            public static set invertCulling(value: boolean);
            /** Gets or sets the modelview matrix.
            */
            public static get modelview(): UnityEngine.Matrix4x4;
            public static set modelview(value: UnityEngine.Matrix4x4);
            /** Submit a vertex.
            */
            public static Vertex3 ($x: number, $y: number, $z: number) : void
            /** Submit a vertex.
            */
            public static Vertex ($v: UnityEngine.Vector3) : void
            /** Sets current texture coordinate (x,y,z) for all texture units.
            */
            public static TexCoord3 ($x: number, $y: number, $z: number) : void
            /** Sets current texture coordinate (v.x,v.y,v.z) for all texture units.
            */
            public static TexCoord ($v: UnityEngine.Vector3) : void
            /** Sets current texture coordinate (x,y) for all texture units.
            */
            public static TexCoord2 ($x: number, $y: number) : void
            /** Sets current texture coordinate (x,y,z) to the actual texture unit.
            */
            public static MultiTexCoord3 ($unit: number, $x: number, $y: number, $z: number) : void
            /** Sets current texture coordinate (v.x,v.y,v.z) to the actual texture unit.
            */
            public static MultiTexCoord ($unit: number, $v: UnityEngine.Vector3) : void
            /** Sets current texture coordinate (x,y) for the actual texture unit.
            */
            public static MultiTexCoord2 ($unit: number, $x: number, $y: number) : void
            /** Sets current vertex color.
            */
            public static Color ($c: UnityEngine.Color) : void
            /** Sends queued-up commands in the driver's command buffer to the GPU.
            */
            public static Flush () : void
            /** Resolves the render target for subsequent operations sampling from it.
            */
            public static RenderTargetBarrier () : void
            /** Sets the current model matrix to the one specified.
            */
            public static MultMatrix ($m: UnityEngine.Matrix4x4) : void
            /** Saves the model, view and projection matrices to the top of the matrix stack.
            */
            public static PushMatrix () : void
            /** Restores the model, view and projection matrices off the top of the matrix stack.
            */
            public static PopMatrix () : void
            /** Load an identity into the current model and view matrices.
            */
            public static LoadIdentity () : void
            /** Helper function to set up an orthograhic projection.
            */
            public static LoadOrtho () : void
            /** Setup a matrix for pixel-correct rendering.
            */
            public static LoadPixelMatrix () : void
            /** Load an arbitrary matrix to the current projection matrix.
            */
            public static LoadProjectionMatrix ($mat: UnityEngine.Matrix4x4) : void
            /** Invalidate the internally cached render state.
            */
            public static InvalidateState () : void
            /** Compute GPU projection matrix from camera's projection matrix.
            * @param $proj Source projection matrix.
            * @param $renderIntoTexture Will this projection be used for rendering into a RenderTexture?
            * @returns Adjusted projection matrix for the current graphics API. 
            */
            public static GetGPUProjectionMatrix ($proj: UnityEngine.Matrix4x4, $renderIntoTexture: boolean) : UnityEngine.Matrix4x4
            /** Setup a matrix for pixel-correct rendering.
            */
            public static LoadPixelMatrix ($left: number, $right: number, $bottom: number, $top: number) : void
            /** Send a user-defined event to a native code plugin.
            * @param $eventID User defined id to send to the callback.
            * @param $callback Native code callback to queue for Unity's renderer to invoke.
            */
            public static IssuePluginEvent ($callback: System.IntPtr, $eventID: number) : void
            /** Begin drawing 3D primitives.
            * @param $mode Primitives to draw: can be TRIANGLES, TRIANGLE_STRIP, QUADS or LINES.
            */
            public static Begin ($mode: number) : void
            /** End drawing 3D primitives.
            */
            public static End () : void
            /** Clear the current render buffer.
            * @param $clearDepth Should the depth buffer be cleared?
            * @param $clearColor Should the color buffer be cleared?
            * @param $backgroundColor The color to clear with, used only if clearColor is true.
            * @param $depth The depth to clear the z-buffer with, used only if clearDepth is true. The valid
            range is from 0 (near plane) to 1 (far plane). The value is graphics API agnostic: the abstraction layer will convert
            the value to match the convention of the current graphics API.
            */
            public static Clear ($clearDepth: boolean, $clearColor: boolean, $backgroundColor: UnityEngine.Color, $depth: number) : void
            public static Clear ($clearDepth: boolean, $clearColor: boolean, $backgroundColor: UnityEngine.Color) : void
            /** Set the rendering viewport.
            */
            public static Viewport ($pixelRect: UnityEngine.Rect) : void
            /** Clear the current render buffer with camera's skybox.
            * @param $clearDepth Should the depth buffer be cleared?
            * @param $camera Camera to get projection parameters and skybox from.
            */
            public static ClearWithSkybox ($clearDepth: boolean, $camera: UnityEngine.Camera) : void
            public constructor ()
        }
        /** Scales render textures to support dynamic resolution if the target platform/graphics API supports it.
        */
        class ScalableBufferManager extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Width scale factor to control dynamic resolution.
            */
            public static get widthScaleFactor(): number;
            /** Height scale factor to control dynamic resolution.
            */
            public static get heightScaleFactor(): number;
            /** Function to resize all buffers marked as DynamicallyScalable.
            * @param $widthScale New scale factor for the width the ScalableBufferManager will use to resize all render textures the user marked as DynamicallyScalable, has to be some value greater than 0.0 and less than or equal to 1.0.
            * @param $heightScale New scale factor for the height the ScalableBufferManager will use to resize all render textures the user marked as DynamicallyScalable, has to be some value greater than 0.0 and less than or equal to 1.0.
            */
            public static ResizeBuffers ($widthScale: number, $heightScale: number) : void
        }
        /** Struct containing basic FrameTimings and accompanying relevant data.
        */
        class FrameTiming extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** This is the total CPU frame time calculated as the time between ends of two frames, which includes all waiting time and overheads, in ms.
            */
            public cpuFrameTime : number
            /** Total time between start of the frame and when the main thread finished the job, in ms.
            */
            public cpuMainThreadFrameTime : number
            /** The CPU time the last frame spent in waiting for Present on the main thread, in ms.
            */
            public cpuMainThreadPresentWaitTime : number
            /** The frame time between start of the work on the render thread and when Present was called, in ms.
            */
            public cpuRenderThreadFrameTime : number
            /** The GPU time for a given frame, in ms.
            */
            public gpuFrameTime : number
            /** This is the CPU clock time of the time when the frame was started.
            */
            public frameStartTimestamp : bigint
            /** This is the CPU clock time of the time when the first job was submitted to GPU.
            */
            public firstSubmitTimestamp : bigint
            /** This is the CPU clock time at the point Present was called for the current frame.
            */
            public cpuTimePresentCalled : bigint
            /** This is the CPU clock time at the point GPU finished rendering the frame and interrupted the CPU.
            */
            public cpuTimeFrameComplete : bigint
            /** This was the height scale factor of the Dynamic Resolution system(if used) for the given frame and the linked frame timings.
            */
            public heightScale : number
            /** This was the width scale factor of the Dynamic Resolution system(if used) for the given frame and the linked frame timings.
            */
            public widthScale : number
            /** This was the vsync mode for the given frame and the linked frame timings.
            */
            public syncInterval : number
        }
        /** The FrameTimingManager allows the user to capture and access FrameTiming data for multiple frames.
        */
        class FrameTimingManager extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Check if frame timing statistics are enabled.
            * @returns Whether frame timing statistics are enabled. 
            */
            public static IsFeatureEnabled () : boolean
            /** This function triggers the FrameTimingManager to capture a snapshot of FrameTiming's data, that can then be accessed by the user.
            */
            public static CaptureFrameTimings () : void
            /** Allows the user to access the currently captured FrameTimings.
            * @param $numFrames User supplies a desired number of frames they would like FrameTimings for. This should be equal to or less than the maximum FrameTimings the platform can capture.
            * @param $timings An array of FrameTiming structs that is passed in by the user and will be filled with data as requested. It is the users job to make sure the array that is passed is large enough to hold the requested number of FrameTimings.
            * @returns Returns the number of FrameTimings it actually was able to get. This will always be equal to or less than the requested numFrames depending on availability of captured FrameTimings. 
            */
            public static GetLatestTimings ($numFrames: number, $timings: System.Array$1<UnityEngine.FrameTiming>) : number
            /** This returns the number of vsyncs per second on the current platform, used to interpret timing results. If the platform does not support returning this value it will return 0.
            * @returns Number of vsyncs per second of the current platform. 
            */
            public static GetVSyncsPerSecond () : number
            /** This returns the frequency of GPU timer on the current platform, used to interpret timing results. If the platform does not support returning this value it will return 0.
            * @returns GPU timer frequency for current platform. 
            */
            public static GetGpuTimerFrequency () : bigint
            /** This returns the frequency of CPU timer on the current platform, used to interpret timing results. If the platform does not support returning this value it will return 0.
            * @returns CPU timer frequency for current platform. 
            */
            public static GetCpuTimerFrequency () : bigint
        }
        /** Data of a lightmap.
        */
        class LightmapData extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Lightmap storing color of incoming light.
            */
            public get lightmapColor(): UnityEngine.Texture2D;
            public set lightmapColor(value: UnityEngine.Texture2D);
            /** Lightmap storing dominant direction of incoming light.
            */
            public get lightmapDir(): UnityEngine.Texture2D;
            public set lightmapDir(value: UnityEngine.Texture2D);
            /** Texture storing occlusion mask per light (ShadowMask, up to four lights).
            */
            public get shadowMask(): UnityEngine.Texture2D;
            public set shadowMask(value: UnityEngine.Texture2D);
            public constructor ()
        }
        /** Class that represents textures in C# code.
        */
        class Texture2D extends UnityEngine.Texture
        {
            protected [__keep_incompatibility]: never;
            /** The format of the pixel data in the texture (Read Only).
            */
            public get format(): UnityEngine.TextureFormat;
            /** The name of the texture mipmap limit group that this texture is associated with. (Read Only)
            */
            public get mipmapLimitGroup(): string;
            /** The number of high resolution mipmap levels from the texture that Unity doesn't upload to the GPU. (Read Only)
            */
            public get activeMipmapLimit(): number;
            /** Gets a small Texture with all white pixels.
            */
            public static get whiteTexture(): UnityEngine.Texture2D;
            /** Gets a small Texture with all black pixels.
            */
            public static get blackTexture(): UnityEngine.Texture2D;
            /** Gets a small Texture with all red pixels.
            */
            public static get redTexture(): UnityEngine.Texture2D;
            /** Gets a small Texture with all gray pixels.
            */
            public static get grayTexture(): UnityEngine.Texture2D;
            /** Gets a small Texture with all gray pixels.
            */
            public static get linearGrayTexture(): UnityEngine.Texture2D;
            /** Gets a small Texture with pixels that represent surface normal vectors at a neutral position.
            */
            public static get normalTexture(): UnityEngine.Texture2D;
            public get isReadable(): boolean;
            /** Returns true if the VTOnly checkbox was checked when the texture was imported; otherwise returns false. For additional information, see TextureImporter.vtOnly.
            */
            public get vtOnly(): boolean;
            /** Determines whether mipmap streaming is enabled for this Texture.
            */
            public get streamingMipmaps(): boolean;
            /** Sets the relative priority for this Texture when reducing memory size to fit within the memory budget.
            */
            public get streamingMipmapsPriority(): number;
            /** The mipmap level to load.
            */
            public get requestedMipmapLevel(): number;
            public set requestedMipmapLevel(value: number);
            /** Restricts the mipmap streaming system to a minimum mip level for this Texture.
            */
            public get minimumMipmapLevel(): number;
            public set minimumMipmapLevel(value: number);
            /** The mipmap level calculated by the streaming system, which takes into account the streaming Cameras and the location of the objects containing this Texture. This is unaffected by requestedMipmapLevel or minimumMipmapLevel.
            */
            public get calculatedMipmapLevel(): number;
            /** The mipmap level that the streaming system would load before memory budgets are applied.
            */
            public get desiredMipmapLevel(): number;
            /** The mipmap level that the mipmap streaming system is in the process of loading.
            */
            public get loadingMipmapLevel(): number;
            /** The mipmap level that is currently loaded by the streaming system.
            */
            public get loadedMipmapLevel(): number;
            /** Indicates whether this texture was imported with TextureImporter.alphaIsTransparency enabled. This setting is available only in the Editor scripts. Note that changing this setting will have no effect; it must be enabled in TextureImporter instead.
            */
            public get alphaIsTransparency(): boolean;
            public set alphaIsTransparency(value: boolean);
            /** This property causes a texture to ignore all texture mipmap limit settings.
            */
            public get ignoreMipmapLimit(): boolean;
            public set ignoreMipmapLimit(value: boolean);
            /** Compress texture at runtime to DXT/BCn or ETC formats.
            */
            public Compress ($highQuality: boolean) : void
            /** Resets the requestedMipmapLevel field.
            */
            public ClearRequestedMipmapLevel () : void
            /** Checks to see whether the mipmap level set by requestedMipmapLevel has finished loading.
            * @returns True if the mipmap level requested by requestedMipmapLevel has finished loading. 
            */
            public IsRequestedMipmapLevelLoaded () : boolean
            /** Resets the minimumMipmapLevel field.
            */
            public ClearMinimumMipmapLevel () : void
            /** Updates Unity texture to use different native texture object.
            * @param $nativeTex Native 2D texture object.
            */
            public UpdateExternalTexture ($nativeTex: System.IntPtr) : void
            /** Gets the raw data from a texture, as a copy.
            * @returns A byte array that contains raw texture data. 
            */
            public GetRawTextureData () : System.Array$1<number>
            /** Gets the pixel color data for part of a mipmap level as Color structs.
            * @param $x The starting x position of the section to fetch.
            * @param $y The starting y position of the section to fetch.
            * @param $blockWidth The width of the section to fetch.
            * @param $blockHeight The height of the section to fetch.
            * @param $miplevel The mipmap level to read from. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns An array that contains the pixel colors. 
            */
            public GetPixels ($x: number, $y: number, $blockWidth: number, $blockHeight: number, $miplevel: number) : System.Array$1<UnityEngine.Color>
            /** Gets the pixel color data for part of a mipmap level as Color structs.
            * @param $x The starting x position of the section to fetch.
            * @param $y The starting y position of the section to fetch.
            * @param $blockWidth The width of the section to fetch.
            * @param $blockHeight The height of the section to fetch.
            * @param $miplevel The mipmap level to read from. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns An array that contains the pixel colors. 
            */
            public GetPixels ($x: number, $y: number, $blockWidth: number, $blockHeight: number) : System.Array$1<UnityEngine.Color>
            /** Gets the pixel color data for a mipmap level as Color32 structs.
            * @param $miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns An array that contains the pixel colors. 
            */
            public GetPixels32 ($miplevel: number) : System.Array$1<UnityEngine.Color32>
            public GetPixels32 () : System.Array$1<UnityEngine.Color32>
            /** Packs multiple Textures into a texture atlas.
            * @param $textures Array of textures to pack into the atlas.
            * @param $padding Padding in pixels between the packed textures.
            * @param $maximumAtlasSize Maximum size of the resulting texture.
            * @param $makeNoLongerReadable Should the texture be marked as no longer readable?
            * @returns An array of rectangles containing the UV coordinates in the atlas for each input texture, or null if packing fails. 
            */
            public PackTextures ($textures: System.Array$1<UnityEngine.Texture2D>, $padding: number, $maximumAtlasSize: number, $makeNoLongerReadable: boolean) : System.Array$1<UnityEngine.Rect>
            public PackTextures ($textures: System.Array$1<UnityEngine.Texture2D>, $padding: number, $maximumAtlasSize: number) : System.Array$1<UnityEngine.Rect>
            public PackTextures ($textures: System.Array$1<UnityEngine.Texture2D>, $padding: number) : System.Array$1<UnityEngine.Rect>
            /** Creates a Unity Texture out of an externally created native texture object.
            * @param $nativeTex Native 2D texture object.
            * @param $width Width of texture in pixels.
            * @param $height Height of texture in pixels.
            * @param $format Format of underlying texture object.
            * @param $mipmap Does the texture have mipmaps?
            * @param $linear Is texture using linear color space?
            */
            public static CreateExternalTexture ($width: number, $height: number, $format: UnityEngine.TextureFormat, $mipChain: boolean, $linear: boolean, $nativeTex: System.IntPtr) : UnityEngine.Texture2D
            /** Sets the pixel color at coordinates (x,y).
            * @param $x The x coordinate of the pixel to set. The range is 0 through (texture width - 1).
            * @param $y The y coordinate of the pixel to set. The range is 0 through (texture height - 1).
            * @param $color The color to set.
            * @param $mipLevel The mipmap level to write to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            */
            public SetPixel ($x: number, $y: number, $color: UnityEngine.Color) : void
            /** Sets the pixel color at coordinates (x,y).
            * @param $x The x coordinate of the pixel to set. The range is 0 through (texture width - 1).
            * @param $y The y coordinate of the pixel to set. The range is 0 through (texture height - 1).
            * @param $color The color to set.
            * @param $mipLevel The mipmap level to write to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            */
            public SetPixel ($x: number, $y: number, $color: UnityEngine.Color, $mipLevel: number) : void
            /** Sets the pixel colors of part of a mipmap level.
            * @param $x The x coordinate to place the block of pixels at. The range is 0 through (texture width - 1).
            * @param $y The y coordinate to place the block of pixels at. The range is 0 through (texture height - 1).
            * @param $blockWidth The width of the block of pixels to set.
            * @param $blockHeight The height of the block of pixels to set.
            * @param $colors The array of pixel colours to use. This is a 2D image flattened to a 1D array. Must be blockWidth x blockHeight in length.
            * @param $miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            */
            public SetPixels ($x: number, $y: number, $blockWidth: number, $blockHeight: number, $colors: System.Array$1<UnityEngine.Color>, $miplevel: number) : void
            public SetPixels ($x: number, $y: number, $blockWidth: number, $blockHeight: number, $colors: System.Array$1<UnityEngine.Color>) : void
            /** Sets the pixel colors of an entire mipmap level.
            * @param $colors The array of pixel colours to use. This is a 2D image flattened to a 1D array.
            * @param $miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            */
            public SetPixels ($colors: System.Array$1<UnityEngine.Color>, $miplevel: number) : void
            public SetPixels ($colors: System.Array$1<UnityEngine.Color>) : void
            /** Gets the pixel color at coordinates (x, y).
            * @param $x The x coordinate of the pixel to get. The range is 0 through (texture width - 1).
            * @param $y The y coordinate of the pixel to get. The range is 0 through (texture height - 1).
            * @param $mipLevel The mipmap level to sample. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns The pixel color. 
            */
            public GetPixel ($x: number, $y: number) : UnityEngine.Color
            /** Gets the pixel color at coordinates (x, y).
            * @param $x The x coordinate of the pixel to get. The range is 0 through (texture width - 1).
            * @param $y The y coordinate of the pixel to get. The range is 0 through (texture height - 1).
            * @param $mipLevel The mipmap level to sample. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns The pixel color. 
            */
            public GetPixel ($x: number, $y: number, $mipLevel: number) : UnityEngine.Color
            /** Gets the filtered pixel color at the normalized coordinates (u, v).
            * @param $u The u coordinate of the pixel to get.
            * @param $v The v coordinate of the pixel to get.
            * @param $mipLevel The mipmap level to read from. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns The pixel color. 
            */
            public GetPixelBilinear ($u: number, $v: number) : UnityEngine.Color
            /** Gets the filtered pixel color at the normalized coordinates (u, v).
            * @param $u The u coordinate of the pixel to get.
            * @param $v The v coordinate of the pixel to get.
            * @param $mipLevel The mipmap level to read from. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns The pixel color. 
            */
            public GetPixelBilinear ($u: number, $v: number, $mipLevel: number) : UnityEngine.Color
            /** Sets the raw data of an entire texture in CPU memory.
            * @param $data The array of data to use.
            * @param $size The size of the data in bytes.
            */
            public LoadRawTextureData ($data: System.IntPtr, $size: number) : void
            /** Sets the raw data of an entire texture in CPU memory.
            * @param $data The array of data to use.
            * @param $size The size of the data in bytes.
            */
            public LoadRawTextureData ($data: System.Array$1<number>) : void
            /** Copies changes you've made in a CPU texture to the GPU.
            * @param $updateMipmaps When the value is true, Unity recalculates mipmap levels, using mipmap level 0 as the source. The default value is true.
            * @param $makeNoLongerReadable When the value is true, Unity deletes the texture in CPU memory after it uploads it to the GPU, and sets Texture.isReadable|isReadable to false. The default value is false.
            */
            public Apply ($updateMipmaps: boolean, $makeNoLongerReadable: boolean) : void
            public Apply ($updateMipmaps: boolean) : void
            public Apply () : void
            /** Reinitializes a Texture2D, making it possible for you to replace width, height, textureformat, and graphicsformat data for that texture.
            * @param $width The new width of the texture.
            * @param $height The new height of the texture.
            * @param $format The new format of the texture.
            * @param $hasMipMap Whether the texture reserves memory for a full mipmap chain.
            * @returns true if the reinitialization was a success. 
            */
            public Reinitialize ($width: number, $height: number) : boolean
            /** Reinitializes a Texture2D, making it possible for you to replace width, height, textureformat, and graphicsformat data for that texture.
            * @param $width The new width of the texture.
            * @param $height The new height of the texture.
            * @param $format The new format of the texture.
            * @param $hasMipMap Whether the texture reserves memory for a full mipmap chain.
            * @returns true if the reinitialization was a success. 
            */
            public Reinitialize ($width: number, $height: number, $format: UnityEngine.TextureFormat, $hasMipMap: boolean) : boolean
            /** Reinitializes a Texture2D, making it possible for you to replace width, height, textureformat, and graphicsformat data for that texture.
            * @param $width The new width of the texture.
            * @param $height The new height of the texture.
            * @param $format The new format of the texture.
            * @param $hasMipMap Whether the texture reserves memory for a full mipmap chain.
            * @returns true if the reinitialization was a success. 
            */
            public Reinitialize ($width: number, $height: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $hasMipMap: boolean) : boolean
            /** Reads pixels from the current render target and writes them to a texture.
            * @param $source The region of the render target to read from.
            * @param $destX The x position in the texture to write the pixels to.
            * @param $destY The y position in the texture to write the pixels to.
            * @param $recalculateMipMaps When the value is true, Unity automatically recalculates the mipmap for the texture after it writes the pixel data. Otherwise, Unity doesn't do this automatically.
            */
            public ReadPixels ($source: UnityEngine.Rect, $destX: number, $destY: number, $recalculateMipMaps: boolean) : void
            public ReadPixels ($source: UnityEngine.Rect, $destX: number, $destY: number) : void
            public static GenerateAtlas ($sizes: System.Array$1<UnityEngine.Vector2>, $padding: number, $atlasSize: number, $results: System.Collections.Generic.List$1<UnityEngine.Rect>) : boolean
            /** Sets the pixel colors of an entire mipmap level.
            * @param $colors The array of pixel colours to use. This is a 2D image flattened to a 1D array.
            * @param $miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            */
            public SetPixels32 ($colors: System.Array$1<UnityEngine.Color32>, $miplevel: number) : void
            /** Sets the pixel colors of an entire mipmap level.
            * @param $colors The array of pixel colours to use. This is a 2D image flattened to a 1D array.
            * @param $miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            */
            public SetPixels32 ($colors: System.Array$1<UnityEngine.Color32>) : void
            /** Sets the pixel colors of part of a mipmap level.
            * @param $x The x coordinate to place the block of pixels at. The range is 0 through (texture width - 1).
            * @param $y The y coordinate to place the block of pixels at. The range is 0 through (texture height - 1).
            * @param $blockWidth The width of the block of pixels to set.
            * @param $blockHeight The height of the block of pixels to set.
            * @param $colors The array of pixel colours to use. This is a 2D image flattened to a 1D array. Must be blockWidth x blockHeight in length.
            * @param $miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            */
            public SetPixels32 ($x: number, $y: number, $blockWidth: number, $blockHeight: number, $colors: System.Array$1<UnityEngine.Color32>, $miplevel: number) : void
            /** Sets the pixel colors of part of a mipmap level.
            * @param $x The x coordinate to place the block of pixels at. The range is 0 through (texture width - 1).
            * @param $y The y coordinate to place the block of pixels at. The range is 0 through (texture height - 1).
            * @param $blockWidth The width of the block of pixels to set.
            * @param $blockHeight The height of the block of pixels to set.
            * @param $colors The array of pixel colours to use. This is a 2D image flattened to a 1D array. Must be blockWidth x blockHeight in length.
            * @param $miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            */
            public SetPixels32 ($x: number, $y: number, $blockWidth: number, $blockHeight: number, $colors: System.Array$1<UnityEngine.Color32>) : void
            /** Gets the pixel color data for a mipmap level as Color structs.
            * @param $miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns An array that contains the pixel colors. 
            */
            public GetPixels ($miplevel: number) : System.Array$1<UnityEngine.Color>
            public GetPixels () : System.Array$1<UnityEngine.Color>
            public constructor ($width: number, $height: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags)
            public constructor ($width: number, $height: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat, $mipCount: number, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags)
            public constructor ($width: number, $height: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat, $mipCount: number, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags, $mipmapLimitDescriptor: UnityEngine.MipmapLimitDescriptor)
            public constructor ($width: number, $height: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags)
            public constructor ($width: number, $height: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $mipCount: number, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags)
            public constructor ($width: number, $height: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $mipCount: number, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags, $mipmapLimitDescriptor: UnityEngine.MipmapLimitDescriptor)
            public constructor ($width: number, $height: number, $textureFormat: UnityEngine.TextureFormat, $mipCount: number, $linear: boolean)
            public constructor ($width: number, $height: number, $textureFormat: UnityEngine.TextureFormat, $mipCount: number, $linear: boolean, $createUninitialized: boolean)
            public constructor ($width: number, $height: number, $textureFormat: UnityEngine.TextureFormat, $mipCount: number, $linear: boolean, $createUninitialized: boolean, $mipmapLimitDescriptor: UnityEngine.MipmapLimitDescriptor)
            public constructor ($width: number, $height: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean, $linear: boolean)
            public constructor ($width: number, $height: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean, $linear: boolean, $createUninitialized: boolean)
            public constructor ($width: number, $height: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean)
            public constructor ($width: number, $height: number)
            public constructor ()
        }
        /** Stores lightmaps of the Scene.
        */
        class LightmapSettings extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** Lightmap array.
            */
            public static get lightmaps(): System.Array$1<UnityEngine.LightmapData>;
            public static set lightmaps(value: System.Array$1<UnityEngine.LightmapData>);
            /** NonDirectional or CombinedDirectional Specular lightmaps rendering mode.
            */
            public static get lightmapsMode(): UnityEngine.LightmapsMode;
            public static set lightmapsMode(value: UnityEngine.LightmapsMode);
            /** Baked Light Probe data.
            */
            public static get lightProbes(): UnityEngine.LightProbes;
            public static set lightProbes(value: UnityEngine.LightProbes);
        }
        /** Stores light probe data for all currently loaded Scenes.
        */
        class LightProbes extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** Positions of the baked light probes (Read Only).
            */
            public get positions(): System.Array$1<UnityEngine.Vector3>;
            /** Coefficients of baked light probes.
            */
            public get bakedProbes(): System.Array$1<UnityEngine.Rendering.SphericalHarmonicsL2>;
            public set bakedProbes(value: System.Array$1<UnityEngine.Rendering.SphericalHarmonicsL2>);
            /** The number of light probes (Read Only).
            */
            public get count(): number;
            /** The number of light probes stored in this LightProbes object (Read Only).
            */
            public get countSelf(): number;
            /** The number of cells space is divided into (Read Only).
            */
            public get cellCount(): number;
            /** The number of cells space is divided into for this LightProbes object (Read Only).
            */
            public get cellCountSelf(): number;
            public static add_lightProbesUpdated ($value: System.Action) : void
            public static remove_lightProbesUpdated ($value: System.Action) : void
            public static add_tetrahedralizationCompleted ($value: System.Action) : void
            public static remove_tetrahedralizationCompleted ($value: System.Action) : void
            public static add_needsRetetrahedralization ($value: System.Action) : void
            public static remove_needsRetetrahedralization ($value: System.Action) : void
            /** Synchronously tetrahedralize the currently loaded LightProbe positions.
            */
            public static Tetrahedralize () : void
            /** Asynchronously tetrahedralize all currently loaded LightProbe positions.
            */
            public static TetrahedralizeAsync () : void
            /** Returns an interpolated probe for the given position for both real-time and baked light probes combined.
            */
            public static GetInterpolatedProbe ($position: UnityEngine.Vector3, $renderer: UnityEngine.Renderer, $probe: $Ref<UnityEngine.Rendering.SphericalHarmonicsL2>) : void
            /** Calculate light probes and occlusion probes at the given world space positions.
            * @param $positions The array of world space positions used to evaluate the probes.
            * @param $lightProbes The array where the resulting light probes are written to.
            * @param $occlusionProbes The array where the resulting occlusion probes are written to.
            */
            public static CalculateInterpolatedLightAndOcclusionProbes ($positions: System.Array$1<UnityEngine.Vector3>, $lightProbes: System.Array$1<UnityEngine.Rendering.SphericalHarmonicsL2>, $occlusionProbes: System.Array$1<UnityEngine.Vector4>) : void
            public static CalculateInterpolatedLightAndOcclusionProbes ($positions: System.Collections.Generic.List$1<UnityEngine.Vector3>, $lightProbes: System.Collections.Generic.List$1<UnityEngine.Rendering.SphericalHarmonicsL2>, $occlusionProbes: System.Collections.Generic.List$1<UnityEngine.Vector4>) : void
            /** Gets the shared LightProbes object for a specific scene.
            * @param $scene The scene to get the shared light probe data for.
            * @returns The shared light probe data for the scene. 
            */
            public static GetSharedLightProbesForScene ($scene: UnityEngine.SceneManagement.Scene) : UnityEngine.LightProbes
            /** Gets an instantiated clone of the LightProbes object for a specific scene.
            * @param $scene The scene to get the shared light probe data for.
            * @returns The cloned light probe data for the scene. 
            */
            public static GetInstantiatedLightProbesForScene ($scene: UnityEngine.SceneManagement.Scene) : UnityEngine.LightProbes
            /** Gets the positions of the baked light probes stored in this LightProbes object.
            * @returns The array of positions of the baked light probes. 
            */
            public GetPositionsSelf () : System.Array$1<UnityEngine.Vector3>
            /** Sets the positions of the baked light probes stored in this LightProbes object.
            * @param $checkForDuplicatePositions Whether to check for duplicate light probe positions at the cost of performance.
            * @param $positions The positions to set.
            * @returns true when the positions were successfully set. Otherwise false. 
            */
            public SetPositionsSelf ($positions: System.Array$1<UnityEngine.Vector3>, $checkForDuplicatePositions: boolean) : boolean
        }
        /** Single, dual, or directional lightmaps rendering mode, used only in GIWorkflowMode.Legacy
        */
        enum LightmapsModeLegacy
        { Single = 0, Dual = 1, Directional = 2 }
        /** Color space for player settings.
        */
        enum ColorSpace
        { Uninitialized = -1, Gamma = 0, Linear = 1 }
        /** The type for the number of bits to be used when an HDR display is active in each color channel of swap chain buffers. The bit count also defines the method Unity uses to render content to the display.
        */
        enum D3DHDRDisplayBitDepth
        { D3DHDRDisplayBitDepth10 = 0, D3DHDRDisplayBitDepth16 = 1 }
        /** Provides access to HDR display settings and information.
        */
        class HDROutputSettings extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** The list of currently connected displays with possible HDR availability.
            */
            public static displays : System.Array$1<UnityEngine.HDROutputSettings>
            /** The HDROutputSettings for the main display.
            */
            public static get main(): UnityEngine.HDROutputSettings;
            /** Describes whether HDR output is currently active on the display. It is true if this is the case, and @@false@ otherwise.
            */
            public get active(): boolean;
            /** Describes whether HDR is currently available on your primary display and that you have HDR enabled in your Unity Project. It is true if this is the case, and false otherwise.
            */
            public get available(): boolean;
            /** Describes whether Unity performs HDR tonemapping automatically.
            */
            public get automaticHDRTonemapping(): boolean;
            public set automaticHDRTonemapping(value: boolean);
            /** The ColorGamut used to output to the active HDR display.
            */
            public get displayColorGamut(): UnityEngine.ColorGamut;
            /** The RenderTextureFormat of the display buffer for the active HDR display.
            */
            public get format(): UnityEngine.RenderTextureFormat;
            /** The Experimental.Rendering.GraphicsFormat of the display buffer for the active HDR display.
            */
            public get graphicsFormat(): UnityEngine.Experimental.Rendering.GraphicsFormat;
            /** The base luminance of a white paper surface in nits or candela per square meter (cd/m2).
            */
            public get paperWhiteNits(): number;
            public set paperWhiteNits(value: number);
            /** Maximum input luminance at which gradation is preserved even when the entire screen is bright.
            */
            public get maxFullFrameToneMapLuminance(): number;
            /** Maximum input luminance at which gradation is preserved when 10% of the screen is bright.
            */
            public get maxToneMapLuminance(): number;
            /** Minimum input luminance at which gradation is identifiable.
            */
            public get minToneMapLuminance(): number;
            /** Describes whether the user has requested to change the HDR Output Mode. It is true if this is the case, and false otherwise.
            */
            public get HDRModeChangeRequested(): boolean;
            /** Use this function to request a change in the HDR Output Mode and in the value of HDROutputSettings.active.
            * @param $enabled Indicates whether HDR should be enabled.
            */
            public RequestHDRModeChange ($enabled: boolean) : void
        }
        /** Format of a RenderTexture.
        */
        enum RenderTextureFormat
        { ARGB32 = 0, Depth = 1, ARGBHalf = 2, Shadowmap = 3, RGB565 = 4, ARGB4444 = 5, ARGB1555 = 6, Default = 7, ARGB2101010 = 8, DefaultHDR = 9, ARGB64 = 10, ARGBFloat = 11, RGFloat = 12, RGHalf = 13, RFloat = 14, RHalf = 15, R8 = 16, ARGBInt = 17, RGInt = 18, RInt = 19, BGRA32 = 20, RGB111110Float = 22, RG32 = 23, RGBAUShort = 24, RG16 = 25, BGRA10101010_XR = 26, BGR101010_XR = 27, R16 = 28 }
        /** Utility class to query properties of a ColorGamut.
        */
        class ColorGamutUtility extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Returns the color primaries mapped to the color space used by the given gamut.
            * @param $gamut The color gamut to look up.
            * @returns Color primaries for the given gamut. 
            */
            public static GetColorPrimaries ($gamut: UnityEngine.ColorGamut) : UnityEngine.ColorPrimaries
            /** Returns the white point that the given gamut uses.
            * @param $gamut The color gamut to look up.
            * @returns The white point that the given gamut uses. 
            */
            public static GetWhitePoint ($gamut: UnityEngine.ColorGamut) : UnityEngine.WhitePoint
            /** Returns the transfer function that the given gamut uses on the current platform.
            * @param $gamut The color gamut to look up.
            * @returns The transfer function that the given gamut uses. 
            */
            public static GetTransferFunction ($gamut: UnityEngine.ColorGamut) : UnityEngine.TransferFunction
            public constructor ()
        }
        /** Represents a color space based on its set of red, green, and blue color primaries.
        */
        enum ColorPrimaries
        { Unknown = -1, Rec709 = 0, Rec2020 = 1, P3 = 2 }
        /** The reference white point of a color space.
        */
        enum WhitePoint
        { Unknown = -1, D65 = 0 }
        /** Contains electro-optical transfer function options.
        */
        enum TransferFunction
        { Unknown = -1, sRGB = 0, BT1886 = 1, PQ = 2, Linear = 3, Gamma22 = 4 }
        /** The type of motion vectors that should be generated.
        */
        enum MotionVectorGenerationMode
        { Camera = 0, Object = 1, ForceNoMotion = 2 }
        /** This represents the script interface for.
        */
        class QualitySettings extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** The maximum number of pixel lights that should affect any object.
            */
            public static get pixelLightCount(): number;
            public static set pixelLightCount(value: number);
            /** Real-time Shadows type to be used.
            */
            public static get shadows(): UnityEngine.ShadowQuality;
            public static set shadows(value: UnityEngine.ShadowQuality);
            /** Directional light shadow projection.
            */
            public static get shadowProjection(): UnityEngine.ShadowProjection;
            public static set shadowProjection(value: UnityEngine.ShadowProjection);
            /** Number of cascades to use for directional light shadows.
            */
            public static get shadowCascades(): number;
            public static set shadowCascades(value: number);
            /** Shadow drawing distance.
            */
            public static get shadowDistance(): number;
            public static set shadowDistance(value: number);
            /** The default resolution of the shadow maps.
            */
            public static get shadowResolution(): UnityEngine.ShadowResolution;
            public static set shadowResolution(value: UnityEngine.ShadowResolution);
            /** The rendering mode of Shadowmask.
            */
            public static get shadowmaskMode(): UnityEngine.ShadowmaskMode;
            public static set shadowmaskMode(value: UnityEngine.ShadowmaskMode);
            /** Offset shadow frustum near plane.
            */
            public static get shadowNearPlaneOffset(): number;
            public static set shadowNearPlaneOffset(value: number);
            /** The normalized cascade distribution for a 2 cascade setup. The value defines the position of the cascade with respect to Zero.
            */
            public static get shadowCascade2Split(): number;
            public static set shadowCascade2Split(value: number);
            /** The normalized cascade start position for a 4 cascade setup. Each member of the vector defines the normalized position of the coresponding cascade with respect to Zero.
            */
            public static get shadowCascade4Split(): UnityEngine.Vector3;
            public static set shadowCascade4Split(value: UnityEngine.Vector3);
            /** Global multiplier for the LOD's switching distance.
            */
            public static get lodBias(): number;
            public static set lodBias(value: number);
            /** Global anisotropic filtering mode.
            */
            public static get anisotropicFiltering(): UnityEngine.AnisotropicFiltering;
            public static set anisotropicFiltering(value: UnityEngine.AnisotropicFiltering);
            /** Indicates how many of the highest-resolution mips of each texture Unity does not upload at the given quality level. To set more specific mipmap limits, you can flag textures to ignore mipmap limits or assign them to mipmap limit groups.
            */
            public static get globalTextureMipmapLimit(): number;
            public static set globalTextureMipmapLimit(value: number);
            /** A maximum LOD level. All LOD groups.
            */
            public static get maximumLODLevel(): number;
            public static set maximumLODLevel(value: number);
            /** Enables or disables LOD Cross Fade.
            */
            public static get enableLODCrossFade(): boolean;
            public static set enableLODCrossFade(value: boolean);
            /** Budget for how many ray casts can be performed per frame for approximate collision testing.
            */
            public static get particleRaycastBudget(): number;
            public static set particleRaycastBudget(value: number);
            /** Should soft blending be used for particles?
            */
            public static get softParticles(): boolean;
            public static set softParticles(value: boolean);
            /** Use a two-pass shader for the vegetation in the terrain engine.
            */
            public static get softVegetation(): boolean;
            public static set softVegetation(value: boolean);
            /** Represents the number of vertical syncs that should pass between each frame.
            */
            public static get vSyncCount(): number;
            public static set vSyncCount(value: number);
            /** How much CPU usage to assign to the final lighting calculations at runtime.
            */
            public static get realtimeGICPUUsage(): number;
            public static set realtimeGICPUUsage(value: number);
            /** Choose the level of Multi-Sample Anti-aliasing (MSAA) that the GPU performs.
            */
            public static get antiAliasing(): number;
            public static set antiAliasing(value: number);
            /** Async texture upload provides timesliced async texture upload on the render thread with tight control over memory and timeslicing. There are no allocations except for the ones which driver has to do. To read data and upload texture data a ringbuffer whose size can be controlled is re-used.
            Use asyncUploadTimeSlice to set the time-slice in milliseconds for asynchronous texture uploads per
            frame. Minimum value is 1 and maximum is 33.
            */
            public static get asyncUploadTimeSlice(): number;
            public static set asyncUploadTimeSlice(value: number);
            /** Asynchronous texture and mesh data upload provides timesliced async texture and mesh data upload on the render thread with tight control over memory and timeslicing. There are no allocations except for the ones which driver has to do. To read data and upload texture and mesh data, Unity re-uses a ringbuffer whose size can be controlled.
            Use asyncUploadBufferSize to set the buffer size for asynchronous texture and mesh data uploads. The minimum value is 2 megabytes and the maximum value is 2047 megabytes. The buffer resizes automatically to fit the largest texture currently loading. To avoid a buffer resize (which can use extra system resources) set this value to the size of the largest texture in the Scene. If you have issues with excessive memory usage, you may need to reduce the value of this buffer or disable asyncUploadPersistentBuffer. Memory fragmentation can occur if you choose the latter option.
            */
            public static get asyncUploadBufferSize(): number;
            public static set asyncUploadBufferSize(value: number);
            /** This flag controls if the async upload pipeline's ring buffer remains allocated when there are no active loading operations.
            Set this to true, to make the ring buffer allocation persist after all upload operations have completed.
            If you have issues with excessive memory usage, you can set this to false. This means you reduce the runtime memory footprint, but memory fragmentation can occur.
            The default value is true.
            */
            public static get asyncUploadPersistentBuffer(): boolean;
            public static set asyncUploadPersistentBuffer(value: boolean);
            /** Enables or disables real-time reflection probes.
            */
            public static get realtimeReflectionProbes(): boolean;
            public static set realtimeReflectionProbes(value: boolean);
            /** If enabled, billboards will face towards camera position rather than camera orientation.
            */
            public static get billboardsFaceCameraPosition(): boolean;
            public static set billboardsFaceCameraPosition(value: boolean);
            /** Use the legacy pre-2022.2 algorithm for distributing details on terrain.
            */
            public static get useLegacyDetailDistribution(): boolean;
            public static set useLegacyDetailDistribution(value: boolean);
            /** In resolution scaling mode, this factor is used to multiply with the target Fixed DPI specified to get the actual Fixed DPI to use for this quality setting.
            */
            public static get resolutionScalingFixedDPIFactor(): number;
            public static set resolutionScalingFixedDPIFactor(value: number);
            /** Controls which fields should have their values overriden in active Terrains.
            */
            public static get terrainQualityOverrides(): UnityEngine.TerrainQualityOverrides;
            public static set terrainQualityOverrides(value: UnityEngine.TerrainQualityOverrides);
            /** Value set to Terrain.heightmapPixelError if TerrainQualityOverrides.PixelError is set in terrainQualityOverrides.
            */
            public static get terrainPixelError(): number;
            public static set terrainPixelError(value: number);
            /** Value set to Terrain.detailObjectDensity if TerrainQualityOverrides.DetailDensity is set in terrainQualityOverrides.
            */
            public static get terrainDetailDensityScale(): number;
            public static set terrainDetailDensityScale(value: number);
            /** Value set to Terrain.basemapDistance if TerrainQualityOverrides.BasemapDistance is set in terrainQualityOverrides.
            */
            public static get terrainBasemapDistance(): number;
            public static set terrainBasemapDistance(value: number);
            /** Value set to Terrain.detailObjectDistance if TerrainQualityOverrides.DetailDistance is set in terrainQualityOverrides.
            */
            public static get terrainDetailDistance(): number;
            public static set terrainDetailDistance(value: number);
            /** Value set to Terrain.treeDistance if TerrainQualityOverrides.TreeDistance is set in terrainQualityOverrides.
            */
            public static get terrainTreeDistance(): number;
            public static set terrainTreeDistance(value: number);
            /** Value set to Terrain.treeBillboardDistance if TerrainQualityOverrides.BillboardStart is set in terrainQualityOverrides.
            */
            public static get terrainBillboardStart(): number;
            public static set terrainBillboardStart(value: number);
            /** Value set to Terrain.treeCrossFadeLength if TerrainQualityOverrides.FadeLength is set in terrainQualityOverrides.
            */
            public static get terrainFadeLength(): number;
            public static set terrainFadeLength(value: number);
            /** Value set to Terrain.treeMaximumFullLODCount if TerrainQualityOverrides.MaxTrees is set in terrainQualityOverrides.
            */
            public static get terrainMaxTrees(): number;
            public static set terrainMaxTrees(value: number);
            /** The RenderPipelineAsset that defines the override render pipeline for the current quality level.
            */
            public static get renderPipeline(): UnityEngine.Rendering.RenderPipelineAsset;
            public static set renderPipeline(value: UnityEngine.Rendering.RenderPipelineAsset);
            /** The maximum number of bones per vertex that are taken into account during skinning, for all meshes in the project.
            */
            public static get skinWeights(): UnityEngine.SkinWeights;
            public static set skinWeights(value: UnityEngine.SkinWeights);
            /** The number of Quality Levels.
            */
            public static get count(): number;
            /** Enable automatic streaming of texture mipmap levels based on their distance from all active cameras.
            */
            public static get streamingMipmapsActive(): boolean;
            public static set streamingMipmapsActive(value: boolean);
            /** The total amount of memory (in megabytes) to be used by streaming and non-streaming textures.
            */
            public static get streamingMipmapsMemoryBudget(): number;
            public static set streamingMipmapsMemoryBudget(value: number);
            /** The number of renderer instances that are processed each frame when calculating which texture mipmap levels should be streamed.
            */
            public static get streamingMipmapsRenderersPerFrame(): number;
            public static set streamingMipmapsRenderersPerFrame(value: number);
            /** The maximum number of mipmap levels to discard for each texture.
            */
            public static get streamingMipmapsMaxLevelReduction(): number;
            public static set streamingMipmapsMaxLevelReduction(value: number);
            /** Process all enabled Cameras for texture streaming (rather than just those with StreamingController components).
            */
            public static get streamingMipmapsAddAllCameras(): boolean;
            public static set streamingMipmapsAddAllCameras(value: boolean);
            /** The maximum number of active texture file IO requests from the texture streaming system.
            */
            public static get streamingMipmapsMaxFileIORequests(): number;
            public static set streamingMipmapsMaxFileIORequests(value: number);
            /** Maximum number of frames queued up by graphics driver.
            */
            public static get maxQueuedFrames(): number;
            public static set maxQueuedFrames(value: number);
            /** The indexed list of available Quality Settings.
            */
            public static get names(): System.Array$1<string>;
            /** Desired color space (Read Only).
            */
            public static get desiredColorSpace(): UnityEngine.ColorSpace;
            /** Active color space (Read Only).
            */
            public static get activeColorSpace(): UnityEngine.ColorSpace;
            public static add_activeQualityLevelChanged ($value: System.Action$2<number, number>) : void
            public static remove_activeQualityLevelChanged ($value: System.Action$2<number, number>) : void
            /** Increase the current quality level.
            * @param $applyExpensiveChanges Should expensive changes be applied (Anti-aliasing etc).
            */
            public static IncreaseLevel ($applyExpensiveChanges: boolean) : void
            /** Decrease the current quality level.
            * @param $applyExpensiveChanges Should expensive changes be applied (Anti-aliasing etc).
            */
            public static DecreaseLevel ($applyExpensiveChanges: boolean) : void
            public static SetQualityLevel ($index: number) : void
            public static IncreaseLevel () : void
            public static DecreaseLevel () : void
            /** Executes the given Action for each tier on the QualitySettings.
            * @param $callback The callback to execute for each level.
            */
            public static ForEach ($callback: System.Action) : void
            public static ForEach ($callback: System.Action$2<number, string>) : void
            /** Sets the QualitySettings.lodBias|lodBias and QualitySettings.maximumLODLevel|maximumLODLevel at the same time.
            * @param $lodBias Global multiplier for the LOD's switching distance.
            * @param $maximumLODLevel A maximum LOD level. All LOD groups.
            * @param $setDirty If true, marks all views as dirty.
            */
            public static SetLODSettings ($lodBias: number, $maximumLODLevel: number, $setDirty?: boolean) : void
            /** Applies new TextureMipmapLimitSettings to the indicated texture mipmap limit group.
            * @param $groupName Name of the texture mipmap limit group to modify.
            * @param $textureMipmapLimitSettings The new texture mipmap limit settings to apply.
            */
            public static SetTextureMipmapLimitSettings ($groupName: string, $textureMipmapLimitSettings: UnityEngine.TextureMipmapLimitSettings) : void
            /** Retrieves a copy of the TextureMipmapLimitSettings from a texture mipmap limit group.
            * @param $groupName Name of the texture mipmap limit group to scan.
            * @returns Structure containing the settings for the indicated groupName. 
            */
            public static GetTextureMipmapLimitSettings ($groupName: string) : UnityEngine.TextureMipmapLimitSettings
            /** Provides a reference to the RenderPipelineAsset that defines the override render pipeline for a given quality level. 
            * @param $index Index of the quality level.
            * @returns Returns null if the quality level does not exist, or if no asset is assigned to that quality level. Otherwise, returns the RenderPipelineAsset that defines the override render pipeline for the quality level. 
            */
            public static GetRenderPipelineAssetAt ($index: number) : UnityEngine.Rendering.RenderPipelineAsset
            /** Returns the current graphics quality level.
            */
            public static GetQualityLevel () : number
            /** Provides a reference to the QualitySettings object.
            * @returns Returns the QualitySettings object. 
            */
            public static GetQualitySettings () : UnityEngine.Object
            /** Sets a new graphics quality level.
            * @param $index Quality index to set.
            * @param $applyExpensiveChanges Should expensive changes be applied (Anti-aliasing etc).
            */
            public static SetQualityLevel ($index: number, $applyExpensiveChanges: boolean) : void
            /** [Editor Only] Returns if the given platform is included by the Quality Level.
            * @param $buildTargetGroupName The platform name.
            * @param $index The index of the Quality Level, must be positive and lower than the count of Quality Levels.
            * @returns If the platform is included. 
            */
            public static IsPlatformIncluded ($buildTargetGroupName: string, $index: number) : boolean
            /** [Editor Only] Includes a platform to be supported by the Quality Level.
            * @param $buildTargetGroupName The platform name.
            * @param $index The index of the Quality Level, must be positive and lower than the count of Quality Levels.
            * @param $error The error found by the API.
            * @returns If errors were found. 
            */
            public static TryIncludePlatformAt ($buildTargetGroupName: string, $index: number, $error: $Ref<System.Exception>) : boolean
            /** [Editor Only] Excludes a platfor for the given Quality Level.
            * @param $buildTargetGroupName The platform name.
            * @param $index The index of the Quality Level, must be positive and lower than the count of Quality Levels.
            * @param $error The error raised by the API.
            * @returns True if no errors were found. 
            */
            public static TryExcludePlatformAt ($buildTargetGroupName: string, $index: number, $error: $Ref<System.Exception>) : boolean
            /** [Editor Only] Obtains an array with the Quality Level indexes that are selected for the given platform.
            * @param $buildTargetGroupName The platform target.
            * @returns The array with the Quality Level indexes that are selected for the given platform. 
            */
            public static GetActiveQualityLevelsForPlatform ($buildTargetGroupName: string) : System.Array$1<number>
            /** [Editor Only] Obtains the number of Quality Levels that are selected for a given platform.
            * @param $buildTargetGroupName The platform to obtain the number of selected Quality Levels.
            * @returns The total amount of Quality Levels active for the given platform. 
            */
            public static GetActiveQualityLevelsForPlatformCount ($buildTargetGroupName: string) : number
            public static GetAllRenderPipelineAssetsForPlatform ($buildTargetGroupName: string, $renderPipelineAssets: $Ref<System.Collections.Generic.List$1<UnityEngine.Rendering.RenderPipelineAsset>>) : void
        }
        enum QualityLevel
        { Fastest = 0, Fast = 1, Simple = 2, Good = 3, Beautiful = 4, Fantastic = 5 }
        /** Determines which type of shadows should be used.
        */
        enum ShadowQuality
        { Disable = 0, HardOnly = 1, All = 2 }
        /** Shadow projection type for.
        */
        enum ShadowProjection
        { CloseFit = 0, StableFit = 1 }
        /** Default shadow resolution. Each decrease in quality level halves the resolution of shadows.
        */
        enum ShadowResolution
        { Low = 0, Medium = 1, High = 2, VeryHigh = 3 }
        /** The rendering mode of Shadowmask.
        */
        enum ShadowmaskMode
        { Shadowmask = 0, DistanceShadowmask = 1 }
        /** Anisotropic filtering mode.
        */
        enum AnisotropicFiltering
        { Disable = 0, Enable = 1, ForceEnable = 2 }
        /** Structure that represents texture mipmap limit settings.
        */
        class TextureMipmapLimitSettings extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Indicates whether the limitBias functions as an offset to the global texture mipmap limit or, instead, acts as an override to it.
            */
            public get limitBiasMode(): UnityEngine.TextureMipmapLimitBiasMode;
            public set limitBiasMode(value: UnityEngine.TextureMipmapLimitBiasMode);
            /** The new value to apply on top of the global texture mipmap limit. Can act as an offset (default) or an override to it.
            */
            public get limitBias(): number;
            public set limitBias(value: number);
        }
        /** Flags used by QualitySettings to specify which Terrain fields the quality settings should override. 
        */
        enum TerrainQualityOverrides
        { None = 0, PixelError = 1, BasemapDistance = 2, DetailDensity = 4, DetailDistance = 8, TreeDistance = 16, BillboardStart = 32, FadeLength = 64, MaxTrees = 128 }
        /** A class you can derive from if you want to create objects that live independently of GameObjects.
        */
        class ScriptableObject extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** Creates an instance of a scriptable object.
            * @param $className The type of the ScriptableObject to create, as the name of the type.
            * @param $type The type of the ScriptableObject to create, as a System.Type instance.
            * @returns The created ScriptableObject. 
            */
            public static CreateInstance ($className: string) : UnityEngine.ScriptableObject
            /** Creates an instance of a scriptable object.
            * @param $className The type of the ScriptableObject to create, as the name of the type.
            * @param $type The type of the ScriptableObject to create, as a System.Type instance.
            * @returns The created ScriptableObject. 
            */
            public static CreateInstance ($type: System.Type) : UnityEngine.ScriptableObject
            public constructor ()
        }
        enum BlendWeights
        { OneBone = 1, TwoBones = 2, FourBones = 4 }
        /** Skin weights.
        */
        enum SkinWeights
        { None = 0, OneBone = 1, TwoBones = 2, FourBones = 4, Unlimited = 255 }
        /** Extension methods to the Renderer class, used only for the UpdateGIMaterials method used by the Global Illumination System.
        */
        class RendererExtensions extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Schedules an update of the albedo and emissive Textures of a system that contains the Renderer.
            */
            public static UpdateGIMaterials ($renderer: UnityEngine.Renderer) : void
        }
        /** When using HDR rendering it can sometime be desirable to switch to LDR rendering during ImageEffect rendering.
        */
        class ImageEffectTransformsToLDR extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Any Image Effect with this attribute can be rendered into the Scene view camera.
        */
        class ImageEffectAllowedInSceneView extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Any Image Effect with this attribute will be rendered after opaque geometry but before transparent geometry.
        */
        class ImageEffectOpaque extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Any Image Effect with this attribute will be rendered after Dynamic Resolution stage.
        */
        class ImageEffectAfterScale extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Use this attribute when image effects are implemented using Command Buffers.
        */
        class ImageEffectUsesCommandBuffer extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Describes a bone weight that affects a vertex in a mesh.
        */
        class BoneWeight1 extends System.ValueType implements System.IEquatable$1<UnityEngine.BoneWeight1>
        {
            protected [__keep_incompatibility]: never;
            /** Skinning weight for bone.
            */
            public get weight(): number;
            public set weight(value: number);
            /** Index of bone.
            */
            public get boneIndex(): number;
            public set boneIndex(value: number);
            public Equals ($other: any) : boolean
            public Equals ($other: UnityEngine.BoneWeight1) : boolean
            public static op_Equality ($lhs: UnityEngine.BoneWeight1, $rhs: UnityEngine.BoneWeight1) : boolean
            public static op_Inequality ($lhs: UnityEngine.BoneWeight1, $rhs: UnityEngine.BoneWeight1) : boolean
        }
        /** Describes the location of blend shape vertex data in a GraphicsBuffer.
        */
        class BlendShapeBufferRange extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The index of the first blend shape vertex for the requested blend shape.
            */
            public get startIndex(): number;
            /** The index of the last blend shape vertex for the requested blend shape.
            */
            public get endIndex(): number;
        }
        /** Describes 4 skinning bone weights that affect a vertex in a mesh.
        */
        class BoneWeight extends System.ValueType implements System.IEquatable$1<UnityEngine.BoneWeight>
        {
            protected [__keep_incompatibility]: never;
            /** Skinning weight for first bone.
            */
            public get weight0(): number;
            public set weight0(value: number);
            /** Skinning weight for second bone.
            */
            public get weight1(): number;
            public set weight1(value: number);
            /** Skinning weight for third bone.
            */
            public get weight2(): number;
            public set weight2(value: number);
            /** Skinning weight for fourth bone.
            */
            public get weight3(): number;
            public set weight3(value: number);
            /** Index of first bone.
            */
            public get boneIndex0(): number;
            public set boneIndex0(value: number);
            /** Index of second bone.
            */
            public get boneIndex1(): number;
            public set boneIndex1(value: number);
            /** Index of third bone.
            */
            public get boneIndex2(): number;
            public set boneIndex2(value: number);
            /** Index of fourth bone.
            */
            public get boneIndex3(): number;
            public set boneIndex3(value: number);
            public Equals ($other: any) : boolean
            public Equals ($other: UnityEngine.BoneWeight) : boolean
            public static op_Equality ($lhs: UnityEngine.BoneWeight, $rhs: UnityEngine.BoneWeight) : boolean
            public static op_Inequality ($lhs: UnityEngine.BoneWeight, $rhs: UnityEngine.BoneWeight) : boolean
        }
        /** Struct used to describe meshes to be combined using Mesh.CombineMeshes.
        */
        class CombineInstance extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Mesh to combine.
            */
            public get mesh(): UnityEngine.Mesh;
            public set mesh(value: UnityEngine.Mesh);
            /** Sub-Mesh index of the Mesh.
            */
            public get subMeshIndex(): number;
            public set subMeshIndex(value: number);
            /** Matrix to transform the Mesh with before combining. Refer to Mesh.CombineMeshes for an example.
            */
            public get transform(): UnityEngine.Matrix4x4;
            public set transform(value: UnityEngine.Matrix4x4);
            /** The baked lightmap UV scale and offset applied to the Mesh.
            */
            public get lightmapScaleOffset(): UnityEngine.Vector4;
            public set lightmapScaleOffset(value: UnityEngine.Vector4);
            /** The real-time lightmap UV scale and offset applied to the Mesh.
            */
            public get realtimeLightmapScaleOffset(): UnityEngine.Vector4;
            public set realtimeLightmapScaleOffset(value: UnityEngine.Vector4);
        }
        /** A script interface for a.
        */
        class Projector extends UnityEngine.Behaviour
        {
            protected [__keep_incompatibility]: never;
            /** The near clipping plane distance.
            */
            public get nearClipPlane(): number;
            public set nearClipPlane(value: number);
            /** The far clipping plane distance.
            */
            public get farClipPlane(): number;
            public set farClipPlane(value: number);
            /** The field of view of the projection in degrees.
            */
            public get fieldOfView(): number;
            public set fieldOfView(value: number);
            /** The aspect ratio of the projection.
            */
            public get aspectRatio(): number;
            public set aspectRatio(value: number);
            /** Is the projection orthographic (true) or perspective (false)?
            */
            public get orthographic(): boolean;
            public set orthographic(value: boolean);
            /** Projection's half-size when in orthographic mode.
            */
            public get orthographicSize(): number;
            public set orthographicSize(value: number);
            /** Which object layers are ignored by the projector.
            */
            public get ignoreLayers(): number;
            public set ignoreLayers(value: number);
            /** The material that will be projected onto every object.
            */
            public get material(): UnityEngine.Material;
            public set material(value: UnityEngine.Material);
            public constructor ()
        }
        enum TexGenMode
        { None = 0, SphereMap = 1, Object = 2, EyeLinear = 3, CubeReflect = 4, CubeNormal = 5 }
        /** The trail renderer is used to make trails behind objects in the Scene as they move about.
        */
        class TrailRenderer extends UnityEngine.Renderer
        {
            protected [__keep_incompatibility]: never;
            /** How long does the trail take to fade out.
            */
            public get time(): number;
            public set time(value: number);
            /** The width of the trail at the spawning point.
            */
            public get startWidth(): number;
            public set startWidth(value: number);
            /** The width of the trail at the end of the trail.
            */
            public get endWidth(): number;
            public set endWidth(value: number);
            /** Set an overall multiplier that is applied to the TrailRenderer.widthCurve to get the final width of the trail.
            */
            public get widthMultiplier(): number;
            public set widthMultiplier(value: number);
            /** Does the GameObject of this Trail Renderer auto destruct?
            */
            public get autodestruct(): boolean;
            public set autodestruct(value: boolean);
            /** Creates trails when the GameObject moves.
            */
            public get emitting(): boolean;
            public set emitting(value: boolean);
            /** Set this to a value greater than 0, to get rounded corners between each segment of the trail.
            */
            public get numCornerVertices(): number;
            public set numCornerVertices(value: number);
            /** Set this to a value greater than 0, to get rounded corners on each end of the trail.
            */
            public get numCapVertices(): number;
            public set numCapVertices(value: number);
            /** Set the minimum distance the trail can travel before a new vertex is added to it.
            */
            public get minVertexDistance(): number;
            public set minVertexDistance(value: number);
            /** Set the color at the start of the trail.
            */
            public get startColor(): UnityEngine.Color;
            public set startColor(value: UnityEngine.Color);
            /** Set the color at the end of the trail.
            */
            public get endColor(): UnityEngine.Color;
            public set endColor(value: UnityEngine.Color);
            /** Get the number of line segments in the trail.
            */
            public get positionCount(): number;
            /** A multiplier for the UV coordinates of the trail texture.
            */
            public get textureScale(): UnityEngine.Vector2;
            public set textureScale(value: UnityEngine.Vector2);
            /** Apply a shadow bias to prevent self-shadowing artifacts. The specified value is the proportion of the trail width at each segment.
            */
            public get shadowBias(): number;
            public set shadowBias(value: number);
            /** Configures a trail to generate Normals and Tangents. With this data, Scene lighting can affect the trail via Normal Maps and the Unity Standard Shader, or your own custom-built Shaders.
            */
            public get generateLightingData(): boolean;
            public set generateLightingData(value: boolean);
            /** Choose whether the U coordinate of the trail texture is tiled or stretched.
            */
            public get textureMode(): UnityEngine.LineTextureMode;
            public set textureMode(value: UnityEngine.LineTextureMode);
            /** Select whether the trail will face the camera, or the orientation of the Transform Component.
            */
            public get alignment(): UnityEngine.LineAlignment;
            public set alignment(value: UnityEngine.LineAlignment);
            /** Specifies how the TrailRenderer interacts with SpriteMask.
            */
            public get maskInteraction(): UnityEngine.SpriteMaskInteraction;
            public set maskInteraction(value: UnityEngine.SpriteMaskInteraction);
            /** Set the curve describing the width of the trail at various points along its length.
            */
            public get widthCurve(): UnityEngine.AnimationCurve;
            public set widthCurve(value: UnityEngine.AnimationCurve);
            /** Set the color gradient describing the color of the trail at various points along its length.
            */
            public get colorGradient(): UnityEngine.Gradient;
            public set colorGradient(value: UnityEngine.Gradient);
            /** Set the position of a vertex in the trail.
            * @param $index Which position to set.
            * @param $position The new position.
            */
            public SetPosition ($index: number, $position: UnityEngine.Vector3) : void
            /** Get the position of a vertex in the trail.
            * @param $index The index of the position to retrieve.
            * @returns The position at the specified index in the array. 
            */
            public GetPosition ($index: number) : UnityEngine.Vector3
            /** Removes all points from the TrailRenderer.
            Useful for restarting a trail from a new position.
            */
            public Clear () : void
            /** Creates a snapshot of TrailRenderer and stores it in mesh.
            * @param $mesh A static mesh that will receive the snapshot of the trail.
            * @param $camera The camera used for determining which way camera-space trails will face.
            * @param $useTransform Include the rotation and scale of the Transform in the baked mesh.
            */
            public BakeMesh ($mesh: UnityEngine.Mesh, $useTransform?: boolean) : void
            /** Creates a snapshot of TrailRenderer and stores it in mesh.
            * @param $mesh A static mesh that will receive the snapshot of the trail.
            * @param $camera The camera used for determining which way camera-space trails will face.
            * @param $useTransform Include the rotation and scale of the Transform in the baked mesh.
            */
            public BakeMesh ($mesh: UnityEngine.Mesh, $camera: UnityEngine.Camera, $useTransform?: boolean) : void
            /** Get the positions of all vertices in the trail.
            * @param $positions The array of positions to retrieve.
            * @returns How many positions were actually stored in the output array. 
            */
            public GetPositions ($positions: System.Array$1<UnityEngine.Vector3>) : number
            /** Get the visible positions of all vertices in the trail.
            * @param $positions The array of positions to retrieve.
            * @returns How many positions were actually stored in the output array. 
            */
            public GetVisiblePositions ($positions: System.Array$1<UnityEngine.Vector3>) : number
            /** Sets the positions of all vertices in the trail.
            * @param $positions The array of positions to set.
            */
            public SetPositions ($positions: System.Array$1<UnityEngine.Vector3>) : void
            /** Adds a position to the trail.
            * @param $position The position to add to the trail.
            */
            public AddPosition ($position: UnityEngine.Vector3) : void
            /** Add an array of positions to the trail.
            * @param $positions The positions to add to the trail.
            */
            public AddPositions ($positions: System.Array$1<UnityEngine.Vector3>) : void
            public SetPositions ($positions: Unity.Collections.NativeArray$1<UnityEngine.Vector3>) : void
            public SetPositions ($positions: Unity.Collections.NativeSlice$1<UnityEngine.Vector3>) : void
            public GetPositions ($positions: Unity.Collections.NativeArray$1<UnityEngine.Vector3>) : number
            public GetPositions ($positions: Unity.Collections.NativeSlice$1<UnityEngine.Vector3>) : number
            public GetVisiblePositions ($positions: Unity.Collections.NativeArray$1<UnityEngine.Vector3>) : number
            public GetVisiblePositions ($positions: Unity.Collections.NativeSlice$1<UnityEngine.Vector3>) : number
            public AddPositions ($positions: Unity.Collections.NativeArray$1<UnityEngine.Vector3>) : void
            public AddPositions ($positions: Unity.Collections.NativeSlice$1<UnityEngine.Vector3>) : void
            public constructor ()
        }
        /** Choose how textures are applied to Lines and Trails.
        */
        enum LineTextureMode
        { Stretch = 0, Tile = 1, DistributePerSegment = 2, RepeatPerSegment = 3, Static = 4 }
        /** Control the direction lines face, when using the LineRenderer or TrailRenderer.
        */
        enum LineAlignment
        { View = 0, Local = 1, TransformZ = 1 }
        /** This enum controls the mode under which the sprite will interact with the masking system.
        */
        enum SpriteMaskInteraction
        { None = 0, VisibleInsideMask = 1, VisibleOutsideMask = 2 }
        /** Represents a Gradient used for animating colors.
        */
        class Gradient extends System.Object implements System.IEquatable$1<UnityEngine.Gradient>
        {
            protected [__keep_incompatibility]: never;
            /** All color keys defined in the gradient.
            */
            public get colorKeys(): System.Array$1<UnityEngine.GradientColorKey>;
            public set colorKeys(value: System.Array$1<UnityEngine.GradientColorKey>);
            /** All alpha keys defined in the gradient.
            */
            public get alphaKeys(): System.Array$1<UnityEngine.GradientAlphaKey>;
            public set alphaKeys(value: System.Array$1<UnityEngine.GradientAlphaKey>);
            /** Controls how the gradient colors are interpolated.
            */
            public get mode(): UnityEngine.GradientMode;
            public set mode(value: UnityEngine.GradientMode);
            /** Indicates the color space that the gradient color keys are using.
            */
            public get colorSpace(): UnityEngine.ColorSpace;
            public set colorSpace(value: UnityEngine.ColorSpace);
            /** Calculate color at a given time.
            * @param $time Time of the evaluation (0 - 1).
            */
            public Evaluate ($time: number) : UnityEngine.Color
            /** Setup Gradient with an array of color keys and alpha keys.
            * @param $colorKeys Color keys of the gradient (maximum 8 color keys).
            * @param $alphaKeys Alpha keys of the gradient (maximum 8 alpha keys).
            */
            public SetKeys ($colorKeys: System.Array$1<UnityEngine.GradientColorKey>, $alphaKeys: System.Array$1<UnityEngine.GradientAlphaKey>) : void
            public Equals ($o: any) : boolean
            public Equals ($other: UnityEngine.Gradient) : boolean
            public constructor ()
        }
        /** The line renderer is used to draw free-floating lines in 3D space.
        */
        class LineRenderer extends UnityEngine.Renderer
        {
            protected [__keep_incompatibility]: never;
            /** Set the width at the start of the line.
            */
            public get startWidth(): number;
            public set startWidth(value: number);
            /** Set the width at the end of the line.
            */
            public get endWidth(): number;
            public set endWidth(value: number);
            /** Set an overall multiplier that is applied to the LineRenderer.widthCurve to get the final width of the line.
            */
            public get widthMultiplier(): number;
            public set widthMultiplier(value: number);
            /** Set this to a value greater than 0, to get rounded corners between each segment of the line.
            */
            public get numCornerVertices(): number;
            public set numCornerVertices(value: number);
            /** Set this to a value greater than 0, to get rounded corners on each end of the line. The default is 0.
            */
            public get numCapVertices(): number;
            public set numCapVertices(value: number);
            /** If enabled, the lines are defined in world space.
            */
            public get useWorldSpace(): boolean;
            public set useWorldSpace(value: boolean);
            /** Connect the start and end positions of the line together to form a continuous loop.
            */
            public get loop(): boolean;
            public set loop(value: boolean);
            /** Set the color at the start of the line.
            */
            public get startColor(): UnityEngine.Color;
            public set startColor(value: UnityEngine.Color);
            /** Set the color at the end of the line.
            */
            public get endColor(): UnityEngine.Color;
            public set endColor(value: UnityEngine.Color);
            /** Set/get the number of vertices.
            */
            public get positionCount(): number;
            public set positionCount(value: number);
            /** A multiplier for the UV coordinates of the line texture.
            */
            public get textureScale(): UnityEngine.Vector2;
            public set textureScale(value: UnityEngine.Vector2);
            /** Apply a shadow bias to prevent self-shadowing artifacts. The specified value is the proportion of the line width at each segment.
            */
            public get shadowBias(): number;
            public set shadowBias(value: number);
            /** Configures a line to generate Normals and Tangents. With this data, Scene lighting can affect the line via Normal Maps and the Unity Standard Shader, or your own custom-built Shaders.
            */
            public get generateLightingData(): boolean;
            public set generateLightingData(value: boolean);
            /** Choose whether the U coordinate of the line texture is tiled or stretched.
            */
            public get textureMode(): UnityEngine.LineTextureMode;
            public set textureMode(value: UnityEngine.LineTextureMode);
            /** Select whether the line will face the camera, or the orientation of the Transform Component.
            */
            public get alignment(): UnityEngine.LineAlignment;
            public set alignment(value: UnityEngine.LineAlignment);
            /** Specifies how the LineRenderer interacts with SpriteMask.
            */
            public get maskInteraction(): UnityEngine.SpriteMaskInteraction;
            public set maskInteraction(value: UnityEngine.SpriteMaskInteraction);
            /** Set the curve describing the width of the line at various points along its length.
            */
            public get widthCurve(): UnityEngine.AnimationCurve;
            public set widthCurve(value: UnityEngine.AnimationCurve);
            /** Set the color gradient describing the color of the line at various points along its length.
            */
            public get colorGradient(): UnityEngine.Gradient;
            public set colorGradient(value: UnityEngine.Gradient);
            /** Set the position of a vertex in the line.
            * @param $index Which position to set.
            * @param $position The new position.
            */
            public SetPosition ($index: number, $position: UnityEngine.Vector3) : void
            /** Get the position of a vertex in the line.
            * @param $index The index of the position to retrieve.
            * @returns The position at the specified index in the array. 
            */
            public GetPosition ($index: number) : UnityEngine.Vector3
            /** Generates a simplified version of the original line by removing points that fall within the specified tolerance.
            * @param $tolerance This value is used to evaluate which points should be removed from the line. A higher value results in a simpler line (less points). A positive value close to zero results in a line with little to no reduction. A value of zero or less has no effect.
            */
            public Simplify ($tolerance: number) : void
            /** Creates a snapshot of LineRenderer and stores it in mesh.
            * @param $mesh A static mesh that will receive the snapshot of the line.
            * @param $camera The camera used for determining which way camera-space lines will face.
            * @param $useTransform Include the rotation and scale of the Transform in the baked mesh.
            */
            public BakeMesh ($mesh: UnityEngine.Mesh, $useTransform?: boolean) : void
            /** Creates a snapshot of LineRenderer and stores it in mesh.
            * @param $mesh A static mesh that will receive the snapshot of the line.
            * @param $camera The camera used for determining which way camera-space lines will face.
            * @param $useTransform Include the rotation and scale of the Transform in the baked mesh.
            */
            public BakeMesh ($mesh: UnityEngine.Mesh, $camera: UnityEngine.Camera, $useTransform?: boolean) : void
            /** Get the positions of all vertices in the line.
            * @param $positions The array of positions to retrieve. The array passed should be of at least positionCount in size.
            * @returns How many positions were actually stored in the output array. 
            */
            public GetPositions ($positions: System.Array$1<UnityEngine.Vector3>) : number
            /** Set the positions of all vertices in the line.
            * @param $positions The array of positions to set.
            */
            public SetPositions ($positions: System.Array$1<UnityEngine.Vector3>) : void
            public SetPositions ($positions: Unity.Collections.NativeArray$1<UnityEngine.Vector3>) : void
            public SetPositions ($positions: Unity.Collections.NativeSlice$1<UnityEngine.Vector3>) : void
            public GetPositions ($positions: Unity.Collections.NativeArray$1<UnityEngine.Vector3>) : number
            public GetPositions ($positions: Unity.Collections.NativeSlice$1<UnityEngine.Vector3>) : number
            public constructor ()
        }
        /** The Render Settings contain values for a range of visual elements in your Scene, like fog and ambient light.
        */
        class RenderSettings extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** Is fog enabled?
            */
            public static get fog(): boolean;
            public static set fog(value: boolean);
            /** The starting distance of linear fog.
            */
            public static get fogStartDistance(): number;
            public static set fogStartDistance(value: number);
            /** The ending distance of linear fog.
            */
            public static get fogEndDistance(): number;
            public static set fogEndDistance(value: number);
            /** Fog mode to use.
            */
            public static get fogMode(): UnityEngine.FogMode;
            public static set fogMode(value: UnityEngine.FogMode);
            /** The color of the fog.
            */
            public static get fogColor(): UnityEngine.Color;
            public static set fogColor(value: UnityEngine.Color);
            /** The density of the exponential fog.
            */
            public static get fogDensity(): number;
            public static set fogDensity(value: number);
            /** Ambient lighting mode.
            */
            public static get ambientMode(): UnityEngine.Rendering.AmbientMode;
            public static set ambientMode(value: UnityEngine.Rendering.AmbientMode);
            /** Ambient lighting coming from above.
            */
            public static get ambientSkyColor(): UnityEngine.Color;
            public static set ambientSkyColor(value: UnityEngine.Color);
            /** Ambient lighting coming from the sides.
            */
            public static get ambientEquatorColor(): UnityEngine.Color;
            public static set ambientEquatorColor(value: UnityEngine.Color);
            /** Ambient lighting coming from below.
            */
            public static get ambientGroundColor(): UnityEngine.Color;
            public static set ambientGroundColor(value: UnityEngine.Color);
            /** How much the light from the Ambient Source affects the Scene.
            */
            public static get ambientIntensity(): number;
            public static set ambientIntensity(value: number);
            /** Flat ambient lighting color.
            */
            public static get ambientLight(): UnityEngine.Color;
            public static set ambientLight(value: UnityEngine.Color);
            /** The color used for the sun shadows in the Subtractive lightmode.
            */
            public static get subtractiveShadowColor(): UnityEngine.Color;
            public static set subtractiveShadowColor(value: UnityEngine.Color);
            /** The global skybox to use.
            */
            public static get skybox(): UnityEngine.Material;
            public static set skybox(value: UnityEngine.Material);
            /** The light used by the procedural skybox.
            */
            public static get sun(): UnityEngine.Light;
            public static set sun(value: UnityEngine.Light);
            /** An ambient probe that captures environment lighting.
            */
            public static get ambientProbe(): UnityEngine.Rendering.SphericalHarmonicsL2;
            public static set ambientProbe(value: UnityEngine.Rendering.SphericalHarmonicsL2);
            public static get customReflectionTexture(): UnityEngine.Texture;
            public static set customReflectionTexture(value: UnityEngine.Texture);
            /** How much the skybox / custom cubemap reflection affects the Scene.
            */
            public static get reflectionIntensity(): number;
            public static set reflectionIntensity(value: number);
            /** The number of times a reflection includes other reflections.
            */
            public static get reflectionBounces(): number;
            public static set reflectionBounces(value: number);
            /** Default reflection mode.
            */
            public static get defaultReflectionMode(): UnityEngine.Rendering.DefaultReflectionMode;
            public static set defaultReflectionMode(value: UnityEngine.Rendering.DefaultReflectionMode);
            /** Cubemap resolution for default reflection.
            */
            public static get defaultReflectionResolution(): number;
            public static set defaultReflectionResolution(value: number);
            /** Size of the Light halos.
            */
            public static get haloStrength(): number;
            public static set haloStrength(value: number);
            /** The intensity of all flares in the Scene.
            */
            public static get flareStrength(): number;
            public static set flareStrength(value: number);
            /** The fade speed of all flares in the Scene.
            */
            public static get flareFadeSpeed(): number;
            public static set flareFadeSpeed(value: number);
        }
        /** Fog mode to use.
        */
        enum FogMode
        { Linear = 1, Exponential = 2, ExponentialSquared = 3 }
        /** Script interface for.
        */
        class Light extends UnityEngine.Behaviour
        {
            protected [__keep_incompatibility]: never;
            /** The type of the light.
            */
            public get type(): UnityEngine.LightType;
            public set type(value: UnityEngine.LightType);
            /** The angle of the spot light's cone in degrees.
            */
            public get spotAngle(): number;
            public set spotAngle(value: number);
            /** The angle of the spot light's inner cone in degrees.
            */
            public get innerSpotAngle(): number;
            public set innerSpotAngle(value: number);
            /** The color of the light.
            */
            public get color(): UnityEngine.Color;
            public set color(value: UnityEngine.Color);
            /** 
            The color temperature of the light.
            Correlated Color Temperature (abbreviated as CCT) is multiplied with the color filter when calculating the final color of a light source. The color temperature of the electromagnetic radiation emitted from an ideal black body is defined as its surface temperature in Kelvin. White is 6500K according to the D65 standard. A candle light is 1800K and a soft warm light bulb is 2700K.
            If you want to use colorTemperature, GraphicsSettings.lightsUseLinearIntensity and Light.useColorTemperature has to be enabled.
            Additional resources: GraphicsSettings.lightsUseLinearIntensity, GraphicsSettings.useColorTemperature.
            */
            public get colorTemperature(): number;
            public set colorTemperature(value: number);
            /** Set to true to use the color temperature.
            */
            public get useColorTemperature(): boolean;
            public set useColorTemperature(value: boolean);
            /** The Intensity of a light is multiplied with the Light color.
            */
            public get intensity(): number;
            public set intensity(value: number);
            /** The multiplier that defines the strength of the bounce lighting.
            */
            public get bounceIntensity(): number;
            public set bounceIntensity(value: number);
            /** Set to true to override light bounding sphere for culling.
            */
            public get useBoundingSphereOverride(): boolean;
            public set useBoundingSphereOverride(value: boolean);
            /** Bounding sphere used to override the regular light bounding sphere during culling.
            */
            public get boundingSphereOverride(): UnityEngine.Vector4;
            public set boundingSphereOverride(value: UnityEngine.Vector4);
            /** Whether to cull shadows for this Light when the Light is outside of the view frustum.
            */
            public get useViewFrustumForShadowCasterCull(): boolean;
            public set useViewFrustumForShadowCasterCull(value: boolean);
            /** The custom resolution of the shadow map.
            */
            public get shadowCustomResolution(): number;
            public set shadowCustomResolution(value: number);
            /** Shadow mapping constant bias.
            */
            public get shadowBias(): number;
            public set shadowBias(value: number);
            /** Shadow mapping normal-based bias.
            */
            public get shadowNormalBias(): number;
            public set shadowNormalBias(value: number);
            /** Near plane value to use for shadow frustums.
            */
            public get shadowNearPlane(): number;
            public set shadowNearPlane(value: number);
            /** Set to true to enable custom matrix for culling during shadows.
            */
            public get useShadowMatrixOverride(): boolean;
            public set useShadowMatrixOverride(value: boolean);
            /** Matrix that overrides the regular light projection matrix during shadow culling. Unity uses this matrix if you set Light.useShadowMatrixOverride to true.
            */
            public get shadowMatrixOverride(): UnityEngine.Matrix4x4;
            public set shadowMatrixOverride(value: UnityEngine.Matrix4x4);
            /** 
            The range of each point of the light.
            Since area lights have a light emitting surface instead of a single point, the cumulative range of the light is larger than this property. This larger range can be read from the Light.dilatedRange property. For non-area lights, Light.range and Light.dilatedRange return the same value.
            */
            public get range(): number;
            public set range(value: number);
            /** 
            The Light.range property describes the range of each point on the light. However, area lights consist of several light-emitting points, and so the effective range is a bit larger, and depends on the size of the area light. This property returns this larger range. Use this property to find whether a given world-space point will be lit by the area light.
            If not an area light, then returns the same value as Light.range.
            */
            public get dilatedRange(): number;
            /** The to use for this light.
            */
            public get flare(): UnityEngine.Flare;
            public set flare(value: UnityEngine.Flare);
            /** This property describes the output of the last Global Illumination bake.
            */
            public get bakingOutput(): UnityEngine.LightBakingOutput;
            public set bakingOutput(value: UnityEngine.LightBakingOutput);
            /** This is used to light certain objects in the Scene selectively.
            */
            public get cullingMask(): number;
            public set cullingMask(value: number);
            /** Determines which rendering LayerMask this Light affects.
            */
            public get renderingLayerMask(): number;
            public set renderingLayerMask(value: number);
            /** Allows you to override the global Shadowmask Mode per light. Only use this with render pipelines that can handle per light Shadowmask modes. Incompatible with the legacy renderers.
            */
            public get lightShadowCasterMode(): UnityEngine.LightShadowCasterMode;
            public set lightShadowCasterMode(value: UnityEngine.LightShadowCasterMode);
            /** Controls the amount of artificial softening applied to the edges of shadows cast by the Point or Spot light (Editor only).
            */
            public get shadowRadius(): number;
            public set shadowRadius(value: number);
            /** Controls the amount of artificial softening applied to the edges of shadows cast by directional lights (Editor only).
            */
            public get shadowAngle(): number;
            public set shadowAngle(value: number);
            /** How this light casts shadows
            */
            public get shadows(): UnityEngine.LightShadows;
            public set shadows(value: UnityEngine.LightShadows);
            /** Strength of light's shadows.
            */
            public get shadowStrength(): number;
            public set shadowStrength(value: number);
            /** The resolution of the shadow map.
            */
            public get shadowResolution(): UnityEngine.Rendering.LightShadowResolution;
            public set shadowResolution(value: UnityEngine.Rendering.LightShadowResolution);
            /** Per-light, per-layer shadow culling distances. Directional lights only. 
            */
            public get layerShadowCullDistances(): System.Array$1<number>;
            public set layerShadowCullDistances(value: System.Array$1<number>);
            /** The size of a directional light's cookie.
            */
            public get cookieSize(): number;
            public set cookieSize(value: number);
            /** The cookie texture projected by the light.
            */
            public get cookie(): UnityEngine.Texture;
            public set cookie(value: UnityEngine.Texture);
            /** How to render the light.
            */
            public get renderMode(): UnityEngine.LightRenderMode;
            public set renderMode(value: UnityEngine.LightRenderMode);
            /** The size of the area light (Editor only).
            */
            public get areaSize(): UnityEngine.Vector2;
            public set areaSize(value: UnityEngine.Vector2);
            /** This property describes what part of a light's contribution can be baked (Editor only).
            */
            public get lightmapBakeType(): UnityEngine.LightmapBakeType;
            public set lightmapBakeType(value: UnityEngine.LightmapBakeType);
            /** Number of command buffers set up on this light (Read Only).
            */
            public get commandBufferCount(): number;
            /** Revert all light parameters to default.
            */
            public Reset () : void
            /** Sets a light dirty to notify the light baking backends to update their internal light representation (Editor only).
            */
            public SetLightDirty () : void
            /** Add a command buffer to be executed at a specified place.
            * @param $evt When to execute the command buffer during rendering.
            * @param $buffer The buffer to execute.
            * @param $shadowPassMask A mask specifying which shadow passes to execute the buffer for.
            */
            public AddCommandBuffer ($evt: UnityEngine.Rendering.LightEvent, $buffer: UnityEngine.Rendering.CommandBuffer) : void
            /** Add a command buffer to be executed at a specified place.
            * @param $evt When to execute the command buffer during rendering.
            * @param $buffer The buffer to execute.
            * @param $shadowPassMask A mask specifying which shadow passes to execute the buffer for.
            */
            public AddCommandBuffer ($evt: UnityEngine.Rendering.LightEvent, $buffer: UnityEngine.Rendering.CommandBuffer, $shadowPassMask: UnityEngine.Rendering.ShadowMapPass) : void
            /** Adds a command buffer to the GPU's async compute queues and executes that command buffer when graphics processing reaches a given point.
            * @param $evt The point during the graphics processing at which this command buffer should commence on the GPU.
            * @param $buffer The buffer to execute.
            * @param $queueType The desired async compute queue type to execute the buffer on.
            * @param $shadowPassMask A mask specifying which shadow passes to execute the buffer for.
            */
            public AddCommandBufferAsync ($evt: UnityEngine.Rendering.LightEvent, $buffer: UnityEngine.Rendering.CommandBuffer, $queueType: UnityEngine.Rendering.ComputeQueueType) : void
            /** Adds a command buffer to the GPU's async compute queues and executes that command buffer when graphics processing reaches a given point.
            * @param $evt The point during the graphics processing at which this command buffer should commence on the GPU.
            * @param $buffer The buffer to execute.
            * @param $queueType The desired async compute queue type to execute the buffer on.
            * @param $shadowPassMask A mask specifying which shadow passes to execute the buffer for.
            */
            public AddCommandBufferAsync ($evt: UnityEngine.Rendering.LightEvent, $buffer: UnityEngine.Rendering.CommandBuffer, $shadowPassMask: UnityEngine.Rendering.ShadowMapPass, $queueType: UnityEngine.Rendering.ComputeQueueType) : void
            /** Remove command buffer from execution at a specified place.
            * @param $evt When to execute the command buffer during rendering.
            * @param $buffer The buffer to execute.
            */
            public RemoveCommandBuffer ($evt: UnityEngine.Rendering.LightEvent, $buffer: UnityEngine.Rendering.CommandBuffer) : void
            /** Remove command buffers from execution at a specified place.
            * @param $evt When to execute the command buffer during rendering.
            */
            public RemoveCommandBuffers ($evt: UnityEngine.Rendering.LightEvent) : void
            /** Remove all command buffers set on this light.
            */
            public RemoveAllCommandBuffers () : void
            /** Get command buffers to be executed at a specified place.
            * @param $evt When to execute the command buffer during rendering.
            * @returns Array of command buffers. 
            */
            public GetCommandBuffers ($evt: UnityEngine.Rendering.LightEvent) : System.Array$1<UnityEngine.Rendering.CommandBuffer>
            public constructor ()
        }
        /** How the material interacts with lightmaps and lightprobes.
        */
        enum MaterialGlobalIlluminationFlags
        { None = 0, RealtimeEmissive = 1, BakedEmissive = 2, EmissiveIsBlack = 4, AnyEmissive = 3 }
        /** Represents the internal handle/id of a GraphicsBuffer.
        */
        class GraphicsBufferHandle extends System.ValueType implements System.IEquatable$1<UnityEngine.GraphicsBufferHandle>
        {
            protected [__keep_incompatibility]: never;
            public value : number
            public Equals ($obj: any) : boolean
            public Equals ($other: UnityEngine.GraphicsBufferHandle) : boolean
            public CompareTo ($other: UnityEngine.GraphicsBufferHandle) : number
            public static op_Equality ($a: UnityEngine.GraphicsBufferHandle, $b: UnityEngine.GraphicsBufferHandle) : boolean
            public static op_Inequality ($a: UnityEngine.GraphicsBufferHandle, $b: UnityEngine.GraphicsBufferHandle) : boolean
        }
        /** The type of a given material property.
        */
        enum MaterialPropertyType
        { Float = 0, Int = 1, Vector = 2, Matrix = 3, Texture = 4, ConstantBuffer = 5, ComputeBuffer = 6 }
        /** The portal for dynamically changing occlusion at runtime.
        */
        class OcclusionPortal extends UnityEngine.Component
        {
            protected [__keep_incompatibility]: never;
            /** Gets / sets the portal's open state.
            */
            public get open(): boolean;
            public set open(value: boolean);
            public constructor ()
        }
        /** OcclusionArea is an area in which occlusion culling is performed.
        */
        class OcclusionArea extends UnityEngine.Component
        {
            protected [__keep_incompatibility]: never;
            /** Center of the occlusion area relative to the transform.
            */
            public get center(): UnityEngine.Vector3;
            public set center(value: UnityEngine.Vector3);
            /** Size that the occlusion area will have.
            */
            public get size(): UnityEngine.Vector3;
            public set size(value: UnityEngine.Vector3);
            public constructor ()
        }
        /** A flare asset. Read more about flares in the.
        */
        class Flare extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Script interface for a.
        */
        class LensFlare extends UnityEngine.Behaviour
        {
            protected [__keep_incompatibility]: never;
            /** The strength of the flare.
            */
            public get brightness(): number;
            public set brightness(value: number);
            /** The fade speed of the flare.
            */
            public get fadeSpeed(): number;
            public set fadeSpeed(value: number);
            /** The color of the flare.
            */
            public get color(): UnityEngine.Color;
            public set color(value: UnityEngine.Color);
            /** The to use.
            */
            public get flare(): UnityEngine.Flare;
            public set flare(value: UnityEngine.Flare);
            public constructor ()
        }
        /** Struct describing the result of a Global Illumination bake for a given light.
        */
        class LightBakingOutput extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** In case of a LightmapBakeType.Mixed light, contains the index of the light as seen from the occlusion probes point of view if any, otherwise -1.
            */
            public probeOcclusionLightIndex : number
            /** In case of a LightmapBakeType.Mixed light, contains the index of the occlusion mask channel to use if any, otherwise -1.
            */
            public occlusionMaskChannel : number
            /** This property describes what part of a light's contribution was baked.
            */
            public lightmapBakeType : UnityEngine.LightmapBakeType
            /** In case of a LightmapBakeType.Mixed light, describes what Mixed mode was used to bake the light, irrelevant otherwise.
            */
            public mixedLightingMode : UnityEngine.MixedLightingMode
            /** Is the light contribution already stored in lightmaps and/or lightprobes?
            */
            public isBaked : boolean
        }
        /** Enum describing what part of a light contribution can be baked.
        */
        enum LightmapBakeType
        { Realtime = 4, Baked = 2, Mixed = 1 }
        /** Allows mixed lights to control shadow caster culling when Shadowmasks are present.
        */
        enum LightShadowCasterMode
        { Default = 0, NonLightmappedOnly = 1, Everything = 2 }
        /** The type of a Light.
        */
        enum LightType
        { Spot = 0, Directional = 1, Point = 2, Area = 3, Rectangle = 3, Disc = 4, Pyramid = 5, Box = 6, Tube = 7 }
        /** Describes the shape of a spot light.
        */
        enum LightShape
        { Cone = 0, Pyramid = 1, Box = 2 }
        /** Shadow casting options for a Light.
        */
        enum LightShadows
        { None = 0, Hard = 1, Soft = 2 }
        /** How the Light is rendered.
        */
        enum LightRenderMode
        { Auto = 0, ForcePixel = 1, ForceVertex = 2 }
        enum LightmappingMode
        { Realtime = 4, Baked = 2, Mixed = 1 }
        /** A script interface for the.
        */
        class Skybox extends UnityEngine.Behaviour
        {
            protected [__keep_incompatibility]: never;
            /** The material used by the skybox.
            */
            public get material(): UnityEngine.Material;
            public set material(value: UnityEngine.Material);
            public constructor ()
        }
        /** A class to access the Mesh of the.
        */
        class MeshFilter extends UnityEngine.Component
        {
            protected [__keep_incompatibility]: never;
            /** Returns the shared mesh of the mesh filter.
            */
            public get sharedMesh(): UnityEngine.Mesh;
            public set sharedMesh(value: UnityEngine.Mesh);
            /** Returns either a new Mesh|mesh or a duplicate of the existing mesh, and assigns it to the mesh filter.
            */
            public get mesh(): UnityEngine.Mesh;
            public set mesh(value: UnityEngine.Mesh);
            public constructor ()
        }
        /** ComputeBuffer type.
        */
        enum ComputeBufferType
        { Default = 0, Raw = 1, Append = 2, Counter = 4, Constant = 8, Structured = 16, DrawIndirect = 256, IndirectArguments = 256, GPUMemory = 512 }
        /** This property only takes effect if you enable a global illumination setting such as for the GameObject associated with the target Mesh Renderer. Otherwise this property defaults to the Light Probes setting.
        */
        enum ReceiveGI
        { Lightmaps = 1, LightProbes = 2 }
        /** The filters that Unity can use when it renders GameObjects in the shadow pass.
        */
        enum ShadowObjectsFilter
        { AllObjects = 0, DynamicOnly = 1, StaticOnly = 2 }
        /** The maximum number of bones affecting a single vertex.
        */
        enum SkinQuality
        { Auto = 0, Bone1 = 1, Bone2 = 2, Bone4 = 4 }
        /** Filtering mode for textures. Corresponds to the settings in a.
        */
        enum FilterMode
        { Point = 0, Bilinear = 1, Trilinear = 2 }
        /** Wrap mode for textures.
        */
        enum TextureWrapMode
        { Repeat = 0, Clamp = 1, Mirror = 2, MirrorOnce = 3 }
        /** NPOT Texture2D|textures support.
        */
        enum NPOTSupport
        { None = 0, Restricted = 1, Full = 2 }
        /** This enum describes how the RenderTexture is used as a VR eye texture. Instead of using the values of this enum manually, use the value returned by XR.XRSettings.eyeTextureDesc|eyeTextureDesc or other VR functions returning a RenderTextureDescriptor.
        */
        enum VRTextureUsage
        { None = 0, OneEye = 1, TwoEyes = 2, DeviceSpecific = 3 }
        /** Set of flags that control the state of a newly-created RenderTexture.
        */
        enum RenderTextureCreationFlags
        { MipMap = 1, AutoGenerateMips = 2, SRGB = 4, EyeTexture = 8, EnableRandomWrite = 16, CreatedFromScript = 32, AllowVerticalFlip = 128, NoResolvedColorSurface = 256, DynamicallyScalable = 1024, BindMS = 2048, DynamicallyScalableExplicit = 65536 }
        /** Color space conversion mode of a RenderTexture.
        */
        enum RenderTextureReadWrite
        { Default = 0, Linear = 1, sRGB = 2 }
        /** Flags enumeration of the render texture memoryless modes.
        */
        enum RenderTextureMemoryless
        { None = 0, Color = 1, Depth = 2, MSAA = 4 }
        /** A set of flags that describe the level of HDR display support available on the system.
        */
        enum HDRDisplaySupportFlags
        { None = 0, Supported = 1, RuntimeSwitchable = 2, AutomaticTonemapping = 4 }
        /** Options for the number of bits for HDR output in each color channel of swap chain buffers. Applicable when an HDR display is active.
        */
        enum HDRDisplayBitDepth
        { BitDepth10 = 0, BitDepth16 = 1 }
        /** Specify the source of a Custom Render Texture initialization.
        */
        enum CustomRenderTextureInitializationSource
        { TextureAndColor = 0, Material = 1 }
        /** Frequency of update or initialization of a Custom Render Texture.
        */
        enum CustomRenderTextureUpdateMode
        { OnLoad = 0, Realtime = 1, OnDemand = 2 }
        /** Space in which coordinates are provided for Update Zones.
        */
        enum CustomRenderTextureUpdateZoneSpace
        { Normalized = 0, Pixel = 1 }
        /** An enumeration that represents the bias mode to use for TextureMipmapLimitSettings.limitBias.
        */
        enum TextureMipmapLimitBiasMode
        { OffsetGlobalLimit = 0, OverrideGlobalLimit = 1 }
        /** Script interface for texture mipmap limit groups.
        */
        class TextureMipmapLimitGroups extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** (Editor Only) Attempts to create a texture mipmap limit group with the indicated groupName.
            * @param $groupName Name of the new texture mipmap limit group.
            */
            public static CreateGroup ($groupName: string) : void
            /** (Editor Only) Attempts to remove a texture mipmap limit group with the indicated groupName.
            * @param $groupName Name of the texture mipmap limit group to remove.
            */
            public static RemoveGroup ($groupName: string) : void
            /** Retrieves a string array containing the name of all texture mipmap limit groups available in the project.
            * @returns String array of texture mipmap limit group names. 
            */
            public static GetGroups () : System.Array$1<string>
            /** Checks whether a texture mipmap limit group with the indicated groupName exists in the project. This operation fails and throws an exception if groupName is null.
            * @param $groupName Name of the texture mipmap limit group to verify.
            * @returns Returns true if a texture mipmap limit group named groupName exists in the project. If that is not the case, returns false. 
            */
            public static HasGroup ($groupName: string) : boolean
        }
        /** The Skinned Mesh filter.
        */
        class SkinnedMeshRenderer extends UnityEngine.Renderer
        {
            protected [__keep_incompatibility]: never;
            /** The maximum number of bones per vertex that are taken into account during skinning.
            */
            public get quality(): UnityEngine.SkinQuality;
            public set quality(value: UnityEngine.SkinQuality);
            /** If enabled, the Skinned Mesh will be updated when offscreen. If disabled, this also disables updating animations.
            */
            public get updateWhenOffscreen(): boolean;
            public set updateWhenOffscreen(value: boolean);
            /** Forces the Skinned Mesh to recalculate its matricies when rendered
            */
            public get forceMatrixRecalculationPerRender(): boolean;
            public set forceMatrixRecalculationPerRender(value: boolean);
            public get rootBone(): UnityEngine.Transform;
            public set rootBone(value: UnityEngine.Transform);
            /** The bones used to skin the mesh.
            */
            public get bones(): System.Array$1<UnityEngine.Transform>;
            public set bones(value: System.Array$1<UnityEngine.Transform>);
            /** The mesh used for skinning.
            */
            public get sharedMesh(): UnityEngine.Mesh;
            public set sharedMesh(value: UnityEngine.Mesh);
            /** Specifies whether skinned motion vectors should be used for this renderer.
            */
            public get skinnedMotionVectors(): boolean;
            public set skinnedMotionVectors(value: boolean);
            /** The intended target usage of the skinned mesh GPU vertex buffer.
            */
            public get vertexBufferTarget(): UnityEngine.GraphicsBuffer.Target;
            public set vertexBufferTarget(value: UnityEngine.GraphicsBuffer.Target);
            /** Returns the weight of a BlendShape for this Renderer.
            * @param $index The index of the BlendShape whose weight you want to retrieve. Index must be smaller than the Mesh.blendShapeCount of the Mesh attached to this Renderer.
            * @returns The weight of the BlendShape. 
            */
            public GetBlendShapeWeight ($index: number) : number
            /** Sets the weight of a BlendShape for this Renderer.
            * @param $index The index of the BlendShape to modify. Index must be smaller than the Mesh.blendShapeCount of the Mesh attached to this Renderer.
            * @param $value The weight for this BlendShape.
            */
            public SetBlendShapeWeight ($index: number, $value: number) : void
            /** Creates a snapshot of SkinnedMeshRenderer and stores it in mesh.
            * @param $mesh A static mesh that will receive the snapshot of the skinned mesh.
            * @param $useScale Whether to compensate for the SkinnedMeshRenderer's Transform scale. If true, the baked Mesh is the same size as the original. If false, the baked Mesh matches the scaling of the SkinnedMeshRenderer's Transform component. The default value is false.
            */
            public BakeMesh ($mesh: UnityEngine.Mesh) : void
            /** Creates a snapshot of SkinnedMeshRenderer and stores it in mesh.
            * @param $mesh A static mesh that will receive the snapshot of the skinned mesh.
            * @param $useScale Whether to compensate for the SkinnedMeshRenderer's Transform scale. If true, the baked Mesh is the same size as the original. If false, the baked Mesh matches the scaling of the SkinnedMeshRenderer's Transform component. The default value is false.
            */
            public BakeMesh ($mesh: UnityEngine.Mesh, $useScale: boolean) : void
            /** Retrieves a GraphicsBuffer that provides direct access to the GPU vertex buffer for this skinned mesh, for the current frame.
            * @returns The skinned mesh vertex buffer as a GraphicsBuffer. 
            */
            public GetVertexBuffer () : UnityEngine.GraphicsBuffer
            /** Retrieves a GraphicsBuffer that provides direct access to the GPU vertex buffer for this skinned mesh, for the previous frame.
            * @returns The skinned mesh vertex buffer as a GraphicsBuffer. 
            */
            public GetPreviousVertexBuffer () : UnityEngine.GraphicsBuffer
            public constructor ()
        }
        /** Renders meshes inserted by the MeshFilter or TextMesh.
        */
        class MeshRenderer extends UnityEngine.Renderer
        {
            protected [__keep_incompatibility]: never;
            /** Vertex attributes in this mesh will override or add attributes of the primary mesh in the MeshRenderer.
            */
            public get additionalVertexStreams(): UnityEngine.Mesh;
            public set additionalVertexStreams(value: UnityEngine.Mesh);
            /** Vertex attributes that override the primary mesh when the MeshRenderer uses lightmaps in the Realtime Global Illumination system.
            */
            public get enlightenVertexStream(): UnityEngine.Mesh;
            public set enlightenVertexStream(value: UnityEngine.Mesh);
            /** Index of the first sub-mesh to use from the Mesh associated with this MeshRenderer (Read Only).
            */
            public get subMeshStartIndex(): number;
            /** Specifies the relative lightmap resolution of this object. (Editor only)
            */
            public get scaleInLightmap(): number;
            public set scaleInLightmap(value: number);
            /** Determines how the object will receive global illumination. (Editor only)
            */
            public get receiveGI(): UnityEngine.ReceiveGI;
            public set receiveGI(value: UnityEngine.ReceiveGI);
            /** When enabled, seams in baked lightmaps will get smoothed. (Editor only)
            */
            public get stitchLightmapSeams(): boolean;
            public set stitchLightmapSeams(value: boolean);
            public constructor ()
        }
        /** Light Probe Group.
        */
        class LightProbeGroup extends UnityEngine.Behaviour
        {
            protected [__keep_incompatibility]: never;
            /** Editor only function to access and modify probe positions.
            */
            public get probePositions(): System.Array$1<UnityEngine.Vector3>;
            public set probePositions(value: System.Array$1<UnityEngine.Vector3>);
            /** Removes ringing from probes if enabled (Editor only).
            */
            public get dering(): boolean;
            public set dering(value: boolean);
            public constructor ()
        }
        /** A collection of common line functions.
        */
        class LineUtility extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static Simplify ($points: System.Collections.Generic.List$1<UnityEngine.Vector3>, $tolerance: number, $pointsToKeep: System.Collections.Generic.List$1<number>) : void
            public static Simplify ($points: System.Collections.Generic.List$1<UnityEngine.Vector3>, $tolerance: number, $simplifiedPoints: System.Collections.Generic.List$1<UnityEngine.Vector3>) : void
            public static Simplify ($points: System.Collections.Generic.List$1<UnityEngine.Vector2>, $tolerance: number, $pointsToKeep: System.Collections.Generic.List$1<number>) : void
            public static Simplify ($points: System.Collections.Generic.List$1<UnityEngine.Vector2>, $tolerance: number, $simplifiedPoints: System.Collections.Generic.List$1<UnityEngine.Vector2>) : void
            public constructor ()
        }
        /** The LOD (level of detail) fade modes. Modes other than LODFadeMode.None will result in Unity calculating a blend factor for blending/interpolating between two neighbouring LODs and pass it to your shader.
        */
        enum LODFadeMode
        { None = 0, CrossFade = 1, SpeedTree = 2 }
        /** Structure for building a LOD for passing to the SetLODs function.
        */
        class LOD extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The screen relative height to use for the transition [0-1].
            */
            public screenRelativeTransitionHeight : number
            /** Width of the cross-fade transition zone (proportion to the current LOD's whole length) [0-1]. Only used if it's not animated.
            */
            public fadeTransitionWidth : number
            /** List of renderers for this LOD level.
            */
            public renderers : System.Array$1<UnityEngine.Renderer>
            public constructor ($screenRelativeTransitionHeight: number, $renderers: System.Array$1<UnityEngine.Renderer>)
        }
        /** LODGroup lets you group multiple Renderers into LOD levels.
        */
        class LODGroup extends UnityEngine.Component
        {
            protected [__keep_incompatibility]: never;
            /** The local reference point against which the LOD distance is calculated.
            */
            public get localReferencePoint(): UnityEngine.Vector3;
            public set localReferencePoint(value: UnityEngine.Vector3);
            /** The size of the LOD object in local space.
            */
            public get size(): number;
            public set size(value: number);
            /** The number of LOD levels.
            */
            public get lodCount(): number;
            /** Specify whether the last LOD level is a BillboardRenderer.
            */
            public get lastLODBillboard(): boolean;
            public set lastLODBillboard(value: boolean);
            /** The LOD fade mode used.
            */
            public get fadeMode(): UnityEngine.LODFadeMode;
            public set fadeMode(value: UnityEngine.LODFadeMode);
            /** Specify if the cross-fading should be animated by time. The animation duration is specified globally as crossFadeAnimationDuration.
            */
            public get animateCrossFading(): boolean;
            public set animateCrossFading(value: boolean);
            /** Allows you to enable or disable the LODGroup.
            */
            public get enabled(): boolean;
            public set enabled(value: boolean);
            /** The cross-fading animation duration in seconds. ArgumentException will be thrown if it is set to zero or a negative value.
            */
            public static get crossFadeAnimationDuration(): number;
            public static set crossFadeAnimationDuration(value: number);
            /** Recalculate the bounding region for the LODGroup (Relatively slow, do not call often).
            */
            public RecalculateBounds () : void
            /** Returns the array of LODs.
            * @returns The LOD array. 
            */
            public GetLODs () : System.Array$1<UnityEngine.LOD>
            /** Set the LODs for the LOD group. This will remove any existing LODs configured on the LODGroup.
            * @param $lods The LODs to use for this group.
            */
            public SetLODs ($lods: System.Array$1<UnityEngine.LOD>) : void
            /** * @param $index The LOD level to use. Passing index < 0 will return to standard LOD processing.
            */
            public ForceLOD ($index: number) : void
            public constructor ()
        }
        /** Determines whether a texture uses a mipmap limit, and which mipmap limit the texture uses, when you create the texture using a constructor.
        */
        class MipmapLimitDescriptor extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Enables or disables the texture using a mipmap limit.
            */
            public get useMipmapLimit(): boolean;
            /** The TextureMipmapLimitGroups|TextureMipmapLimitGroup to use the mipmap limit of.
            */
            public get groupName(): string;
            public constructor ($useMipmapLimit: boolean, $groupName: string)
        }
        /** Class for handling 3D Textures, Use this to create.
        */
        class Texture3D extends UnityEngine.Texture
        {
            protected [__keep_incompatibility]: never;
            /** The depth of the texture (Read Only).
            */
            public get depth(): number;
            /** The format of the pixel data in the texture (Read Only).
            */
            public get format(): UnityEngine.TextureFormat;
            public get isReadable(): boolean;
            /** Updates Unity texture to use different native texture object.
            * @param $nativeTex Native 3D texture object.
            */
            public UpdateExternalTexture ($nativeTex: System.IntPtr) : void
            /** Gets the pixel color data for a mipmap level as Color structs.
            * @param $miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns An array that contains the pixel colors. 
            */
            public GetPixels ($miplevel: number) : System.Array$1<UnityEngine.Color>
            /** Gets the pixel color data for a mipmap level as Color structs.
            * @param $miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns An array that contains the pixel colors. 
            */
            public GetPixels () : System.Array$1<UnityEngine.Color>
            /** Gets the pixel color data for a mipmap level as Color32 structs.
            * @param $miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns An array that contains the pixel colors. 
            */
            public GetPixels32 ($miplevel: number) : System.Array$1<UnityEngine.Color32>
            /** Gets the pixel color data for a mipmap level as Color32 structs.
            * @param $miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns An array that contains the pixel colors. 
            */
            public GetPixels32 () : System.Array$1<UnityEngine.Color32>
            /** Sets the pixel colors of an entire mipmap level.
            * @param $colors The array of pixel colours to use. This is a 3D texture flattened to a 1D array.
            * @param $miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            */
            public SetPixels ($colors: System.Array$1<UnityEngine.Color>, $miplevel: number) : void
            /** Sets the pixel colors of an entire mipmap level.
            * @param $colors The array of pixel colours to use. This is a 3D texture flattened to a 1D array.
            * @param $miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            */
            public SetPixels ($colors: System.Array$1<UnityEngine.Color>) : void
            /** Sets the pixel colors of an entire mipmap level.
            * @param $colors The array of pixel colours to use. This is a 3D texture flattened to a 1D array.
            * @param $miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            */
            public SetPixels32 ($colors: System.Array$1<UnityEngine.Color32>, $miplevel: number) : void
            /** Sets the pixel colors of an entire mipmap level.
            * @param $colors The array of pixel colours to use. This is a 3D texture flattened to a 1D array.
            * @param $miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            */
            public SetPixels32 ($colors: System.Array$1<UnityEngine.Color32>) : void
            /** Creates Unity Texture out of externally created native texture object.
            * @param $nativeTex Native 3D texture object.
            * @param $width Width of texture in pixels.
            * @param $height Height of texture in pixels.
            * @param $depth Depth of texture in pixels
            * @param $format Format of underlying texture object.
            * @param $mipmap Does the texture have mipmaps?
            */
            public static CreateExternalTexture ($width: number, $height: number, $depth: number, $format: UnityEngine.TextureFormat, $mipChain: boolean, $nativeTex: System.IntPtr) : UnityEngine.Texture3D
            /** Copies changes you've made in a CPU texture to the GPU.
            * @param $updateMipmaps When the value is true, Unity recalculates mipmap levels, using mipmap level 0 as the source. The default value is true.
            * @param $makeNoLongerReadable When the value is true, Unity deletes the texture in CPU memory after it uploads it to the GPU, and sets Texture.isReadable|isReadable to false. The default value is false.
            */
            public Apply ($updateMipmaps: boolean, $makeNoLongerReadable: boolean) : void
            public Apply ($updateMipmaps: boolean) : void
            public Apply () : void
            /** Sets the pixel color at coordinates (x, y, z).
            * @param $x The x coordinate of the pixel to set. The range is 0 through the (texture width - 1).
            * @param $y The y coordinate of the pixel to set. The range is 0 through the (texture height - 1).
            * @param $z The z coordinate of the pixel to set. The range is 0 through the (texture depth - 1).
            * @param $color The color to set.
            * @param $mipLevel The mipmap level to write to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            */
            public SetPixel ($x: number, $y: number, $z: number, $color: UnityEngine.Color) : void
            /** Sets the pixel color at coordinates (x, y, z).
            * @param $x The x coordinate of the pixel to set. The range is 0 through the (texture width - 1).
            * @param $y The y coordinate of the pixel to set. The range is 0 through the (texture height - 1).
            * @param $z The z coordinate of the pixel to set. The range is 0 through the (texture depth - 1).
            * @param $color The color to set.
            * @param $mipLevel The mipmap level to write to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            */
            public SetPixel ($x: number, $y: number, $z: number, $color: UnityEngine.Color, $mipLevel: number) : void
            /** Gets the pixel color at coordinates (x, y, z).
            * @param $x The x coordinate of the pixel to get. The range is 0 through the (texture width - 1).
            * @param $y The y coordinate of the pixel to get. The range is 0 through the (texture height - 1).
            * @param $z The z coordinate of the pixel to get. The range is 0 through the (texture depth - 1).
            * @param $mipLevel The mipmap level to sample. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns The pixel color. 
            */
            public GetPixel ($x: number, $y: number, $z: number) : UnityEngine.Color
            /** Gets the pixel color at coordinates (x, y, z).
            * @param $x The x coordinate of the pixel to get. The range is 0 through the (texture width - 1).
            * @param $y The y coordinate of the pixel to get. The range is 0 through the (texture height - 1).
            * @param $z The z coordinate of the pixel to get. The range is 0 through the (texture depth - 1).
            * @param $mipLevel The mipmap level to sample. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns The pixel color. 
            */
            public GetPixel ($x: number, $y: number, $z: number, $mipLevel: number) : UnityEngine.Color
            /** Gets the filtered pixel color at the normalized coordinates (u, v, w).
            * @param $u The u coordinate of the pixel to get.
            * @param $v The v coordinate of the pixel to get.
            * @param $w The w coordinate of the pixel to get.
            * @param $mipLevel The mipmap level to read from. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns The pixel color. 
            */
            public GetPixelBilinear ($u: number, $v: number, $w: number) : UnityEngine.Color
            /** Gets the filtered pixel color at the normalized coordinates (u, v, w).
            * @param $u The u coordinate of the pixel to get.
            * @param $v The v coordinate of the pixel to get.
            * @param $w The w coordinate of the pixel to get.
            * @param $mipLevel The mipmap level to read from. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns The pixel color. 
            */
            public GetPixelBilinear ($u: number, $v: number, $w: number, $mipLevel: number) : UnityEngine.Color
            public constructor ($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags)
            public constructor ($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags, $mipCount: number)
            public constructor ($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags)
            public constructor ($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags, $mipCount: number)
            public constructor ($width: number, $height: number, $depth: number, $textureFormat: UnityEngine.TextureFormat, $mipCount: number)
            public constructor ($width: number, $height: number, $depth: number, $textureFormat: UnityEngine.TextureFormat, $mipCount: number, $nativeTex: System.IntPtr)
            public constructor ($width: number, $height: number, $depth: number, $textureFormat: UnityEngine.TextureFormat, $mipCount: number, $nativeTex: System.IntPtr, $createUninitialized: boolean)
            public constructor ($width: number, $height: number, $depth: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean)
            public constructor ($width: number, $height: number, $depth: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean, $createUninitialized: boolean)
            public constructor ($width: number, $height: number, $depth: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean, $nativeTex: System.IntPtr)
            public constructor ()
        }
        /** Class for handling 2D texture arrays.
        */
        class Texture2DArray extends UnityEngine.Texture
        {
            protected [__keep_incompatibility]: never;
            /** Read Only. This property is used as a parameter in some overloads of the CommandBuffer.Blit, Graphics.Blit, CommandBuffer.SetRenderTarget, and Graphics.SetRenderTarget methods to indicate that all texture array slices are bound. The value of this property is -1.
            */
            public static get allSlices(): number;
            /** Number of elements in a texture array (Read Only).
            */
            public get depth(): number;
            /** Texture format (Read Only).
            */
            public get format(): UnityEngine.TextureFormat;
            /** The name of the texture mipmap limit group that this texture is associated with. (Read Only)
            */
            public get mipmapLimitGroup(): string;
            /** The number of high resolution mipmap levels from the texture that Unity doesn't upload to the GPU. (Read Only)
            */
            public get activeMipmapLimit(): number;
            public get isReadable(): boolean;
            /** This property causes a texture to ignore all texture mipmap limit settings.
            */
            public get ignoreMipmapLimit(): boolean;
            public set ignoreMipmapLimit(value: boolean);
            /** Gets the pixel color data for a mipmap level of a slice as Color structs.
            * @param $arrayElement The array slice to read pixel data from.
            * @param $miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns An array that contains the pixel colors. 
            */
            public GetPixels ($arrayElement: number, $miplevel: number) : System.Array$1<UnityEngine.Color>
            /** Gets the pixel color data for a mipmap level of a slice as Color structs.
            * @param $arrayElement The array slice to read pixel data from.
            * @param $miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns An array that contains the pixel colors. 
            */
            public GetPixels ($arrayElement: number) : System.Array$1<UnityEngine.Color>
            /** Gets the pixel color data for a mipmap level of a slice as Color32 structs.
            * @param $arrayElement The array slice to read pixel data from.
            * @param $miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns An array that contains the pixel colors. 
            */
            public GetPixels32 ($arrayElement: number, $miplevel: number) : System.Array$1<UnityEngine.Color32>
            /** Gets the pixel color data for a mipmap level of a slice as Color32 structs.
            * @param $arrayElement The array slice to read pixel data from.
            * @param $miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns An array that contains the pixel colors. 
            */
            public GetPixels32 ($arrayElement: number) : System.Array$1<UnityEngine.Color32>
            /** Sets the pixel colors of an entire mipmap level of a slice.
            * @param $colors The array of pixel colours to use. This is a 2D image flattened to a 1D array.
            * @param $arrayElement The array slice to write to.
            * @param $miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            */
            public SetPixels ($colors: System.Array$1<UnityEngine.Color>, $arrayElement: number, $miplevel: number) : void
            /** Sets the pixel colors of an entire mipmap level of a slice.
            * @param $colors The array of pixel colours to use. This is a 2D image flattened to a 1D array.
            * @param $arrayElement The array slice to write to.
            * @param $miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            */
            public SetPixels ($colors: System.Array$1<UnityEngine.Color>, $arrayElement: number) : void
            /** Sets the pixel colors of an entire mipmap level of a slice.
            * @param $colors The array of pixel colours to use. This is a 2D image flattened to a 1D array.
            * @param $arrayElement The array slice to write colors to.
            * @param $miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            */
            public SetPixels32 ($colors: System.Array$1<UnityEngine.Color32>, $arrayElement: number, $miplevel: number) : void
            /** Sets the pixel colors of an entire mipmap level of a slice.
            * @param $colors The array of pixel colours to use. This is a 2D image flattened to a 1D array.
            * @param $arrayElement The array slice to write colors to.
            * @param $miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            */
            public SetPixels32 ($colors: System.Array$1<UnityEngine.Color32>, $arrayElement: number) : void
            /** Copies changes you've made in a CPU texture to the GPU.
            * @param $updateMipmaps When the value is true, Unity recalculates mipmap levels, using mipmap level 0 as the source. The default value is true.
            * @param $makeNoLongerReadable When the value is true, Unity deletes the texture in CPU memory after it uploads it to the GPU, and sets Texture.isReadable|isReadable to false. The default value is false.
            */
            public Apply ($updateMipmaps: boolean, $makeNoLongerReadable: boolean) : void
            public Apply ($updateMipmaps: boolean) : void
            public Apply () : void
            public constructor ($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags)
            public constructor ($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags, $mipCount: number)
            public constructor ($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags, $mipCount: number, $mipmapLimitDescriptor: UnityEngine.MipmapLimitDescriptor)
            public constructor ($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags)
            public constructor ($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags, $mipCount: number)
            public constructor ($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags, $mipCount: number, $mipmapLimitDescriptor: UnityEngine.MipmapLimitDescriptor)
            public constructor ($width: number, $height: number, $depth: number, $textureFormat: UnityEngine.TextureFormat, $mipCount: number, $linear: boolean, $createUninitialized: boolean, $mipmapLimitDescriptor: UnityEngine.MipmapLimitDescriptor)
            public constructor ($width: number, $height: number, $depth: number, $textureFormat: UnityEngine.TextureFormat, $mipCount: number, $linear: boolean, $createUninitialized: boolean)
            public constructor ($width: number, $height: number, $depth: number, $textureFormat: UnityEngine.TextureFormat, $mipCount: number, $linear: boolean)
            public constructor ($width: number, $height: number, $depth: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean, $linear: boolean, $createUninitialized: boolean)
            public constructor ($width: number, $height: number, $depth: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean, $linear: boolean)
            public constructor ($width: number, $height: number, $depth: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean)
            public constructor ()
        }
        /** Class for handling Cubemap arrays.
        */
        class CubemapArray extends UnityEngine.Texture
        {
            protected [__keep_incompatibility]: never;
            /** Number of cubemaps in the array (Read Only).
            */
            public get cubemapCount(): number;
            /** Texture format (Read Only).
            */
            public get format(): UnityEngine.TextureFormat;
            public get isReadable(): boolean;
            /** Gets the pixel color data for a mipmap level of a face of a slice as Color structs.
            * @param $face The CubemapFace to read from.
            * @param $miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @param $arrayElement The array slice to read pixel data from.
            * @returns An array that contains the pixel colors. 
            */
            public GetPixels ($face: UnityEngine.CubemapFace, $arrayElement: number, $miplevel: number) : System.Array$1<UnityEngine.Color>
            /** Gets the pixel color data for a mipmap level of a face of a slice as Color structs.
            * @param $face The CubemapFace to read from.
            * @param $miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @param $arrayElement The array slice to read pixel data from.
            * @returns An array that contains the pixel colors. 
            */
            public GetPixels ($face: UnityEngine.CubemapFace, $arrayElement: number) : System.Array$1<UnityEngine.Color>
            /** Gets the pixel color data for a mipmap level of a face of a slice as Color32 structs.
            * @param $face The CubemapFace to read pixel data from.
            * @param $arrayElement The array slice to read pixel data from.
            * @param $miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns An array that contains the pixel colors. 
            */
            public GetPixels32 ($face: UnityEngine.CubemapFace, $arrayElement: number, $miplevel: number) : System.Array$1<UnityEngine.Color32>
            /** Gets the pixel color data for a mipmap level of a face of a slice as Color32 structs.
            * @param $face The CubemapFace to read pixel data from.
            * @param $arrayElement The array slice to read pixel data from.
            * @param $miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns An array that contains the pixel colors. 
            */
            public GetPixels32 ($face: UnityEngine.CubemapFace, $arrayElement: number) : System.Array$1<UnityEngine.Color32>
            /** Sets the pixel colors of an entire mipmap level of a face of a slice.
            * @param $colors The array of pixel colours to use. This is a 2D image flattened to a 1D array.
            * @param $miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @param $face The CubemapFace to write colors to.
            * @param $arrayElement The array slice to write colors to.
            */
            public SetPixels ($colors: System.Array$1<UnityEngine.Color>, $face: UnityEngine.CubemapFace, $arrayElement: number, $miplevel: number) : void
            /** Sets the pixel colors of an entire mipmap level of a face of a slice.
            * @param $colors The array of pixel colours to use. This is a 2D image flattened to a 1D array.
            * @param $miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @param $face The CubemapFace to write colors to.
            * @param $arrayElement The array slice to write colors to.
            */
            public SetPixels ($colors: System.Array$1<UnityEngine.Color>, $face: UnityEngine.CubemapFace, $arrayElement: number) : void
            /** Sets the pixel colors of an entire mipmap level of a face of a slice.
            * @param $colors The array of pixel colours to use. This is a 2D image flattened to a 1D array.
            * @param $face The CubemapFace to write colors to.
            * @param $arrayElement The array slice to write colors to.
            * @param $miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            */
            public SetPixels32 ($colors: System.Array$1<UnityEngine.Color32>, $face: UnityEngine.CubemapFace, $arrayElement: number, $miplevel: number) : void
            /** Sets the pixel colors of an entire mipmap level of a face of a slice.
            * @param $colors The array of pixel colours to use. This is a 2D image flattened to a 1D array.
            * @param $face The CubemapFace to write colors to.
            * @param $arrayElement The array slice to write colors to.
            * @param $miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            */
            public SetPixels32 ($colors: System.Array$1<UnityEngine.Color32>, $face: UnityEngine.CubemapFace, $arrayElement: number) : void
            /** Copies changes you've made in a CPU texture to the GPU.
            * @param $updateMipmaps When the value is true, Unity recalculates mipmap levels, using mipmap level 0 as the source. The default value is true.
            * @param $makeNoLongerReadable When the value is true, Unity deletes the texture in CPU memory after it uploads it to the GPU, and sets Texture.isReadable|isReadable to false. The default value is false.
            */
            public Apply ($updateMipmaps: boolean, $makeNoLongerReadable: boolean) : void
            public Apply ($updateMipmaps: boolean) : void
            public Apply () : void
            public constructor ($width: number, $cubemapCount: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags)
            public constructor ($width: number, $cubemapCount: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags, $mipCount: number)
            public constructor ($width: number, $cubemapCount: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags)
            public constructor ($width: number, $cubemapCount: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags, $mipCount: number)
            public constructor ($width: number, $cubemapCount: number, $textureFormat: UnityEngine.TextureFormat, $mipCount: number, $linear: boolean, $createUninitialized: boolean)
            public constructor ($width: number, $cubemapCount: number, $textureFormat: UnityEngine.TextureFormat, $mipCount: number, $linear: boolean)
            public constructor ($width: number, $cubemapCount: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean, $linear: boolean, $createUninitialized: boolean)
            public constructor ($width: number, $cubemapCount: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean, $linear: boolean)
            public constructor ($width: number, $cubemapCount: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean)
            public constructor ()
        }
        /** Class for handling Sparse Textures.
        */
        class SparseTexture extends UnityEngine.Texture
        {
            protected [__keep_incompatibility]: never;
            /** Get sparse texture tile width (Read Only).
            */
            public get tileWidth(): number;
            /** Get sparse texture tile height (Read Only).
            */
            public get tileHeight(): number;
            /** Is the sparse texture actually created? (Read Only)
            */
            public get isCreated(): boolean;
            /** Update sparse texture tile with color values.
            * @param $tileX Tile X coordinate.
            * @param $tileY Tile Y coordinate.
            * @param $miplevel Mipmap level of the texture.
            * @param $data Tile color data.
            */
            public UpdateTile ($tileX: number, $tileY: number, $miplevel: number, $data: System.Array$1<UnityEngine.Color32>) : void
            /** Update sparse texture tile with raw pixel values.
            * @param $tileX Tile X coordinate.
            * @param $tileY Tile Y coordinate.
            * @param $miplevel Mipmap level of the texture.
            * @param $data Tile raw pixel data.
            */
            public UpdateTileRaw ($tileX: number, $tileY: number, $miplevel: number, $data: System.Array$1<number>) : void
            /** Unload sparse texture tile.
            * @param $tileX Tile X coordinate.
            * @param $tileY Tile Y coordinate.
            * @param $miplevel Mipmap level of the texture.
            */
            public UnloadTile ($tileX: number, $tileY: number, $miplevel: number) : void
            public constructor ($width: number, $height: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat, $mipCount: number)
            public constructor ($width: number, $height: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $mipCount: number)
            public constructor ($width: number, $height: number, $textureFormat: UnityEngine.TextureFormat, $mipCount: number)
            public constructor ($width: number, $height: number, $textureFormat: UnityEngine.TextureFormat, $mipCount: number, $linear: boolean)
            public constructor ()
        }
        /** This struct contains all the information required to create a RenderTexture. It can be copied, cached, and reused to easily create RenderTextures that all share the same properties. Avoid using the default constructor as it does not initialize some flags with the recommended values.
        */
        class RenderTextureDescriptor extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The width of the render texture in pixels.
            */
            public get width(): number;
            public set width(value: number);
            /** The height of the render texture in pixels.
            */
            public get height(): number;
            public set height(value: number);
            /** The multisample antialiasing level for the RenderTexture.
            Additional resources: RenderTexture.antiAliasing.
            */
            public get msaaSamples(): number;
            public set msaaSamples(value: number);
            /** Volume extent of a 3D render texture.
            */
            public get volumeDepth(): number;
            public set volumeDepth(value: number);
            /** User-defined mipmap count.
            */
            public get mipCount(): number;
            public set mipCount(value: number);
            /** The color format for the RenderTexture. You can set this format to None to achieve depth-only rendering.
            */
            public get graphicsFormat(): UnityEngine.Experimental.Rendering.GraphicsFormat;
            public set graphicsFormat(value: UnityEngine.Experimental.Rendering.GraphicsFormat);
            /** The format of the stencil data that you can encapsulate within a RenderTexture.
            Specifying this property creates a stencil element for the RenderTexture and sets its format.
            This allows for stencil data to be bound as a Texture to all shader types for the platforms that support it.
            This property does not specify the format of the stencil buffer, which is constrained by the depth buffer format specified in RenderTexture.depth.
            Currently, most platforms only support R8_UInt (DirectX11, DirectX12), while PS4 also supports R8_UNorm.
            */
            public get stencilFormat(): UnityEngine.Experimental.Rendering.GraphicsFormat;
            public set stencilFormat(value: UnityEngine.Experimental.Rendering.GraphicsFormat);
            /** The desired format of the depth/stencil buffer.
            */
            public get depthStencilFormat(): UnityEngine.Experimental.Rendering.GraphicsFormat;
            public set depthStencilFormat(value: UnityEngine.Experimental.Rendering.GraphicsFormat);
            /** The format of the RenderTarget is expressed as a RenderTextureFormat. Internally, this format is stored as a GraphicsFormat compatible with the current system (see SystemInfo.GetCompatibleFormat). Therefore, if you set a format and immediately get it again, it may return a different result from the one just set.
            */
            public get colorFormat(): UnityEngine.RenderTextureFormat;
            public set colorFormat(value: UnityEngine.RenderTextureFormat);
            /** This flag causes the render texture uses sRGB read/write conversions.
            */
            public get sRGB(): boolean;
            public set sRGB(value: boolean);
            /** The precision of the render texture's depth buffer in bits (0, 16, 24 and 32 are supported).
            */
            public get depthBufferBits(): number;
            public set depthBufferBits(value: number);
            /** Dimensionality (type) of the render texture.
            Additional resources: RenderTexture.dimension.
            */
            public get dimension(): UnityEngine.Rendering.TextureDimension;
            public set dimension(value: UnityEngine.Rendering.TextureDimension);
            /** Determines how the RenderTexture is sampled if it is used as a shadow map.
            Additional resources: ShadowSamplingMode for more details.
            */
            public get shadowSamplingMode(): UnityEngine.Rendering.ShadowSamplingMode;
            public set shadowSamplingMode(value: UnityEngine.Rendering.ShadowSamplingMode);
            /** If this RenderTexture is a VR eye texture used in stereoscopic rendering, this property decides what special rendering occurs, if any. Instead of setting this manually, use the value returned by XR.XRSettings.eyeTextureDesc|eyeTextureDesc or other VR functions returning a RenderTextureDescriptor.
            */
            public get vrUsage(): UnityEngine.VRTextureUsage;
            public set vrUsage(value: UnityEngine.VRTextureUsage);
            /** A set of RenderTextureCreationFlags that control how the texture is created.
            */
            public get flags(): UnityEngine.RenderTextureCreationFlags;
            /** The render texture memoryless mode property.
            */
            public get memoryless(): UnityEngine.RenderTextureMemoryless;
            public set memoryless(value: UnityEngine.RenderTextureMemoryless);
            /** Render texture has mipmaps when this flag is set.
            Additional resources: RenderTexture.useMipMap.
            */
            public get useMipMap(): boolean;
            public set useMipMap(value: boolean);
            /** Mipmap levels are generated automatically when this flag is set.
            */
            public get autoGenerateMips(): boolean;
            public set autoGenerateMips(value: boolean);
            /** Enable random access write into this render texture on Shader Model 5.0 level shaders.
            Additional resources: RenderTexture.enableRandomWrite.
            */
            public get enableRandomWrite(): boolean;
            public set enableRandomWrite(value: boolean);
            /** If true and msaaSamples is greater than 1, the render texture will not be resolved by default.  Use this if the render texture needs to be bound as a multisampled texture in a shader.
            */
            public get bindMS(): boolean;
            public set bindMS(value: boolean);
            /** Set to true to enable dynamic resolution scaling on this render texture. Mutually exclusive with RenderTextureDescriptor.useDynamicScaleExplicit
            Additional resources: RenderTexture.useDynamicScale.
            */
            public get useDynamicScale(): boolean;
            public set useDynamicScale(value: boolean);
            /** Set to true to enable dynamic resolution scaling on this render texture and control when this scaling happens. Mutually exclusive with RenderTextureDescriptor.useDynamicScale
            Additional resources: RenderTexture.useDynamicScaleExplicit.
            */
            public get useDynamicScaleExplicit(): boolean;
            public set useDynamicScaleExplicit(value: boolean);
            public constructor ($width: number, $height: number)
            public constructor ($width: number, $height: number, $colorFormat: UnityEngine.RenderTextureFormat)
            public constructor ($width: number, $height: number, $colorFormat: UnityEngine.RenderTextureFormat, $depthBufferBits: number)
            public constructor ($width: number, $height: number, $colorFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $depthBufferBits: number)
            public constructor ($width: number, $height: number, $colorFormat: UnityEngine.RenderTextureFormat, $depthBufferBits: number, $mipCount: number)
            public constructor ($width: number, $height: number, $colorFormat: UnityEngine.RenderTextureFormat, $depthBufferBits: number, $mipCount: number, $readWrite: UnityEngine.RenderTextureReadWrite)
            public constructor ($width: number, $height: number, $colorFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $depthBufferBits: number, $mipCount: number)
            public constructor ($width: number, $height: number, $colorFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $depthStencilFormat: UnityEngine.Experimental.Rendering.GraphicsFormat)
            public constructor ($width: number, $height: number, $colorFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $depthStencilFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $mipCount: number)
        }
        /** Structure describing an Update Zone.
        */
        class CustomRenderTextureUpdateZone extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Position of the center of the Update Zone within the Custom Render Texture.
            */
            public updateZoneCenter : UnityEngine.Vector3
            /** Size of the Update Zone.
            */
            public updateZoneSize : UnityEngine.Vector3
            /** Rotation of the Update Zone.
            */
            public rotation : number
            /** Shader Pass used to update the Custom Render Texture for this Update Zone.
            */
            public passIndex : number
            /** If true, and if the texture is double buffered, a request is made to swap the buffers before the next update. Otherwise, the buffers will not be swapped.
            */
            public needSwap : boolean
        }
        /** Describes options for displaying movie playback controls.
        */
        enum FullScreenMovieControlMode
        { Full = 0, Minimal = 1, CancelOnInput = 2, Hidden = 3 }
        /** Describes scaling modes for displaying movies.
        */
        enum FullScreenMovieScalingMode
        { None = 0, AspectFit = 1, AspectFill = 2, Fill = 3 }
        /** ActivityIndicator Style (Android Specific).
        */
        enum AndroidActivityIndicatorStyle
        { DontShow = -1, Large = 0, InversedLarge = 1, Small = 2, InversedSmall = 3 }
        /** Interface into functionality unique to handheld devices.
        */
        class Handheld extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Plays a full-screen movie.
            * @param $path Filesystem path to the movie file.
            * @param $bgColor Background color.
            * @param $controlMode How the playback controls are to be displayed.
            * @param $scalingMode How the movie is to be scaled to fit the screen.
            */
            public static PlayFullScreenMovie ($path: string, $bgColor: UnityEngine.Color, $controlMode: UnityEngine.FullScreenMovieControlMode, $scalingMode: UnityEngine.FullScreenMovieScalingMode) : boolean
            /** Plays a full-screen movie.
            * @param $path Filesystem path to the movie file.
            * @param $bgColor Background color.
            * @param $controlMode How the playback controls are to be displayed.
            * @param $scalingMode How the movie is to be scaled to fit the screen.
            */
            public static PlayFullScreenMovie ($path: string, $bgColor: UnityEngine.Color, $controlMode: UnityEngine.FullScreenMovieControlMode) : boolean
            /** Plays a full-screen movie.
            * @param $path Filesystem path to the movie file.
            * @param $bgColor Background color.
            * @param $controlMode How the playback controls are to be displayed.
            * @param $scalingMode How the movie is to be scaled to fit the screen.
            */
            public static PlayFullScreenMovie ($path: string, $bgColor: UnityEngine.Color) : boolean
            /** Plays a full-screen movie.
            * @param $path Filesystem path to the movie file.
            * @param $bgColor Background color.
            * @param $controlMode How the playback controls are to be displayed.
            * @param $scalingMode How the movie is to be scaled to fit the screen.
            */
            public static PlayFullScreenMovie ($path: string) : boolean
            /** Triggers device vibration.
            */
            public static Vibrate () : void
            public static SetActivityIndicatorStyle ($style: UnityEngine.iOS.ActivityIndicatorStyle) : void
            /** Sets the desired activity indicator style.
            */
            public static SetActivityIndicatorStyle ($style: UnityEngine.AndroidActivityIndicatorStyle) : void
            /** Gets the current activity indicator style.
            */
            public static GetActivityIndicatorStyle () : number
            /** Starts os activity indicator.
            */
            public static StartActivityIndicator () : void
            /** Stops os activity indicator.
            */
            public static StopActivityIndicator () : void
            public static ClearShaderCache () : void
            public constructor ()
        }
        /** Utilities to compute hashes.
        */
        class HashUtilities extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Append inHash in outHash.
            * @param $inHash Hash to append.
            * @param $outHash Hash that will be updated.
            */
            public static AppendHash ($inHash: $Ref<UnityEngine.Hash128>, $outHash: $Ref<UnityEngine.Hash128>) : void
            /** Compute a Hash128 of a Matrix4x4.
            * @param $value The Matrix4x4 to hash.
            * @param $hash The computed hash.
            */
            public static QuantisedMatrixHash ($value: $Ref<UnityEngine.Matrix4x4>, $hash: $Ref<UnityEngine.Hash128>) : void
            /** Compute a Hash128 of a Vector3.
            * @param $hash The Vector3 to hash.
            * @param $value The computed hash.
            */
            public static QuantisedVectorHash ($value: $Ref<UnityEngine.Vector3>, $hash: $Ref<UnityEngine.Hash128>) : void
            /** Compute a 128 bit hash based on a value. the type of the value must be a value type.
            * @param $value A reference to the value to hash.
            * @param $hash A reference to the Hash128 to updated with the computed hash.
            */
            public static ComputeHash128 ($value: System.Array$1<number>, $hash: $Ref<UnityEngine.Hash128>) : void
        }
        /** Utilities to compute hashes with unsafe code.
        */
        class HashUnsafeUtilities extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class HmiPlatform extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static LogStartupTiming ($tag: string) : void
            public constructor ()
        }
        /** Determines whether the mouse cursor is rendered using software rendering or, on supported platforms, hardware rendering.
        */
        enum CursorMode
        { Auto = 0, ForceSoftware = 1 }
        /** How the cursor should behave.
        */
        enum CursorLockMode
        { None = 0, Locked = 1, Confined = 2 }
        /** Cursor API for setting the cursor (mouse pointer).
        */
        class Cursor extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Determines whether the hardware pointer is visible or not.
            */
            public static get visible(): boolean;
            public static set visible(value: boolean);
            /** Determines whether the hardware pointer is locked to the center of the view, constrained to the window, or not constrained at all.
            */
            public static get lockState(): UnityEngine.CursorLockMode;
            public static set lockState(value: UnityEngine.CursorLockMode);
            /** Sets a custom cursor to use as your cursor.
            * @param $texture The texture to use for the cursor. To use a texture, import it with `Read/Write` enabled. Alternatively, you can use the default cursor import setting. If you created your cursor texture from code, it must be in RGBA32 format, have alphaIsTransparency enabled, and have no mip chain. To use the default cursor, set the texture to `Null`.
            * @param $hotspot The offset from the top left of the texture to use as the target point. This must be in the bounds of the cursor.
            * @param $cursorMode Whether to render this cursor as a hardware cursor on supported platforms, or force software cursor.
            */
            public static SetCursor ($texture: UnityEngine.Texture2D, $hotspot: UnityEngine.Vector2, $cursorMode: UnityEngine.CursorMode) : void
            public constructor ()
        }
        /** Key codes returned by Event.keyCode. These map directly to a physical key on the keyboard. If "Use Physical Keys" is enabled in, these map directly to a physical key on the keyboard. If "Use Physical Keys" is disabled these map to language dependent mapping, different for every platform and cannot be guaranteed to work. "Use Physical Keys" is enabled by default from 2022.1
        */
        enum KeyCode
        { None = 0, Backspace = 8, Delete = 127, Tab = 9, Clear = 12, Return = 13, Pause = 19, Escape = 27, Space = 32, Keypad0 = 256, Keypad1 = 257, Keypad2 = 258, Keypad3 = 259, Keypad4 = 260, Keypad5 = 261, Keypad6 = 262, Keypad7 = 263, Keypad8 = 264, Keypad9 = 265, KeypadPeriod = 266, KeypadDivide = 267, KeypadMultiply = 268, KeypadMinus = 269, KeypadPlus = 270, KeypadEnter = 271, KeypadEquals = 272, UpArrow = 273, DownArrow = 274, RightArrow = 275, LeftArrow = 276, Insert = 277, Home = 278, End = 279, PageUp = 280, PageDown = 281, F1 = 282, F2 = 283, F3 = 284, F4 = 285, F5 = 286, F6 = 287, F7 = 288, F8 = 289, F9 = 290, F10 = 291, F11 = 292, F12 = 293, F13 = 294, F14 = 295, F15 = 296, Alpha0 = 48, Alpha1 = 49, Alpha2 = 50, Alpha3 = 51, Alpha4 = 52, Alpha5 = 53, Alpha6 = 54, Alpha7 = 55, Alpha8 = 56, Alpha9 = 57, Exclaim = 33, DoubleQuote = 34, Hash = 35, Dollar = 36, Percent = 37, Ampersand = 38, Quote = 39, LeftParen = 40, RightParen = 41, Asterisk = 42, Plus = 43, Comma = 44, Minus = 45, Period = 46, Slash = 47, Colon = 58, Semicolon = 59, Less = 60, Equals = 61, Greater = 62, Question = 63, At = 64, LeftBracket = 91, Backslash = 92, RightBracket = 93, Caret = 94, Underscore = 95, BackQuote = 96, A = 97, B = 98, C = 99, D = 100, E = 101, F = 102, G = 103, H = 104, I = 105, J = 106, K = 107, L = 108, M = 109, N = 110, O = 111, P = 112, Q = 113, R = 114, S = 115, T = 116, U = 117, V = 118, W = 119, X = 120, Y = 121, Z = 122, LeftCurlyBracket = 123, Pipe = 124, RightCurlyBracket = 125, Tilde = 126, Numlock = 300, CapsLock = 301, ScrollLock = 302, RightShift = 303, LeftShift = 304, RightControl = 305, LeftControl = 306, RightAlt = 307, LeftAlt = 308, LeftMeta = 310, LeftCommand = 310, LeftApple = 310, LeftWindows = 311, RightMeta = 309, RightCommand = 309, RightApple = 309, RightWindows = 312, AltGr = 313, Help = 315, Print = 316, SysReq = 317, Break = 318, Menu = 319, WheelUp = 321, WheelDown = 322, Mouse0 = 323, Mouse1 = 324, Mouse2 = 325, Mouse3 = 326, Mouse4 = 327, Mouse5 = 328, Mouse6 = 329, JoystickButton0 = 330, JoystickButton1 = 331, JoystickButton2 = 332, JoystickButton3 = 333, JoystickButton4 = 334, JoystickButton5 = 335, JoystickButton6 = 336, JoystickButton7 = 337, JoystickButton8 = 338, JoystickButton9 = 339, JoystickButton10 = 340, JoystickButton11 = 341, JoystickButton12 = 342, JoystickButton13 = 343, JoystickButton14 = 344, JoystickButton15 = 345, JoystickButton16 = 346, JoystickButton17 = 347, JoystickButton18 = 348, JoystickButton19 = 349, Joystick1Button0 = 350, Joystick1Button1 = 351, Joystick1Button2 = 352, Joystick1Button3 = 353, Joystick1Button4 = 354, Joystick1Button5 = 355, Joystick1Button6 = 356, Joystick1Button7 = 357, Joystick1Button8 = 358, Joystick1Button9 = 359, Joystick1Button10 = 360, Joystick1Button11 = 361, Joystick1Button12 = 362, Joystick1Button13 = 363, Joystick1Button14 = 364, Joystick1Button15 = 365, Joystick1Button16 = 366, Joystick1Button17 = 367, Joystick1Button18 = 368, Joystick1Button19 = 369, Joystick2Button0 = 370, Joystick2Button1 = 371, Joystick2Button2 = 372, Joystick2Button3 = 373, Joystick2Button4 = 374, Joystick2Button5 = 375, Joystick2Button6 = 376, Joystick2Button7 = 377, Joystick2Button8 = 378, Joystick2Button9 = 379, Joystick2Button10 = 380, Joystick2Button11 = 381, Joystick2Button12 = 382, Joystick2Button13 = 383, Joystick2Button14 = 384, Joystick2Button15 = 385, Joystick2Button16 = 386, Joystick2Button17 = 387, Joystick2Button18 = 388, Joystick2Button19 = 389, Joystick3Button0 = 390, Joystick3Button1 = 391, Joystick3Button2 = 392, Joystick3Button3 = 393, Joystick3Button4 = 394, Joystick3Button5 = 395, Joystick3Button6 = 396, Joystick3Button7 = 397, Joystick3Button8 = 398, Joystick3Button9 = 399, Joystick3Button10 = 400, Joystick3Button11 = 401, Joystick3Button12 = 402, Joystick3Button13 = 403, Joystick3Button14 = 404, Joystick3Button15 = 405, Joystick3Button16 = 406, Joystick3Button17 = 407, Joystick3Button18 = 408, Joystick3Button19 = 409, Joystick4Button0 = 410, Joystick4Button1 = 411, Joystick4Button2 = 412, Joystick4Button3 = 413, Joystick4Button4 = 414, Joystick4Button5 = 415, Joystick4Button6 = 416, Joystick4Button7 = 417, Joystick4Button8 = 418, Joystick4Button9 = 419, Joystick4Button10 = 420, Joystick4Button11 = 421, Joystick4Button12 = 422, Joystick4Button13 = 423, Joystick4Button14 = 424, Joystick4Button15 = 425, Joystick4Button16 = 426, Joystick4Button17 = 427, Joystick4Button18 = 428, Joystick4Button19 = 429, Joystick5Button0 = 430, Joystick5Button1 = 431, Joystick5Button2 = 432, Joystick5Button3 = 433, Joystick5Button4 = 434, Joystick5Button5 = 435, Joystick5Button6 = 436, Joystick5Button7 = 437, Joystick5Button8 = 438, Joystick5Button9 = 439, Joystick5Button10 = 440, Joystick5Button11 = 441, Joystick5Button12 = 442, Joystick5Button13 = 443, Joystick5Button14 = 444, Joystick5Button15 = 445, Joystick5Button16 = 446, Joystick5Button17 = 447, Joystick5Button18 = 448, Joystick5Button19 = 449, Joystick6Button0 = 450, Joystick6Button1 = 451, Joystick6Button2 = 452, Joystick6Button3 = 453, Joystick6Button4 = 454, Joystick6Button5 = 455, Joystick6Button6 = 456, Joystick6Button7 = 457, Joystick6Button8 = 458, Joystick6Button9 = 459, Joystick6Button10 = 460, Joystick6Button11 = 461, Joystick6Button12 = 462, Joystick6Button13 = 463, Joystick6Button14 = 464, Joystick6Button15 = 465, Joystick6Button16 = 466, Joystick6Button17 = 467, Joystick6Button18 = 468, Joystick6Button19 = 469, Joystick7Button0 = 470, Joystick7Button1 = 471, Joystick7Button2 = 472, Joystick7Button3 = 473, Joystick7Button4 = 474, Joystick7Button5 = 475, Joystick7Button6 = 476, Joystick7Button7 = 477, Joystick7Button8 = 478, Joystick7Button9 = 479, Joystick7Button10 = 480, Joystick7Button11 = 481, Joystick7Button12 = 482, Joystick7Button13 = 483, Joystick7Button14 = 484, Joystick7Button15 = 485, Joystick7Button16 = 486, Joystick7Button17 = 487, Joystick7Button18 = 488, Joystick7Button19 = 489, Joystick8Button0 = 490, Joystick8Button1 = 491, Joystick8Button2 = 492, Joystick8Button3 = 493, Joystick8Button4 = 494, Joystick8Button5 = 495, Joystick8Button6 = 496, Joystick8Button7 = 497, Joystick8Button8 = 498, Joystick8Button9 = 499, Joystick8Button10 = 500, Joystick8Button11 = 501, Joystick8Button12 = 502, Joystick8Button13 = 503, Joystick8Button14 = 504, Joystick8Button15 = 505, Joystick8Button16 = 506, Joystick8Button17 = 507, Joystick8Button18 = 508, Joystick8Button19 = 509 }
        enum iPhoneScreenOrientation
        { Unknown = 0, Portrait = 1, PortraitUpsideDown = 2, LandscapeLeft = 3, LandscapeRight = 4, AutoRotation = 5, Landscape = 6 }
        enum iPhoneNetworkReachability
        { NotReachable = 0, ReachableViaCarrierDataNetwork = 1, ReachableViaWiFiNetwork = 2 }
        enum iPhoneGeneration
        { Unknown = 0, iPhone = 1, iPhone3G = 2, iPhone3GS = 3, iPodTouch1Gen = 4, iPodTouch2Gen = 5, iPodTouch3Gen = 6, iPad1Gen = 7, iPhone4 = 8, iPodTouch4Gen = 9, iPad2Gen = 10, iPhone4S = 11, iPad3Gen = 12, iPhone5 = 13, iPodTouch5Gen = 14, iPadMini1Gen = 15, iPad4Gen = 16, iPhone5C = 17, iPhone5S = 18, iPhoneUnknown = 19, iPadUnknown = 20, iPodTouchUnknown = 21 }
        class iPhoneSettings extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        enum iPhoneTouchPhase
        { Began = 0, Moved = 1, Stationary = 2, Ended = 3, Canceled = 4 }
        class iPhoneTouch extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get fingerId(): number;
            public get position(): UnityEngine.Vector2;
            public get deltaPosition(): UnityEngine.Vector2;
            public get deltaTime(): number;
            public get tapCount(): number;
            public get phase(): UnityEngine.iPhoneTouchPhase;
        }
        enum iPhoneMovieControlMode
        { Full = 0, Minimal = 1, CancelOnTouch = 2, Hidden = 3, VolumeOnly = 4 }
        enum iPhoneMovieScalingMode
        { None = 0, AspectFit = 1, AspectFill = 2, Fill = 3 }
        class iPhoneUtils extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        enum iPhoneKeyboardType
        { Default = 0, ASCIICapable = 1, NumbersAndPunctuation = 2, URL = 3, NumberPad = 4, PhonePad = 5, NamePhonePad = 6, EmailAddress = 7 }
        class iPhoneKeyboard extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get text(): string;
            public set text(value: string);
            public static get hideInput(): boolean;
            public static set hideInput(value: boolean);
            public get active(): boolean;
            public set active(value: boolean);
            public get done(): boolean;
            public static get area(): UnityEngine.Rect;
            public static get visible(): boolean;
            public constructor ()
        }
        class iPhoneAccelerationEvent extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get acceleration(): UnityEngine.Vector3;
            public get deltaTime(): number;
        }
        enum iPhoneOrientation
        { Unknown = 0, Portrait = 1, PortraitUpsideDown = 2, LandscapeLeft = 3, LandscapeRight = 4, FaceUp = 5, FaceDown = 6 }
        class iPhoneInput extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get accelerationEvents(): System.Array$1<UnityEngine.iPhoneAccelerationEvent>;
            public static get touches(): System.Array$1<UnityEngine.iPhoneTouch>;
            public static get touchCount(): number;
            public static get multiTouchEnabled(): boolean;
            public static set multiTouchEnabled(value: boolean);
            public static get accelerationEventCount(): number;
            public static get acceleration(): UnityEngine.Vector3;
            public static GetTouch ($index: number) : UnityEngine.iPhoneTouch
            public static GetAccelerationEvent ($index: number) : UnityEngine.iPhoneAccelerationEvent
            public constructor ()
        }
        class iPhone extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get generation(): UnityEngine.iPhoneGeneration;
            public static get vendorIdentifier(): string;
            public static get advertisingIdentifier(): string;
            public static get advertisingTrackingEnabled(): boolean;
            public static SetNoBackupFlag ($path: string) : void
            public static ResetNoBackupFlag ($path: string) : void
            public constructor ()
        }
        enum iOSActivityIndicatorStyle
        { DontShow = 0, WhiteLarge = 1, White = 2, Gray = 3 }
        class ADBannerView extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get loaded(): boolean;
            public get visible(): boolean;
            public set visible(value: boolean);
            public get layout(): UnityEngine.ADBannerView.Layout;
            public set layout(value: UnityEngine.ADBannerView.Layout);
            public get position(): UnityEngine.Vector2;
            public set position(value: UnityEngine.Vector2);
            public get size(): UnityEngine.Vector2;
            public static add_onBannerWasClicked ($value: UnityEngine.ADBannerView.BannerWasClickedDelegate) : void
            public static remove_onBannerWasClicked ($value: UnityEngine.ADBannerView.BannerWasClickedDelegate) : void
            public static add_onBannerWasLoaded ($value: UnityEngine.ADBannerView.BannerWasLoadedDelegate) : void
            public static remove_onBannerWasLoaded ($value: UnityEngine.ADBannerView.BannerWasLoadedDelegate) : void
            public static IsAvailable ($type: UnityEngine.ADBannerView.Type) : boolean
            public constructor ($type: UnityEngine.ADBannerView.Type, $layout: UnityEngine.ADBannerView.Layout)
        }
        class ADInterstitialAd extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get isAvailable(): boolean;
            public get loaded(): boolean;
            public static add_onInterstitialWasLoaded ($value: UnityEngine.ADInterstitialAd.InterstitialWasLoadedDelegate) : void
            public static remove_onInterstitialWasLoaded ($value: UnityEngine.ADInterstitialAd.InterstitialWasLoadedDelegate) : void
            public Show () : void
            public ReloadAd () : void
            public constructor ($autoReload: boolean)
            public constructor ()
        }
        /** Initializes a new instance of the Logger.
        */
        class Logger extends System.Object implements UnityEngine.ILogger, UnityEngine.ILogHandler
        {
            protected [__keep_incompatibility]: never;
            /** Set  Logger.ILogHandler.
            */
            public get logHandler(): UnityEngine.ILogHandler;
            public set logHandler(value: UnityEngine.ILogHandler);
            /** To runtime toggle debug logging [ON/OFF].
            */
            public get logEnabled(): boolean;
            public set logEnabled(value: boolean);
            /** To selective enable debug log message.
            */
            public get filterLogType(): UnityEngine.LogType;
            public set filterLogType(value: UnityEngine.LogType);
            /** Check logging is enabled based on the LogType.
            * @param $logType The type of the log message.
            * @returns Retrun true in case logs of LogType will be logged otherwise returns false. 
            */
            public IsLogTypeAllowed ($logType: UnityEngine.LogType) : boolean
            /** Logs message to the Unity Console using default logger.
            * @param $logType The type of the log message.
            * @param $tag Used to identify the source of a log message. It usually identifies the class where the log call occurs.
            * @param $message String or object to be converted to string representation for display.
            * @param $context Object to which the message applies.
            */
            public Log ($logType: UnityEngine.LogType, $message: any) : void
            /** Logs message to the Unity Console using default logger.
            * @param $logType The type of the log message.
            * @param $tag Used to identify the source of a log message. It usually identifies the class where the log call occurs.
            * @param $message String or object to be converted to string representation for display.
            * @param $context Object to which the message applies.
            */
            public Log ($logType: UnityEngine.LogType, $message: any, $context: UnityEngine.Object) : void
            /** Logs message to the Unity Console using default logger.
            * @param $logType The type of the log message.
            * @param $tag Used to identify the source of a log message. It usually identifies the class where the log call occurs.
            * @param $message String or object to be converted to string representation for display.
            * @param $context Object to which the message applies.
            */
            public Log ($logType: UnityEngine.LogType, $tag: string, $message: any) : void
            /** Logs message to the Unity Console using default logger.
            * @param $logType The type of the log message.
            * @param $tag Used to identify the source of a log message. It usually identifies the class where the log call occurs.
            * @param $message String or object to be converted to string representation for display.
            * @param $context Object to which the message applies.
            */
            public Log ($logType: UnityEngine.LogType, $tag: string, $message: any, $context: UnityEngine.Object) : void
            /** Logs message to the Unity Console using default logger.
            * @param $logType The type of the log message.
            * @param $tag Used to identify the source of a log message. It usually identifies the class where the log call occurs.
            * @param $message String or object to be converted to string representation for display.
            * @param $context Object to which the message applies.
            */
            public Log ($message: any) : void
            /** Logs message to the Unity Console using default logger.
            * @param $logType The type of the log message.
            * @param $tag Used to identify the source of a log message. It usually identifies the class where the log call occurs.
            * @param $message String or object to be converted to string representation for display.
            * @param $context Object to which the message applies.
            */
            public Log ($tag: string, $message: any) : void
            /** Logs message to the Unity Console using default logger.
            * @param $logType The type of the log message.
            * @param $tag Used to identify the source of a log message. It usually identifies the class where the log call occurs.
            * @param $message String or object to be converted to string representation for display.
            * @param $context Object to which the message applies.
            */
            public Log ($tag: string, $message: any, $context: UnityEngine.Object) : void
            /** A variant of Logger.Log that logs an warning message.
            * @param $tag Used to identify the source of a log message. It usually identifies the class where the log call occurs.
            * @param $message String or object to be converted to string representation for display.
            * @param $context Object to which the message applies.
            */
            public LogWarning ($tag: string, $message: any) : void
            /** A variant of Logger.Log that logs an warning message.
            * @param $tag Used to identify the source of a log message. It usually identifies the class where the log call occurs.
            * @param $message String or object to be converted to string representation for display.
            * @param $context Object to which the message applies.
            */
            public LogWarning ($tag: string, $message: any, $context: UnityEngine.Object) : void
            /** A variant of Logger.Log that logs an error message.
            * @param $tag Used to identify the source of a log message. It usually identifies the class where the log call occurs.
            * @param $message String or object to be converted to string representation for display.
            * @param $context Object to which the message applies.
            */
            public LogError ($tag: string, $message: any) : void
            /** A variant of Logger.Log that logs an error message.
            * @param $tag Used to identify the source of a log message. It usually identifies the class where the log call occurs.
            * @param $message String or object to be converted to string representation for display.
            * @param $context Object to which the message applies.
            */
            public LogError ($tag: string, $message: any, $context: UnityEngine.Object) : void
            /** A variant of Logger.Log that logs an exception message.
            * @param $exception Runtime Exception.
            * @param $context Object to which the message applies.
            */
            public LogException ($exception: System.Exception) : void
            /** A variant of Logger.Log that logs an exception message.
            * @param $exception Runtime Exception.
            * @param $context Object to which the message applies.
            */
            public LogException ($exception: System.Exception, $context: UnityEngine.Object) : void
            /** Logs a formatted message.
            * @param $logType The type of the log message.
            * @param $context Object to which the message applies.
            * @param $format A composite format string.
            * @param $args Format arguments.
            */
            public LogFormat ($logType: UnityEngine.LogType, $format: string, ...args: any[]) : void
            /** Logs a formatted message.
            * @param $logType The type of the log message.
            * @param $context Object to which the message applies.
            * @param $format A composite format string.
            * @param $args Format arguments.
            */
            public LogFormat ($logType: UnityEngine.LogType, $context: UnityEngine.Object, $format: string, ...args: any[]) : void
            public constructor ($logHandler: UnityEngine.ILogHandler)
        }
        /** A collection of common color functions.
        */
        class ColorUtility extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Attempts to convert a html color string.
            * @param $htmlString Case insensitive html string to be converted into a color.
            * @param $color The converted color.
            * @returns True if the string was successfully converted else false. 
            */
            public static TryParseHtmlString ($htmlString: string, $color: $Ref<UnityEngine.Color>) : boolean
            /** Returns the color as a hexadecimal string in the format "RRGGBB".
            * @param $color The color to be converted.
            * @returns Hexadecimal string representing the color. 
            */
            public static ToHtmlStringRGB ($color: UnityEngine.Color) : string
            /** Returns the color as a hexadecimal string in the format "RRGGBBAA".
            * @param $color The color to be converted.
            * @returns Hexadecimal string representing the color. 
            */
            public static ToHtmlStringRGBA ($color: UnityEngine.Color) : string
            public constructor ()
        }
        /** Color key used by Gradient.
        */
        class GradientColorKey extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Color of key.
            */
            public color : UnityEngine.Color
            /** Time of the key (0 - 1).
            */
            public time : number
            public constructor ($col: UnityEngine.Color, $time: number)
        }
        /** Alpha key used by Gradient.
        */
        class GradientAlphaKey extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Alpha channel of key.
            */
            public alpha : number
            /** Time of the key (0 - 1).
            */
            public time : number
            public constructor ($alpha: number, $time: number)
        }
        /** Color interpolation mode used by Gradient.
        */
        enum GradientMode
        { Blend = 0, Fixed = 1, PerceptualBlend = 2 }
        /** This struct contains the view space coordinates of the near projection plane.
        */
        class FrustumPlanes extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Position in view space of the left side of the near projection plane.
            */
            public left : number
            /** Position in view space of the right side of the near projection plane.
            */
            public right : number
            /** Position in view space of the bottom side of the near projection plane.
            */
            public bottom : number
            /** Position in view space of the top side of the near projection plane.
            */
            public top : number
            /** Z distance from the origin of view space to the near projection plane.
            */
            public zNear : number
            /** Z distance from the origin of view space to the far projection plane.
            */
            public zFar : number
        }
        /** A collection of common math functions.
        */
        class Mathf extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The well-known 3.14159265358979... value (Read Only).
            */
            public static PI : number
            /** A representation of positive infinity (Read Only).
            */
            public static Infinity : number
            /** A representation of negative infinity (Read Only).
            */
            public static NegativeInfinity : number
            /** Degrees-to-radians conversion constant (Read Only).
            */
            public static Deg2Rad : number
            /** Radians-to-degrees conversion constant (Read Only).
            */
            public static Rad2Deg : number
            /** A tiny floating point value (Read Only).
            */
            public static Epsilon : number
            /** Converts the given value from gamma (sRGB) to linear color space.
            */
            public static GammaToLinearSpace ($value: number) : number
            /** Converts the given value from linear to gamma (sRGB) color space.
            */
            public static LinearToGammaSpace ($value: number) : number
            /** Convert a color temperature in Kelvin to RGB color.
            * @param $kelvin Temperature in Kelvin. Range 1000 to 40000 Kelvin.
            * @returns Correlated Color Temperature as floating point RGB color. 
            */
            public static CorrelatedColorTemperatureToRGB ($kelvin: number) : UnityEngine.Color
            /** Encode a floating point value into a 16-bit representation.
            * @param $val The floating point value to convert.
            * @returns The converted half-precision float, stored in a 16-bit unsigned integer. 
            */
            public static FloatToHalf ($val: number) : number
            /** Convert a half precision float to a 32-bit floating point value.
            * @param $val The half precision value to convert.
            * @returns The decoded 32-bit float. 
            */
            public static HalfToFloat ($val: number) : number
            /** Generate 2D Perlin noise.
            * @param $x X-coordinate of sample point.
            * @param $y Y-coordinate of sample point.
            * @returns Value between 0.0 and 1.0. (Return value might be slightly below 0.0 or beyond 1.0.) 
            */
            public static PerlinNoise ($x: number, $y: number) : number
            /** Generates a 1D pseudo-random pattern of float values across a 2D plane.
            * @param $x The X-coordinate of the given sample point.
            * @returns A value in the range of 0.0 and 1.0. The value might be slightly higher or lower than this range. 
            */
            public static PerlinNoise1D ($x: number) : number
            /** Returns the sine of angle f.
            * @param $f The input angle, in radians.
            * @returns The return value between -1 and +1. 
            */
            public static Sin ($f: number) : number
            /** Returns the cosine of angle f.
            * @param $f The input angle, in radians.
            * @returns The return value between -1 and 1. 
            */
            public static Cos ($f: number) : number
            /** Returns the tangent of angle f in radians.
            */
            public static Tan ($f: number) : number
            /** Returns the arc-sine of f - the angle in radians whose sine is f.
            */
            public static Asin ($f: number) : number
            /** Returns the arc-cosine of f - the angle in radians whose cosine is f.
            */
            public static Acos ($f: number) : number
            /** Returns the arc-tangent of f - the angle in radians whose tangent is f.
            */
            public static Atan ($f: number) : number
            /** Returns the angle in radians whose Tan is y/x.
            */
            public static Atan2 ($y: number, $x: number) : number
            /** Returns square root of f.
            */
            public static Sqrt ($f: number) : number
            /** Returns the absolute value of f.
            */
            public static Abs ($f: number) : number
            /** Returns the absolute value of value.
            */
            public static Abs ($value: number) : number
            /** Returns the smallest of two or more values.
            */
            public static Min ($a: number, $b: number) : number
            /** Returns the smallest of two or more values.
            */
            public static Min (...values: number[]) : number
            /** Returns the largest of two or more values. When comparing negative values, values closer to zero are considered larger.
            */
            public static Max ($a: number, $b: number) : number
            /** Returns the largest of two or more values. When comparing negative values, values closer to zero are considered larger.
            */
            public static Max (...values: number[]) : number
            /** Returns f raised to power p.
            */
            public static Pow ($f: number, $p: number) : number
            /** Returns e raised to the specified power.
            */
            public static Exp ($power: number) : number
            /** Returns the logarithm of a specified number in a specified base.
            */
            public static Log ($f: number, $p: number) : number
            /** Returns the natural (base e) logarithm of a specified number.
            */
            public static Log ($f: number) : number
            /** Returns the base 10 logarithm of a specified number.
            */
            public static Log10 ($f: number) : number
            /** Returns the smallest integer greater than or equal to f.
            */
            public static Ceil ($f: number) : number
            /** Returns the largest integer smaller than or equal to f.
            */
            public static Floor ($f: number) : number
            /** Returns f rounded to the nearest integer.
            */
            public static Round ($f: number) : number
            /** Returns the smallest integer greater to or equal to f.
            */
            public static CeilToInt ($f: number) : number
            /** Returns the largest integer smaller to or equal to f.
            */
            public static FloorToInt ($f: number) : number
            /** Returns f rounded to the nearest integer.
            */
            public static RoundToInt ($f: number) : number
            /** Returns the sign of f.
            */
            public static Sign ($f: number) : number
            /** Clamps the given value between the given minimum float and maximum float values.  Returns the given value if it is within the minimum and maximum range.
            * @param $value The floating point value to restrict inside the range defined by the minimum and maximum values.
            * @param $min The minimum floating point value to compare against.
            * @param $max The maximum floating point value to compare against.
            * @returns The float result between the minimum and maximum values. 
            */
            public static Clamp ($value: number, $min: number, $max: number) : number
            /** Clamps value between 0 and 1 and returns value.
            */
            public static Clamp01 ($value: number) : number
            /** Linearly interpolates between a and b by t.
            * @param $a The start value.
            * @param $b The end value.
            * @param $t The interpolation value between the two floats.
            * @returns The interpolated float result between the two float values. 
            */
            public static Lerp ($a: number, $b: number, $t: number) : number
            /** Linearly interpolates between a and b by t with no limit to t.
            * @param $a The start value.
            * @param $b The end value.
            * @param $t The interpolation between the two floats.
            * @returns The float value as a result from the linear interpolation. 
            */
            public static LerpUnclamped ($a: number, $b: number, $t: number) : number
            /** Same as Lerp but makes sure the values interpolate correctly when they wrap around 360 degrees.
            * @param $a The start angle. A float expressed in degrees.
            * @param $b The end angle. A float expressed in degrees.
            * @param $t The interpolation value between the start and end angles. This value is clamped to the range [0, 1].
            * @returns Returns the interpolated float result between angle a and angle b, based on the interpolation value t. 
            */
            public static LerpAngle ($a: number, $b: number, $t: number) : number
            /** Moves a value current towards target.
            * @param $current The current value.
            * @param $target The value to move towards.
            * @param $maxDelta The maximum change applied to the current value.
            */
            public static MoveTowards ($current: number, $target: number, $maxDelta: number) : number
            /** Same as MoveTowards but makes sure the values interpolate correctly when they wrap around 360 degrees.
            */
            public static MoveTowardsAngle ($current: number, $target: number, $maxDelta: number) : number
            /** Interpolates between from and to with smoothing at the limits.
            * @param $from The start of the range.
            * @param $to The end of the range.
            * @param $t The interpolation value between the from and to range limits.
            * @returns The interpolated float result between from and to. 
            */
            public static SmoothStep ($from: number, $to: number, $t: number) : number
            public static Gamma ($value: number, $absmax: number, $gamma: number) : number
            /** Compares two floating point values and returns true if they are similar.
            */
            public static Approximately ($a: number, $b: number) : boolean
            /** Gradually changes a value towards a desired goal over time.
            * @param $current The current position.
            * @param $target The target position.
            * @param $currentVelocity The current velocity. This method modifies the currentVelocity every time it is called.
            * @param $smoothTime The approximate time it takes to reach the target position. The lower the value the faster this method reaches the target. The minimum value is 0.0001. If a lower value is specified, it is automatically clamped to this minimum value.
            * @param $maxSpeed Use this optional parameter to specify a maximum speed. By default, the maximum speed is set to infinity.
            * @param $deltaTime The time since this method was last called. By default, this is set to `Time.deltaTime`.
            */
            public static SmoothDamp ($current: number, $target: number, $currentVelocity: $Ref<number>, $smoothTime: number, $maxSpeed: number) : number
            /** Gradually changes a value towards a desired goal over time.
            * @param $current The current position.
            * @param $target The target position.
            * @param $currentVelocity The current velocity. This method modifies the currentVelocity every time it is called.
            * @param $smoothTime The approximate time it takes to reach the target position. The lower the value the faster this method reaches the target. The minimum value is 0.0001. If a lower value is specified, it is automatically clamped to this minimum value.
            * @param $maxSpeed Use this optional parameter to specify a maximum speed. By default, the maximum speed is set to infinity.
            * @param $deltaTime The time since this method was last called. By default, this is set to `Time.deltaTime`.
            */
            public static SmoothDamp ($current: number, $target: number, $currentVelocity: $Ref<number>, $smoothTime: number) : number
            /** Gradually changes a value towards a desired goal over time.
            * @param $current The current position.
            * @param $target The target position.
            * @param $currentVelocity The current velocity. This method modifies the currentVelocity every time it is called.
            * @param $smoothTime The approximate time it takes to reach the target position. The lower the value the faster this method reaches the target. The minimum value is 0.0001. If a lower value is specified, it is automatically clamped to this minimum value.
            * @param $maxSpeed Use this optional parameter to specify a maximum speed. By default, the maximum speed is set to infinity.
            * @param $deltaTime The time since this method was last called. By default, this is set to `Time.deltaTime`.
            */
            public static SmoothDamp ($current: number, $target: number, $currentVelocity: $Ref<number>, $smoothTime: number, $maxSpeed: number, $deltaTime: number) : number
            /** Gradually changes an angle given in degrees towards a desired goal angle over time.
            * @param $current The current position.
            * @param $target The target position.
            * @param $currentVelocity The current velocity. This method modifies the currentVelocity every time the method is called.
            * @param $smoothTime The approximate time it takes to reach the target position. The lower the value the faster this method reaches the target. The minimum value is 0.0001. If a lower value is specified, it is automatically clamped to this minimum value.
            * @param $maxSpeed Use this optional parameter to specify a maximum speed. By default, the maximum speed is set to infinity.
            * @param $deltaTime The time since this method was last called. By default, this is set to `Time.deltaTime`.
            */
            public static SmoothDampAngle ($current: number, $target: number, $currentVelocity: $Ref<number>, $smoothTime: number, $maxSpeed: number) : number
            /** Gradually changes an angle given in degrees towards a desired goal angle over time.
            * @param $current The current position.
            * @param $target The target position.
            * @param $currentVelocity The current velocity. This method modifies the currentVelocity every time the method is called.
            * @param $smoothTime The approximate time it takes to reach the target position. The lower the value the faster this method reaches the target. The minimum value is 0.0001. If a lower value is specified, it is automatically clamped to this minimum value.
            * @param $maxSpeed Use this optional parameter to specify a maximum speed. By default, the maximum speed is set to infinity.
            * @param $deltaTime The time since this method was last called. By default, this is set to `Time.deltaTime`.
            */
            public static SmoothDampAngle ($current: number, $target: number, $currentVelocity: $Ref<number>, $smoothTime: number) : number
            /** Gradually changes an angle given in degrees towards a desired goal angle over time.
            * @param $current The current position.
            * @param $target The target position.
            * @param $currentVelocity The current velocity. This method modifies the currentVelocity every time the method is called.
            * @param $smoothTime The approximate time it takes to reach the target position. The lower the value the faster this method reaches the target. The minimum value is 0.0001. If a lower value is specified, it is automatically clamped to this minimum value.
            * @param $maxSpeed Use this optional parameter to specify a maximum speed. By default, the maximum speed is set to infinity.
            * @param $deltaTime The time since this method was last called. By default, this is set to `Time.deltaTime`.
            */
            public static SmoothDampAngle ($current: number, $target: number, $currentVelocity: $Ref<number>, $smoothTime: number, $maxSpeed: number, $deltaTime: number) : number
            /** Loops the value t, so that it is never larger than length and never smaller than 0.
            */
            public static Repeat ($t: number, $length: number) : number
            /** PingPong returns a value that increments and decrements between zero and the length. It follows the triangle wave formula where the bottom is set to zero and the peak is set to length.
            */
            public static PingPong ($t: number, $length: number) : number
            /** Determines where a value lies between two points.
            * @param $a The start of the range.
            * @param $b The end of the range.
            * @param $value The point within the range you want to calculate.
            * @returns A value between zero and one, representing where the "value" parameter falls within the range defined by a and b. 
            */
            public static InverseLerp ($a: number, $b: number, $value: number) : number
            /** Calculates the shortest difference between two angles.
            * @param $current The current angle in degrees.
            * @param $target The target angle in degrees.
            * @returns A value between -179 and 180, in degrees. 
            */
            public static DeltaAngle ($current: number, $target: number) : number
            /** Returns the next power of two that is equal to, or greater than, the argument.
            */
            public static NextPowerOfTwo ($value: number) : number
            /** Returns the closest power of two value.
            */
            public static ClosestPowerOfTwo ($value: number) : number
            /** Returns true if the value is power of two.
            */
            public static IsPowerOfTwo ($value: number) : boolean
        }
        /** Ping any given IP address (given in dot notation).
        */
        class Ping extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Has the ping function completed?
            */
            public get isDone(): boolean;
            /** This property contains the ping time result in milliseconds after isDone returns true.
            */
            public get time(): number;
            /** The IP target of the ping.
            */
            public get ip(): string;
            public DestroyPing () : void
            public constructor ($address: string)
        }
        /** An exception thrown by the PlayerPrefs class in a  web player build.
        */
        class PlayerPrefsException extends System.Exception implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ($error: string)
        }
        /** PlayerPrefs is a class that stores Player preferences between game sessions. It can store string, float and integer values into the user’s platform registry.
        */
        class PlayerPrefs extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Sets a single integer value for the preference identified by the given key. You can use PlayerPrefs.GetInt to retrieve this value.
            */
            public static SetInt ($key: string, $value: number) : void
            /** Returns the value corresponding to key in the preference file if it exists.
            */
            public static GetInt ($key: string, $defaultValue: number) : number
            /** Returns the value corresponding to key in the preference file if it exists.
            */
            public static GetInt ($key: string) : number
            /** Sets the float value of the preference identified by the given key. You can use PlayerPrefs.GetFloat to retrieve this value.
            */
            public static SetFloat ($key: string, $value: number) : void
            /** Returns the value corresponding to key in the preference file if it exists.
            */
            public static GetFloat ($key: string, $defaultValue: number) : number
            /** Returns the value corresponding to key in the preference file if it exists.
            */
            public static GetFloat ($key: string) : number
            /** Sets a single string value for the preference identified by the given key. You can use PlayerPrefs.GetString to retrieve this value. 
            */
            public static SetString ($key: string, $value: string) : void
            /** Returns the value corresponding to key in the preference file if it exists.
            */
            public static GetString ($key: string, $defaultValue: string) : string
            /** Returns the value corresponding to key in the preference file if it exists.
            */
            public static GetString ($key: string) : string
            /** Returns true if the given key exists in PlayerPrefs, otherwise returns false.
            */
            public static HasKey ($key: string) : boolean
            /** Removes the given key from the PlayerPrefs. If the key does not exist, DeleteKey has no impact.
            */
            public static DeleteKey ($key: string) : void
            /** Removes all keys and values from the preferences. Use with caution.
            */
            public static DeleteAll () : void
            /** Saves all modified preferences.
            */
            public static Save () : void
            public constructor ()
        }
        /** Base class to derive custom property attributes from. Use this to create custom attributes for script variables.
        */
        class PropertyAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            /** Optional field to specify the order that multiple DecorationDrawers should be drawn in.
            */
            public get order(): number;
            public set order(value: number);
        }
        /** Base class to derive custom property attributes for collections from. Use this to create custom attributes for array and list variables in scripts.
        */
        class PropertyCollectionAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
        }
        /** Use this attribute to add a context menu to a field that calls a  named method.
        */
        class ContextMenuItemAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            /** The name of the context menu item.
            */
            public name : string
            /** The name of the function that should be called.
            */
            public function : string
            public constructor ($name: string, $function: string)
        }
        /** Use this attribute on enum value declarations to change the display name shown in the Inspector.
        */
        class InspectorNameAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            /** Name to display in the Inspector.
            */
            public displayName : string
            public constructor ($displayName: string)
        }
        /** Specify a tooltip for a field in the Inspector window.
        */
        class TooltipAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            /** The tooltip text.
            */
            public tooltip : string
            public constructor ($tooltip: string)
        }
        /** Use this PropertyAttribute to add some spacing in the Inspector.
        */
        class SpaceAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            /** The spacing in pixels.
            */
            public height : number
            public constructor ()
            public constructor ($height: number)
        }
        /** Use this PropertyAttribute to add a header above some fields in the Inspector.
        */
        class HeaderAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            /** The header text.
            */
            public header : string
            public constructor ($header: string)
        }
        /** Attribute used to make a float or int variable in a script be restricted to a specific range.
        */
        class RangeAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public min : number
            public max : number
            public constructor ($min: number, $max: number)
        }
        /** Attribute used to make a float or int variable in a script be restricted to a specific minimum value.
        */
        class MinAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            /** The minimum allowed value.
            */
            public min : number
            public constructor ($min: number)
        }
        /** Attribute to make a string be edited with a multi-line textfield.
        */
        class MultilineAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public lines : number
            public constructor ()
            public constructor ($lines: number)
        }
        /** Attribute to make a string be edited with a height-flexible and scrollable text area.
        */
        class TextAreaAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            /** The minimum amount of lines the text area will use.
            */
            public minLines : number
            /** The maximum amount of lines the text area can show before it starts using a scrollbar.
            */
            public maxLines : number
            public constructor ()
            public constructor ($minLines: number, $maxLines: number)
        }
        /** Attribute used to configure the usage of the ColorField and Color Picker for a color.
        */
        class ColorUsageAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            /** If false then the alpha bar is hidden in the ColorField and the alpha value is not shown in the Color Picker.
            */
            public showAlpha : boolean
            /** If set to true the Color is treated as a HDR color.
            */
            public hdr : boolean
            public constructor ($showAlpha: boolean)
            public constructor ($showAlpha: boolean, $hdr: boolean)
        }
        /** Controls how the Gradient inspector editor treats the color values.
        */
        class GradientUsageAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            /** If set to true the Gradient uses HDR colors.
            */
            public hdr : boolean
            /** The color space the Gradient uses.
            */
            public colorSpace : UnityEngine.ColorSpace
            public constructor ($hdr: boolean)
            public constructor ($hdr: boolean, $colorSpace: UnityEngine.ColorSpace)
        }
        /** Attribute used to make a float, int, or string variable in a script be delayed.
        */
        class DelayedAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Disables reordering of an array or list in the Inspector window.
        */
        class NonReorderableAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Easily generate random data for games.
        */
        class Random extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Gets or sets the full internal state of the random number generator.
            */
            public static get state(): UnityEngine.Random.State;
            public static set state(value: UnityEngine.Random.State);
            /** Returns a random float within [0.0..1.0] (range is inclusive) (Read Only).
            */
            public static get value(): number;
            /** Returns a random point inside or on a sphere with radius 1.0 (Read Only).
            */
            public static get insideUnitSphere(): UnityEngine.Vector3;
            /** Returns a random point inside or on a circle with radius 1.0 (Read Only).
            */
            public static get insideUnitCircle(): UnityEngine.Vector2;
            /** Returns a random point on the surface of a sphere with radius 1.0 (Read Only).
            */
            public static get onUnitSphere(): UnityEngine.Vector3;
            /** Returns a random rotation (Read Only).
            */
            public static get rotation(): UnityEngine.Quaternion;
            /** Returns a random rotation with uniform distribution (Read Only).
            */
            public static get rotationUniform(): UnityEngine.Quaternion;
            /** Initializes the random number generator state with a seed.
            * @param $seed Seed used to initialize the random number generator.
            */
            public static InitState ($seed: number) : void
            /** Returns a random float within [minInclusive..maxInclusive] (range is inclusive).
            */
            public static Range ($minInclusive: number, $maxInclusive: number) : number
            /** Return a random int within [minInclusive..maxExclusive) (Read Only).
            */
            public static Range ($minInclusive: number, $maxExclusive: number) : number
            /** Generates a random color from HSV and alpha ranges.
            * @param $hueMin Minimum hue [0..1].
            * @param $hueMax Maximum hue [0..1].
            * @param $saturationMin Minimum saturation [0..1].
            * @param $saturationMax Maximum saturation [0..1].
            * @param $valueMin Minimum value [0..1].
            * @param $valueMax Maximum value [0..1].
            * @param $alphaMin Minimum alpha [0..1].
            * @param $alphaMax Maximum alpha [0..1].
            * @returns A random color with HSV and alpha values in the (inclusive) input ranges. Values for each component are derived via linear interpolation of value. 
            */
            public static ColorHSV () : UnityEngine.Color
            /** Generates a random color from HSV and alpha ranges.
            * @param $hueMin Minimum hue [0..1].
            * @param $hueMax Maximum hue [0..1].
            * @param $saturationMin Minimum saturation [0..1].
            * @param $saturationMax Maximum saturation [0..1].
            * @param $valueMin Minimum value [0..1].
            * @param $valueMax Maximum value [0..1].
            * @param $alphaMin Minimum alpha [0..1].
            * @param $alphaMax Maximum alpha [0..1].
            * @returns A random color with HSV and alpha values in the (inclusive) input ranges. Values for each component are derived via linear interpolation of value. 
            */
            public static ColorHSV ($hueMin: number, $hueMax: number) : UnityEngine.Color
            /** Generates a random color from HSV and alpha ranges.
            * @param $hueMin Minimum hue [0..1].
            * @param $hueMax Maximum hue [0..1].
            * @param $saturationMin Minimum saturation [0..1].
            * @param $saturationMax Maximum saturation [0..1].
            * @param $valueMin Minimum value [0..1].
            * @param $valueMax Maximum value [0..1].
            * @param $alphaMin Minimum alpha [0..1].
            * @param $alphaMax Maximum alpha [0..1].
            * @returns A random color with HSV and alpha values in the (inclusive) input ranges. Values for each component are derived via linear interpolation of value. 
            */
            public static ColorHSV ($hueMin: number, $hueMax: number, $saturationMin: number, $saturationMax: number) : UnityEngine.Color
            /** Generates a random color from HSV and alpha ranges.
            * @param $hueMin Minimum hue [0..1].
            * @param $hueMax Maximum hue [0..1].
            * @param $saturationMin Minimum saturation [0..1].
            * @param $saturationMax Maximum saturation [0..1].
            * @param $valueMin Minimum value [0..1].
            * @param $valueMax Maximum value [0..1].
            * @param $alphaMin Minimum alpha [0..1].
            * @param $alphaMax Maximum alpha [0..1].
            * @returns A random color with HSV and alpha values in the (inclusive) input ranges. Values for each component are derived via linear interpolation of value. 
            */
            public static ColorHSV ($hueMin: number, $hueMax: number, $saturationMin: number, $saturationMax: number, $valueMin: number, $valueMax: number) : UnityEngine.Color
            /** Generates a random color from HSV and alpha ranges.
            * @param $hueMin Minimum hue [0..1].
            * @param $hueMax Maximum hue [0..1].
            * @param $saturationMin Minimum saturation [0..1].
            * @param $saturationMax Maximum saturation [0..1].
            * @param $valueMin Minimum value [0..1].
            * @param $valueMax Maximum value [0..1].
            * @param $alphaMin Minimum alpha [0..1].
            * @param $alphaMax Maximum alpha [0..1].
            * @returns A random color with HSV and alpha values in the (inclusive) input ranges. Values for each component are derived via linear interpolation of value. 
            */
            public static ColorHSV ($hueMin: number, $hueMax: number, $saturationMin: number, $saturationMax: number, $valueMin: number, $valueMax: number, $alphaMin: number, $alphaMax: number) : UnityEngine.Color
        }
        /** Attribute to specify an icon for a MonoBehaviour or ScriptableObject.
        */
        class IconAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            /** A project-relative path to a texture.
            */
            public get path(): string;
            public constructor ($path: string)
        }
        /** Asynchronous load request from the Resources bundle.
        */
        class ResourceRequest extends UnityEngine.AsyncOperation
        {
            protected [__keep_incompatibility]: never;
            /** Asset object being loaded (Read Only).
            */
            public get asset(): UnityEngine.Object;
            public constructor ()
        }
        /** Derive from this base class to provide alternative implementations to the C# behavior of specific Resources methods.
        */
        class ResourcesAPI extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** The specific ResourcesAPI instance to use to handle overridden Resources methods.
            */
            public static get overrideAPI(): UnityEngine.ResourcesAPI;
            public static set overrideAPI(value: UnityEngine.ResourcesAPI);
        }
        /** The Resources class allows you to find and access Objects including assets.
        */
        class Resources extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Returns a list of all objects of Type type.
            */
            public static FindObjectsOfTypeAll ($type: System.Type) : System.Array$1<UnityEngine.Object>
            /** Loads an asset stored at path in a Resources folder using an optional systemTypeInstance filter.
            * @param $path Path to the target resource to load.
            * @param $systemTypeInstance Type filter for objects returned.
            * @returns The requested asset returned as an Object. 
            */
            public static Load ($path: string) : UnityEngine.Object
            /** Loads an asset stored at path in a Resources folder using an optional systemTypeInstance filter.
            * @param $path Path to the target resource to load.
            * @param $systemTypeInstance Type filter for objects returned.
            * @returns The requested asset returned as an Object. 
            */
            public static Load ($path: string, $systemTypeInstance: System.Type) : UnityEngine.Object
            /** Asynchronously loads an asset stored at path in a Resources folder.
            * @param $path Pathname of the target folder. When using the empty string (i.e., ""), the function will load the entire contents of the Resources folder.
            */
            public static LoadAsync ($path: string) : UnityEngine.ResourceRequest
            /** Asynchronously loads an asset stored at path in a Resources folder.
            * @param $path Pathname of the target folder. When using the empty string (i.e., ""), the function will load the entire contents of the Resources folder.
            * @param $systemTypeInstance Type filter for objects returned.
            */
            public static LoadAsync ($path: string, $type: System.Type) : UnityEngine.ResourceRequest
            /** Loads all assets in a folder or file at path in a Resources folder.
            * @param $path Pathname of the target folder. When using the empty string (i.e., ""), the function will load the entire contents of the Resources folder.
            * @param $systemTypeInstance Type filter for objects returned.
            */
            public static LoadAll ($path: string, $systemTypeInstance: System.Type) : System.Array$1<UnityEngine.Object>
            /** Loads all assets in a folder or file at path in a Resources folder.
            * @param $path Pathname of the target folder. When using the empty string (i.e., ""), the function will load the entire contents of the Resources folder.
            */
            public static LoadAll ($path: string) : System.Array$1<UnityEngine.Object>
            public static GetBuiltinResource ($type: System.Type, $path: string) : UnityEngine.Object
            /** Unloads assetToUnload from memory.
            */
            public static UnloadAsset ($assetToUnload: UnityEngine.Object) : void
            /** Unloads assets that are not used.
            * @returns Object on which you can yield to wait until the operation completes. 
            */
            public static UnloadUnusedAssets () : UnityEngine.AsyncOperation
            /** Translates an instance ID to an object reference.
            * @param $instanceID Instance ID of an Object.
            * @returns Resolved reference or null if the instance ID didn't match anything. 
            */
            public static InstanceIDToObject ($instanceID: number) : UnityEngine.Object
            public static InstanceIDToObjectList ($instanceIDs: Unity.Collections.NativeArray$1<number>, $objects: System.Collections.Generic.List$1<UnityEngine.Object>) : void
            /** Returns true if the given instance ID corresponds to a valid Object in memory. The Object could have been deleted or not loaded into memory yet.
            * @param $instanceID ID of an Object.
            */
            public static InstanceIDIsValid ($instanceId: number) : boolean
            public static InstanceIDsToValidArray ($instanceIDs: Unity.Collections.NativeArray$1<number>, $validArray: Unity.Collections.NativeArray$1<boolean>) : void
            public constructor ()
        }
        /** Prevents MonoBehaviour of same type (or subtype) to be added more than once to a GameObject.
        */
        class DisallowMultipleComponent extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** The RequireComponent attribute automatically adds required components as dependencies.
        */
        class RequireComponent extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public m_Type0 : System.Type
            public m_Type1 : System.Type
            public m_Type2 : System.Type
            public constructor ($requiredComponent: System.Type)
            public constructor ($requiredComponent: System.Type, $requiredComponent2: System.Type)
            public constructor ($requiredComponent: System.Type, $requiredComponent2: System.Type, $requiredComponent3: System.Type)
        }
        /** The AddComponentMenu attribute allows you to place a script anywhere in the "Component" menu, instead of just the "Component->Scripts" menu.
        */
        class AddComponentMenu extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get componentMenu(): string;
            /** The order of the component in the component menu (lower values appear higher in the menu).
            */
            public get componentOrder(): number;
            public constructor ($menuName: string)
            public constructor ($menuName: string, $order: number)
        }
        /** Mark a ScriptableObject-derived type to be automatically listed in the Assets/Create submenu, so that instances of the type can be easily created and stored in the project as ".asset" files.
        */
        class CreateAssetMenuAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            /** The display name for this type shown in the Assets/Create menu.
            */
            public get menuName(): string;
            public set menuName(value: string);
            /** The default file name used by newly created instances of this type.
            */
            public get fileName(): string;
            public set fileName(value: string);
            /** The position of the menu item within the Assets/Create menu.
            */
            public get order(): number;
            public set order(value: number);
            public constructor ()
        }
        /** The ContextMenu attribute allows you to add commands to the context menu.
        */
        class ContextMenu extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public menuItem : string
            public validate : boolean
            public priority : number
            public disabledTooltip : string
            public constructor ($itemName: string)
            public constructor ($itemName: string, $isValidateFunction: boolean)
            public constructor ($itemName: string, $isValidateFunction: boolean, $priority: number)
            public constructor ($itemName: string, $isValidateFunction: boolean, $priority: number, $disabledTooltip: string)
        }
        /** Makes all instances of a script execute in Edit Mode.
        */
        class ExecuteInEditMode extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Makes instances of a script always execute, both as part of Play Mode and when editing.
        */
        class ExecuteAlways extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Flags a variable to not appear in the Inspector.
        */
        class HideInInspector extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Marks the methods you want to hide from the Console window callstack. When you hide these methods they are removed from the detail area of the selected message in the Console window.
        */
        class HideInCallstackAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Provide a custom documentation URL for a class.
        */
        class HelpURLAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            /** The documentation URL specified for this class.
            */
            public get URL(): string;
            public constructor ($url: string)
        }
        class DefaultExecutionOrder extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get order(): number;
            public constructor ($order: number)
        }
        /** Assembly level attribute. Any classes in an assembly with this attribute will be considered to be Editor Classes.
        */
        class AssemblyIsEditorAssembly extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Add this attribute to a class to prevent creating a Preset from the instances of the class.
        */
        class ExcludeFromPresetAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Awaitable type used to expose asynchronous code, as well as an async return type specifically tailored for Unity.
        */
        class Awaitable extends System.Object implements System.Collections.IEnumerator
        {
            protected [__keep_incompatibility]: never;
            /** Indicates if the awaitable has run to completion.
            */
            public get IsCompleted(): boolean;
            /** Creates an Awaitable from an existing AsyncOperation object.
            * @param $op Async operation object.
            * @param $cancellationToken Optional cancellation token.
            */
            public static FromAsyncOperation ($op: UnityEngine.AsyncOperation, $cancellationToken?: System.Threading.CancellationToken) : UnityEngine.Awaitable
            public GetAwaiter () : UnityEngine.Awaitable.Awaiter
            /** Cancel the awaitable. If the awaitable is being awaited, the awaiter will get a System.OperationCanceledException.
            */
            public Cancel () : void
            /** Awaitable resuming on next frame.
            * @param $cancellationToken Optional cancellation token.
            */
            public static NextFrameAsync ($cancellationToken?: System.Threading.CancellationToken) : UnityEngine.Awaitable
            /** Awaitable resuming after the specified number of seconds.
            * @param $seconds Seconds to wait for.
            * @param $cancellationToken Optional cancellation token.
            */
            public static WaitForSecondsAsync ($seconds: number, $cancellationToken?: System.Threading.CancellationToken) : UnityEngine.Awaitable
            /** Awaitable resuming on the next fixed update frame (see Time.fixedDeltaTime).
            */
            public static FixedUpdateAsync ($cancellationToken?: System.Threading.CancellationToken) : UnityEngine.Awaitable
            /** Awaitable resuming after all Unity subsystem have run for the current frame.
            * @param $cancellationToken Optional cancellation token used to signal cancellation.
            */
            public static EndOfFrameAsync ($cancellationToken?: System.Threading.CancellationToken) : UnityEngine.Awaitable
            /** Resumes execution on the Unity main thread. If the caller is already on the main thread, it will complete immediately.
            * @returns Awaitable object that completes when switching on the main thread. 
            */
            public static MainThreadAsync () : UnityEngine.MainThreadAwaitable
            /** Resumes execution on a ThreadPool background thread. If the caller is already on a background thread, it will complete immediately.
            * @returns Awaitable object that completes when switching to a background thread. 
            */
            public static BackgroundThreadAsync () : UnityEngine.BackgroundThreadAwaitable
        }
        class MainThreadAwaitable extends System.ValueType implements System.Runtime.CompilerServices.INotifyCompletion
        {
            protected [__keep_incompatibility]: never;
            public get IsCompleted(): boolean;
            public GetAwaiter () : UnityEngine.MainThreadAwaitable
            public GetResult () : void
            public OnCompleted ($continuation: System.Action) : void
        }
        class BackgroundThreadAwaitable extends System.ValueType implements System.Runtime.CompilerServices.INotifyCompletion
        {
            protected [__keep_incompatibility]: never;
            public get IsCompleted(): boolean;
            public GetAwaiter () : UnityEngine.BackgroundThreadAwaitable
            public GetResult () : void
            public OnCompleted ($continuation: System.Action) : void
        }
        class Awaitable$1<T> extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public Cancel () : void
            public GetAwaiter () : UnityEngine.Awaitable$1.Awaiter<T>
        }
        class AsyncOperationAwaitableExtensions extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static GetAwaiter ($op: UnityEngine.AsyncOperation) : UnityEngine.Awaitable.Awaiter
        }
        class UnityEventAwaitableExtensions extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static GetAwaiter ($ev: UnityEngine.Events.UnityEvent) : UnityEngine.Awaitable.Awaiter
        }
        interface ISerializationCallbackReceiver
        {
            /** Implement this method to receive a callback before Unity serializes your object.
            */
            OnBeforeSerialize () : void
            /** Implement this method to receive a callback after Unity deserializes your object.
            */
            OnAfterDeserialize () : void
        }
        /** Objects allowing to control completion of an Awaitable object from user code.
        */
        class AwaitableCompletionSource extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Get the awaitable controlled by the completion source.
            */
            public get Awaitable(): UnityEngine.Awaitable;
            /** Raise completion.
            */
            public SetResult () : void
            /** Raise cancellation.
            */
            public SetCanceled () : void
            /** Raise completion with an exception.
            * @param $exception Exception to raise in the continuation.
            */
            public SetException ($exception: System.Exception) : void
            /** Raise the awaitable completion.
            * @returns Indicates if the completion was successfully raised. 
            */
            public TrySetResult () : boolean
            /** Raise cancellation (returns false if the awaitable was already completed or canceled).
            * @returns Indicates if the cancellation was successfuly raised. 
            */
            public TrySetCanceled () : boolean
            /** Raise completion with an exception.
            * @param $exception Exception to raise in the continuation.
            * @returns Indicates if the completion was successfully raised. 
            */
            public TrySetException ($exception: System.Exception) : boolean
            /** Reset the completion source (this will set the Awaitable property to a new Awaitable object).
            */
            public Reset () : void
            public constructor ()
        }
        class AwaitableCompletionSource$1<T> extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get Awaitable(): UnityEngine.Awaitable$1<T>;
            public SetResult ($value: $Ref<T>) : void
            public SetCanceled () : void
            public SetException ($exception: System.Exception) : void
            public TrySetResult ($value: $Ref<T>) : boolean
            public TrySetCanceled () : boolean
            public TrySetException ($exception: System.Exception) : boolean
            public Reset () : void
            public constructor ()
        }
        /** A handle to one of the tag values that can be applied to a GameObject.
        */
        class TagHandle extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Get a handle to a existing defined tag.
            * @param $tagName The name of the tag to get a handle to.
            * @returns A new TagHandle for the existing tag. 
            */
            public static GetExistingTag ($tagName: string) : UnityEngine.TagHandle
        }
        /** MonoBehaviour.StartCoroutine returns a Coroutine. Instances of this class are only used to reference these coroutines, and do not hold any exposed properties or functions.
        */
        class Coroutine extends UnityEngine.YieldInstruction
        {
            protected [__keep_incompatibility]: never;
        }
        /** Base class for custom yield instructions to suspend coroutines.
        */
        class CustomYieldInstruction extends System.Object implements System.Collections.IEnumerator
        {
            protected [__keep_incompatibility]: never;
            /** Indicates if coroutine should be kept suspended.
            */
            public get keepWaiting(): boolean;
            public get Current(): any;
            public MoveNext () : boolean
            public Reset () : void
        }
        /** Add this attribute to a class to prevent the class and its inherited classes from being created with ObjectFactory methods.
        */
        class ExcludeFromObjectFactoryAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Shows sorted enum values in the Inspector enum UI dropdowns i.e. EditorGUI.EnumPopup, PropertyField etc. This attribute can be applied to enum types only.
        */
        class InspectorOrderAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ($inspectorSort?: UnityEngine.InspectorSort, $sortDirection?: UnityEngine.InspectorSortDirection)
        }
        /** Defines if enum should be shown sorted by name or by value.
        */
        enum InspectorSort
        { ByName = 0, ByValue = 1 }
        /** Defines if enum should be shown in ascending or descending order.
        */
        enum InspectorSortDirection
        { Ascending = 0, Descending = 1 }
        /** Specifies Layers to use in a Physics.Raycast.
        */
        class LayerMask extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Converts a layer mask value to an integer value.
            */
            public get value(): number;
            public set value(value: number);
            public static op_Implicit ($mask: UnityEngine.LayerMask) : number
            public static op_Implicit ($intVal: number) : UnityEngine.LayerMask
            /** Given a layer number, returns the name of the layer as defined in either a Builtin or a User Layer in the.
            */
            public static LayerToName ($layer: number) : string
            /** Given a layer name, returns the layer index as defined by either a Builtin or a User Layer in the.
            */
            public static NameToLayer ($layerName: string) : number
            /** Given a set of layer names as defined by either a Builtin or a User Layer in the, returns the equivalent layer mask for all of them.
            * @param $layerNames List of layer names to convert to a layer mask.
            * @returns The layer mask created from the layerNames. 
            */
            public static GetMask (...layerNames: string[]) : number
        }
        class LazyLoadReference$1<T> extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get isSet(): boolean;
            public get isBroken(): boolean;
            public get asset(): T;
            public set asset(value: T);
            public get instanceID(): number;
            public set instanceID(value: number);
            public static op_Implicit ($asset: any) : any
            public static op_Implicit ($instanceID: any) : any
            public constructor ($asset: T)
            public constructor ($instanceID: number)
        }
        /** MonoBehaviour is a base class that many Unity scripts derive from.
        */
        class MonoBehaviour extends UnityEngine.Behaviour
        {
            protected [__keep_incompatibility]: never;
            /** Cancellation token raised when the MonoBehaviour is destroyed (Read Only).
            */
            public get destroyCancellationToken(): System.Threading.CancellationToken;
            /** Disabling this lets you skip the GUI layout phase.
            */
            public get useGUILayout(): boolean;
            public set useGUILayout(value: boolean);
            /** Returns a boolean value which represents if Start was called.
            */
            public get didStart(): boolean;
            /** Returns a boolean value which represents if Awake was called.
            */
            public get didAwake(): boolean;
            /** Allow a specific instance of a MonoBehaviour to run in edit mode (only available in the editor).
            */
            public get runInEditMode(): boolean;
            public set runInEditMode(value: boolean);
            /** Is any invoke pending on this MonoBehaviour?
            */
            public IsInvoking () : boolean
            /** Cancels all Invoke calls on this MonoBehaviour.
            */
            public CancelInvoke () : void
            /** Invokes the method methodName in time seconds.
            */
            public Invoke ($methodName: string, $time: number) : void
            /** Invokes the method methodName in time seconds, then repeatedly every repeatRate seconds.
            * @param $methodName The name of a method to invoke.
            * @param $time Start invoking after n seconds.
            * @param $repeatRate Repeat every n seconds.
            */
            public InvokeRepeating ($methodName: string, $time: number, $repeatRate: number) : void
            /** Cancels all Invoke calls with name methodName on this behaviour.
            */
            public CancelInvoke ($methodName: string) : void
            /** Is any invoke on methodName pending?
            */
            public IsInvoking ($methodName: string) : boolean
            /** Starts a coroutine named methodName.
            */
            public StartCoroutine ($methodName: string) : UnityEngine.Coroutine
            /** Starts a coroutine named methodName.
            */
            public StartCoroutine ($methodName: string, $value: any) : UnityEngine.Coroutine
            /** Starts a Coroutine.
            */
            public StartCoroutine ($routine: System.Collections.IEnumerator) : UnityEngine.Coroutine
            /** Stops the first coroutine named methodName, or the coroutine stored in routine running on this behaviour.
            * @param $methodName Name of coroutine.
            * @param $routine Name of the function in code, including coroutines.
            */
            public StopCoroutine ($routine: System.Collections.IEnumerator) : void
            /** Stops the first coroutine named methodName, or the coroutine stored in routine running on this behaviour.
            * @param $methodName Name of coroutine.
            * @param $routine Name of the function in code, including coroutines.
            */
            public StopCoroutine ($routine: UnityEngine.Coroutine) : void
            /** Stops the first coroutine named methodName, or the coroutine stored in routine running on this behaviour.
            * @param $methodName Name of coroutine.
            * @param $routine Name of the function in code, including coroutines.
            */
            public StopCoroutine ($methodName: string) : void
            /** Stops all coroutines running on this behaviour.
            */
            public StopAllCoroutines () : void
            /** Logs message to the Unity Console (identical to Debug.Log).
            */
            public static print ($message: any) : void
            public constructor ()
        }
        /** Describes an integer range.
        */
        class RangeInt extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The starting index of the range, where 0 is the first position, 1 is the second, 2 is the third, and so on.
            */
            public start : number
            /** The length of the range.
            */
            public length : number
            /** The end index of the range (not inclusive).
            */
            public get end(): number;
            public constructor ($start: number, $length: number)
        }
        /** Specifies when to get a callback during the startup of the runtime or when entering play mode in the Editor. Used with RuntimeInitializeOnLoadMethodAttribute.
        */
        enum RuntimeInitializeLoadType
        { AfterSceneLoad = 0, BeforeSceneLoad = 1, AfterAssembliesLoaded = 2, BeforeSplashScreen = 3, SubsystemRegistration = 4 }
        /** Use this attribute to get a callback when the runtime is starting up and loading the first scene.
        */
        class RuntimeInitializeOnLoadMethodAttribute extends UnityEngine.Scripting.PreserveAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            /** Controling the callback invocation time.
            */
            public get loadType(): UnityEngine.RuntimeInitializeLoadType;
            public constructor ()
            public constructor ($loadType: UnityEngine.RuntimeInitializeLoadType)
        }
        /** Add this attribute to a script class to mark its GameObject as a selection base object for Scene View picking.
        */
        class SelectionBaseAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class StackTraceUtility extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static ExtractStackTrace () : string
            public static ExtractStringFromException ($exception: any) : string
        }
        class UnityException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class MissingComponentException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class UnassignedReferenceException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class MissingReferenceException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        /** Represents a raw text or binary file asset.
        */
        class TextAsset extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** The raw bytes of the text asset. (Read Only)
            */
            public get bytes(): System.Array$1<number>;
            /** The text contents of the file as a string. (Read Only)
            */
            public get text(): string;
            /** The size of the text asset data in bytes. (Read Only)
            */
            public get dataSize(): bigint;
            public constructor ()
            public constructor ($text: string)
        }
        class TrackedReference extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static op_Equality ($x: UnityEngine.TrackedReference, $y: UnityEngine.TrackedReference) : boolean
            public static op_Inequality ($x: UnityEngine.TrackedReference, $y: UnityEngine.TrackedReference) : boolean
            public static op_Implicit ($exists: UnityEngine.TrackedReference) : boolean
        }
        /** Declares an assembly to be compatible (API wise) with a specific Unity API. Used by internal tools to avoid processing the assembly in order to decide whether assemblies may be using old Unity API.
        */
        class UnityAPICompatibilityVersionAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            /** Version of Unity API.
            */
            public get version(): string;
            public constructor ($version: string, $checkOnlyUnityVersion: boolean)
            public constructor ($version: string, $configurationAssembliesHashes: System.Array$1<string>)
        }
        /** Bit mask that controls object destruction, saving and visibility in inspectors.
        */
        enum HideFlags
        { None = 0, HideInHierarchy = 1, HideInInspector = 2, DontSaveInEditor = 4, NotEditable = 8, DontSaveInBuild = 16, DontUnloadUnusedAsset = 32, DontSave = 52, HideAndDontSave = 61 }
        /** Options to specify if and how to sort objects returned by a function.
        */
        enum FindObjectsSortMode
        { None = 0, InstanceID = 1 }
        /** Options to control whether object find functions return inactive objects.
        */
        enum FindObjectsInactive
        { Exclude = 0, Include = 1 }
        /** Waits until the end of the frame after Unity has rendered every Camera and GUI, just before displaying the frame on screen.
        */
        class WaitForEndOfFrame extends UnityEngine.YieldInstruction
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Waits until next fixed frame rate update function. Additional resources: MonoBehaviour.FixedUpdate.
        */
        class WaitForFixedUpdate extends UnityEngine.YieldInstruction
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Suspends the coroutine execution for the given amount of seconds using scaled time.
        */
        class WaitForSeconds extends UnityEngine.YieldInstruction
        {
            protected [__keep_incompatibility]: never;
            public constructor ($seconds: number)
            public constructor ()
        }
        /** Suspends the coroutine execution for the given amount of seconds using unscaled time.
        */
        class WaitForSecondsRealtime extends UnityEngine.CustomYieldInstruction implements System.Collections.IEnumerator
        {
            protected [__keep_incompatibility]: never;
            /** The given amount of seconds that the yield instruction will wait for.
            */
            public get waitTime(): number;
            public set waitTime(value: number);
            public get keepWaiting(): boolean;
            public constructor ($time: number)
        }
        /** Suspends the coroutine execution until the supplied delegate evaluates to true.
        */
        class WaitUntil extends UnityEngine.CustomYieldInstruction implements System.Collections.IEnumerator
        {
            protected [__keep_incompatibility]: never;
            public get keepWaiting(): boolean;
            public constructor ($predicate: System.Func$1<boolean>)
        }
        /** Suspends the coroutine execution until the supplied delegate evaluates to false.
        */
        class WaitWhile extends UnityEngine.CustomYieldInstruction implements System.Collections.IEnumerator
        {
            protected [__keep_incompatibility]: never;
            public get keepWaiting(): boolean;
            public constructor ($predicate: System.Func$1<boolean>)
        }
        /** Webplayer security related class. Not supported from 5.4.0 onwards.
        */
        class Security extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class Types extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        /** Force Unity to serialize a private field.
        */
        class SerializeField extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** A that instructs Unity to serialize a field as a reference instead of as a value.
        */
        class SerializeReference extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Prefer ScriptableObject derived type to use binary serialization regardless of project's asset serialization mode.
        */
        class PreferBinarySerialization extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Compute Shader asset.
        */
        class ComputeShader extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** The local keyword space of this compute shader.
            */
            public get keywordSpace(): UnityEngine.Rendering.LocalKeywordSpace;
            /** An array containing names of the local shader keywords that are currently enabled for this compute shader.
            */
            public get shaderKeywords(): System.Array$1<string>;
            public set shaderKeywords(value: System.Array$1<string>);
            /** An array containing the local shader keywords that are currently enabled for this compute shader.
            */
            public get enabledKeywords(): System.Array$1<UnityEngine.Rendering.LocalKeyword>;
            public set enabledKeywords(value: System.Array$1<UnityEngine.Rendering.LocalKeyword>);
            /** Find ComputeShader kernel index.
            * @param $name Name of kernel function.
            * @returns The Kernel index. If the kernel is not found, Unity logs a "FindKernel failed" error message and raises an ArgumentException. 
            */
            public FindKernel ($name: string) : number
            /** Checks whether a shader contains a given kernel.
            * @param $name The name of the kernel to look for.
            * @returns True if the kernel is found, false otherwise. 
            */
            public HasKernel ($name: string) : boolean
            /** Set a float parameter.
            * @param $name Variable name in shader code.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $val Value to set.
            */
            public SetFloat ($nameID: number, $val: number) : void
            /** Set an integer parameter.
            * @param $name Variable name in shader code.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $val Value to set.
            */
            public SetInt ($nameID: number, $val: number) : void
            /** Set a vector parameter.
            * @param $name Variable name in shader code.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $val Value to set.
            */
            public SetVector ($nameID: number, $val: UnityEngine.Vector4) : void
            /** Set a Matrix parameter.
            * @param $name Variable name in shader code.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $val Value to set.
            */
            public SetMatrix ($nameID: number, $val: UnityEngine.Matrix4x4) : void
            /** Set a vector array parameter.
            * @param $name Variable name in shader code.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $values Value to set.
            */
            public SetVectorArray ($nameID: number, $values: System.Array$1<UnityEngine.Vector4>) : void
            /** Set a Matrix array parameter.
            * @param $name Variable name in shader code.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $values Value to set.
            */
            public SetMatrixArray ($nameID: number, $values: System.Array$1<UnityEngine.Matrix4x4>) : void
            /** Set a texture parameter.
            * @param $kernelIndex For which kernel the texture is being set. See FindKernel.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $name Name of the buffer variable in shader code.
            * @param $texture Texture to set.
            * @param $mipLevel Optional mipmap level of the read-write texture.
            * @param $element Optional parameter that specifies the type of data to set from the RenderTexture.
            */
            public SetTexture ($kernelIndex: number, $nameID: number, $texture: UnityEngine.Texture, $mipLevel: number) : void
            /** Set a texture parameter from a global texture property.
            * @param $kernelIndex For which kernel the texture is being set. See FindKernel.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $name Name of the buffer variable in shader code.
            * @param $globalTextureName Global texture property to assign to shader.
            * @param $globalTextureNameID Property name ID, use Shader.PropertyToID to get it.
            */
            public SetTextureFromGlobal ($kernelIndex: number, $nameID: number, $globalTextureNameID: number) : void
            /** Sets a RayTracingAccelerationStructure to be used for Inline Ray Tracing (Ray Queries).
            * @param $kernelIndex For which kernel the RayTracingAccelerationStructure is being set. See FindKernel.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $accelerationStructure The RayTracingAccelerationStructure object to bind.
            * @param $name Resource name in shader code.
            */
            public SetRayTracingAccelerationStructure ($kernelIndex: number, $nameID: number, $accelerationStructure: UnityEngine.Rendering.RayTracingAccelerationStructure) : void
            /** Sets an input or output compute buffer.
            * @param $kernelIndex For which kernel the buffer is being set. See FindKernel.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $name Name of the buffer variable in shader code.
            * @param $buffer Buffer to set.
            */
            public SetBuffer ($kernelIndex: number, $nameID: number, $buffer: UnityEngine.ComputeBuffer) : void
            /** Sets an input or output compute buffer.
            * @param $kernelIndex For which kernel the buffer is being set. See FindKernel.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $name Name of the buffer variable in shader code.
            * @param $buffer Buffer to set.
            */
            public SetBuffer ($kernelIndex: number, $nameID: number, $buffer: UnityEngine.GraphicsBuffer) : void
            /** Get kernel thread group sizes.
            * @param $kernelIndex Which kernel to query. A single compute shader asset can have multiple kernel entry points.
            * @param $x Thread group size in the X dimension.
            * @param $y Thread group size in the Y dimension.
            * @param $z Thread group size in the Z dimension.
            */
            public GetKernelThreadGroupSizes ($kernelIndex: number, $x: $Ref<number>, $y: $Ref<number>, $z: $Ref<number>) : void
            /** Execute a compute shader.
            * @param $kernelIndex Which kernel to execute. A single compute shader asset can have multiple kernel entry points.
            * @param $threadGroupsX Number of work groups in the X dimension.
            * @param $threadGroupsY Number of work groups in the Y dimension.
            * @param $threadGroupsZ Number of work groups in the Z dimension.
            */
            public Dispatch ($kernelIndex: number, $threadGroupsX: number, $threadGroupsY: number, $threadGroupsZ: number) : void
            /** Enables a local shader keyword for this compute shader.
            * @param $keyword The name of the Rendering.LocalKeyword to enable.
            */
            public EnableKeyword ($keyword: string) : void
            /** Disables a local shader keyword for this compute shader.
            * @param $keyword The name of the Rendering.LocalKeyword to disable.
            */
            public DisableKeyword ($keyword: string) : void
            /** Checks whether a local shader keyword is enabled for this compute shader.
            * @param $keyword The name of the Rendering.LocalKeyword to check.
            * @returns Returns true if the given Rendering.LocalKeyword is enabled for this compute shader. Otherwise, returns false. 
            */
            public IsKeywordEnabled ($keyword: string) : boolean
            /** Enables a local shader keyword for this compute shader.
            * @param $keyword The name of the Rendering.LocalKeyword to enable.
            */
            public EnableKeyword ($keyword: $Ref<UnityEngine.Rendering.LocalKeyword>) : void
            /** Disables a local shader keyword for this compute shader.
            * @param $keyword The name of the Rendering.LocalKeyword to disable.
            */
            public DisableKeyword ($keyword: $Ref<UnityEngine.Rendering.LocalKeyword>) : void
            /** Sets the state of a local shader keyword for this compute shader.
            * @param $keyword The Rendering.LocalKeyword keyword to enable or disable.
            * @param $value The desired keyword state.
            */
            public SetKeyword ($keyword: $Ref<UnityEngine.Rendering.LocalKeyword>, $value: boolean) : void
            /** Checks whether a local shader keyword is enabled for this compute shader.
            * @param $keyword The name of the Rendering.LocalKeyword to check.
            * @returns Returns true if the given Rendering.LocalKeyword is enabled for this compute shader. Otherwise, returns false. 
            */
            public IsKeywordEnabled ($keyword: $Ref<UnityEngine.Rendering.LocalKeyword>) : boolean
            /** Allows you to check whether the current end user device supports the features required to run the specified compute shader kernel.
            * @param $kernelIndex Which kernel to query.
            * @returns True if the specified compute kernel is able to run on the current end user device, false otherwise. 
            */
            public IsSupported ($kernelIndex: number) : boolean
            /** Set a float parameter.
            * @param $name Variable name in shader code.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $val Value to set.
            */
            public SetFloat ($name: string, $val: number) : void
            /** Set an integer parameter.
            * @param $name Variable name in shader code.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $val Value to set.
            */
            public SetInt ($name: string, $val: number) : void
            /** Set a vector parameter.
            * @param $name Variable name in shader code.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $val Value to set.
            */
            public SetVector ($name: string, $val: UnityEngine.Vector4) : void
            /** Set a Matrix parameter.
            * @param $name Variable name in shader code.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $val Value to set.
            */
            public SetMatrix ($name: string, $val: UnityEngine.Matrix4x4) : void
            /** Set a vector array parameter.
            * @param $name Variable name in shader code.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $values Value to set.
            */
            public SetVectorArray ($name: string, $values: System.Array$1<UnityEngine.Vector4>) : void
            /** Set a Matrix array parameter.
            * @param $name Variable name in shader code.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $values Value to set.
            */
            public SetMatrixArray ($name: string, $values: System.Array$1<UnityEngine.Matrix4x4>) : void
            /** Set multiple consecutive float parameters at once.
            * @param $name Array variable name in the shader code.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $values Value array to set.
            */
            public SetFloats ($name: string, ...values: number[]) : void
            /** Set multiple consecutive float parameters at once.
            * @param $name Array variable name in the shader code.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $values Value array to set.
            */
            public SetFloats ($nameID: number, ...values: number[]) : void
            /** Set multiple consecutive integer parameters at once.
            * @param $name Array variable name in the shader code.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $values Value array to set.
            */
            public SetInts ($name: string, ...values: number[]) : void
            /** Set multiple consecutive integer parameters at once.
            * @param $name Array variable name in the shader code.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $values Value array to set.
            */
            public SetInts ($nameID: number, ...values: number[]) : void
            /** Set a bool parameter.
            * @param $name Variable name in shader code.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $val Value to set.
            */
            public SetBool ($name: string, $val: boolean) : void
            /** Set a bool parameter.
            * @param $name Variable name in shader code.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $val Value to set.
            */
            public SetBool ($nameID: number, $val: boolean) : void
            /** Set a texture parameter.
            * @param $kernelIndex For which kernel the texture is being set. See FindKernel.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $name Name of the buffer variable in shader code.
            * @param $texture Texture to set.
            * @param $mipLevel Optional mipmap level of the read-write texture.
            * @param $element Optional parameter that specifies the type of data to set from the RenderTexture.
            */
            public SetTexture ($kernelIndex: number, $nameID: number, $texture: UnityEngine.Texture) : void
            /** Set a texture parameter.
            * @param $kernelIndex For which kernel the texture is being set. See FindKernel.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $name Name of the buffer variable in shader code.
            * @param $texture Texture to set.
            * @param $mipLevel Optional mipmap level of the read-write texture.
            * @param $element Optional parameter that specifies the type of data to set from the RenderTexture.
            */
            public SetTexture ($kernelIndex: number, $name: string, $texture: UnityEngine.Texture) : void
            /** Set a texture parameter.
            * @param $kernelIndex For which kernel the texture is being set. See FindKernel.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $name Name of the buffer variable in shader code.
            * @param $texture Texture to set.
            * @param $mipLevel Optional mipmap level of the read-write texture.
            * @param $element Optional parameter that specifies the type of data to set from the RenderTexture.
            */
            public SetTexture ($kernelIndex: number, $name: string, $texture: UnityEngine.Texture, $mipLevel: number) : void
            /** Set a texture parameter.
            * @param $kernelIndex For which kernel the texture is being set. See FindKernel.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $name Name of the buffer variable in shader code.
            * @param $texture Texture to set.
            * @param $mipLevel Optional mipmap level of the read-write texture.
            * @param $element Optional parameter that specifies the type of data to set from the RenderTexture.
            */
            public SetTexture ($kernelIndex: number, $nameID: number, $texture: UnityEngine.RenderTexture, $mipLevel: number, $element: UnityEngine.Rendering.RenderTextureSubElement) : void
            /** Set a texture parameter.
            * @param $kernelIndex For which kernel the texture is being set. See FindKernel.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $name Name of the buffer variable in shader code.
            * @param $texture Texture to set.
            * @param $mipLevel Optional mipmap level of the read-write texture.
            * @param $element Optional parameter that specifies the type of data to set from the RenderTexture.
            */
            public SetTexture ($kernelIndex: number, $name: string, $texture: UnityEngine.RenderTexture, $mipLevel: number, $element: UnityEngine.Rendering.RenderTextureSubElement) : void
            /** Set a texture parameter from a global texture property.
            * @param $kernelIndex For which kernel the texture is being set. See FindKernel.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $name Name of the buffer variable in shader code.
            * @param $globalTextureName Global texture property to assign to shader.
            * @param $globalTextureNameID Property name ID, use Shader.PropertyToID to get it.
            */
            public SetTextureFromGlobal ($kernelIndex: number, $name: string, $globalTextureName: string) : void
            /** Sets an input or output compute buffer.
            * @param $kernelIndex For which kernel the buffer is being set. See FindKernel.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $name Name of the buffer variable in shader code.
            * @param $buffer Buffer to set.
            */
            public SetBuffer ($kernelIndex: number, $name: string, $buffer: UnityEngine.ComputeBuffer) : void
            /** Sets an input or output compute buffer.
            * @param $kernelIndex For which kernel the buffer is being set. See FindKernel.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $name Name of the buffer variable in shader code.
            * @param $buffer Buffer to set.
            */
            public SetBuffer ($kernelIndex: number, $name: string, $buffer: UnityEngine.GraphicsBuffer) : void
            /** Sets a RayTracingAccelerationStructure to be used for Inline Ray Tracing (Ray Queries).
            * @param $kernelIndex For which kernel the RayTracingAccelerationStructure is being set. See FindKernel.
            * @param $nameID Property name ID, use Shader.PropertyToID to get it.
            * @param $accelerationStructure The RayTracingAccelerationStructure object to bind.
            * @param $name Resource name in shader code.
            */
            public SetRayTracingAccelerationStructure ($kernelIndex: number, $name: string, $accelerationStructure: UnityEngine.Rendering.RayTracingAccelerationStructure) : void
            /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the ComputeShader.
            * @param $nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
            * @param $name The name of the buffer to bind as constant buffer.
            * @param $buffer The buffer to bind as constant buffer.
            * @param $offset The offset in bytes from the beginning of the ComputeBuffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
            * @param $size The number of bytes to bind.
            */
            public SetConstantBuffer ($nameID: number, $buffer: UnityEngine.ComputeBuffer, $offset: number, $size: number) : void
            /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the ComputeShader.
            * @param $nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
            * @param $name The name of the buffer to bind as constant buffer.
            * @param $buffer The buffer to bind as constant buffer.
            * @param $offset The offset in bytes from the beginning of the ComputeBuffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
            * @param $size The number of bytes to bind.
            */
            public SetConstantBuffer ($name: string, $buffer: UnityEngine.ComputeBuffer, $offset: number, $size: number) : void
            /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the ComputeShader.
            * @param $nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
            * @param $name The name of the buffer to bind as constant buffer.
            * @param $buffer The buffer to bind as constant buffer.
            * @param $offset The offset in bytes from the beginning of the ComputeBuffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
            * @param $size The number of bytes to bind.
            */
            public SetConstantBuffer ($nameID: number, $buffer: UnityEngine.GraphicsBuffer, $offset: number, $size: number) : void
            /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the ComputeShader.
            * @param $nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
            * @param $name The name of the buffer to bind as constant buffer.
            * @param $buffer The buffer to bind as constant buffer.
            * @param $offset The offset in bytes from the beginning of the ComputeBuffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
            * @param $size The number of bytes to bind.
            */
            public SetConstantBuffer ($name: string, $buffer: UnityEngine.GraphicsBuffer, $offset: number, $size: number) : void
            /** Execute a compute shader.
            * @param $kernelIndex Which kernel to execute. A single compute shader asset can have multiple kernel entry points.
            * @param $argsBuffer Buffer with dispatch arguments.
            * @param $argsOffset The byte offset into the buffer, where the draw arguments start.
            */
            public DispatchIndirect ($kernelIndex: number, $argsBuffer: UnityEngine.ComputeBuffer, $argsOffset: number) : void
            public DispatchIndirect ($kernelIndex: number, $argsBuffer: UnityEngine.ComputeBuffer) : void
            /** Execute a compute shader.
            * @param $kernelIndex Which kernel to execute. A single compute shader asset can have multiple kernel entry points.
            * @param $argsBuffer Buffer with dispatch arguments.
            * @param $argsOffset The byte offset into the buffer, where the draw arguments start.
            */
            public DispatchIndirect ($kernelIndex: number, $argsBuffer: UnityEngine.GraphicsBuffer, $argsOffset: number) : void
            public DispatchIndirect ($kernelIndex: number, $argsBuffer: UnityEngine.GraphicsBuffer) : void
        }
        /** ShaderVariantCollection records which shader variants are actually used in each shader.
        */
        class ShaderVariantCollection extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** Number of shaders in this collection (Read Only).
            */
            public get shaderCount(): number;
            /** Number of total variants in this collection (Read Only).
            */
            public get variantCount(): number;
            /** Number of total variants in this collection that are already warmed up (Read Only).
            */
            public get warmedUpVariantCount(): number;
            /** Is this ShaderVariantCollection already warmed up? (Read Only)
            */
            public get isWarmedUp(): boolean;
            /** Remove all shader variants from the collection.
            */
            public Clear () : void
            /** Prewarms all shader variants in this shader variant collection.
            */
            public WarmUp () : void
            /** Prewarms the given number of shader variants in this shader variant collection.
            * @param $variantCount The maximum number of variants to warm up.
            * @returns True if all variants in this shader variant collection have been warmed up, false otherwise. 
            */
            public WarmUpProgressively ($variantCount: number) : boolean
            public Add ($variant: UnityEngine.ShaderVariantCollection.ShaderVariant) : boolean
            public Remove ($variant: UnityEngine.ShaderVariantCollection.ShaderVariant) : boolean
            public Contains ($variant: UnityEngine.ShaderVariantCollection.ShaderVariant) : boolean
            public constructor ()
        }
        /** Defines the axes that can be snapped.
        */
        enum SnapAxis
        { None = 0, X = 1, Y = 2, Z = 4, All = 7 }
        /** Snap values to rounded increments.
        */
        class Snapping extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Rounds value to the closest multiple of snap.
            * @param $val The value to round.
            * @param $snap The increment to round to.
            * @returns The rounded value. 
            */
            public static Snap ($val: number, $snap: number) : number
            /** Rounds value to the closest multiple of snap.
            * @param $val The value to round.
            * @param $snap The increment to round to.
            * @returns The rounded value. 
            */
            public static Snap ($val: UnityEngine.Vector2, $snap: UnityEngine.Vector2) : UnityEngine.Vector2
            /** Rounds value to the closest multiple of snap.
            * @param $val The value to round.
            * @param $snap The increment to round to.
            * @param $axis Restrict snapping to the components on these axes.
            * @returns The rounded value. 
            */
            public static Snap ($val: UnityEngine.Vector3, $snap: UnityEngine.Vector3, $axis?: UnityEngine.SnapAxis) : UnityEngine.Vector3
        }
        /** StaticBatchingUtility can prepare your objects to take advantage of Unity's static batching.
        */
        class StaticBatchingUtility extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Combines all children GameObjects of the staticBatchRoot for static batching.
            * @param $staticBatchRoot The GameObject that should become the root of the combined batch.
            */
            public static Combine ($staticBatchRoot: UnityEngine.GameObject) : void
            /** SCombines all GameObjects in gos for static batching and treats staticBatchRoot as the root.
            * @param $gos The GameObjects to prepare for static batching.
            * @param $staticBatchRoot The GameObject that should become the root of the combined batch.
            */
            public static Combine ($gos: System.Array$1<UnityEngine.GameObject>, $staticBatchRoot: UnityEngine.GameObject) : void
            public constructor ()
        }
        /** Enumeration for SystemInfo.batteryStatus which represents the current status of the device's battery.
        */
        enum BatteryStatus
        { Unknown = 0, Charging = 1, Discharging = 2, NotCharging = 3, Full = 4 }
        /** Enumeration for SystemInfo.operatingSystemFamily.
        */
        enum OperatingSystemFamily
        { Other = 0, MacOSX = 1, Windows = 2, Linux = 3 }
        /** Enumeration for SystemInfo.deviceType, denotes a coarse grouping of kinds of devices.
        */
        enum DeviceType
        { Unknown = 0, Handheld = 1, Console = 2, Desktop = 3 }
        /** Access system and hardware information.
        */
        class SystemInfo extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Value returned by SystemInfo string properties which are not supported on the current platform.
            */
            public static unsupportedIdentifier : string
            /** The current battery level (Read Only).
            */
            public static get batteryLevel(): number;
            /** Returns the current status of the device's battery (Read Only).
            */
            public static get batteryStatus(): UnityEngine.BatteryStatus;
            /** Operating system name with version (Read Only).
            */
            public static get operatingSystem(): string;
            /** Returns the operating system family the game is running on (Read Only).
            */
            public static get operatingSystemFamily(): UnityEngine.OperatingSystemFamily;
            /** Processor name (Read Only).
            */
            public static get processorType(): string;
            /** Processor frequency in MHz (Read Only).
            */
            public static get processorFrequency(): number;
            /** Number of processors present (Read Only).
            */
            public static get processorCount(): number;
            /** Amount of system memory present (Read Only).
            */
            public static get systemMemorySize(): number;
            /** A unique device identifier. It's guaranteed to be unique for every device (Read Only).
            */
            public static get deviceUniqueIdentifier(): string;
            /** The user defined name of the device (Read Only).
            */
            public static get deviceName(): string;
            /** The model of the device (Read Only).
            */
            public static get deviceModel(): string;
            /** Is an accelerometer available on the device?
            */
            public static get supportsAccelerometer(): boolean;
            /** Is a gyroscope available on the device?
            */
            public static get supportsGyroscope(): boolean;
            /** Is the device capable of reporting its location?
            */
            public static get supportsLocationService(): boolean;
            /** Is the device capable of providing the user haptic feedback by vibration?
            */
            public static get supportsVibration(): boolean;
            /** Is there an Audio device available for playback? (Read Only)
            */
            public static get supportsAudio(): boolean;
            /** Returns the kind of device the application is running on (Read Only).
            */
            public static get deviceType(): UnityEngine.DeviceType;
            /** Amount of video memory present (Read Only).
            */
            public static get graphicsMemorySize(): number;
            /** The name of the graphics device (Read Only).
            */
            public static get graphicsDeviceName(): string;
            /** The vendor of the graphics device (Read Only).
            */
            public static get graphicsDeviceVendor(): string;
            /** The identifier code of the graphics device (Read Only).
            */
            public static get graphicsDeviceID(): number;
            /** The identifier code of the graphics device vendor (Read Only).
            */
            public static get graphicsDeviceVendorID(): number;
            /** The graphics API type used by the graphics device (Read Only).
            */
            public static get graphicsDeviceType(): UnityEngine.Rendering.GraphicsDeviceType;
            /** Returns true if the texture UV coordinate convention for this platform has Y starting at the top of the image.
            */
            public static get graphicsUVStartsAtTop(): boolean;
            /** The graphics API type and driver version used by the graphics device (Read Only).
            */
            public static get graphicsDeviceVersion(): string;
            /** Graphics device shader capability level (Read Only).
            */
            public static get graphicsShaderLevel(): number;
            /** Is graphics device using multi-threaded rendering (Read Only)?
            */
            public static get graphicsMultiThreaded(): boolean;
            /** Application's actual rendering threading mode (Read Only).
            */
            public static get renderingThreadingMode(): UnityEngine.Rendering.RenderingThreadingMode;
            /** The foveated rendering technique supported on this platform.
            */
            public static get foveatedRenderingCaps(): UnityEngine.Rendering.FoveatedRenderingCaps;
            /** True if the GPU supports hidden surface removal.
            */
            public static get hasHiddenSurfaceRemovalOnGPU(): boolean;
            /** Returns true when the GPU has native support for indexing uniform arrays in fragment shaders without restrictions.
            */
            public static get hasDynamicUniformArrayIndexingInFragmentShaders(): boolean;
            /** Are built-in shadows supported? (Read Only)
            */
            public static get supportsShadows(): boolean;
            /** Is sampling raw depth from shadowmaps supported? (Read Only)
            */
            public static get supportsRawShadowDepthSampling(): boolean;
            /** Whether motion vectors are supported on this platform.
            */
            public static get supportsMotionVectors(): boolean;
            /** Are 3D (volume) textures supported? (Read Only)
            */
            public static get supports3DTextures(): boolean;
            /** Are compressed formats for 3D (volume) textures supported? (Read Only).
            */
            public static get supportsCompressed3DTextures(): boolean;
            /** Are 2D Array textures supported? (Read Only)
            */
            public static get supports2DArrayTextures(): boolean;
            /** Are 3D (volume) RenderTextures supported? (Read Only)
            */
            public static get supports3DRenderTextures(): boolean;
            /** Are Cubemap Array textures supported? (Read Only)
            */
            public static get supportsCubemapArrayTextures(): boolean;
            /** Returns true when anisotropic filtering is supported on the device.
            */
            public static get supportsAnisotropicFilter(): boolean;
            /** Support for various Graphics.CopyTexture cases (Read Only).
            */
            public static get copyTextureSupport(): UnityEngine.Rendering.CopyTextureSupport;
            /** Are compute shaders supported? (Read Only)
            */
            public static get supportsComputeShaders(): boolean;
            /** Are geometry shaders supported? (Read Only)
            */
            public static get supportsGeometryShaders(): boolean;
            /** Are tessellation shaders supported? (Read Only)
            */
            public static get supportsTessellationShaders(): boolean;
            /** Boolean that indicates if SV_RenderTargetArrayIndex can be used in a vertex shader (true if it can be used, false if not).
            */
            public static get supportsRenderTargetArrayIndexFromVertexShader(): boolean;
            /** Is GPU draw call instancing supported? (Read Only)
            */
            public static get supportsInstancing(): boolean;
            /** Does the hardware support quad topology? (Read Only)
            */
            public static get supportsHardwareQuadTopology(): boolean;
            /** Are 32-bit index buffers supported? (Read Only)
            */
            public static get supports32bitsIndexBuffer(): boolean;
            /** Are sparse textures supported? (Read Only)
            */
            public static get supportsSparseTextures(): boolean;
            /** How many simultaneous render targets (MRTs) are supported? (Read Only)
            */
            public static get supportedRenderTargetCount(): number;
            /** Returns true when the platform supports different blend modes when rendering to multiple render targets, or false otherwise.
            */
            public static get supportsSeparatedRenderTargetsBlend(): boolean;
            /** The maximum number of random write targets (UAV) that Unity supports simultaneously. (Read Only)
            */
            public static get supportedRandomWriteTargetCount(): number;
            /** Are multisampled textures supported? (Read Only)
            */
            public static get supportsMultisampledTextures(): number;
            /** Boolean that indicates whether multisampled texture arrays are supported (true if supported, false if not supported).
            */
            public static get supportsMultisampled2DArrayTextures(): boolean;
            /** Returns true if multisampled textures are resolved automatically
            */
            public static get supportsMultisampleAutoResolve(): boolean;
            /** Returns true if the 'Mirror Once' texture wrap mode is supported. (Read Only)
            */
            public static get supportsTextureWrapMirrorOnce(): number;
            /** This property is true if the current platform uses a reversed depth buffer (where values range from 1 at the near plane and 0 at far plane), and false if the depth buffer is normal (0 is near, 1 is far). (Read Only)
            */
            public static get usesReversedZBuffer(): boolean;
            /** What NPOT (non-power of two size) texture support does the GPU provide? (Read Only)
            */
            public static get npotSupport(): UnityEngine.NPOTSupport;
            /** Maximum texture size in pixels (Read Only).
            */
            public static get maxTextureSize(): number;
            /** Maximum 3D texture size in pixels (Read Only).
            */
            public static get maxTexture3DSize(): number;
            /** Maximum number of slices in a Texture array (Read Only).
            */
            public static get maxTextureArraySlices(): number;
            /** Maximum cubemap texture size in pixels (Read Only).
            */
            public static get maxCubemapSize(): number;
            /** Returns the maximum anisotropic level for anisotropic filtering that is supported on the device. 
            */
            public static get maxAnisotropyLevel(): number;
            /** Determines how many compute buffers Unity supports simultaneously in a vertex shader for reading. (Read Only)
            */
            public static get maxComputeBufferInputsVertex(): number;
            /** Determines how many compute buffers Unity supports simultaneously in a fragment shader for reading. (Read Only)
            */
            public static get maxComputeBufferInputsFragment(): number;
            /** Determines how many compute buffers Unity supports simultaneously in a geometry shader for reading. (Read Only)
            */
            public static get maxComputeBufferInputsGeometry(): number;
            /** Determines how many compute buffers Unity supports simultaneously in a domain shader for reading. (Read Only)
            */
            public static get maxComputeBufferInputsDomain(): number;
            /** Determines how many compute buffers Unity supports simultaneously in a hull shader for reading. (Read Only)
            */
            public static get maxComputeBufferInputsHull(): number;
            /** Determines how many compute buffers Unity supports simultaneously in a compute shader for reading. (Read Only)
            */
            public static get maxComputeBufferInputsCompute(): number;
            /** The largest total number of invocations in a single local work group that can be dispatched to a compute shader (Read Only).
            */
            public static get maxComputeWorkGroupSize(): number;
            /** The maximum number of work groups that a compute shader can use in X dimension (Read Only).
            */
            public static get maxComputeWorkGroupSizeX(): number;
            /** The maximum number of work groups that a compute shader can use in Y dimension (Read Only).
            */
            public static get maxComputeWorkGroupSizeY(): number;
            /** The maximum number of work groups that a compute shader can use in Z dimension (Read Only).
            */
            public static get maxComputeWorkGroupSizeZ(): number;
            /** Size of the compute thread group that supports efficient memory sharing on the GPU (Read Only).
            */
            public static get computeSubGroupSize(): number;
            /** Returns true when the platform supports asynchronous compute queues and false if otherwise.
            */
            public static get supportsAsyncCompute(): boolean;
            /** Specifies whether the current platform supports the GPU Recorder or not. (Read Only).
            */
            public static get supportsGpuRecorder(): boolean;
            /** true if the platform supports GraphicsFences, otherwise false.
            */
            public static get supportsGraphicsFence(): boolean;
            /** Returns true if asynchronous readback of GPU data is available for this device and false otherwise.
            */
            public static get supportsAsyncGPUReadback(): boolean;
            /** Checks if ray tracing shaders are supported by the current system configuration. (Read Only)
            */
            public static get supportsRayTracingShaders(): boolean;
            /** Checks if any ray tracing features are supported by the current system configuration. (Read Only)
            */
            public static get supportsRayTracing(): boolean;
            /** Is inline ray tracing (ray query) supported? (Read Only)
            */
            public static get supportsInlineRayTracing(): boolean;
            /** Does the current renderer support binding constant buffers directly? (Read Only)
            */
            public static get supportsSetConstantBuffer(): boolean;
            /** Minimum buffer offset (in bytes) when binding a constant buffer using Shader.SetConstantBuffer or Material.SetConstantBuffer.
            */
            public static get constantBufferOffsetAlignment(): number;
            /** The maximum size of a constant buffer binding (Read Only).
            */
            public static get maxConstantBufferSize(): number;
            /** The maximum size of a graphics buffer (GraphicsBuffer, ComputeBuffer, vertex/index buffer, etc.) in bytes (Read Only).
            */
            public static get maxGraphicsBufferSize(): bigint;
            /** Returns true if the GPU supports partial mipmap chains (Read Only).
            */
            public static get hasMipMaxLevel(): boolean;
            /** Is streaming of texture mip maps supported? (Read Only)
            */
            public static get supportsMipStreaming(): boolean;
            /** True if the Graphics API takes RenderBufferLoadAction and RenderBufferStoreAction into account, false if otherwise.
            */
            public static get usesLoadStoreActions(): boolean;
            /** Returns a bitwise combination of HDRDisplaySupportFlags describing the support for HDR displays on the system.
            */
            public static get hdrDisplaySupportFlags(): UnityEngine.HDRDisplaySupportFlags;
            /** Is conservative rasterization supported? (Read Only)
            */
            public static get supportsConservativeRaster(): boolean;
            /** Boolean that indicates whether Multiview is supported (true if supported, false if not supported). (Read Only)
            */
            public static get supportsMultiview(): boolean;
            /** This property is true if the graphics API of the target build platform takes RenderBufferStoreAction.StoreAndResolve into account, false if otherwise.
            */
            public static get supportsStoreAndResolveAction(): boolean;
            /** Returns true if the platform supports multisample resolve of depth textures.
            */
            public static get supportsMultisampleResolveDepth(): boolean;
            /** Returns true if the platform supports multisample resolve of stencil textures. Otherwise, returns false.
            */
            public static get supportsMultisampleResolveStencil(): boolean;
            /** Returns true if the graphics system supports GPU draw calls with indirect argument buffers. (Read Only)
            */
            public static get supportsIndirectArgumentsBuffer(): boolean;
            /** Is render texture format supported?
            * @param $format The format to look up.
            * @returns True if the format is supported. 
            */
            public static SupportsRenderTextureFormat ($format: UnityEngine.RenderTextureFormat) : boolean
            /** Is blending supported on render texture format?
            * @param $format The format to look up.
            * @returns True if blending is supported on the given format. 
            */
            public static SupportsBlendingOnRenderTextureFormat ($format: UnityEngine.RenderTextureFormat) : boolean
            /** Tests if a RenderTextureFormat can be used with RenderTexture.enableRandomWrite.
            * @param $format The format to look up.
            * @returns True if the format can be used for random access writes. 
            */
            public static SupportsRandomWriteOnRenderTextureFormat ($format: UnityEngine.RenderTextureFormat) : boolean
            /** Is texture format supported on this device?
            * @param $format The TextureFormat format to look up.
            * @returns True if the format is supported. 
            */
            public static SupportsTextureFormat ($format: UnityEngine.TextureFormat) : boolean
            /** Indicates whether the given combination of a vertex attribute format and dimension is supported on this device.
            * @param $format The VertexAttributeFormat format to look up.
            * @param $dimension The dimension of vertex data to check for.
            * @returns True if the format with the given dimension is supported. 
            */
            public static SupportsVertexAttributeFormat ($format: UnityEngine.Rendering.VertexAttributeFormat, $dimension: number) : boolean
            /** Verifies that the specified graphics format is supported for the specified usage.
            * @param $format The Experimental.Rendering.GraphicsFormat format to look up.
            * @param $usage The Experimental.Rendering.GraphicsFormatUsage usage to look up.
            * @returns Returns true if the format is supported for the specific usage. Returns false otherwise. 
            */
            public static IsFormatSupported ($format: UnityEngine.Experimental.Rendering.GraphicsFormat, $usage: UnityEngine.Experimental.Rendering.GraphicsFormatUsage) : boolean
            /** Returns a format supported by the platform for the specified usage.
            * @param $format The Experimental.Rendering.GraphicsFormat format to look up.
            * @param $usage The Experimental.Rendering.GraphicsFormatUsage usage to look up.
            * @returns Returns a format supported by the platform. If no equivalent or compatible format is supported, the function returns GraphicsFormat.None. 
            */
            public static GetCompatibleFormat ($format: UnityEngine.Experimental.Rendering.GraphicsFormat, $usage: UnityEngine.Experimental.Rendering.GraphicsFormatUsage) : UnityEngine.Experimental.Rendering.GraphicsFormat
            /** Returns the platform-specific GraphicsFormat that is associated with the DefaultFormat.
            * @param $format The DefaultFormat format to look up.
            */
            public static GetGraphicsFormat ($format: UnityEngine.Experimental.Rendering.DefaultFormat) : UnityEngine.Experimental.Rendering.GraphicsFormat
            /** Checks if the target platform supports the MSAA samples count in the RenderTextureDescriptor argument.
            * @param $desc The RenderTextureDescriptor to check.
            * @returns If the target platform supports the given MSAA samples count of RenderTextureDescriptor, returns the given MSAA samples count. Otherwise returns a lower fallback MSAA samples count value that the target platform supports. 
            */
            public static GetRenderTextureSupportedMSAASampleCount ($desc: UnityEngine.RenderTextureDescriptor) : number
            public constructor ()
        }
        /** Provides an interface to get time information from Unity.
        */
        class Time extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** The time at the beginning of this frame (Read Only).
            */
            public static get time(): number;
            /** The double precision time at the beginning of this frame (Read Only). This is the time in seconds since the start of the game.
            */
            public static get timeAsDouble(): number;
            /** The time this frame has started (Read Only). This is the time in seconds since the start of the game represented as a RationalTime.
            */
            public static get timeAsRational(): Unity.IntegerTime.RationalTime;
            /** The time since this frame started (Read Only). This is the time in seconds since the last non-additive scene has finished loading.
            */
            public static get timeSinceLevelLoad(): number;
            /** The double precision time since this frame started (Read Only). This is the time in seconds since the last non-additive scene has finished loading.
            */
            public static get timeSinceLevelLoadAsDouble(): number;
            /** The interval in seconds from the last frame to the current one (Read Only).
            */
            public static get deltaTime(): number;
            /** The time since the last MonoBehaviour.FixedUpdate started (Read Only). This is the time in seconds since the start of the game.
            */
            public static get fixedTime(): number;
            /** The double precision time since the last MonoBehaviour.FixedUpdate started (Read Only). This is the time in seconds since the start of the game.
            */
            public static get fixedTimeAsDouble(): number;
            /** The timeScale-independent time for this frame (Read Only). This is the time in seconds since the start of the game.
            */
            public static get unscaledTime(): number;
            /** The double precision timeScale-independent time for this frame (Read Only). This is the time in seconds since the start of the game.
            */
            public static get unscaledTimeAsDouble(): number;
            /** The timeScale-independent time at the beginning of the last MonoBehaviour.FixedUpdate phase (Read Only). This is the time in seconds since the start of the game.
            */
            public static get fixedUnscaledTime(): number;
            /** The double precision timeScale-independent time at the beginning of the last MonoBehaviour.FixedUpdate (Read Only). This is the time in seconds since the start of the game.
            */
            public static get fixedUnscaledTimeAsDouble(): number;
            /** The timeScale-independent interval in seconds from the last frame to the current one (Read Only).
            */
            public static get unscaledDeltaTime(): number;
            /** The timeScale-independent interval in seconds from the last MonoBehaviour.FixedUpdate phase to the current one (Read Only).
            */
            public static get fixedUnscaledDeltaTime(): number;
            /** The interval in seconds at which physics and other fixed frame rate updates (like MonoBehaviour's MonoBehaviour.FixedUpdate) are performed.
            */
            public static get fixedDeltaTime(): number;
            public static set fixedDeltaTime(value: number);
            /** The maximum value of Time.deltaTime in any given frame. This is a time in seconds that limits the increase of Time.time between two frames.
            */
            public static get maximumDeltaTime(): number;
            public static set maximumDeltaTime(value: number);
            /** A smoothed out Time.deltaTime (Read Only).
            */
            public static get smoothDeltaTime(): number;
            /** The maximum time a frame can spend on particle updates. If the frame takes longer than this, then updates are split into multiple smaller updates.
            */
            public static get maximumParticleDeltaTime(): number;
            public static set maximumParticleDeltaTime(value: number);
            /** The scale at which time passes.
            */
            public static get timeScale(): number;
            public static set timeScale(value: number);
            /** The total number of frames since the start of the game (Read Only).
            */
            public static get frameCount(): number;
            public static get renderedFrameCount(): number;
            /** The real time in seconds since the game started (Read Only).
            */
            public static get realtimeSinceStartup(): number;
            /** The real time in seconds since the game started (Read Only). Double precision version of Time.realtimeSinceStartup. 
            */
            public static get realtimeSinceStartupAsDouble(): number;
            /** Slows your application’s playback time to allow Unity to save screenshots in between frames.
            */
            public static get captureDeltaTime(): number;
            public static set captureDeltaTime(value: number);
            /** Slows your application’s playback time to allow Unity to save screenshots in between frames.
            */
            public static get captureDeltaTimeRational(): Unity.IntegerTime.RationalTime;
            public static set captureDeltaTimeRational(value: Unity.IntegerTime.RationalTime);
            /** The reciprocal of Time.captureDeltaTime.
            */
            public static get captureFramerate(): number;
            public static set captureFramerate(value: number);
            /** Returns true if called inside a fixed time step callback (like MonoBehaviour's MonoBehaviour.FixedUpdate), otherwise returns false.
            */
            public static get inFixedTimeStep(): boolean;
            public constructor ()
        }
        /** Interface for on-screen keyboards. Only native iPhone, Android, and Windows Store Apps are supported.
        */
        class TouchScreenKeyboard extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Is touch screen keyboard supported.
            */
            public static get isSupported(): boolean;
            /** Checks if the text within an input field can be selected and modified while TouchScreenKeyboard is open.
            * @returns Returns true when you are able to select and modify the input field, returns false otherwise. 
            */
            public static get isInPlaceEditingAllowed(): boolean;
            /** Returns the text displayed by the input field of the keyboard.
            */
            public get text(): string;
            public set text(value: string);
            /** Will text input field above the keyboard be hidden when the keyboard is on screen?
            */
            public static get hideInput(): boolean;
            public static set hideInput(value: boolean);
            /** Is the keyboard visible or sliding into the position on the screen?
            */
            public get active(): boolean;
            public set active(value: boolean);
            /** Returns the status of the on-screen keyboard. (Read Only)
            */
            public get status(): UnityEngine.TouchScreenKeyboard.Status;
            /** How many characters the keyboard input field is limited to. 0 = infinite.
            */
            public get characterLimit(): number;
            public set characterLimit(value: number);
            /** Specifies whether the TouchScreenKeyboard supports the selection property. (Read Only)
            */
            public get canGetSelection(): boolean;
            /** Specifies whether the TouchScreenKeyboard supports the selection property. (Read Only)
            */
            public get canSetSelection(): boolean;
            /** Gets or sets the character range of the selected text within the string currently being edited.
            */
            public get selection(): UnityEngine.RangeInt;
            public set selection(value: UnityEngine.RangeInt);
            /** Returns the TouchScreenKeyboardType of the keyboard.
            */
            public get type(): UnityEngine.TouchScreenKeyboardType;
            /** Specified on which display the on-screen keyboard will appear.
            */
            public get targetDisplay(): number;
            public set targetDisplay(value: number);
            /** Returns portion of the screen which is covered by the keyboard.
            */
            public static get area(): UnityEngine.Rect;
            /** Returns true whenever any keyboard is visible on the screen.
            */
            public static get visible(): boolean;
            /** Opens the native keyboard provided by OS on the screen.
            * @param $text Text to edit.
            * @param $keyboardType Type of keyboard (eg, any text, numbers only, etc).
            * @param $autocorrection Is autocorrection applied?
            * @param $multiline Can more than one line of text be entered?
            * @param $secure Is the text masked (for passwords, etc)?
            * @param $alert Is the keyboard opened in alert mode?
            * @param $textPlaceholder Text to be used if no other text is present.
            * @param $characterLimit How many characters the keyboard input field is limited to. 0 = infinite. (Android and iOS only)
            */
            public static Open ($text: string, $keyboardType: UnityEngine.TouchScreenKeyboardType, $autocorrection: boolean, $multiline: boolean, $secure: boolean, $alert: boolean, $textPlaceholder: string, $characterLimit: number) : UnityEngine.TouchScreenKeyboard
            /** Opens the native keyboard provided by OS on the screen.
            * @param $text Text to edit.
            * @param $keyboardType Type of keyboard (eg, any text, numbers only, etc).
            * @param $autocorrection Is autocorrection applied?
            * @param $multiline Can more than one line of text be entered?
            * @param $secure Is the text masked (for passwords, etc)?
            * @param $alert Is the keyboard opened in alert mode?
            * @param $textPlaceholder Text to be used if no other text is present.
            * @param $characterLimit How many characters the keyboard input field is limited to. 0 = infinite. (Android and iOS only)
            */
            public static Open ($text: string, $keyboardType: UnityEngine.TouchScreenKeyboardType, $autocorrection: boolean, $multiline: boolean, $secure: boolean, $alert: boolean, $textPlaceholder: string) : UnityEngine.TouchScreenKeyboard
            /** Opens the native keyboard provided by OS on the screen.
            * @param $text Text to edit.
            * @param $keyboardType Type of keyboard (eg, any text, numbers only, etc).
            * @param $autocorrection Is autocorrection applied?
            * @param $multiline Can more than one line of text be entered?
            * @param $secure Is the text masked (for passwords, etc)?
            * @param $alert Is the keyboard opened in alert mode?
            * @param $textPlaceholder Text to be used if no other text is present.
            * @param $characterLimit How many characters the keyboard input field is limited to. 0 = infinite. (Android and iOS only)
            */
            public static Open ($text: string, $keyboardType: UnityEngine.TouchScreenKeyboardType, $autocorrection: boolean, $multiline: boolean, $secure: boolean, $alert: boolean) : UnityEngine.TouchScreenKeyboard
            /** Opens the native keyboard provided by OS on the screen.
            * @param $text Text to edit.
            * @param $keyboardType Type of keyboard (eg, any text, numbers only, etc).
            * @param $autocorrection Is autocorrection applied?
            * @param $multiline Can more than one line of text be entered?
            * @param $secure Is the text masked (for passwords, etc)?
            * @param $alert Is the keyboard opened in alert mode?
            * @param $textPlaceholder Text to be used if no other text is present.
            * @param $characterLimit How many characters the keyboard input field is limited to. 0 = infinite. (Android and iOS only)
            */
            public static Open ($text: string, $keyboardType: UnityEngine.TouchScreenKeyboardType, $autocorrection: boolean, $multiline: boolean, $secure: boolean) : UnityEngine.TouchScreenKeyboard
            /** Opens the native keyboard provided by OS on the screen.
            * @param $text Text to edit.
            * @param $keyboardType Type of keyboard (eg, any text, numbers only, etc).
            * @param $autocorrection Is autocorrection applied?
            * @param $multiline Can more than one line of text be entered?
            * @param $secure Is the text masked (for passwords, etc)?
            * @param $alert Is the keyboard opened in alert mode?
            * @param $textPlaceholder Text to be used if no other text is present.
            * @param $characterLimit How many characters the keyboard input field is limited to. 0 = infinite. (Android and iOS only)
            */
            public static Open ($text: string, $keyboardType: UnityEngine.TouchScreenKeyboardType, $autocorrection: boolean, $multiline: boolean) : UnityEngine.TouchScreenKeyboard
            /** Opens the native keyboard provided by OS on the screen.
            * @param $text Text to edit.
            * @param $keyboardType Type of keyboard (eg, any text, numbers only, etc).
            * @param $autocorrection Is autocorrection applied?
            * @param $multiline Can more than one line of text be entered?
            * @param $secure Is the text masked (for passwords, etc)?
            * @param $alert Is the keyboard opened in alert mode?
            * @param $textPlaceholder Text to be used if no other text is present.
            * @param $characterLimit How many characters the keyboard input field is limited to. 0 = infinite. (Android and iOS only)
            */
            public static Open ($text: string, $keyboardType: UnityEngine.TouchScreenKeyboardType, $autocorrection: boolean) : UnityEngine.TouchScreenKeyboard
            /** Opens the native keyboard provided by OS on the screen.
            * @param $text Text to edit.
            * @param $keyboardType Type of keyboard (eg, any text, numbers only, etc).
            * @param $autocorrection Is autocorrection applied?
            * @param $multiline Can more than one line of text be entered?
            * @param $secure Is the text masked (for passwords, etc)?
            * @param $alert Is the keyboard opened in alert mode?
            * @param $textPlaceholder Text to be used if no other text is present.
            * @param $characterLimit How many characters the keyboard input field is limited to. 0 = infinite. (Android and iOS only)
            */
            public static Open ($text: string, $keyboardType: UnityEngine.TouchScreenKeyboardType) : UnityEngine.TouchScreenKeyboard
            /** Opens the native keyboard provided by OS on the screen.
            * @param $text Text to edit.
            * @param $keyboardType Type of keyboard (eg, any text, numbers only, etc).
            * @param $autocorrection Is autocorrection applied?
            * @param $multiline Can more than one line of text be entered?
            * @param $secure Is the text masked (for passwords, etc)?
            * @param $alert Is the keyboard opened in alert mode?
            * @param $textPlaceholder Text to be used if no other text is present.
            * @param $characterLimit How many characters the keyboard input field is limited to. 0 = infinite. (Android and iOS only)
            */
            public static Open ($text: string) : UnityEngine.TouchScreenKeyboard
            public constructor ($text: string, $keyboardType: UnityEngine.TouchScreenKeyboardType, $autocorrection: boolean, $multiline: boolean, $secure: boolean, $alert: boolean, $textPlaceholder: string, $characterLimit: number)
        }
        /** Enumeration of the different types of supported touchscreen keyboards.
        */
        enum TouchScreenKeyboardType
        { Default = 0, ASCIICapable = 1, NumbersAndPunctuation = 2, URL = 3, NumberPad = 4, PhonePad = 5, NamePhonePad = 6, EmailAddress = 7, NintendoNetworkAccount = 8, Social = 9, Search = 10, DecimalPad = 11, OneTimeCode = 12 }
        class UnityEventQueueSystem extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static GenerateEventIdForPayload ($eventPayloadName: string) : string
            public static GetGlobalEventQueue () : System.IntPtr
            public constructor ()
        }
        /** Representation of a Position, and a Rotation in 3D Space
        */
        class Pose extends System.ValueType implements System.IEquatable$1<UnityEngine.Pose>
        {
            protected [__keep_incompatibility]: never;
            /** The position component of the pose.
            */
            public position : UnityEngine.Vector3
            /** The rotation component of the pose.
            */
            public rotation : UnityEngine.Quaternion
            /** Returns the forward vector of the pose.
            */
            public get forward(): UnityEngine.Vector3;
            /** Returns the right vector of the pose.
            */
            public get right(): UnityEngine.Vector3;
            /** Returns the up vector of the pose.
            */
            public get up(): UnityEngine.Vector3;
            /** Shorthand for pose which represents zero position, and an identity rotation.
            */
            public static get identity(): UnityEngine.Pose;
            public ToString () : string
            public ToString ($format: string) : string
            /** Transforms the current pose into the local space of the provided pose.
            */
            public GetTransformedBy ($lhs: UnityEngine.Pose) : UnityEngine.Pose
            /** Transforms the current pose into the local space of the provided pose.
            */
            public GetTransformedBy ($lhs: UnityEngine.Transform) : UnityEngine.Pose
            public Equals ($obj: any) : boolean
            public Equals ($other: UnityEngine.Pose) : boolean
            public static op_Equality ($a: UnityEngine.Pose, $b: UnityEngine.Pose) : boolean
            public static op_Inequality ($a: UnityEngine.Pose, $b: UnityEngine.Pose) : boolean
            public constructor ($position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion)
        }
        /** Controls the from a script.
        */
        class FrameDebugger extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Queries whether the is enabled.
            */
            public static get enabled(): boolean;
        }
        /** An enumeration of transform properties that can be driven on a RectTransform by an object.
        */
        enum DrivenTransformProperties
        { None = 0, All = -1, AnchoredPositionX = 2, AnchoredPositionY = 4, AnchoredPositionZ = 8, Rotation = 16, ScaleX = 32, ScaleY = 64, ScaleZ = 128, AnchorMinX = 256, AnchorMinY = 512, AnchorMaxX = 1024, AnchorMaxY = 2048, SizeDeltaX = 4096, SizeDeltaY = 8192, PivotX = 16384, PivotY = 32768, AnchoredPosition = 6, AnchoredPosition3D = 14, Scale = 224, AnchorMin = 768, AnchorMax = 3072, Anchors = 3840, SizeDelta = 12288, Pivot = 49152 }
        /** A component can be designed to drive a RectTransform. The DrivenRectTransformTracker struct is used to specify which RectTransforms it is driving.
        */
        class DrivenRectTransformTracker extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Stop recording undo actions from driven RectTransforms.
            */
            public static StopRecordingUndo () : void
            /** Resume recording undo of driven RectTransforms.
            */
            public static StartRecordingUndo () : void
            /** Add a RectTransform to be driven.
            * @param $driver The object to drive properties.
            * @param $rectTransform The RectTransform to be driven.
            * @param $drivenProperties The properties to be driven.
            */
            public Add ($driver: UnityEngine.Object, $rectTransform: UnityEngine.RectTransform, $drivenProperties: UnityEngine.DrivenTransformProperties) : void
            /** Clear the list of RectTransforms being driven.
            */
            public Clear () : void
        }
        /** Position, size, anchor and pivot information for a rectangle.
        */
        class RectTransform extends UnityEngine.Transform implements System.Collections.IEnumerable
        {
            protected [__keep_incompatibility]: never;
            /** The calculated rectangle in the local space of the Transform.
            */
            public get rect(): UnityEngine.Rect;
            /** The normalized position in the parent RectTransform that the lower left corner is anchored to.
            */
            public get anchorMin(): UnityEngine.Vector2;
            public set anchorMin(value: UnityEngine.Vector2);
            /** The normalized position in the parent RectTransform that the upper right corner is anchored to.
            */
            public get anchorMax(): UnityEngine.Vector2;
            public set anchorMax(value: UnityEngine.Vector2);
            /** The position of the pivot of this RectTransform relative to the anchor reference point.
            */
            public get anchoredPosition(): UnityEngine.Vector2;
            public set anchoredPosition(value: UnityEngine.Vector2);
            /** The size of this RectTransform relative to the distances between the anchors.
            */
            public get sizeDelta(): UnityEngine.Vector2;
            public set sizeDelta(value: UnityEngine.Vector2);
            /** The normalized position in this RectTransform that it rotates around.
            */
            public get pivot(): UnityEngine.Vector2;
            public set pivot(value: UnityEngine.Vector2);
            /** The 3D position of the pivot of this RectTransform relative to the anchor reference point.
            */
            public get anchoredPosition3D(): UnityEngine.Vector3;
            public set anchoredPosition3D(value: UnityEngine.Vector3);
            /** The offset of the lower left corner of the rectangle relative to the lower left anchor.
            */
            public get offsetMin(): UnityEngine.Vector2;
            public set offsetMin(value: UnityEngine.Vector2);
            /** The offset of the upper right corner of the rectangle relative to the upper right anchor.
            */
            public get offsetMax(): UnityEngine.Vector2;
            public set offsetMax(value: UnityEngine.Vector2);
            /** The object that is driving the values of this RectTransform. Value is null if not driven.
            */
            public get drivenByObject(): UnityEngine.Object;
            public static add_reapplyDrivenProperties ($value: UnityEngine.RectTransform.ReapplyDrivenProperties) : void
            public static remove_reapplyDrivenProperties ($value: UnityEngine.RectTransform.ReapplyDrivenProperties) : void
            /** Force the recalculation of RectTransforms internal data.
            */
            public ForceUpdateRectTransforms () : void
            /** Get the corners of the calculated rectangle in the local space of its Transform.
            * @param $fourCornersArray The array that corners are filled into.
            */
            public GetLocalCorners ($fourCornersArray: System.Array$1<UnityEngine.Vector3>) : void
            /** Get the corners of the calculated rectangle in world space.
            * @param $fourCornersArray The array that corners are filled into.
            */
            public GetWorldCorners ($fourCornersArray: System.Array$1<UnityEngine.Vector3>) : void
            public SetInsetAndSizeFromParentEdge ($edge: UnityEngine.RectTransform.Edge, $inset: number, $size: number) : void
            public SetSizeWithCurrentAnchors ($axis: UnityEngine.RectTransform.Axis, $size: number) : void
            public constructor ()
        }
        /** SpriteRenderer draw mode.
        */
        enum SpriteDrawMode
        { Simple = 0, Sliced = 1, Tiled = 2 }
        /** Tiling mode for SpriteRenderer.tileMode.
        */
        enum SpriteTileMode
        { Continuous = 0, Adaptive = 1 }
        /** Renders a Sprite for 2D graphics.
        */
        class SpriteRenderer extends UnityEngine.Renderer
        {
            protected [__keep_incompatibility]: never;
            /** The Sprite to render.
            */
            public get sprite(): UnityEngine.Sprite;
            public set sprite(value: UnityEngine.Sprite);
            /** The current draw mode of the Sprite Renderer.
            */
            public get drawMode(): UnityEngine.SpriteDrawMode;
            public set drawMode(value: UnityEngine.SpriteDrawMode);
            /** Property to set or get the size to render when the SpriteRenderer.drawMode is set to SpriteDrawMode.Sliced or SpriteDrawMode.Tiled.
            */
            public get size(): UnityEngine.Vector2;
            public set size(value: UnityEngine.Vector2);
            /** The current threshold for Sprite Renderer tiling.
            */
            public get adaptiveModeThreshold(): number;
            public set adaptiveModeThreshold(value: number);
            /** The current tile mode of the Sprite Renderer.
            */
            public get tileMode(): UnityEngine.SpriteTileMode;
            public set tileMode(value: UnityEngine.SpriteTileMode);
            /** Rendering color for the Sprite graphic.
            */
            public get color(): UnityEngine.Color;
            public set color(value: UnityEngine.Color);
            /** Specifies how the sprite interacts with the masks.
            */
            public get maskInteraction(): UnityEngine.SpriteMaskInteraction;
            public set maskInteraction(value: UnityEngine.SpriteMaskInteraction);
            /** Flips the sprite on the X axis.
            */
            public get flipX(): boolean;
            public set flipX(value: boolean);
            /** Flips the sprite on the Y axis.
            */
            public get flipY(): boolean;
            public set flipY(value: boolean);
            /** Determines the position of the Sprite used for sorting the SpriteRenderer.
            */
            public get spriteSortPoint(): UnityEngine.SpriteSortPoint;
            public set spriteSortPoint(value: UnityEngine.SpriteSortPoint);
            public RegisterSpriteChangeCallback ($callback: UnityEngine.Events.UnityAction$1<UnityEngine.SpriteRenderer>) : void
            public UnregisterSpriteChangeCallback ($callback: UnityEngine.Events.UnityAction$1<UnityEngine.SpriteRenderer>) : void
            public constructor ()
        }
        /** Represents a Sprite object for use in 2D gameplay.
        */
        class Sprite extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** Bounds of the Sprite, specified by its center and extents in world space units.
            */
            public get bounds(): UnityEngine.Bounds;
            /** Location of the Sprite on the original Texture, specified in pixels.
            */
            public get rect(): UnityEngine.Rect;
            /** Returns the border sizes of the Sprite.
            */
            public get border(): UnityEngine.Vector4;
            /** Get the reference to the used Texture. If packed this will point to the atlas, if not packed will point to the source Sprite.
            */
            public get texture(): UnityEngine.Texture2D;
            /** The number of pixels in the Sprite that correspond to one unit in world space. (Read Only)
            */
            public get pixelsPerUnit(): number;
            /** The Variant scale of Texture used by the Sprite. This is useful to check when a Variant SpriteAtlas is being used by Sprites.
            */
            public get spriteAtlasTextureScale(): number;
            /** Returns the Texture that contains the alpha channel from the source Texture. Unity generates this Texture under the hood for Sprites that have alpha in the source, and need to be compressed using techniques like ETC1.
            Returns NULL if there is no associated alpha Texture for the source Sprite. This is the case if the Sprite has not been setup to use ETC1 compression.
            */
            public get associatedAlphaSplitTexture(): UnityEngine.Texture2D;
            /** Location of the Sprite's center point in the Rect on the original Texture, specified in pixels.
            */
            public get pivot(): UnityEngine.Vector2;
            /** Returns true if this Sprite is packed in an atlas.
            */
            public get packed(): boolean;
            /** If Sprite is packed (see Sprite.packed), returns its SpritePackingMode.
            */
            public get packingMode(): UnityEngine.SpritePackingMode;
            /** If Sprite is packed (see Sprite.packed), returns its SpritePackingRotation.
            */
            public get packingRotation(): UnityEngine.SpritePackingRotation;
            /** Get the rectangle this Sprite uses on its Texture. Raises an exception if this Sprite is tightly packed in an atlas.
            */
            public get textureRect(): UnityEngine.Rect;
            /** Gets the offset of the rectangle this Sprite uses on its Texture to the original Sprite bounds. If Sprite mesh type is FullRect, offset is zero.
            */
            public get textureRectOffset(): UnityEngine.Vector2;
            /** Returns a copy of the array containing Sprite mesh vertex positions.
            */
            public get vertices(): System.Array$1<UnityEngine.Vector2>;
            /** Returns a copy of the array containing Sprite mesh triangles.
            */
            public get triangles(): System.Array$1<number>;
            /** The base Texture coordinates of the Sprite mesh.
            */
            public get uv(): System.Array$1<UnityEngine.Vector2>;
            /** Gets the number of Secondary Textures that the Sprite is using.
            * @returns Returns the number of Secondary Textures that the Sprite is using. 
            */
            public GetSecondaryTextureCount () : number
            /** Retrieves an array of SecondarySpriteTexture used by the Sprite.
            * @param $secondaryTexture The array of SecondarySpriteTexture to contain the Secondary Textures properties used by the Sprite.
            * @returns Returns the number of Secondary Textures properties retrieved. 
            */
            public GetSecondaryTextures ($secondaryTexture: System.Array$1<UnityEngine.SecondarySpriteTexture>) : number
            /** The number of physics shapes for the Sprite.
            * @returns The number of physics shapes for the Sprite. 
            */
            public GetPhysicsShapeCount () : number
            /** Gets the number of ScriptableObject that the sprite references.
            * @returns Returns the number of ScriptableObject that the sprite is referencing.
            */
            public GetScriptableObjectsCount () : number
            /** Retrieves an array of ScriptableObject referenced by the sprite.
            * @param $scriptableObjects The array of ScriptableObject to contain the ScriptableObjects referenced by the sprite.
            * @returns Returns the number of ScriptableObjects retrieved. 
            */
            public GetScriptableObjects ($scriptableObjects: System.Array$1<UnityEngine.ScriptableObject>) : number
            /** Adds a ScriptableObject reference to the sprite.
            * @param $obj The ScriptableObject reference to add.
            * @returns Returns true if the reference is added. Returns false if the sprite is already referencing the ScriptableObject .
            */
            public AddScriptableObject ($obj: UnityEngine.ScriptableObject) : boolean
            /** Removes the ScriptableObject reference from the sprite.
            * @param $i The index of the ScriptableObject reference to remove.
            * @returns Returns true if the reference is removed. Returns false if the sprite is not referencing the ScriptableObject.
            */
            public RemoveScriptableObjectAt ($i: number) : boolean
            /** Replace the ScriptableObject reference from the sprite.
            * @param $obj The new ScriptableObject to reference.
            * @param $i The index of the ScriptableObject reference to be replaced.
            * @returns Returns true if the reference is replaced. Returns false otherwise. 
            */
            public SetScriptableObjectAt ($obj: UnityEngine.ScriptableObject, $i: number) : boolean
            /** Retrieves the number of points in the selected physics shape for the sprite.
            * @param $shapeIdx The index of the physics shape to retrieve the number of points from.
            * @returns Returns the number of points in the selected physics shape for the sprite.
            */
            public GetPhysicsShapePointCount ($shapeIdx: number) : number
            public GetPhysicsShape ($shapeIdx: number, $physicsShape: System.Collections.Generic.List$1<UnityEngine.Vector2>) : number
            public OverridePhysicsShape ($physicsShapes: System.Collections.Generic.IList$1<System.Array$1<UnityEngine.Vector2>>) : void
            /** Sets up new Sprite geometry.
            * @param $vertices Array of vertex positions in Sprite Rect space.
            * @param $triangles Array of sprite mesh triangle indices.
            */
            public OverrideGeometry ($vertices: System.Array$1<UnityEngine.Vector2>, $triangles: System.Array$1<number>) : void
            /** Create a new Sprite object.
            * @param $texture The Texture to obtain the Sprite graphic from.
            * @param $rect The rectangular section of the Texture to use for the Sprite.
            * @param $pivot The Sprite's pivot point relative to its graphic rectangle.
            * @param $pixelsPerUnit The number of pixels in the Sprite that correspond to one unit in world space.
            * @param $extrude The amount by which the Sprite mesh should be expanded outwards.
            * @param $meshType The type of mesh that is generated for the Sprite.
            * @param $border The border sizes of the Sprite (X=left, Y=bottom, Z=right, W=top).
            * @param $generateFallbackPhysicsShape Whether to generate a default physics shape for the Sprite.
            * @param $secondaryTextures The Secondary Texture properties to be used by the created Sprite.
            */
            public static Create ($texture: UnityEngine.Texture2D, $rect: UnityEngine.Rect, $pivot: UnityEngine.Vector2, $pixelsPerUnit: number, $extrude: number, $meshType: UnityEngine.SpriteMeshType, $border: UnityEngine.Vector4, $generateFallbackPhysicsShape: boolean) : UnityEngine.Sprite
            /** Create a new Sprite object.
            * @param $texture The Texture to obtain the Sprite graphic from.
            * @param $rect The rectangular section of the Texture to use for the Sprite.
            * @param $pivot The Sprite's pivot point relative to its graphic rectangle.
            * @param $pixelsPerUnit The number of pixels in the Sprite that correspond to one unit in world space.
            * @param $extrude The amount by which the Sprite mesh should be expanded outwards.
            * @param $meshType The type of mesh that is generated for the Sprite.
            * @param $border The border sizes of the Sprite (X=left, Y=bottom, Z=right, W=top).
            * @param $generateFallbackPhysicsShape Whether to generate a default physics shape for the Sprite.
            * @param $secondaryTextures The Secondary Texture properties to be used by the created Sprite.
            */
            public static Create ($texture: UnityEngine.Texture2D, $rect: UnityEngine.Rect, $pivot: UnityEngine.Vector2, $pixelsPerUnit: number, $extrude: number, $meshType: UnityEngine.SpriteMeshType, $border: UnityEngine.Vector4, $generateFallbackPhysicsShape: boolean, $secondaryTextures: System.Array$1<UnityEngine.SecondarySpriteTexture>) : UnityEngine.Sprite
            /** Create a new Sprite object.
            * @param $texture The Texture to obtain the Sprite graphic from.
            * @param $rect The rectangular section of the Texture to use for the Sprite.
            * @param $pivot The Sprite's pivot point relative to its graphic rectangle.
            * @param $pixelsPerUnit The number of pixels in the Sprite that correspond to one unit in world space.
            * @param $extrude The amount by which the Sprite mesh should be expanded outwards.
            * @param $meshType The type of mesh that is generated for the Sprite.
            * @param $border The border sizes of the Sprite (X=left, Y=bottom, Z=right, W=top).
            * @param $generateFallbackPhysicsShape Whether to generate a default physics shape for the Sprite.
            * @param $secondaryTextures The Secondary Texture properties to be used by the created Sprite.
            */
            public static Create ($texture: UnityEngine.Texture2D, $rect: UnityEngine.Rect, $pivot: UnityEngine.Vector2, $pixelsPerUnit: number, $extrude: number, $meshType: UnityEngine.SpriteMeshType, $border: UnityEngine.Vector4) : UnityEngine.Sprite
            /** Create a new Sprite object.
            * @param $texture The Texture to obtain the Sprite graphic from.
            * @param $rect The rectangular section of the Texture to use for the Sprite.
            * @param $pivot The Sprite's pivot point relative to its graphic rectangle.
            * @param $pixelsPerUnit The number of pixels in the Sprite that correspond to one unit in world space.
            * @param $extrude The amount by which the Sprite mesh should be expanded outwards.
            * @param $meshType The type of mesh that is generated for the Sprite.
            * @param $border The border sizes of the Sprite (X=left, Y=bottom, Z=right, W=top).
            * @param $generateFallbackPhysicsShape Whether to generate a default physics shape for the Sprite.
            * @param $secondaryTextures The Secondary Texture properties to be used by the created Sprite.
            */
            public static Create ($texture: UnityEngine.Texture2D, $rect: UnityEngine.Rect, $pivot: UnityEngine.Vector2, $pixelsPerUnit: number, $extrude: number, $meshType: UnityEngine.SpriteMeshType) : UnityEngine.Sprite
            /** Create a new Sprite object.
            * @param $texture The Texture to obtain the Sprite graphic from.
            * @param $rect The rectangular section of the Texture to use for the Sprite.
            * @param $pivot The Sprite's pivot point relative to its graphic rectangle.
            * @param $pixelsPerUnit The number of pixels in the Sprite that correspond to one unit in world space.
            * @param $extrude The amount by which the Sprite mesh should be expanded outwards.
            * @param $meshType The type of mesh that is generated for the Sprite.
            * @param $border The border sizes of the Sprite (X=left, Y=bottom, Z=right, W=top).
            * @param $generateFallbackPhysicsShape Whether to generate a default physics shape for the Sprite.
            * @param $secondaryTextures The Secondary Texture properties to be used by the created Sprite.
            */
            public static Create ($texture: UnityEngine.Texture2D, $rect: UnityEngine.Rect, $pivot: UnityEngine.Vector2, $pixelsPerUnit: number, $extrude: number) : UnityEngine.Sprite
            /** Create a new Sprite object.
            * @param $texture The Texture to obtain the Sprite graphic from.
            * @param $rect The rectangular section of the Texture to use for the Sprite.
            * @param $pivot The Sprite's pivot point relative to its graphic rectangle.
            * @param $pixelsPerUnit The number of pixels in the Sprite that correspond to one unit in world space.
            * @param $extrude The amount by which the Sprite mesh should be expanded outwards.
            * @param $meshType The type of mesh that is generated for the Sprite.
            * @param $border The border sizes of the Sprite (X=left, Y=bottom, Z=right, W=top).
            * @param $generateFallbackPhysicsShape Whether to generate a default physics shape for the Sprite.
            * @param $secondaryTextures The Secondary Texture properties to be used by the created Sprite.
            */
            public static Create ($texture: UnityEngine.Texture2D, $rect: UnityEngine.Rect, $pivot: UnityEngine.Vector2, $pixelsPerUnit: number) : UnityEngine.Sprite
            /** Create a new Sprite object.
            * @param $texture The Texture to obtain the Sprite graphic from.
            * @param $rect The rectangular section of the Texture to use for the Sprite.
            * @param $pivot The Sprite's pivot point relative to its graphic rectangle.
            * @param $pixelsPerUnit The number of pixels in the Sprite that correspond to one unit in world space.
            * @param $extrude The amount by which the Sprite mesh should be expanded outwards.
            * @param $meshType The type of mesh that is generated for the Sprite.
            * @param $border The border sizes of the Sprite (X=left, Y=bottom, Z=right, W=top).
            * @param $generateFallbackPhysicsShape Whether to generate a default physics shape for the Sprite.
            * @param $secondaryTextures The Secondary Texture properties to be used by the created Sprite.
            */
            public static Create ($texture: UnityEngine.Texture2D, $rect: UnityEngine.Rect, $pivot: UnityEngine.Vector2) : UnityEngine.Sprite
        }
        /** Determines the position of the Sprite used for sorting the Renderer.
        */
        enum SpriteSortPoint
        { Center = 0, Pivot = 1 }
        /** Defines the type of mesh generated for a sprite.
        */
        enum SpriteMeshType
        { FullRect = 0, Tight = 1 }
        /** How a Sprite's graphic rectangle is aligned with its pivot point.
        */
        enum SpriteAlignment
        { Center = 0, TopLeft = 1, TopCenter = 2, TopRight = 3, LeftCenter = 4, RightCenter = 5, BottomLeft = 6, BottomCenter = 7, BottomRight = 8, Custom = 9 }
        /** Sprite packing modes for the Sprite Packer.
        */
        enum SpritePackingMode
        { Tight = 0, Rectangle = 1 }
        /** Sprite rotation modes for the Sprite Packer.
        */
        enum SpritePackingRotation
        { None = 0, FlipHorizontal = 1, FlipVertical = 2, Rotate180 = 3, Any = 15 }
        /** Encapsulates a Texture2D and its shader property name to give Sprite-based renderers access to a secondary texture, in addition to the main Sprite texture.
        */
        class SecondarySpriteTexture extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The shader property name of the secondary Sprite texture. Use this name to identify and sample the texture in the shader.
            */
            public name : string
            /** The texture to be used as a secondary Sprite texture.
            */
            public texture : UnityEngine.Texture2D
        }
    }
    namespace Unity.Jobs {
        interface IJob
        {
            /** Implement this method to perform work on a worker thread.
            */
            Execute () : void
        }
        /** Extension methods for Jobs using the IJob interface.
        */
        class IJobExtensions extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        /** A handle to a job, which uniquely identifies a job scheduled in the job system.
        */
        class JobHandle extends System.ValueType implements System.IEquatable$1<Unity.Jobs.JobHandle>
        {
            protected [__keep_incompatibility]: never;
            /** Returns false if the task is currently running. Returns true if the task has completed.
            */
            public get IsCompleted(): boolean;
            /** Ensures that the job has completed.
            */
            public Complete () : void
            /** Ensures that all jobs have completed.
            */
            public static CompleteAll ($job0: $Ref<Unity.Jobs.JobHandle>, $job1: $Ref<Unity.Jobs.JobHandle>) : void
            /** Ensures that all jobs have completed.
            */
            public static CompleteAll ($job0: $Ref<Unity.Jobs.JobHandle>, $job1: $Ref<Unity.Jobs.JobHandle>, $job2: $Ref<Unity.Jobs.JobHandle>) : void
            public static CompleteAll ($jobs: Unity.Collections.NativeArray$1<Unity.Jobs.JobHandle>) : void
            /** By default jobs are only put on a local queue when using Job Schedule functions, this actually makes them available to the worker threads to execute them.
            */
            public static ScheduleBatchedJobs () : void
            /** Combines multiple dependencies into a single one.
            */
            public static CombineDependencies ($job0: Unity.Jobs.JobHandle, $job1: Unity.Jobs.JobHandle) : Unity.Jobs.JobHandle
            /** Combines multiple dependencies into a single one.
            */
            public static CombineDependencies ($job0: Unity.Jobs.JobHandle, $job1: Unity.Jobs.JobHandle, $job2: Unity.Jobs.JobHandle) : Unity.Jobs.JobHandle
            public static CombineDependencies ($jobs: Unity.Collections.NativeArray$1<Unity.Jobs.JobHandle>) : Unity.Jobs.JobHandle
            public static CombineDependencies ($jobs: Unity.Collections.NativeSlice$1<Unity.Jobs.JobHandle>) : Unity.Jobs.JobHandle
            /** CheckFenceIsDependencyOrDidSyncFence.
            * @param $jobHandle Job handle.
            * @param $dependsOn Job handle dependency.
            * @returns Return value. 
            */
            public static CheckFenceIsDependencyOrDidSyncFence ($jobHandle: Unity.Jobs.JobHandle, $dependsOn: Unity.Jobs.JobHandle) : boolean
            public Equals ($other: Unity.Jobs.JobHandle) : boolean
            public Equals ($obj: any) : boolean
            public static op_Equality ($a: Unity.Jobs.JobHandle, $b: Unity.Jobs.JobHandle) : boolean
            public static op_Inequality ($a: Unity.Jobs.JobHandle, $b: Unity.Jobs.JobHandle) : boolean
        }
        interface IJobFor
        {
            /** Implement this method to perform work against a specific iteration index.
            * @param $index The index of the for loop at which to perform work.
            */
            Execute ($index: number) : void
        }
        /** Extension methods for Jobs using the IJobFor.
        */
        class IJobForExtensions extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        interface IJobParallelFor
        {
            /** Implement this method to perform work against a specific iteration index.
            * @param $index The index of the Parallel for loop at which to perform work.
            */
            Execute ($index: number) : void
        }
        /** Extension methods for Jobs using the IJobParallelFor.
        */
        class IJobParallelForExtensions extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace Unity.Collections {
        class NativeArray$1<T> extends System.ValueType implements System.Collections.Generic.IEnumerable$1<T>, System.Collections.IEnumerable, System.IDisposable, System.IEquatable$1<Unity.Collections.NativeArray$1<T>>
        {
            protected [__keep_incompatibility]: never;
            public get Length(): number;
            public get IsCreated(): boolean;
            public get_Item ($index: number) : T
            public set_Item ($index: number, $value: T) : void
            public Dispose () : void
            public Dispose ($inputDeps: Unity.Jobs.JobHandle) : Unity.Jobs.JobHandle
            public CopyFrom ($array: System.Array$1<T>) : void
            public CopyFrom ($array: Unity.Collections.NativeArray$1<T>) : void
            public CopyTo ($array: System.Array$1<T>) : void
            public CopyTo ($array: Unity.Collections.NativeArray$1<T>) : void
            public ToArray () : System.Array$1<T>
            public GetEnumerator () : Unity.Collections.NativeArray$1.Enumerator<T>
            public Equals ($other: Unity.Collections.NativeArray$1<T>) : boolean
            public Equals ($obj: any) : boolean
            public static op_Equality ($left: any, $right: any) : any
            public static op_Inequality ($left: any, $right: any) : any
            public static Copy ($src: any, $dst: any) : any
            public static Copy ($src: any, $dst: any) : any
            public static Copy ($src: any, $dst: any) : any
            public static Copy ($src: any, $dst: any) : any
            public static Copy ($src: any, $dst: any) : any
            public static Copy ($src: any, $dst: any, $length: any) : any
            public static Copy ($src: any, $dst: any, $length: any) : any
            public static Copy ($src: any, $dst: any, $length: any) : any
            public static Copy ($src: any, $dst: any, $length: any) : any
            public static Copy ($src: any, $dst: any, $length: any) : any
            public static Copy ($src: any, $srcIndex: any, $dst: any, $dstIndex: any, $length: any) : any
            public static Copy ($src: any, $srcIndex: any, $dst: any, $dstIndex: any, $length: any) : any
            public static Copy ($src: any, $srcIndex: any, $dst: any, $dstIndex: any, $length: any) : any
            public static Copy ($src: any, $srcIndex: any, $dst: any, $dstIndex: any, $length: any) : any
            public static Copy ($src: any, $srcIndex: any, $dst: any, $dstIndex: any, $length: any) : any
            public GetSubArray ($start: number, $length: number) : Unity.Collections.NativeArray$1<T>
            public AsReadOnly () : Unity.Collections.NativeArray$1.ReadOnly<T>
            public constructor ($length: number, $allocator: Unity.Collections.Allocator, $options?: Unity.Collections.NativeArrayOptions)
            public constructor ($array: System.Array$1<T>, $allocator: Unity.Collections.Allocator)
            public constructor ($array: Unity.Collections.NativeArray$1<T>, $allocator: Unity.Collections.Allocator)
            public [Symbol.iterator]() : IterableIterator<T>
        }
        class NativeSlice$1<T> extends System.ValueType implements System.Collections.Generic.IEnumerable$1<T>, System.Collections.IEnumerable, System.IEquatable$1<Unity.Collections.NativeSlice$1<T>>
        {
            protected [__keep_incompatibility]: never;
            public get Stride(): number;
            public get Length(): number;
            public static op_Implicit ($array: any) : any
            public get_Item ($index: number) : T
            public set_Item ($index: number, $value: T) : void
            public CopyFrom ($slice: Unity.Collections.NativeSlice$1<T>) : void
            public CopyFrom ($array: System.Array$1<T>) : void
            public CopyTo ($array: Unity.Collections.NativeArray$1<T>) : void
            public CopyTo ($array: System.Array$1<T>) : void
            public ToArray () : System.Array$1<T>
            public GetEnumerator () : Unity.Collections.NativeSlice$1.Enumerator<T>
            public Equals ($other: Unity.Collections.NativeSlice$1<T>) : boolean
            public Equals ($obj: any) : boolean
            public static op_Equality ($left: any, $right: any) : any
            public static op_Inequality ($left: any, $right: any) : any
            public constructor ($slice: Unity.Collections.NativeSlice$1<T>, $start: number)
            public constructor ($slice: Unity.Collections.NativeSlice$1<T>, $start: number, $length: number)
            public constructor ($array: Unity.Collections.NativeArray$1<T>)
            public constructor ($array: Unity.Collections.NativeArray$1<T>, $start: number)
            public constructor ($array: Unity.Collections.NativeArray$1<T>, $start: number, $length: number)
            public [Symbol.iterator]() : IterableIterator<T>
        }
        /** The ReadOnly attribute lets you mark a member of a struct used in a job as read-only.
        */
        class ReadOnlyAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** The WriteOnly attribute lets you mark a member of a struct used in a job as write-only.
        */
        class WriteOnlyAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Automatically deallocates the native container when the job is finished.
        */
        class DeallocateOnJobCompletionAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** The container has from start a size that will never change.
        */
        class NativeFixedLengthAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            /** The fixed number of elements in the container.
            */
            public FixedLength : number
            public constructor ($fixedLength: number)
        }
        class NativeMatchesParallelForLengthAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** NativeDisableParallelForRestrictionAttribute.
        */
        class NativeDisableParallelForRestrictionAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Used to specify allocation type for NativeArray.
        */
        enum Allocator
        { Invalid = 0, None = 1, Temp = 2, TempJob = 3, Persistent = 4, AudioKernel = 5, Domain = 6, FirstUserIndex = 64 }
        /** Native leak memory leak detection mode enum.
        */
        enum NativeLeakDetectionMode
        { Disabled = 1, Enabled = 2, EnabledWithStackTrace = 3 }
        /** Static class for native leak detection settings.
        */
        class NativeLeakDetection extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Set whether native memory leak detection should be enabled or disabled.
            */
            public static get Mode(): Unity.Collections.NativeLeakDetectionMode;
            public static set Mode(value: Unity.Collections.NativeLeakDetectionMode);
        }
        /** NativeArrayOptions lets you control if memory should be cleared on allocation or left uninitialized.
        */
        enum NativeArrayOptions
        { UninitializedMemory = 0, ClearMemory = 1 }
        class NativeSliceExtensions extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace Unity.Jobs.LowLevel.Unsafe {
        class BatchQueryJob$2<CommandT, ResultT> extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public constructor ($commands: Unity.Collections.NativeArray$1<CommandT>, $results: Unity.Collections.NativeArray$1<ResultT>)
        }
        class BatchQueryJobStruct$1<T> extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public static Initialize () : any
        }
        /** JobHandle Unsafe Utilities.
        */
        class JobHandleUnsafeUtility extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        /** All job interface types must be marked with the JobProducerType. This is used to compile the Execute method by the Burst ASM inspector.
        */
        class JobProducerTypeAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            /** ProducerType is the type containing a static method named "Execute" method which is the method invokes by the job system.
            */
            public get ProducerType(): System.Type;
            public constructor ($producerType: System.Type)
        }
        /** Struct containing information about a range the job is allowed to work on.
        */
        class JobRanges extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Total iteration count.
            */
            public TotalIterationCount : number
        }
        /** ScheduleMode options for scheduling a manage job.
        */
        enum ScheduleMode
        { Run = 0, Batched = 1, Parallel = 1, Single = 2 }
        /** Determines what the job is used for (ParallelFor or a single job).
        */
        enum JobType
        { Single = 0, ParallelFor = 1 }
        /** Static class containing functionality to create, run and debug jobs.
        */
        class JobsUtility extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** The maximum number of job threads that the job system can create. 
            */
            public static MaxJobThreadCount : number
            /** Size of a cache line.
            */
            public static CacheLineSize : number
            /** Returns true if we this is called from inside of a C# job.
            */
            public static get IsExecutingJob(): boolean;
            /** Enables and disables the job debugger at runtime. Note that currently the job debugger is only supported in the Editor. Thus this only has effect in the editor.
            */
            public static get JobDebuggerEnabled(): boolean;
            public static set JobDebuggerEnabled(value: boolean);
            /** When disabled, forces jobs that have already been compiled with burst to run in mono instead. For example if you want to debug the C# jobs or just want to compare behaviour or performance.
            */
            public static get JobCompilerEnabled(): boolean;
            public static set JobCompilerEnabled(value: boolean);
            /** Maximum number of worker threads available to the Unity JobQueue (Read Only).
            */
            public static get JobWorkerMaximumCount(): number;
            /** Current number of worker threads available to the Unity JobQueue.
            */
            public static get JobWorkerCount(): number;
            public static set JobWorkerCount(value: number);
            /** Returns the index for the current thread when executing a job, otherwise 0. 
            */
            public static get ThreadIndex(): number;
            /** Returns the maximum number of job workers that can work on a job at the same time.
            */
            public static get ThreadIndexCount(): number;
            /** Returns the begin index and end index of the range.
            */
            public static GetJobRange ($ranges: $Ref<Unity.Jobs.LowLevel.Unsafe.JobRanges>, $jobIndex: number, $beginIndex: $Ref<number>, $endIndex: $Ref<number>) : void
            /** Returns the work stealing range.
            * @returns Returns true if successful. 
            */
            public static GetWorkStealingRange ($ranges: $Ref<Unity.Jobs.LowLevel.Unsafe.JobRanges>, $jobIndex: number, $beginIndex: $Ref<number>, $endIndex: $Ref<number>) : boolean
            public static Schedule ($parameters: $Ref<Unity.Jobs.LowLevel.Unsafe.JobsUtility.JobScheduleParameters>) : Unity.Jobs.JobHandle
            public static ScheduleParallelFor ($parameters: $Ref<Unity.Jobs.LowLevel.Unsafe.JobsUtility.JobScheduleParameters>, $arrayLength: number, $innerloopBatchCount: number) : Unity.Jobs.JobHandle
            public static ScheduleParallelForTransform ($parameters: $Ref<Unity.Jobs.LowLevel.Unsafe.JobsUtility.JobScheduleParameters>, $transfromAccesssArray: System.IntPtr) : Unity.Jobs.JobHandle
            public static ScheduleParallelForTransformReadOnly ($parameters: $Ref<Unity.Jobs.LowLevel.Unsafe.JobsUtility.JobScheduleParameters>, $transfromAccesssArray: System.IntPtr, $innerloopBatchCount: number) : Unity.Jobs.JobHandle
            /** Creates job reflection data.
            * @returns Returns pointer to internal JobReflectionData. 
            */
            public static CreateJobReflectionData ($type: System.Type, $managedJobFunction0: any, $managedJobFunction1?: any, $managedJobFunction2?: any) : System.IntPtr
            /** Creates job reflection data.
            * @returns Returns pointer to internal JobReflectionData. 
            */
            public static CreateJobReflectionData ($wrapperJobType: System.Type, $userJobType: System.Type, $managedJobFunction0: any) : System.IntPtr
            /** Reset JobWorkerCount to the Unity adjusted value.
            */
            public static ResetJobWorkerCount () : void
        }
    }
    namespace Unity.Jobs.LowLevel.Unsafe.JobsUtility {
        class JobScheduleParameters extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public Dependency : Unity.Jobs.JobHandle
            public ScheduleMode : number
            public ReflectionData : System.IntPtr
            public JobDataPtr : System.IntPtr
        }
    }
    namespace Unity.IntegerTime {
        /** Data-type representing a discrete time value.
        */
        class DiscreteTime extends System.ValueType implements System.IFormattable, System.IComparable$1<Unity.IntegerTime.DiscreteTime>, System.IEquatable$1<Unity.IntegerTime.DiscreteTime>
        {
            protected [__keep_incompatibility]: never;
            /** The underlying discrete time value, which represents the number of discrete ticks.
            */
            public Value : bigint
            /** The zero value.
            */
            public static Zero : Unity.IntegerTime.DiscreteTime
            /** The minimum representable time.
            */
            public static MinValue : Unity.IntegerTime.DiscreteTime
            /** The maximum representable time.
            */
            public static MaxValue : Unity.IntegerTime.DiscreteTime
            public static TicksPerSecond : number
            /** The duration in seconds of a tick (the smallest representable unit of time).
            */
            public static Tick : number
            /** The maximum representable time in seconds.
            */
            public static MaxValueSeconds : bigint
            /** The minimum representable time in seconds.
            */
            public static MinValueSeconds : bigint
            public static Tick5Fps : number
            public static Tick10Fps : number
            public static Tick12Fps : number
            public static Tick15Fps : number
            public static Tick2397Fps : number
            public static Tick24Fps : number
            public static Tick25Fps : number
            public static Tick2997Fps : number
            public static Tick30Fps : number
            public static Tick48Fps : number
            public static Tick50Fps : number
            public static Tick5995Fps : number
            public static Tick60Fps : number
            public static Tick90Fps : number
            public static Tick11988Fps : number
            public static Tick120Fps : number
            public static Tick240Fps : number
            public static Tick1000Fps : number
            public static Tick8Khz : number
            public static Tick16Khz : number
            public static Tick22Khz : number
            public static Tick44Khz : number
            public static Tick48Khz : number
            public static Tick88Khz : number
            public static Tick96Khz : number
            public static Tick192Khz : number
            /** Explicitly converts a tick value to a DiscreteTime value.
            * @param $v The tick count.
            * @returns The DiscreteTime representation. 
            */
            public static FromTicks ($v: bigint) : Unity.IntegerTime.DiscreteTime
            public static op_Explicit ($v: number) : Unity.IntegerTime.DiscreteTime
            public static op_Explicit ($d: Unity.IntegerTime.DiscreteTime) : number
            public static op_Implicit ($t: Unity.IntegerTime.DiscreteTime) : Unity.IntegerTime.RationalTime
            public static op_Equality ($lhs: Unity.IntegerTime.DiscreteTime, $rhs: Unity.IntegerTime.DiscreteTime) : boolean
            public static op_Inequality ($lhs: Unity.IntegerTime.DiscreteTime, $rhs: Unity.IntegerTime.DiscreteTime) : boolean
            public static op_LessThan ($lhs: Unity.IntegerTime.DiscreteTime, $rhs: Unity.IntegerTime.DiscreteTime) : boolean
            public static op_GreaterThan ($lhs: Unity.IntegerTime.DiscreteTime, $rhs: Unity.IntegerTime.DiscreteTime) : boolean
            public static op_LessThanOrEqual ($lhs: Unity.IntegerTime.DiscreteTime, $rhs: Unity.IntegerTime.DiscreteTime) : boolean
            public static op_GreaterThanOrEqual ($lhs: Unity.IntegerTime.DiscreteTime, $rhs: Unity.IntegerTime.DiscreteTime) : boolean
            public static op_Addition ($lhs: Unity.IntegerTime.DiscreteTime, $rhs: Unity.IntegerTime.DiscreteTime) : Unity.IntegerTime.DiscreteTime
            public static op_Subtraction ($lhs: Unity.IntegerTime.DiscreteTime, $rhs: Unity.IntegerTime.DiscreteTime) : Unity.IntegerTime.DiscreteTime
            public static op_Multiply ($lhs: Unity.IntegerTime.DiscreteTime, $rhs: bigint) : Unity.IntegerTime.DiscreteTime
            public static op_Multiply ($lhs: Unity.IntegerTime.DiscreteTime, $s: number) : Unity.IntegerTime.DiscreteTime
            public static op_Division ($lhs: Unity.IntegerTime.DiscreteTime, $s: number) : Unity.IntegerTime.DiscreteTime
            public static op_Division ($lhs: Unity.IntegerTime.DiscreteTime, $s: bigint) : Unity.IntegerTime.DiscreteTime
            public static op_Modulus ($lhs: Unity.IntegerTime.DiscreteTime, $rhs: Unity.IntegerTime.DiscreteTime) : Unity.IntegerTime.DiscreteTime
            public static op_UnaryNegation ($lhs: Unity.IntegerTime.DiscreteTime) : Unity.IntegerTime.DiscreteTime
            public Equals ($rhs: Unity.IntegerTime.DiscreteTime) : boolean
            public Equals ($o: any) : boolean
            /** Returns a string representation of the time.
            */
            public ToString () : string
            /** Returns a string representation of the time.
            */
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            public CompareTo ($other: Unity.IntegerTime.DiscreteTime) : number
            public constructor ($x: Unity.IntegerTime.DiscreteTime)
            public constructor ($v: number)
            public constructor ($v: bigint)
        }
        /** Data type that represents time as an integer count of a rational number.
        */
        class RationalTime extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Returns the number of ticks.
            */
            public get Count(): bigint;
            /** Returns the number of ticks per second.
            */
            public get Ticks(): Unity.IntegerTime.RationalTime.TicksPerSecond;
            public static FromDouble ($t: number, $ticksPerSecond: Unity.IntegerTime.RationalTime.TicksPerSecond) : Unity.IntegerTime.RationalTime
            public static op_Explicit ($t: Unity.IntegerTime.RationalTime) : Unity.IntegerTime.DiscreteTime
            public constructor ($count: bigint, $ticks: Unity.IntegerTime.RationalTime.TicksPerSecond)
        }
        /** Extension methods for the DiscreteTime.
        */
        class DiscreteTimeTimeExtensions extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Returns the absolute value of a time value.
            * @param $lhs The DiscreteTime input.
            * @returns The absolute value of the input. 
            */
            public static Abs ($lhs: Unity.IntegerTime.DiscreteTime) : Unity.IntegerTime.DiscreteTime
            /** Returns the minimum of two time values.
            * @param $lhs The first operand.
            * @param $rhs The second operand.
            * @returns The minimum of the two specified time values. 
            */
            public static Min ($lhs: Unity.IntegerTime.DiscreteTime, $rhs: Unity.IntegerTime.DiscreteTime) : Unity.IntegerTime.DiscreteTime
            /** Returns the maximum of two time values.
            * @param $lhs The first operand.
            * @param $rhs The second operand.
            * @returns The maximum of the two specified time values. 
            */
            public static Max ($lhs: Unity.IntegerTime.DiscreteTime, $rhs: Unity.IntegerTime.DiscreteTime) : Unity.IntegerTime.DiscreteTime
            /** Clamps the value x into the interval [a, b].
            * @param $x The input value.
            * @param $a The lower bound.
            * @param $b The upper bound.
            * @returns The clamped value. 
            */
            public static Clamp ($x: Unity.IntegerTime.DiscreteTime, $a: Unity.IntegerTime.DiscreteTime, $b: Unity.IntegerTime.DiscreteTime) : Unity.IntegerTime.DiscreteTime
            /** The lower integer number of seconds represented as a DiscreteTime.
            * @param $x The input.
            * @returns The result of rounding a DiscreteTime value up to the nearest integral value less or equal to the original value. 
            */
            public static Floor ($x: Unity.IntegerTime.DiscreteTime) : Unity.IntegerTime.DiscreteTime
            /** Returns b if c is true, a otherwise.
            * @param $a The return value for the true path.
            * @param $b The return value for the false path.
            * @param $c The return value selector.
            * @returns Returns b if c is true, a otherwise. 
            */
            public static Select ($a: Unity.IntegerTime.DiscreteTime, $b: Unity.IntegerTime.DiscreteTime, $c: boolean) : Unity.IntegerTime.DiscreteTime
        }
        /** Extension method operations for RationalTime.
        */
        class RationalTimeExtensions extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Converts the data type to Double.
            * @param $value The RationalTime value.
            * @returns The Double representation for rational time (potentially lossy). 
            */
            public static ToDouble ($value: Unity.IntegerTime.RationalTime) : number
            /** Validity check.
            * @returns True if the TicksPerSecond is valid and false otherwise. 
            */
            public static IsValid ($value: Unity.IntegerTime.RationalTime) : boolean
            public static Convert ($time: Unity.IntegerTime.RationalTime, $rate: Unity.IntegerTime.RationalTime.TicksPerSecond) : Unity.IntegerTime.RationalTime
            /** Adds two Rational Times together.
            * @param $t The left hand side.
            * @param $r The right hand side.
            * @returns A new instance that is the sum of the two operands. 
            */
            public static Add ($lhs: Unity.IntegerTime.RationalTime, $rhs: Unity.IntegerTime.RationalTime) : Unity.IntegerTime.RationalTime
            /** Subtracts a RationalTime from another.
            * @param $t The left hand side.
            * @param $r The right hand side.
            * @returns A new instance that is the difference between the left operand and the right one. 
            */
            public static Subtract ($lhs: Unity.IntegerTime.RationalTime, $rhs: Unity.IntegerTime.RationalTime) : Unity.IntegerTime.RationalTime
            /** Multiplies two Rational Times together.
            * @param $t The left hand side.
            * @param $r The right hand side.
            * @returns A new instance that is the multiplication of the two operands. 
            */
            public static Multiply ($lhs: Unity.IntegerTime.RationalTime, $rhs: Unity.IntegerTime.RationalTime) : Unity.IntegerTime.RationalTime
            /** Divides a RationalTime by another.
            * @param $t The left hand side.
            * @param $r The right hand side.
            * @returns A new instance that is the division of the left operand by the right one. 
            */
            public static Divide ($lhs: Unity.IntegerTime.RationalTime, $rhs: Unity.IntegerTime.RationalTime) : Unity.IntegerTime.RationalTime
        }
    }
    namespace Unity.IntegerTime.RationalTime {
        class TicksPerSecond extends System.ValueType implements System.IEquatable$1<Unity.IntegerTime.RationalTime.TicksPerSecond>
        {
            protected [__keep_incompatibility]: never;
            public static DefaultTicksPerSecond : Unity.IntegerTime.RationalTime.TicksPerSecond
            public static TicksPerSecond24 : Unity.IntegerTime.RationalTime.TicksPerSecond
            public static TicksPerSecond25 : Unity.IntegerTime.RationalTime.TicksPerSecond
            public static TicksPerSecond30 : Unity.IntegerTime.RationalTime.TicksPerSecond
            public static TicksPerSecond50 : Unity.IntegerTime.RationalTime.TicksPerSecond
            public static TicksPerSecond60 : Unity.IntegerTime.RationalTime.TicksPerSecond
            public static TicksPerSecond120 : Unity.IntegerTime.RationalTime.TicksPerSecond
            public static TicksPerSecond2397 : Unity.IntegerTime.RationalTime.TicksPerSecond
            public static TicksPerSecond2425 : Unity.IntegerTime.RationalTime.TicksPerSecond
            public static TicksPerSecond2997 : Unity.IntegerTime.RationalTime.TicksPerSecond
            public static TicksPerSecond5994 : Unity.IntegerTime.RationalTime.TicksPerSecond
            public static TicksPerSecond11988 : Unity.IntegerTime.RationalTime.TicksPerSecond
            public get Numerator(): number;
            public get Denominator(): number;
            public get Valid(): boolean;
            public Equals ($rhs: Unity.IntegerTime.RationalTime.TicksPerSecond) : boolean
            public Equals ($rhs: any) : boolean
            public constructor ($num: number, $den?: number)
        }
    }
    namespace Unity.Profiling {
        /** IgnoredByDeepProfilerAttribute prevents Unity Profiler from capturing method calls.
        */
        class IgnoredByDeepProfilerAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Use to specify category for instrumentation Profiler markers.
        */
        class ProfilerCategory extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Gets Profiler category name.
            */
            public get Name(): string;
            /** Gets Profiler category color.
            */
            public get Color(): UnityEngine.Color32;
            /** Rendering system Profiler category.
            */
            public static get Render(): Unity.Profiling.ProfilerCategory;
            /** Generic C# code Profiler category.
            */
            public static get Scripts(): Unity.Profiling.ProfilerCategory;
            /** UI Profiler category.
            */
            public static get Gui(): Unity.Profiling.ProfilerCategory;
            /** Physics system Profiler category.
            */
            public static get Physics(): Unity.Profiling.ProfilerCategory;
            /** The Physics 2D system category for the Profiler.
            */
            public static get Physics2D(): Unity.Profiling.ProfilerCategory;
            /** Animation Profiler category.
            */
            public static get Animation(): Unity.Profiling.ProfilerCategory;
            /** AI and NavMesh Profiler category.
            */
            public static get Ai(): Unity.Profiling.ProfilerCategory;
            /** Audio system Profiler category.
            */
            public static get Audio(): Unity.Profiling.ProfilerCategory;
            /** Video system Profiler category.
            */
            public static get Video(): Unity.Profiling.ProfilerCategory;
            /** Particle system Profiler category.
            */
            public static get Particles(): Unity.Profiling.ProfilerCategory;
            /** Global Illumination Profiler category.
            */
            public static get Lighting(): Unity.Profiling.ProfilerCategory;
            /** Networking system Profiler category.
            */
            public static get Network(): Unity.Profiling.ProfilerCategory;
            /** Loading system Profiler category.
            */
            public static get Loading(): Unity.Profiling.ProfilerCategory;
            /** VR systen Profiler category.
            */
            public static get Vr(): Unity.Profiling.ProfilerCategory;
            /** Input system Profiler category.
            */
            public static get Input(): Unity.Profiling.ProfilerCategory;
            /** Memory allocation Profiler category.
            */
            public static get Memory(): Unity.Profiling.ProfilerCategory;
            /** Virtual Texturing system Profiler category.
            */
            public static get VirtualTexturing(): Unity.Profiling.ProfilerCategory;
            /** File IO Profiler category.
            */
            public static get FileIO(): Unity.Profiling.ProfilerCategory;
            /** Internal Unity systems Profiler category.
            */
            public static get Internal(): Unity.Profiling.ProfilerCategory;
            public static op_Implicit ($category: Unity.Profiling.ProfilerCategory) : number
            public constructor ($categoryName: string)
            public constructor ($categoryName: string, $color: Unity.Profiling.ProfilerCategoryColor)
        }
        /** Profiler category colors enum.
        */
        enum ProfilerCategoryColor
        { Render = 0, Scripts = 1, BurstJobs = 2, Other = 3, Physics = 4, Animation = 5, Audio = 6, AudioJob = 7, AudioUpdateJob = 8, Lighting = 9, GC = 10, VSync = 11, Memory = 12, Internal = 13, UI = 14, Build = 15, Input = 16 }
        /** Options for determining if a Profiler category is built into Unity by default.
        */
        enum ProfilerCategoryFlags
        { None = 0, Builtin = 1 }
        /** Performance marker used for profiling arbitrary code blocks.
        */
        class ProfilerMarker extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Gets native handle of the ProfilerMarker.
            */
            public get Handle(): System.IntPtr;
            /** Begin profiling a piece of code marked with a custom name defined by this instance of ProfilerMarker.
            * @param $contextUnityObject Object associated with the operation.
            */
            public Begin () : void
            /** Begin profiling a piece of code marked with a custom name defined by this instance of ProfilerMarker.
            * @param $contextUnityObject Object associated with the operation.
            */
            public Begin ($contextUnityObject: UnityEngine.Object) : void
            /** End profiling a piece of code marked with a custom name defined by this instance of ProfilerMarker.
            */
            public End () : void
            /** Creates a helper struct for the scoped using blocks.
            * @returns IDisposable struct which calls Begin and End automatically. 
            */
            public Auto () : Unity.Profiling.ProfilerMarker.AutoScope
            public constructor ($name: string)
            public constructor ($category: Unity.Profiling.ProfilerCategory, $name: string)
            public constructor ($category: Unity.Profiling.ProfilerCategory, $name: string, $flags: Unity.Profiling.LowLevel.MarkerFlags)
        }
        /** Defines Profiler flow event type.
        */
        enum ProfilerFlowEventType
        { Begin = 0, ParallelNext = 1, End = 2, Next = 3 }
        /** Options for Profiler marker data unit types.
        */
        enum ProfilerMarkerDataUnit
        { Undefined = 0, TimeNanoseconds = 1, Bytes = 2, Count = 3, Percent = 4, FrequencyHz = 5 }
        enum ProfilerCounterOptions
        { None = 0, FlushOnEndOfFrame = 2, ResetToZeroOnFlush = 4 }
        /** ProfilerRecorder lifecycle and collection options.
        */
        enum ProfilerRecorderOptions
        { None = 0, StartImmediately = 1, KeepAliveDuringDomainReload = 2, CollectOnlyOnCurrentThread = 4, WrapAroundWhenCapacityReached = 8, SumAllSamplesInFrame = 16, GpuRecorder = 64, Default = 24 }
        /** Sample value structure.
        */
        class ProfilerRecorderSample extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Raw sample value.
            */
            public get Value(): bigint;
            /** Sample count.
            */
            public get Count(): bigint;
        }
        /** Records the Profiler metric data that a Profiler marker or counter produces.
        */
        class ProfilerRecorder extends System.ValueType implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            /** Indicates whether ProfilerRecorder is associated with a valid Profiler marker or counter.
            */
            public get Valid(): boolean;
            /** Value data type of the Profiler metric.
            */
            public get DataType(): Unity.Profiling.LowLevel.ProfilerMarkerDataType;
            /** Unit type.
            */
            public get UnitType(): Unity.Profiling.ProfilerMarkerDataUnit;
            /** Gets current value of the Profiler metric.
            */
            public get CurrentValue(): bigint;
            /** Gets current value of the Profiler metric as double value.
            */
            public get CurrentValueAsDouble(): number;
            /** Gets the last value collected by the ProfilerRecorder.
            */
            public get LastValue(): bigint;
            /** Gets the last value collected by the ProfilerRecorder as double.
            */
            public get LastValueAsDouble(): number;
            /** Maximum amount of samples ProfilerRecorder can capture.
            */
            public get Capacity(): number;
            /** Collected samples count.
            */
            public get Count(): number;
            /** Indicates if ProfilerRecorder is attached to the Profiler metric.
            */
            public get IsRunning(): boolean;
            /** Indicates if ProfilerRecorder capacity has been exceeded.
            */
            public get WrappedAround(): boolean;
            /** Initialize a new instance of ProfilerRecorder and start data collection.
            * @param $category Profiler category.
            * @param $statName Profiler marker or counter name.
            * @param $capacity Maximum amount of samples to collect.
            * @param $options ProfilerRecorder options.
            * @returns Returns new enabled recorder instance. 
            */
            public static StartNew ($category: Unity.Profiling.ProfilerCategory, $statName: string, $capacity?: number, $options?: Unity.Profiling.ProfilerRecorderOptions) : Unity.Profiling.ProfilerRecorder
            /** Initialize a new instance of ProfilerRecorder for ProfilerMarker and start data collection.
            * @param $capacity Maximum amount of samples to be collected.
            * @param $options Profiler recorder options.
            * @param $marker Profiler marker instance.
            * @returns Returns new enabled recorder instance. 
            */
            public static StartNew ($marker: Unity.Profiling.ProfilerMarker, $capacity?: number, $options?: Unity.Profiling.ProfilerRecorderOptions) : Unity.Profiling.ProfilerRecorder
            /** Start data collection.
            */
            public Start () : void
            /** Stops data collection.
            */
            public Stop () : void
            /** Stops data collection and clears collected samples.
            */
            public Reset () : void
            /** Gets sample data.
            */
            public GetSample ($index: number) : Unity.Profiling.ProfilerRecorderSample
            public CopyTo ($outSamples: System.Collections.Generic.List$1<Unity.Profiling.ProfilerRecorderSample>, $reset?: boolean) : void
            /** Use to convert collected samples to an array.
            */
            public ToArray () : System.Array$1<Unity.Profiling.ProfilerRecorderSample>
            /** Releases unmanaged instance of the ProfilerRecorder.
            */
            public Dispose () : void
            public constructor ($statName: string, $capacity?: number, $options?: Unity.Profiling.ProfilerRecorderOptions)
            public constructor ($categoryName: string, $statName: string, $capacity?: number, $options?: Unity.Profiling.ProfilerRecorderOptions)
            public constructor ($category: Unity.Profiling.ProfilerCategory, $statName: string, $capacity?: number, $options?: Unity.Profiling.ProfilerRecorderOptions)
            public constructor ($marker: Unity.Profiling.ProfilerMarker, $capacity?: number, $options?: Unity.Profiling.ProfilerRecorderOptions)
            public constructor ($statHandle: Unity.Profiling.LowLevel.Unsafe.ProfilerRecorderHandle, $capacity?: number, $options?: Unity.Profiling.ProfilerRecorderOptions)
        }
        /** A raw data representation of a screenshot.
        */
        class DebugScreenCapture extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** A non-owning reference to the image data.
            */
            public get RawImageDataReference(): Unity.Collections.NativeArray$1<number>;
            public set RawImageDataReference(value: Unity.Collections.NativeArray$1<number>);
            /** The format in which the image was captured.
            */
            public get ImageFormat(): UnityEngine.TextureFormat;
            public set ImageFormat(value: UnityEngine.TextureFormat);
            /** Width of the image.
            */
            public get Width(): number;
            public set Width(value: number);
            /** Height of the image.
            */
            public get Height(): number;
            public set Height(value: number);
        }
    }
    namespace Unity.Profiling.ProfilerMarker {
        class AutoScope extends System.ValueType implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public Dispose () : void
        }
    }
    namespace Unity.Profiling.LowLevel {
        /** Profiler marker usage flags.
        */
        enum MarkerFlags
        { Default = 0, Script = 2, ScriptInvoke = 32, ScriptDeepProfiler = 64, AvailabilityEditor = 4, AvailabilityNonDevelopment = 8, Warning = 16, Counter = 128, SampleGPU = 256 }
        /** Options for the Profiler metadata type.
        */
        enum ProfilerMarkerDataType
        { InstanceId = 1, Int32 = 2, UInt32 = 3, Int64 = 4, UInt64 = 5, Float = 6, Double = 7, String16 = 9, Blob8 = 11, GfxResourceId = 12 }
    }
    namespace Unity.Profiling.LowLevel.Unsafe {
        /** Gets the handle of a Profiler metric.
        */
        class ProfilerRecorderHandle extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Indicates if a handle is valid and can be used with ProfilerRecorder.
            */
            public get Valid(): boolean;
            /** Gets description of Profiler marker or counter handle.
            */
            public static GetDescription ($handle: Unity.Profiling.LowLevel.Unsafe.ProfilerRecorderHandle) : Unity.Profiling.LowLevel.Unsafe.ProfilerRecorderDescription
            public static GetAvailable ($outRecorderHandleList: System.Collections.Generic.List$1<Unity.Profiling.LowLevel.Unsafe.ProfilerRecorderHandle>) : void
        }
        /** Gets the description of a Profiler metric.
        */
        class ProfilerRecorderDescription extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Gets the ProfilerCategory value of the Profiler metric.
            */
            public get Category(): Unity.Profiling.ProfilerCategory;
            /** Profiler marker flags of the metric.
            */
            public get Flags(): Unity.Profiling.LowLevel.MarkerFlags;
            /** Gets the data value type of the Profiler metric.
            */
            public get DataType(): Unity.Profiling.LowLevel.ProfilerMarkerDataType;
            /** Gets the data unit type of the Profiler metric.
            */
            public get UnitType(): Unity.Profiling.ProfilerMarkerDataUnit;
            /** Name length excluding null terminator.
            */
            public get NameUtf8Len(): number;
            /** The name of the Profiler metric.
            */
            public get Name(): string;
        }
        /** Describes Profiler metadata parameter that can be associated with a sample.
        */
        class ProfilerMarkerData extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Metadata type.
            */
            public Type : number
            /** Size of the metadata value in bytes.
            */
            public Size : number
        }
        /** Provides information about Profiler category.
        */
        class ProfilerCategoryDescription extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Profiler category identifier.
            */
            public Id : number
            /** Profiler category flags.
            */
            public Flags : number
            /** Profiler category color.
            */
            public Color : UnityEngine.Color32
            /** Profiler category name length.
            */
            public NameUtf8Len : number
            /** Gets Profiler category name as string.
            */
            public get Name(): string;
        }
        /** Utility class which provides access to low level Profiler API.
        */
        class ProfilerUnsafeUtility extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Rendering system Profiler category.
            */
            public static CategoryRender : number
            /** Generic C# code Profiler category.
            */
            public static CategoryScripts : number
            /** UI Profiler category.
            */
            public static CategoryGUI : number
            /** Physics system Profiler category.
            */
            public static CategoryPhysics : number
            /** Animation Profiler category.
            */
            public static CategoryAnimation : number
            /** AI and NavMesh Profiler category.
            */
            public static CategoryAi : number
            /** Audio system Profiler category.
            */
            public static CategoryAudio : number
            /** Video system Profiler category.
            */
            public static CategoryVideo : number
            /** Particle system Profiler category.
            */
            public static CategoryParticles : number
            /** Global Illumination Profiler category.
            */
            public static CategoryLighting : number
            /** Networking system Profiler category.
            */
            public static CategoryNetwork : number
            /** Loading system Profiler category.
            */
            public static CategoryLoading : number
            /** Uncategorized Profiler category.
            */
            public static CategoryOther : number
            /** VR systen Profiler category.
            */
            public static CategoryVr : number
            /** Memory allocation Profiler category.
            */
            public static CategoryAllocation : number
            /** Internal Unity systems Profiler category.
            */
            public static CategoryInternal : number
            /** File IO Profiler category.
            */
            public static CategoryFileIO : number
            /** Input system Profiler category.
            */
            public static CategoryInput : number
            /** Virtual Texturing system Profiler category.
            */
            public static CategoryVirtualTexturing : number
            /** Physics 2D system Profiler category.
            */
            public static CategoryPhysics2D : number
            /** Gets Profiler timestamp.
            */
            public static get Timestamp(): bigint;
            /** Gets conversion ratio from Profiler timestamp to nanoseconds.
            */
            public static get TimestampToNanosecondsConversionRatio(): Unity.Profiling.LowLevel.Unsafe.ProfilerUnsafeUtility.TimestampConversionRatio;
            /** Retrieves Profiler category information such as name or color.
            * @param $categoryId Profiler category identifier.
            * @returns Returns description of the category. 
            */
            public static GetCategoryDescription ($categoryId: number) : Unity.Profiling.LowLevel.Unsafe.ProfilerCategoryDescription
            /** Constructs a new Profiler marker handle for code instrumentation.
            * @param $name A marker name.
            * @param $categoryId A profiler category identifier.
            * @param $flags The marker flags.
            * @param $metadataCount The metadata parameters count, or 0 if no parameters are expected.
            * @param $nameLen Marker name string length.
            * @returns Returns the marker native handle. 
            */
            public static CreateMarker ($name: string, $categoryId: number, $flags: Unity.Profiling.LowLevel.MarkerFlags, $metadataCount: number) : System.IntPtr
            /** Set Profiler marker metadata name and type.
            * @param $markerPtr Profiler marker handle.
            * @param $index Metadata parameter index.
            * @param $name Metadata parameter name.
            * @param $type Metadata type. Must be one of ProfilerMarkerDataType values.
            * @param $unit Metadata unit. Must be one of ProfilerMarkerDataUnit values.
            * @param $nameLen Metadata parameter name length.
            */
            public static SetMarkerMetadata ($markerPtr: System.IntPtr, $index: number, $name: string, $type: number, $unit: number) : void
            /** Starts profiling a piece of code marked with a custom name that the markerPtr handle has defined.
            * @param $markerPtr Profiler marker handle.
            */
            public static BeginSample ($markerPtr: System.IntPtr) : void
            /** End profiling a piece of code marked with a custom name defined by this instance of ProfilerMarker.
            * @param $markerPtr Marker handle.
            */
            public static EndSample ($markerPtr: System.IntPtr) : void
            /** Create a new Profiler flow identifier.
            * @returns Returns flow identifier. 
            */
            public static CreateFlow ($categoryId: number) : number
            /** Add flow event to a Profiler sample.
            * @param $flowId Profiler flow identifier.
            * @param $flowEventType Flow event type.
            */
            public static FlowEvent ($flowId: number, $flowEventType: Unity.Profiling.ProfilerFlowEventType) : void
        }
    }
    namespace Unity.Profiling.LowLevel.Unsafe.ProfilerUnsafeUtility {
        class TimestampConversionRatio extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public Numerator : bigint
            public Denominator : bigint
        }
    }
    namespace Unity.Profiling.Memory {
        /** Flags that specify what kind of data to capture in a snapshot.
        */
        enum CaptureFlags
        { ManagedObjects = 1, NativeObjects = 2, NativeAllocations = 4, NativeAllocationSites = 8, NativeStackTraces = 16 }
        /** Container for memory snapshot metadata.
        */
        class MemorySnapshotMetadata extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** User defined metadata.
            */
            public get Description(): string;
            public set Description(value: string);
            public constructor ()
        }
        /** Memory profiling API container class.
        */
        class MemoryProfiler extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static add_CreatingMetadata ($value: System.Action$1<Unity.Profiling.Memory.MemorySnapshotMetadata>) : void
            public static remove_CreatingMetadata ($value: System.Action$1<Unity.Profiling.Memory.MemorySnapshotMetadata>) : void
            public static TakeSnapshot ($path: string, $finishCallback: System.Action$2<string, boolean>, $captureFlags?: Unity.Profiling.Memory.CaptureFlags) : void
            public static TakeSnapshot ($path: string, $finishCallback: System.Action$2<string, boolean>, $screenshotCallback: System.Action$3<string, boolean, Unity.Profiling.DebugScreenCapture>, $captureFlags?: Unity.Profiling.Memory.CaptureFlags) : void
            public static TakeTempSnapshot ($finishCallback: System.Action$2<string, boolean>, $captureFlags?: Unity.Profiling.Memory.CaptureFlags) : void
        }
    }
    namespace Unity.IO.LowLevel.Unsafe {
        /** Describes the offset, size, and destination buffer of a single read operation.
        */
        class ReadCommand extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The offset where the read begins, within the file.
            */
            public Offset : bigint
            /** The size of the read in bytes.
            */
            public Size : bigint
        }
        /** An array of ReadCommand instances to pass to AsyncReadManager.Read and AsyncReadManager.ReadDeferred.
        */
        class ReadCommandArray extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The number of individual entries in the array of ReadCommands pointed to by ReadCommands.
            */
            public CommandCount : number
        }
        /** Defines the possible existential states of a file.
        */
        enum FileState
        { Absent = 0, Exists = 1 }
        /** The possible statuses of a FileHandle.
        */
        enum FileStatus
        { Closed = 0, Pending = 1, Open = 2, OpenFailed = 3 }
        /** The results of an asynchronous AsyncReadManager.GetFileInfo call.
        */
        class FileInfoResult extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Indicates the size of the file in bytes.
            */
            public FileSize : bigint
            /** Indicates whether the file exists or not.
            */
            public FileState : Unity.IO.LowLevel.Unsafe.FileState
        }
        /** Subsystem tags for the read request, describing broad asset type or subsystem that triggered the read request.
        */
        enum AssetLoadingSubsystem
        { Other = 0, Texture = 1, VirtualTexture = 2, Mesh = 3, Audio = 4, Scripts = 5, EntitiesScene = 6, EntitiesStreamBinaryReader = 7, FileInfo = 8, ContentLoading = 9 }
        /** The state of an asynchronous file request.
        */
        enum ReadStatus
        { Complete = 0, InProgress = 1, Failed = 2, Truncated = 4, Canceled = 5 }
        /** The priority level attached to the AsyncReadManager read request.
        */
        enum Priority
        { PriorityLow = 0, PriorityHigh = 1 }
        /** A handle to an asynchronously opened file.
        */
        class FileHandle extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The current status of this FileHandle.
            */
            public get Status(): Unity.IO.LowLevel.Unsafe.FileStatus;
            /** The JobHandle of the asynchronous file open operation begun by the call to AsyncReadManager.OpenFileAsync that returned this FileHandle instance.
            */
            public get JobHandle(): Unity.Jobs.JobHandle;
            /** Reports whether this FileHandle instance is valid.
            * @returns True, if this FileHandle represents an open file; otherwise, false. 
            */
            public IsValid () : boolean
            /** Asynchronously closes the file referenced by this FileHandle and disposes the FileHandle instance.
            * @param $dependency (Optional) The JobHandle to wait on before closing the file.
            * @returns The JobHandle for the asynchronous close operation. You can use this JobHandle as a dependency when scheduling other jobs that must not run before the close operation is finished. 
            */
            public Close ($dependency?: Unity.Jobs.JobHandle) : Unity.Jobs.JobHandle
        }
        /** You can use this handle to query the status of an asynchronous read operation. Note: To avoid a memory leak, you must call Dispose.
        */
        class ReadHandle extends System.ValueType implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            /** JobHandle that completes when the read operation completes.
            */
            public get JobHandle(): Unity.Jobs.JobHandle;
            /** Current state of the read operation.
            */
            public get Status(): Unity.IO.LowLevel.Unsafe.ReadStatus;
            /** The number of read commands performed for this read operation. Will return zero until the reads have begun.
            */
            public get ReadCount(): bigint;
            /** Check if the ReadHandle is valid.
            * @returns True if the ReadHandle is valid. 
            */
            public IsValid () : boolean
            /** Disposes the ReadHandle. Use this to free up internal resources for reuse.
            */
            public Dispose () : void
            /** Cancels the AsyncReadManager.Read operation on this handle.
            */
            public Cancel () : void
            /** Returns the total number of bytes read by all the ReadCommand operations the asynchronous file read request.
            * @returns The total number of bytes read by the asynchronous file read request. 
            */
            public GetBytesRead () : bigint
            /** Returns the total number of bytes read for a specific ReadCommand index.
            * @param $readCommandIndex The index of the ReadCommand for which to retrieve the number of bytes read.
            * @returns The number of bytes read for the specified ReadCommand. 
            */
            public GetBytesRead ($readCommandIndex: number) : bigint
        }
        /** With the AsyncReadManager, you can perform asynchronous I/O operations through Unity's virtual file system. You can perform these operations on any thread or job.
        */
        class AsyncReadManager extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Queues a set of read operations for a file opened with OpenFileAsync.
            * @param $fileHandle The FileHandle to be read from, opened by AsyncReadManager.OpenFileAsync.
            * @param $readCmdArray A struct containing the read commands to queue.
            * @returns A ReadHandle object you can use to check the status and monitor the progress of the read operations. 
            */
            public static Read ($fileHandle: $Ref<Unity.IO.LowLevel.Unsafe.FileHandle>, $readCmdArray: Unity.IO.LowLevel.Unsafe.ReadCommandArray) : Unity.IO.LowLevel.Unsafe.ReadHandle
            /** Opens the file asynchronously.
            * @param $fileName The path to the file to be opened.
            * @returns The FileHandle of the file being opened. Use the FileHandle to check the status of the open operation, to read the file, and to close the file when done. 
            */
            public static OpenFileAsync ($fileName: string) : Unity.IO.LowLevel.Unsafe.FileHandle
            /** Closes a file held open internally by the AsyncReadManager.
            * @param $fileName The path to the file to close.
            * @param $dependency (Optional) A JobHandle to wait on before performing the close.
            * @returns A JobHandle that completes when the asynchronous close operation finishes. 
            */
            public static CloseCachedFileAsync ($fileName: string, $dependency?: Unity.Jobs.JobHandle) : Unity.Jobs.JobHandle
        }
        /** The state of the read request at the time of retrieval of AsyncReadManagerMetrics.
        */
        enum ProcessingState
        { Unknown = 0, InQueue = 1, Reading = 2, Completed = 3, Failed = 4, Canceled = 5 }
        /** The type of FileReadType|file read requested from the AsyncReadManager.
        */
        enum FileReadType
        { Sync = 0, Async = 1 }
        /** Metrics for an individual read request.
        */
        class AsyncReadManagerRequestMetric extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The name of the asset being read.
            */
            public get AssetName(): string;
            /** The filename the read request is reading from.
            */
            public get FileName(): string;
            /** The offset of the read request from the start of the file, in bytes.
            */
            public get OffsetBytes(): bigint;
            /** The size of the read request, in bytes.
            */
            public get SizeBytes(): bigint;
            /** The of the asset being read in the read request.
            */
            public get AssetTypeId(): bigint;
            /** Total number of bytes of the read request read so far.
            */
            public get CurrentBytesRead(): bigint;
            /** The number of batch read commands contained in the read request.
            */
            public get BatchReadCount(): number;
            /** Returns whether this read request contained batch read commands.
            */
            public get IsBatchRead(): boolean;
            /** The ProcessingState|state of the read request at the time of retrieving the metrics.
            */
            public get State(): Unity.IO.LowLevel.Unsafe.ProcessingState;
            /** The FileReadType|read type (sync or async) of the read request.
            */
            public get ReadType(): Unity.IO.LowLevel.Unsafe.FileReadType;
            /** The Priority|priority level of the read request.
            */
            public get PriorityLevel(): Unity.IO.LowLevel.Unsafe.Priority;
            /** The AssetLoadingSubsystem|Subsystem tag assigned to the read operation.
            */
            public get Subsystem(): Unity.IO.LowLevel.Unsafe.AssetLoadingSubsystem;
            /** The time at which the read request was made, in microseconds elapsed since application startup.
            */
            public get RequestTimeMicroseconds(): number;
            /** The amount of time the read request waited in the AsyncReadManager queue, in microseconds.
            */
            public get TimeInQueueMicroseconds(): number;
            /** The total time in microseconds from the read request being added until its completion, or the time of metrics retrieval, depending whether the read has completed or not.
            */
            public get TotalTimeMicroseconds(): number;
        }
        /** Manages the recording and retrieval of metrics from the AsyncReadManager.
        */
        class AsyncReadManagerMetrics extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Reports whether the metrics system for the AsyncReadManager is currently recording data.
            * @returns True, if the metrics system of the AsyncReadManager is currently recording data; false, otherwise. 
            */
            public static IsEnabled () : boolean
            /** Clears the metrics for all completed requests, including failed and canceled requests.
            */
            public static ClearCompletedMetrics () : void
            public static GetMetrics ($filters: Unity.IO.LowLevel.Unsafe.AsyncReadManagerMetricsFilters, $flags: Unity.IO.LowLevel.Unsafe.AsyncReadManagerMetrics.Flags) : System.Array$1<Unity.IO.LowLevel.Unsafe.AsyncReadManagerRequestMetric>
            public static GetMetrics ($outMetrics: System.Collections.Generic.List$1<Unity.IO.LowLevel.Unsafe.AsyncReadManagerRequestMetric>, $filters: Unity.IO.LowLevel.Unsafe.AsyncReadManagerMetricsFilters, $flags: Unity.IO.LowLevel.Unsafe.AsyncReadManagerMetrics.Flags) : void
            public static GetMetrics ($flags: Unity.IO.LowLevel.Unsafe.AsyncReadManagerMetrics.Flags) : System.Array$1<Unity.IO.LowLevel.Unsafe.AsyncReadManagerRequestMetric>
            public static GetMetrics ($outMetrics: System.Collections.Generic.List$1<Unity.IO.LowLevel.Unsafe.AsyncReadManagerRequestMetric>, $flags: Unity.IO.LowLevel.Unsafe.AsyncReadManagerMetrics.Flags) : void
            /** Begin recording metrics data for AsyncReadManager read operations.
            */
            public static StartCollectingMetrics () : void
            /** Stop recording metrics data for AsyncReadManager read operations.
            */
            public static StopCollectingMetrics () : void
            public static GetCurrentSummaryMetrics ($flags: Unity.IO.LowLevel.Unsafe.AsyncReadManagerMetrics.Flags) : Unity.IO.LowLevel.Unsafe.AsyncReadManagerSummaryMetrics
            public static GetCurrentSummaryMetrics ($metricsFilters: Unity.IO.LowLevel.Unsafe.AsyncReadManagerMetricsFilters, $flags: Unity.IO.LowLevel.Unsafe.AsyncReadManagerMetrics.Flags) : Unity.IO.LowLevel.Unsafe.AsyncReadManagerSummaryMetrics
            /** Summarizes an array containing AsyncReadManagerRequestMetric records.
            * @param $metrics Array of previously collected AsyncReadManagerRequestMetrics.
            * @returns Calculated summary of the given metrics. 
            */
            public static GetSummaryOfMetrics ($metrics: System.Array$1<Unity.IO.LowLevel.Unsafe.AsyncReadManagerRequestMetric>) : Unity.IO.LowLevel.Unsafe.AsyncReadManagerSummaryMetrics
            public static GetSummaryOfMetrics ($metrics: System.Collections.Generic.List$1<Unity.IO.LowLevel.Unsafe.AsyncReadManagerRequestMetric>) : Unity.IO.LowLevel.Unsafe.AsyncReadManagerSummaryMetrics
            /** Summarizes AsyncReadManagerRequestMetric records that match the specified filter.
            * @param $metrics List of previously collected AsyncReadManagerRequestMetrics.
            * @param $metricsFilters AsyncReadManagerMetricsFilters|Filters to apply to the data used in calculating the summary.
            * @returns Calculated summary of given metrics that match the filters. 
            */
            public static GetSummaryOfMetrics ($metrics: System.Array$1<Unity.IO.LowLevel.Unsafe.AsyncReadManagerRequestMetric>, $metricsFilters: Unity.IO.LowLevel.Unsafe.AsyncReadManagerMetricsFilters) : Unity.IO.LowLevel.Unsafe.AsyncReadManagerSummaryMetrics
            public static GetSummaryOfMetrics ($metrics: System.Collections.Generic.List$1<Unity.IO.LowLevel.Unsafe.AsyncReadManagerRequestMetric>, $metricsFilters: Unity.IO.LowLevel.Unsafe.AsyncReadManagerMetricsFilters) : Unity.IO.LowLevel.Unsafe.AsyncReadManagerSummaryMetrics
            /** Returns the amount of data (in bytes) read through systems other than the AsyncReadManager.
            * @param $emptyAfterRead Set to true to reset the underlying data counter to zero after calling this function. Set to false if you want each call to this function to return the running, cumulative total.
            * @returns Number of bytes of data read through systems other than the AsyncReadManager since you started metrics collection or you cleared this data counter by setting emptyAfterRead to true. 
            */
            public static GetTotalSizeOfNonASRMReadsBytes ($emptyAfterRead: boolean) : bigint
        }
        /** Defines a filter for selecting specific categories of data when summarizing AsyncReadManager metrics.
        */
        class AsyncReadManagerMetricsFilters extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Set TypeID filters on an existing SummaryMetricsFilters instance.
            * @param $_typeID  to filter by. Summary will include reads that have this type ID only.
            * @param $_typeIDs Array of to filter by. Summary will include reads that have any of these Type IDs.
            */
            public SetTypeIDFilter ($_typeIDs: System.Array$1<bigint>) : void
            /** Set ProcessingState filters on an existing SummaryMetricsFilters instance.
            * @param $_state ProcessingState to filter by. Summary will include reads that have this state only.
            * @param $_states Array of ProcessingState|ProcessingStates to filter by. Summary will include reads that have any of these states.
            */
            public SetStateFilter ($_states: System.Array$1<Unity.IO.LowLevel.Unsafe.ProcessingState>) : void
            /** Set FileReadType filters on an existing SummaryMetricsFilters instance.
            * @param $_readType FileReadType to filter by. Summary will include reads that had this read type only.
            * @param $_readTypes Array of FileReadType|FileReadTypes to filter by. Summary will include reads that have any of these read types.
            */
            public SetReadTypeFilter ($_readTypes: System.Array$1<Unity.IO.LowLevel.Unsafe.FileReadType>) : void
            /** Set Priority filters on an existing SummaryMetricsFilters instance.
            * @param $_priorityLevel Priority level to filter by. Summary will include reads that had this priority level only.
            * @param $_priorityLevels Array of priority levels to filter by. Summary will include reads that have any of these priority levels.
            */
            public SetPriorityFilter ($_priorityLevels: System.Array$1<Unity.IO.LowLevel.Unsafe.Priority>) : void
            /** Set AssetLoadingSubsystem filters on an existing SummaryMetricsFilters instance.
            * @param $_subsystem AssetLoadingSubsystem to filter by. Summary will include reads that have this subsystem tag only.
            * @param $_subsystems Array of AssetLoadingSubsystem|AssetLoadingSubsystems to filter by. Summary will include reads that have any of these subsystem tags.
            */
            public SetSubsystemFilter ($_subsystems: System.Array$1<Unity.IO.LowLevel.Unsafe.AssetLoadingSubsystem>) : void
            /** Set TypeID filters on an existing SummaryMetricsFilters instance.
            * @param $_typeID  to filter by. Summary will include reads that have this type ID only.
            * @param $_typeIDs Array of to filter by. Summary will include reads that have any of these Type IDs.
            */
            public SetTypeIDFilter ($_typeID: bigint) : void
            /** Set ProcessingState filters on an existing SummaryMetricsFilters instance.
            * @param $_state ProcessingState to filter by. Summary will include reads that have this state only.
            * @param $_states Array of ProcessingState|ProcessingStates to filter by. Summary will include reads that have any of these states.
            */
            public SetStateFilter ($_state: Unity.IO.LowLevel.Unsafe.ProcessingState) : void
            /** Set FileReadType filters on an existing SummaryMetricsFilters instance.
            * @param $_readType FileReadType to filter by. Summary will include reads that had this read type only.
            * @param $_readTypes Array of FileReadType|FileReadTypes to filter by. Summary will include reads that have any of these read types.
            */
            public SetReadTypeFilter ($_readType: Unity.IO.LowLevel.Unsafe.FileReadType) : void
            /** Set Priority filters on an existing SummaryMetricsFilters instance.
            * @param $_priorityLevel Priority level to filter by. Summary will include reads that had this priority level only.
            * @param $_priorityLevels Array of priority levels to filter by. Summary will include reads that have any of these priority levels.
            */
            public SetPriorityFilter ($_priorityLevel: Unity.IO.LowLevel.Unsafe.Priority) : void
            /** Set AssetLoadingSubsystem filters on an existing SummaryMetricsFilters instance.
            * @param $_subsystem AssetLoadingSubsystem to filter by. Summary will include reads that have this subsystem tag only.
            * @param $_subsystems Array of AssetLoadingSubsystem|AssetLoadingSubsystems to filter by. Summary will include reads that have any of these subsystem tags.
            */
            public SetSubsystemFilter ($_subsystem: Unity.IO.LowLevel.Unsafe.AssetLoadingSubsystem) : void
            /** Remove the TypeID filters from an existing SummaryMetricsFilters instance.
            */
            public RemoveTypeIDFilter () : void
            /** Remove the State filters from an existing SummaryMetricsFilters instance.
            */
            public RemoveStateFilter () : void
            /** Remove the ReadType filters from an existing SummaryMetricsFilters instance.
            */
            public RemoveReadTypeFilter () : void
            /** Remove the Priority filters from an existing SummaryMetricsFilters instance.
            */
            public RemovePriorityFilter () : void
            /** Remove the Subsystem filters from an existing SummaryMetricsFilters instance.
            */
            public RemoveSubsystemFilter () : void
            /** Clears all the filters on an existing AsyncReadManagerMetricsFilters instance.
            */
            public ClearFilters () : void
            public constructor ()
            public constructor ($typeID: bigint)
            public constructor ($state: Unity.IO.LowLevel.Unsafe.ProcessingState)
            public constructor ($readType: Unity.IO.LowLevel.Unsafe.FileReadType)
            public constructor ($priorityLevel: Unity.IO.LowLevel.Unsafe.Priority)
            public constructor ($subsystem: Unity.IO.LowLevel.Unsafe.AssetLoadingSubsystem)
            public constructor ($typeIDs: System.Array$1<bigint>)
            public constructor ($states: System.Array$1<Unity.IO.LowLevel.Unsafe.ProcessingState>)
            public constructor ($readTypes: System.Array$1<Unity.IO.LowLevel.Unsafe.FileReadType>)
            public constructor ($priorityLevels: System.Array$1<Unity.IO.LowLevel.Unsafe.Priority>)
            public constructor ($subsystems: System.Array$1<Unity.IO.LowLevel.Unsafe.AssetLoadingSubsystem>)
            public constructor ($typeIDs: System.Array$1<bigint>, $states: System.Array$1<Unity.IO.LowLevel.Unsafe.ProcessingState>, $readTypes: System.Array$1<Unity.IO.LowLevel.Unsafe.FileReadType>, $priorityLevels: System.Array$1<Unity.IO.LowLevel.Unsafe.Priority>, $subsystems: System.Array$1<Unity.IO.LowLevel.Unsafe.AssetLoadingSubsystem>)
        }
        /** A summary of the metrics collected for AsyncReadManager read operations.
        */
        class AsyncReadManagerSummaryMetrics extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** The total number of bytes read in the metrics included in the summary calculation.
            */
            public get TotalBytesRead(): bigint;
            /** The mean rate of reading of data (bandwidth), in Mbps, for read request metrics included in the summary calculation.
            */
            public get AverageBandwidthMBPerSecond(): number;
            /** The mean size of data read, in bytes, for read request metrics included in the summary calculation.
            */
            public get AverageReadSizeInBytes(): number;
            /** The mean time taken from request to the start of reading, in microseconds, for read request metrics included in the summary calculation.
            */
            public get AverageWaitTimeMicroseconds(): number;
            /** The mean time taken for reading (excluding queue time), in microseconds, for read request metrics included in the summary calculation.
            */
            public get AverageReadTimeMicroseconds(): number;
            /** The mean time taken from request to completion, in microseconds, for completed read request metrics included in the summary calculation.
            */
            public get AverageTotalRequestTimeMicroseconds(): number;
            /** The mean rate of request throughput, in Mbps, for read request metrics included in the summary calculation.
            */
            public get AverageThroughputMBPerSecond(): number;
            /** The longest time spent waiting of metrics included in the summary calculation, in microseconds.
            */
            public get LongestWaitTimeMicroseconds(): number;
            /** The longest read time (not including time in queue) included in the summary calculation in microseconds.
            */
            public get LongestReadTimeMicroseconds(): number;
            /** The for the longest read included in the summary calculation.
            */
            public get LongestReadAssetType(): bigint;
            /** The for the longest wait time included in the summary calculation.
            */
            public get LongestWaitAssetType(): bigint;
            /** The Subsystem tag for the longest read included in the summary calculation.
            */
            public get LongestReadSubsystem(): Unity.IO.LowLevel.Unsafe.AssetLoadingSubsystem;
            /** The Subsystem tag for the longest wait time included in the summary calculation.
            */
            public get LongestWaitSubsystem(): Unity.IO.LowLevel.Unsafe.AssetLoadingSubsystem;
            /** The total number of in progress requests in the metrics included in the summary calculation.
            */
            public get NumberOfInProgressRequests(): number;
            /** The total number of completed requests in the metrics included in the summary calculation.
            */
            public get NumberOfCompletedRequests(): number;
            /** The total number of failed requests in the metrics included in the summary calculation.
            */
            public get NumberOfFailedRequests(): number;
            /** The total number of waiting requests in the metrics included in the summary calculation.
            */
            public get NumberOfWaitingRequests(): number;
            /** The total number of canceled requests in the metrics included in the summary calculation.
            */
            public get NumberOfCanceledRequests(): number;
            /** The total number of read requests included in the summary calculation.
            */
            public get TotalNumberOfRequests(): number;
            /** The total number of cached reads (so read time was zero) in the metrics included in the summary calculation.
            */
            public get NumberOfCachedReads(): number;
            /** The total number of Async reads in the metrics included in the summary calculation.
            */
            public get NumberOfAsyncReads(): number;
            /** The total number of Sync reads in the metrics included in the summary calculation.
            */
            public get NumberOfSyncReads(): number;
            public constructor ()
        }
        /** Class that provides access to some of the Unity low level virtual file system APIs.
        */
        class VirtualFileSystem extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** This method looks up the virtual file entry specified, and returns the details of that file within the file on the local filesystem.
            * @param $vfsFileName Virtual file entry to find.
            * @param $localFileName Out parameter containing the file on the local filesystem.
            * @param $localFileOffset Out parameter containing the offset inside of file on the local filesystem.
            * @param $localFileSize Out parameter containing the size inside of file on the local filesystem.
            * @returns Details were successfully found. 
            */
            public static GetLocalFileSystemName ($vfsFileName: string, $localFileName: $Ref<string>, $localFileOffset: $Ref<bigint>, $localFileSize: $Ref<bigint>) : boolean
        }
    }
    namespace Unity.IO.LowLevel.Unsafe.AsyncReadManagerMetrics {
        enum Flags
        { None = 0, ClearOnRead = 1 }
    }
    namespace Unity.IO.Archive {
        /** Options for tracking the status of the archive operation.
        */
        enum ArchiveStatus
        { InProgress = 0, Complete = 1, Failed = 2 }
        /** Represents information about a file included in an archive.
        */
        class ArchiveFileInfo extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The name of the archived file.
            */
            public Filename : string
            /** The size of the archived file, in bytes.
            */
            public FileSize : bigint
        }
        /** Represents an asynchronous operation handle that references an archive.
        */
        class ArchiveHandle extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Status of the archive mount operation.
            */
            public get Status(): Unity.IO.Archive.ArchiveStatus;
            /** JobHandle of the mount operation.
            */
            public get JobHandle(): Unity.Jobs.JobHandle;
            /** The type of compression the archive uses.
            */
            public get Compression(): UnityEngine.CompressionType;
            /** Indicates if the archive contains streamed blocks.
            */
            public get IsStreamed(): boolean;
            /** Removes the archive from its mount point.
            * @returns Returns the JobHandle of the unmount operation. 
            */
            public Unmount () : Unity.Jobs.JobHandle
            /** Retrieves the path where the archive was mounted.
            * @returns Returns the path where the archive was mounted. 
            */
            public GetMountPath () : string
            /** Retrieves information about files included in the archive.
            * @returns Returns array of ArchiveFileInfo structs, describing each file included in the archive. 
            */
            public GetFileInfo () : System.Array$1<Unity.IO.Archive.ArchiveFileInfo>
        }
        /** Provides methods for managing Unity archive files.
        */
        class ArchiveFileInterface extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Loads all files in an archive to a mount point.
            * @param $namespaceId ContentNamespace identifier.
            * @param $filePath Path of the archive on disk.
            * @param $prefix Mount point identifier. Set to an empty string if no prefix should be used.
            * @returns Returns an operation handle that references the archive. 
            */
            public static MountAsync ($namespaceId: Unity.Content.ContentNamespace, $filePath: string, $prefix: string) : Unity.IO.Archive.ArchiveHandle
            /** Retrieves all mounted archives.
            * @param $namespaceId ContentNamespace identifier.
            * @returns Returns operation handles that reference mounted archives. 
            */
            public static GetMountedArchives ($namespaceId: Unity.Content.ContentNamespace) : System.Array$1<Unity.IO.Archive.ArchiveHandle>
        }
    }
    namespace Unity.Content {
        /** Provides functionality for grouping loaded Archive files into separate namespaces.
        */
        class ContentNamespace extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Indicates whether the ContentNamespace still exists.
            */
            public get IsValid(): boolean;
            /** Default ContentNamespace object.
            */
            public static get Default(): Unity.Content.ContentNamespace;
            /** Retrieves the name of the ContentNamespace.
            * @returns Returns the name of the ContentNamespace. 
            */
            public GetName () : string
            /** Destroys the specified ContentNamespace object.
            */
            public Delete () : void
            /** Retrieves or creates the ContentNamespace if it doesn't exist.
            * @param $name Name of the ContentNamespace. It must contain only alphanumeric characters and have a maximum length of 16 characters.
            * @returns Returns the specified ContentNamespace object. 
            */
            public static GetOrCreateNamespace ($name: string) : Unity.Content.ContentNamespace
            /** Retrieves all existing ContentNamespace objects.
            * @returns Returns all existing ContentNamespace objects. 
            */
            public static GetAll () : System.Array$1<Unity.Content.ContentNamespace>
        }
    }
    namespace Unity.Collections.NativeArray$1 {
        class Enumerator<T> extends System.ValueType implements System.Collections.Generic.IEnumerator$1<T>, System.Collections.IEnumerator, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get Current(): T;
            public Dispose () : void
            public MoveNext () : boolean
            public Reset () : void
            public constructor ($array: $Ref<Unity.Collections.NativeArray$1<T>>)
        }
        class ReadOnly<T> extends System.ValueType implements System.Collections.Generic.IEnumerable$1<T>, System.Collections.IEnumerable
        {
            protected [__keep_incompatibility]: never;
            public get Length(): number;
            public get IsCreated(): boolean;
            public CopyTo ($array: System.Array$1<T>) : void
            public CopyTo ($array: Unity.Collections.NativeArray$1<T>) : void
            public ToArray () : System.Array$1<T>
            public get_Item ($index: number) : T
            public UnsafeElementAt ($index: number) : $Ref<T>
            public GetEnumerator () : Unity.Collections.NativeArray$1.ReadOnly.Enumerator<T>
            public [Symbol.iterator]() : IterableIterator<T>
        }
    }
    namespace Unity.Collections.NativeArray$1.ReadOnly {
        class Enumerator<T> extends System.ValueType implements System.Collections.Generic.IEnumerator$1<T>, System.Collections.IEnumerator, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace Unity.Collections.NativeSlice$1 {
        class Enumerator<T> extends System.ValueType implements System.Collections.Generic.IEnumerator$1<T>, System.Collections.IEnumerator, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get Current(): T;
            public Dispose () : void
            public MoveNext () : boolean
            public Reset () : void
            public constructor ($array: $Ref<Unity.Collections.NativeSlice$1<T>>)
        }
    }
    namespace Unity.Collections.LowLevel.Unsafe {
        /** Allows you to create your own custom native container.
        */
        class NativeContainerAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** NativeContainerIsReadOnlyAttribute.
        */
        class NativeContainerIsReadOnlyAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** NativeContainerIsAtomicWriteOnlyAttribute.
        */
        class NativeContainerIsAtomicWriteOnlyAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** NativeContainerSupportsMinMaxWriteRestrictionAttribute.
        */
        class NativeContainerSupportsMinMaxWriteRestrictionAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Indicates that a native container can be automatically deallocated.
        */
        class NativeContainerSupportsDeallocateOnJobCompletionAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** NativeContainerSupportsDeferredConvertListToArray.
        */
        class NativeContainerSupportsDeferredConvertListToArray extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** This attribute can inject a worker thread index into an int on the job struct. This is usually used in the implementation of atomic containers. The index is guaranteed to be unique to any other job that might be running in parallel.
        */
        class NativeSetThreadIndexAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class NativeContainerNeedsThreadIndexAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Used in conjunction with the ReadOnlyAttribute, WriteAccessRequiredAttribute lets you specify which struct method and property require write access to be invoked.
        */
        class WriteAccessRequiredAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** By default unsafe Pointers are not allowed to be used in a job since it is not possible for the Job Debugger to gurantee race condition free behaviour. This attribute lets you explicitly disable the restriction on a job.
        */
        class NativeDisableUnsafePtrRestrictionAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** By default native containers are tracked by the safety system to avoid race conditions. The safety system encapsulates the best practices and catches many race condition bugs from the start.
        */
        class NativeDisableContainerSafetyRestrictionAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** When this attribute is applied to a field in a job struct, the managed reference to the class will be set to null on the copy of the job struct that is passed to the job.
        */
        class NativeSetClassTypeToNullOnScheduleAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** The result of requesting to enforce that all buffer jobs on an AtomicSafetyHandle have completed.
        */
        enum EnforceJobResult
        { AllJobsAlreadySynced = 0, DidSyncRunningJobs = 1, HandleWasAlreadyDeallocated = 2 }
        /** Enumeration of AtomicSafetyHandle errors.
        */
        enum AtomicSafetyErrorType
        { Deallocated = 0, DeallocatedFromJob = 1, NotAllocatedFromJob = 2 }
        /** AtomicSafetyHandle is used by the job system to coordinate access to container memory from multiple jobs safely.
        */
        class AtomicSafetyHandle extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Creates a new AtomicSafetyHandle.
            * @returns The newly created AtomicSafetyHandle. 
            */
            public static Create () : Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle
            /** Returns a single shared handle, that can be shared by for example NativeSlice pointing to stack memory.
            * @returns Safety handle. 
            */
            public static GetTempUnsafePtrSliceHandle () : Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle
            /** Returns the safety handle which should be used for all temp memory allocations in this temp memory scope.
            * @returns The safety handle for temp memory allocations in the current scope. 
            */
            public static GetTempMemoryHandle () : Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle
            /** Checks if an AtomicSafetyHandle is the temp memory safety handle for the currently active temp memory scope.
            * @param $handle Safety handle.
            * @returns True if the safety handle is the temp memory handle for the current scope. 
            */
            public static IsTempMemoryHandle ($handle: Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle) : boolean
            /** Releases a previously created AtomicSafetyHandle.
            * @param $handle Safety handle.
            */
            public static Release ($handle: Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle) : void
            /** Check if the handle still has its default value (i.e. has not yet been initialized by being assigned or passed to AtomicSafetyHandle.Create).
            * @param $handle Safety handle.
            * @returns true if the handle has not yet been initialized and still has its default value; false otherwise. 
            */
            public static IsDefaultValue ($handle: $Ref<Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle>) : boolean
            /** Marks the AtomicSafetyHandle so that it cannot be disposed of.
            * @param $handle Safety handle.
            */
            public static PrepareUndisposable ($handle: $Ref<Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle>) : void
            /** Switches the AtomicSafetyHandle to the secondary version number.
            * @param $handle Safety handle.
            */
            public static UseSecondaryVersion ($handle: $Ref<Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle>) : void
            /** Set whether handles which use the secondary version number are allowed to write to the container protected by this handle.
            * @param $handle Safety handle.
            * @param $allowWriting If true, handles using the secondary version number should be configured to allow write access to the container. If false, handles using the secondary version number should be configured to only allow read access to the container.
            */
            public static SetAllowSecondaryVersionWriting ($handle: Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle, $allowWriting: boolean) : void
            /** Lets you automatically bump the secondary version when scheduling a job that has write access to the atomic safety handle.
            * @param $handle Safety handle.
            * @param $value Use true to bump secondary version on schedule.
            */
            public static SetBumpSecondaryVersionOnScheduleWrite ($handle: Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle, $value: boolean) : void
            /** Lets you prevent read or write access on the atomic safety handle.
            * @param $handle Safety handle.
            * @param $allowReadWriteAccess Use false to disallow read or write access, or true otherwise.
            */
            public static SetAllowReadOrWriteAccess ($handle: Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle, $allowReadWriteAccess: boolean) : void
            /** Returns true if the AtomicSafetyHandle is configured to allow reading or writing.
            * @param $handle Safety handle.
            * @returns True if the AtomicSafetyHandle is configured to allow reading or writing, false otherwise. 
            */
            public static GetAllowReadOrWriteAccess ($handle: Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle) : boolean
            /** Sets or unsets the nested container flag on an AtomicSafetyHandle.
            * @param $handle Safety handle.
            * @param $isNestedContainer true if the container protected by this AtomicSafetyHandle should be flagged as nested; false otherwise.
            */
            public static SetNestedContainer ($handle: Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle, $isNestedContainer: boolean) : void
            /** Check whether the given AtomicSafetyHandle represents a nested container, and therefore cannot safely be used in jobs.
            * @param $handle Safety handle.
            * @returns true if the given AtomicSafetyHandle is marked as a nested container; false otherwise. 
            */
            public static GetNestedContainer ($handle: Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle) : boolean
            /** Performs AtomicSafetyHandle.CheckWriteAndThrow and then, assuming that the handle can be written to, bumps the secondary version.
            * @param $handle The AtomicSafetyHandle to check.
            */
            public static CheckWriteAndBumpSecondaryVersion ($handle: Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle) : void
            /** Waits for all jobs running against this AtomicSafetyHandle to complete.
            * @param $handle Safety handle.
            * @returns A value describing how much work was done by the job system to complete the request. 
            */
            public static EnforceAllBufferJobsHaveCompleted ($handle: Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle) : Unity.Collections.LowLevel.Unsafe.EnforceJobResult
            /** Waits for all jobs running against this AtomicSafetyHandle to complete and then releases the atomic safety handle.
            * @param $handle Safety handle.
            * @returns A value describing how much work was done by the job system to complete the request. 
            */
            public static EnforceAllBufferJobsHaveCompletedAndRelease ($handle: Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle) : Unity.Collections.LowLevel.Unsafe.EnforceJobResult
            /** Waits for all jobs running against this AtomicSafetyHandle to complete and then disables the read and write access on this atomic safety handle.
            * @param $handle Safety handle.
            * @returns A value describing how much work was done by the job system to complete the request. 
            */
            public static EnforceAllBufferJobsHaveCompletedAndDisableReadWrite ($handle: Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle) : Unity.Collections.LowLevel.Unsafe.EnforceJobResult
            /** Checks if the handle can be deallocated. Throws an exception if it has already been destroyed or a job is currently accessing the data.
            * @param $handle The AtomicSafetyHandle to check.
            */
            public static CheckDeallocateAndThrow ($handle: Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle) : void
            /** Check if the data pointer is in a valid state to be aliased by a view on the container which will use the secondary version number.
            * @param $handle The AtomicSafetyHandle to check.
            */
            public static CheckGetSecondaryDataPointerAndThrow ($handle: Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle) : void
            /** Fetch the job handles of all jobs reading from the safety handle.
            * @param $handle The atomic safety handle to return readers for.
            * @param $maxCount The maximum number of handles to be written to the output array.
            * @param $output A buffer where the job handles will be written.
            * @returns The actual number of readers on the handle, which can be greater than the maximum count provided. 
            */
            public static GetReaderArray ($handle: Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle, $maxCount: number, $output: System.IntPtr) : number
            /** Return the writer (if any) on an atomic safety handle.
            * @param $handle Safety handle.
            * @returns The job handle of the writer. 
            */
            public static GetWriter ($handle: Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle) : Unity.Jobs.JobHandle
            /** Checks if the handle can be read from. Throws an exception if already destroyed or a job is currently writing to the data.
            * @param $handle The AtomicSafetyHandle to check.
            */
            public static CheckReadAndThrow ($handle: Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle) : void
            /** Checks if the handle can be written to. Throws an exception if already destroyed or a job is currently reading or writing to the data.
            * @param $handle The AtomicSafetyHandle to check.
            */
            public static CheckWriteAndThrow ($handle: Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle) : void
            /** Check that the handle has been initialized, and if so, check that it is still valid.
            * @param $handle Safety handle.
            */
            public static ValidateNonDefaultHandle ($handle: $Ref<Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle>) : void
            /** Check if the handle has been initialized and is currently valid.
            * @param $handle Safety handle.
            * @returns true if the handle has been initialized and is valid; false otherwise. 
            */
            public static IsValidNonDefaultHandle ($handle: $Ref<Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle>) : boolean
            /** Checks if the handle is still valid and throws an exception if it is already destroyed.
            * @param $handle The AtomicSafetyHandle to check.
            */
            public static CheckExistsAndThrow ($handle: $Ref<Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle>) : void
            /** Check if the AtomicSafetyHandle is still valid.
            * @param $handle Safety handle.
            * @returns true if the AtomicSafetyHandle is still valid, false otherwise. 
            */
            public static IsHandleValid ($handle: $Ref<Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle>) : boolean
            /** Return the name of the specified reading job.
            * @param $handle Safety handle.
            * @param $readerIndex Index of the reader.
            * @returns The debug name of the reader. 
            */
            public static GetReaderName ($handle: Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle, $readerIndex: number) : string
            /** Return the debug name of the current writer on an atomic safety handle.
            * @param $handle Safety handle.
            * @returns Name of the writer, if any. 
            */
            public static GetWriterName ($handle: Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle) : string
            /** Assigns the provided static safety ID to an AtomicSafetyHandle. The ID's owner type name and any custom error messages are used by the job debugger when reporting errors involving the target handle.
            * @param $handle The AtomicSafetyHandle to modify.
            * @param $staticSafetyId The static safety ID to associate with the provided handle. This ID must have been allocated with NewStaticSafetyId.
            */
            public static SetStaticSafetyId ($handle: $Ref<Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle>, $staticSafetyId: number) : void
        }
        /** DisposeSentinel is used to automatically detect memory leaks.
        */
        class DisposeSentinel extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Releases the AtomicSafetyHandle and clears the DisposeSentinel.
            * @param $safety The AtomicSafetyHandle returned when invoking Create.
            * @param $sentinel The DisposeSentinel.
            */
            public static Dispose ($safety: $Ref<Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle>, $sentinel: $Ref<Unity.Collections.LowLevel.Unsafe.DisposeSentinel>) : void
            public static Create ($safety: $Ref<Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle>, $sentinel: $Ref<Unity.Collections.LowLevel.Unsafe.DisposeSentinel>, $callSiteStackDepth: number, $allocator: Unity.Collections.Allocator) : void
            /** Clears the DisposeSentinel.
            * @param $sentinel The DisposeSentinel to clear.
            */
            public static Clear ($sentinel: $Ref<Unity.Collections.LowLevel.Unsafe.DisposeSentinel>) : void
        }
        /** NativeArray Unsafe Utility.
        */
        class NativeArrayUnsafeUtility extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        /** NativeSlice unsafe utility class.
        */
        class NativeSliceUnsafeUtility extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        /** Unsafe utility class.
        */
        class UnsafeUtility extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Returns the offset of the field relative struct or class it is contained in.
            */
            public static GetFieldOffset ($field: System.Reflection.FieldInfo) : number
            /** Releases a GC Object Handle, previously aquired by UnsafeUtility.PinGCObjectAndGetAddress.
            */
            public static ReleaseGCObject ($gcHandle: bigint) : void
            /** Any memory allocated before this call, that hasn't already been freed, is assumed to have leaked. Prints a list of leaks.
            * @returns The number of leaks found. 
            */
            public static CheckForLeaks () : number
            /** Tells the leak checking system to ignore any memory allocations made up to that point - if they leak, they are forgiven.
            * @returns The number of leaks forgiven. 
            */
            public static ForgiveLeaks () : number
            /** Get whether leak detection is 1=disabled, 2=enabled, or 3=enabled with callstacks.
            * @returns The mode of leak detection. 
            */
            public static GetLeakDetectionMode () : Unity.Collections.NativeLeakDetectionMode
            /** Sets whether leak detection is 1=disabled, 2=enabled, or 3=enabled with callstacks.
            * @param $value The mode of leak detection.
            */
            public static SetLeakDetectionMode ($value: Unity.Collections.NativeLeakDetectionMode) : void
            /** Returns true if the allocator label is valid and can be used to allocate or deallocate memory.
            */
            public static IsValidAllocator ($allocator: Unity.Collections.Allocator) : boolean
            public static SizeOf ($type: System.Type) : number
            /** Returns whether the struct is blittable.
            * @param $type The System.Type of a struct.
            * @returns True if struct is blittable, otherwise false. 
            */
            public static IsBlittable ($type: System.Type) : boolean
            /** Returns whether the struct or type is unmanaged. An unmanaged type contains no managed fields, and can be freely copied in memory.
            * @param $type The System.Type of a struct.
            * @returns True if struct is unmanaged, otherwise false. 
            */
            public static IsUnmanaged ($type: System.Type) : boolean
            /** Returns whether the type is acceptable as an element type in native containers.
            * @param $type The System.Type to check.
            * @returns True if type is acceptable as a native container element. 
            */
            public static IsValidNativeContainerElementType ($type: System.Type) : boolean
        }
    }
    namespace Unity.Burst {
        /** The BurstAuthorizedExternalMethod attribute lets you mark a function as being authorized for Burst to call from within a static constructor.
        */
        class BurstAuthorizedExternalMethodAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** The BurstDiscard attribute lets you remove a method or property from being compiled to native code by the burst compiler.
        */
        class BurstDiscardAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
    }
    namespace JetBrains.Annotations {
        class CanBeNullAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class NotNullAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class ItemNotNullAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class ItemCanBeNullAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class StringFormatMethodAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get FormatParameterName(): string;
            public constructor ($formatParameterName: string)
        }
        class ValueProviderAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Name(): string;
            public constructor ($name: string)
        }
        class InvokerParameterNameAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class NotifyPropertyChangedInvocatorAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get ParameterName(): string;
            public constructor ()
            public constructor ($parameterName: string)
        }
        class ContractAnnotationAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Contract(): string;
            public get ForceFullStates(): boolean;
            public constructor ($contract: string)
            public constructor ($contract: string, $forceFullStates: boolean)
        }
        class LocalizationRequiredAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Required(): boolean;
            public constructor ()
            public constructor ($required: boolean)
        }
        class CannotApplyEqualityOperatorAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class BaseTypeRequiredAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get BaseType(): System.Type;
            public constructor ($baseType: System.Type)
        }
        class UsedImplicitlyAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get UseKindFlags(): JetBrains.Annotations.ImplicitUseKindFlags;
            public get TargetFlags(): JetBrains.Annotations.ImplicitUseTargetFlags;
            public constructor ()
            public constructor ($useKindFlags: JetBrains.Annotations.ImplicitUseKindFlags)
            public constructor ($targetFlags: JetBrains.Annotations.ImplicitUseTargetFlags)
            public constructor ($useKindFlags: JetBrains.Annotations.ImplicitUseKindFlags, $targetFlags: JetBrains.Annotations.ImplicitUseTargetFlags)
        }
        enum ImplicitUseKindFlags
        { Default = 7, Access = 1, Assign = 2, InstantiatedWithFixedConstructorSignature = 4, InstantiatedNoFixedConstructorSignature = 8 }
        enum ImplicitUseTargetFlags
        { Default = 1, Itself = 1, Members = 2, WithMembers = 3 }
        class MeansImplicitUseAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get UseKindFlags(): JetBrains.Annotations.ImplicitUseKindFlags;
            public get TargetFlags(): JetBrains.Annotations.ImplicitUseTargetFlags;
            public constructor ()
            public constructor ($useKindFlags: JetBrains.Annotations.ImplicitUseKindFlags)
            public constructor ($targetFlags: JetBrains.Annotations.ImplicitUseTargetFlags)
            public constructor ($useKindFlags: JetBrains.Annotations.ImplicitUseKindFlags, $targetFlags: JetBrains.Annotations.ImplicitUseTargetFlags)
        }
        class PublicAPIAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Comment(): string;
            public constructor ()
            public constructor ($comment: string)
        }
        class InstantHandleAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class PureAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class MustUseReturnValueAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Justification(): string;
            public constructor ()
            public constructor ($justification: string)
        }
        class ProvidesContextAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class PathReferenceAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get BasePath(): string;
            public constructor ()
            public constructor ($basePath: string)
        }
        class SourceTemplateAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class MacroAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Expression(): string;
            public set Expression(value: string);
            public get Editable(): number;
            public set Editable(value: number);
            public get Target(): string;
            public set Target(value: string);
            public constructor ()
        }
        class CollectionAccessAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get CollectionAccessType(): JetBrains.Annotations.CollectionAccessType;
            public constructor ($collectionAccessType: JetBrains.Annotations.CollectionAccessType)
        }
        enum CollectionAccessType
        { None = 0, Read = 1, ModifyExistingContent = 2, UpdatedContent = 6 }
        class AssertionMethodAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class AssertionConditionAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get ConditionType(): JetBrains.Annotations.AssertionConditionType;
            public constructor ($conditionType: JetBrains.Annotations.AssertionConditionType)
        }
        enum AssertionConditionType
        { IS_TRUE = 0, IS_FALSE = 1, IS_NULL = 2, IS_NOT_NULL = 3 }
        class TerminatesProgramAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class LinqTunnelAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class NoEnumerationAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class RegexPatternAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class NoReorderAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
    }
    namespace UnityEngine.SortingLayer {
        interface LayerCallback
        { 
        (layer: UnityEngine.SortingLayer) : void; 
        Invoke?: (layer: UnityEngine.SortingLayer) => void;
        }
        var LayerCallback: { new (func: (layer: UnityEngine.SortingLayer) => void): LayerCallback; }
    }
    namespace UnityEngine.Application {
        interface AdvertisingIdentifierCallback
        { 
        (advertisingId: string, trackingEnabled: boolean, errorMsg: string) : void; 
        Invoke?: (advertisingId: string, trackingEnabled: boolean, errorMsg: string) => void;
        }
        var AdvertisingIdentifierCallback: { new (func: (advertisingId: string, trackingEnabled: boolean, errorMsg: string) => void): AdvertisingIdentifierCallback; }
        interface LowMemoryCallback
        { 
        () : void; 
        Invoke?: () => void;
        }
        var LowMemoryCallback: { new (func: () => void): LowMemoryCallback; }
        interface MemoryUsageChangedCallback
        { 
        (usage: $Ref<UnityEngine.ApplicationMemoryUsageChange>) : void; 
        Invoke?: (usage: $Ref<UnityEngine.ApplicationMemoryUsageChange>) => void;
        }
        var MemoryUsageChangedCallback: { new (func: (usage: $Ref<UnityEngine.ApplicationMemoryUsageChange>) => void): MemoryUsageChangedCallback; }
        interface LogCallback
        { 
        (condition: string, stackTrace: string, type: UnityEngine.LogType) : void; 
        Invoke?: (condition: string, stackTrace: string, type: UnityEngine.LogType) => void;
        }
        var LogCallback: { new (func: (condition: string, stackTrace: string, type: UnityEngine.LogType) => void): LogCallback; }
    }
    namespace UnityEngine.Events {
        /** Zero argument delegate used by UnityEvents.
        */
        interface UnityAction
        { 
        () : void; 
        Invoke?: () => void;
        }
        var UnityAction: { new (func: () => void): UnityAction; }
        /** Abstract base class for UnityEvents.
        */
        class UnityEventBase extends System.Object implements UnityEngine.ISerializationCallbackReceiver
        {
            protected [__keep_incompatibility]: never;
            /** Get the number of registered persistent listeners.
            */
            public GetPersistentEventCount () : number
            /** Get the target component of the listener at index index.
            * @param $index Index of the listener to query.
            */
            public GetPersistentTarget ($index: number) : UnityEngine.Object
            /** Get the target method name of the listener at index index.
            * @param $index Index of the listener to query.
            */
            public GetPersistentMethodName ($index: number) : string
            /** Modify the execution state of a persistent listener.
            * @param $index Index of the listener to query.
            * @param $state State to set.
            */
            public SetPersistentListenerState ($index: number, $state: UnityEngine.Events.UnityEventCallState) : void
            /** Returns the execution state of a persistent listener.
            * @param $index Index of the listener to query.
            * @returns Execution state of the persistent listener. 
            */
            public GetPersistentListenerState ($index: number) : UnityEngine.Events.UnityEventCallState
            /** Remove all non-persistent (ie created from script) listeners  from the event.
            */
            public RemoveAllListeners () : void
            /** Given an object, function name, and a list of argument types; find the method that matches.
            * @param $obj Object to search for the method.
            * @param $functionName Function name to search for.
            * @param $argumentTypes Argument types for the function.
            */
            public static GetValidMethodInfo ($obj: any, $functionName: string, $argumentTypes: System.Array$1<System.Type>) : System.Reflection.MethodInfo
            /** Given an object type, function name, and a list of argument types; find the method that matches.
            * @param $objectType Object type to search for the method.
            * @param $functionName Function name to search for.
            * @param $argumentTypes Argument types for the function.
            */
            public static GetValidMethodInfo ($objectType: System.Type, $functionName: string, $argumentTypes: System.Array$1<System.Type>) : System.Reflection.MethodInfo
            /** Implement this method to receive a callback before Unity serializes your object.
            */
            public OnBeforeSerialize () : void
            /** Implement this method to receive a callback after Unity deserializes your object.
            */
            public OnAfterDeserialize () : void
        }
        /** A zero argument persistent callback that can be saved with the Scene.
        */
        class UnityEvent extends UnityEngine.Events.UnityEventBase implements UnityEngine.ISerializationCallbackReceiver
        {
            protected [__keep_incompatibility]: never;
            /** Add a non persistent listener to the UnityEvent.
            * @param $call Callback function.
            */
            public AddListener ($call: UnityEngine.Events.UnityAction) : void
            /** Remove a non persistent listener from the UnityEvent. If you have added the same listener multiple times, this method will remove all occurrences of it.
            * @param $call Callback function.
            */
            public RemoveListener ($call: UnityEngine.Events.UnityAction) : void
            /** Invoke all registered callbacks (runtime and persistent).
            */
            public Invoke () : void
            public constructor ()
        }
        class UnityEvent$1<T0> extends UnityEngine.Events.UnityEventBase implements UnityEngine.ISerializationCallbackReceiver
        {
            protected [__keep_incompatibility]: never;
            public AddListener ($call: UnityEngine.Events.UnityAction$1<T0>) : void
            public RemoveListener ($call: UnityEngine.Events.UnityAction$1<T0>) : void
            public Invoke ($arg0: T0) : void
            public constructor ()
        }
        class UnityEvent$2<T0, T1> extends UnityEngine.Events.UnityEventBase implements UnityEngine.ISerializationCallbackReceiver
        {
            protected [__keep_incompatibility]: never;
            public AddListener ($call: UnityEngine.Events.UnityAction$2<T0, T1>) : void
            public RemoveListener ($call: UnityEngine.Events.UnityAction$2<T0, T1>) : void
            public Invoke ($arg0: T0, $arg1: T1) : void
            public constructor ()
        }
        class UnityEvent$3<T0, T1, T2> extends UnityEngine.Events.UnityEventBase implements UnityEngine.ISerializationCallbackReceiver
        {
            protected [__keep_incompatibility]: never;
            public AddListener ($call: UnityEngine.Events.UnityAction$3<T0, T1, T2>) : void
            public RemoveListener ($call: UnityEngine.Events.UnityAction$3<T0, T1, T2>) : void
            public Invoke ($arg0: T0, $arg1: T1, $arg2: T2) : void
            public constructor ()
        }
        class UnityEvent$4<T0, T1, T2, T3> extends UnityEngine.Events.UnityEventBase implements UnityEngine.ISerializationCallbackReceiver
        {
            protected [__keep_incompatibility]: never;
            public AddListener ($call: UnityEngine.Events.UnityAction$4<T0, T1, T2, T3>) : void
            public RemoveListener ($call: UnityEngine.Events.UnityAction$4<T0, T1, T2, T3>) : void
            public Invoke ($arg0: T0, $arg1: T1, $arg2: T2, $arg3: T3) : void
            public constructor ()
        }
        interface UnityAction$1<T0>
        { 
        (arg0: T0) : void; 
        Invoke?: (arg0: T0) => void;
        }
        /** The mode that a listener is operating in.
        */
        enum PersistentListenerMode
        { EventDefined = 0, Void = 1, Object = 2, Int = 3, Float = 4, String = 5, Bool = 6 }
        /** Controls the scope of UnityEvent callbacks.
        */
        enum UnityEventCallState
        { Off = 0, EditorAndRuntime = 1, RuntimeOnly = 2 }
        interface UnityAction$2<T0, T1>
        { 
        (arg0: T0, arg1: T1) : void; 
        Invoke?: (arg0: T0, arg1: T1) => void;
        }
        interface UnityAction$3<T0, T1, T2>
        { 
        (arg0: T0, arg1: T1, arg2: T2) : void; 
        Invoke?: (arg0: T0, arg1: T1, arg2: T2) => void;
        }
        interface UnityAction$4<T0, T1, T2, T3>
        { 
        (arg0: T0, arg1: T1, arg2: T2, arg3: T3) : void; 
        Invoke?: (arg0: T0, arg1: T1, arg2: T2, arg3: T3) => void;
        }
    }
    namespace UnityEngine.Camera {
        interface CameraCallback
        { 
        (cam: UnityEngine.Camera) : void; 
        Invoke?: (cam: UnityEngine.Camera) => void;
        }
        var CameraCallback: { new (func: (cam: UnityEngine.Camera) => void): CameraCallback; }
        enum GateFitMode
        { Vertical = 1, Horizontal = 2, Fill = 3, Overscan = 4, None = 0 }
        enum MonoOrStereoscopicEye
        { Left = 0, Right = 1, Mono = 2 }
        class GateFitParameters extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get mode(): UnityEngine.Camera.GateFitMode;
            public set mode(value: UnityEngine.Camera.GateFitMode);
            public get aspect(): number;
            public set aspect(value: number);
            public constructor ($mode: UnityEngine.Camera.GateFitMode, $aspect: number)
        }
        enum StereoscopicEye
        { Left = 0, Right = 1 }
        enum SceneViewFilterMode
        { Off = 0, ShowFiltered = 1 }
        class RenderRequest extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get isValid(): boolean;
            public get mode(): UnityEngine.Camera.RenderRequestMode;
            public get result(): UnityEngine.RenderTexture;
            public get outputSpace(): UnityEngine.Camera.RenderRequestOutputSpace;
            public constructor ($mode: UnityEngine.Camera.RenderRequestMode, $rt: UnityEngine.RenderTexture)
            public constructor ($mode: UnityEngine.Camera.RenderRequestMode, $space: UnityEngine.Camera.RenderRequestOutputSpace, $rt: UnityEngine.RenderTexture)
        }
        enum FieldOfViewAxis
        { Vertical = 0, Horizontal = 1 }
        enum RenderRequestMode
        { None = 0, ObjectId = 1, Depth = 2, VertexNormal = 3, WorldPosition = 4, EntityId = 5, BaseColor = 6, SpecularColor = 7, Metallic = 8, Emission = 9, Normal = 10, Smoothness = 11, Occlusion = 12, DiffuseColor = 13 }
        enum RenderRequestOutputSpace
        { ScreenSpace = -1, UV0 = 0, UV1 = 1, UV2 = 2, UV3 = 3, UV4 = 4, UV5 = 5, UV6 = 6, UV7 = 7, UV8 = 8 }
    }
    namespace UnityEngine.Rendering {
        /** Opaque object sorting mode of a Camera.
        */
        enum OpaqueSortMode
        { Default = 0, FrontToBack = 1, NoDistanceSort = 2 }
        /** Defines a place in camera's rendering to attach Rendering.CommandBuffer objects to.
        */
        enum CameraEvent
        { BeforeDepthTexture = 0, AfterDepthTexture = 1, BeforeDepthNormalsTexture = 2, AfterDepthNormalsTexture = 3, BeforeGBuffer = 4, AfterGBuffer = 5, BeforeLighting = 6, AfterLighting = 7, BeforeFinalPass = 8, AfterFinalPass = 9, BeforeForwardOpaque = 10, AfterForwardOpaque = 11, BeforeImageEffectsOpaque = 12, AfterImageEffectsOpaque = 13, BeforeSkybox = 14, AfterSkybox = 15, BeforeForwardAlpha = 16, AfterForwardAlpha = 17, BeforeImageEffects = 18, AfterImageEffects = 19, AfterEverything = 20, BeforeReflections = 21, AfterReflections = 22, BeforeHaloAndLensFlares = 23, AfterHaloAndLensFlares = 24 }
        /** List of graphics commands to execute.
        */
        class CommandBuffer extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            /** Throw an exception when SetRenderTarget is recorded on a command buffer. This is mainly usefull when using native renderpasses to avoid inadvertently recording SetRenderTarget commands on the command buffer.
            */
            public static ThrowOnSetRenderTarget : boolean
            /** Name of this command buffer.
            */
            public get name(): string;
            public set name(value: string);
            /** Size of this command buffer in bytes (Read Only).
            */
            public get sizeInBytes(): number;
            /** Adds a command to copy the pixel data from one texture, convert the data into a different format, and copy it into another texture.
            * @param $src The source texture. The texture must be a Texture2D or Cubemap.
            * @param $dst The destination texture. The texture must be a Texture2D, Texture2DArray, Cubemap, or CubemapArray. The texture must also be uncompressed and correspond to a supported RenderTextureFormat.
            * @param $srcElement The element in the source texture to copy from. Use CubemapFace if src is a Cubemap. Set the value to 0 if src is a 2D texture.
            * @param $dstElement The element in the source texture to copy to. For example, the CubemapFace in a Cubemap or the slice in a texture array. Set the value to 0 if `dst` is a 2D texture.
            */
            public ConvertTexture ($src: UnityEngine.Rendering.RenderTargetIdentifier, $dst: UnityEngine.Rendering.RenderTargetIdentifier) : void
            /** Adds a command to copy the pixel data from one texture, convert the data into a different format, and copy it into another texture.
            * @param $src The source texture. The texture must be a Texture2D or Cubemap.
            * @param $dst The destination texture. The texture must be a Texture2D, Texture2DArray, Cubemap, or CubemapArray. The texture must also be uncompressed and correspond to a supported RenderTextureFormat.
            * @param $srcElement The element in the source texture to copy from. Use CubemapFace if src is a Cubemap. Set the value to 0 if src is a 2D texture.
            * @param $dstElement The element in the source texture to copy to. For example, the CubemapFace in a Cubemap or the slice in a texture array. Set the value to 0 if `dst` is a 2D texture.
            */
            public ConvertTexture ($src: UnityEngine.Rendering.RenderTargetIdentifier, $srcElement: number, $dst: UnityEngine.Rendering.RenderTargetIdentifier, $dstElement: number) : void
            /** Adds an "AsyncGPUReadback.WaitAllRequests" command to the CommandBuffer.
            */
            public WaitAllAsyncReadbackRequests () : void
            public RequestAsyncReadback ($src: UnityEngine.ComputeBuffer, $callback: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>) : void
            public RequestAsyncReadback ($src: UnityEngine.GraphicsBuffer, $callback: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>) : void
            public RequestAsyncReadback ($src: UnityEngine.ComputeBuffer, $size: number, $offset: number, $callback: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>) : void
            public RequestAsyncReadback ($src: UnityEngine.GraphicsBuffer, $size: number, $offset: number, $callback: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>) : void
            public RequestAsyncReadback ($src: UnityEngine.Texture, $callback: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>) : void
            public RequestAsyncReadback ($src: UnityEngine.Texture, $mipIndex: number, $callback: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>) : void
            public RequestAsyncReadback ($src: UnityEngine.Texture, $mipIndex: number, $dstFormat: UnityEngine.TextureFormat, $callback: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>) : void
            public RequestAsyncReadback ($src: UnityEngine.Texture, $mipIndex: number, $dstFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $callback: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>) : void
            public RequestAsyncReadback ($src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $callback: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>) : void
            public RequestAsyncReadback ($src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $dstFormat: UnityEngine.TextureFormat, $callback: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>) : void
            public RequestAsyncReadback ($src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $dstFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $callback: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>) : void
            /** Add a "set invert culling" command to the buffer.
            * @param $invertCulling A boolean indicating whether to invert the backface culling (true) or not (false).
            */
            public SetInvertCulling ($invertCulling: boolean) : void
            /** Adds a command to set a float parameter on a ComputeShader.
            * @param $computeShader ComputeShader to set parameter for.
            * @param $name Name of the variable in shader code.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $val Value to set.
            */
            public SetComputeFloatParam ($computeShader: UnityEngine.ComputeShader, $nameID: number, $val: number) : void
            /** Adds a command to set an integer parameter on a ComputeShader.
            * @param $computeShader ComputeShader to set parameter for.
            * @param $name Name of the variable in shader code.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $val Value to set.
            */
            public SetComputeIntParam ($computeShader: UnityEngine.ComputeShader, $nameID: number, $val: number) : void
            /** Adds a command to set a vector parameter on a ComputeShader.
            * @param $computeShader ComputeShader to set parameter for.
            * @param $name Name of the variable in shader code.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $val Value to set.
            */
            public SetComputeVectorParam ($computeShader: UnityEngine.ComputeShader, $nameID: number, $val: UnityEngine.Vector4) : void
            /** Adds a command to set a vector array parameter on a ComputeShader.
            * @param $computeShader ComputeShader to set parameter for.
            * @param $name Property name.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $values Value to set.
            */
            public SetComputeVectorArrayParam ($computeShader: UnityEngine.ComputeShader, $nameID: number, $values: System.Array$1<UnityEngine.Vector4>) : void
            /** Adds a command to set a matrix parameter on a ComputeShader.
            * @param $computeShader ComputeShader to set parameter for.
            * @param $name Name of the variable in shader code.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $val Value to set.
            */
            public SetComputeMatrixParam ($computeShader: UnityEngine.ComputeShader, $nameID: number, $val: UnityEngine.Matrix4x4) : void
            /** Adds a command to set a matrix array parameter on a ComputeShader.
            * @param $computeShader ComputeShader to set parameter for.
            * @param $name Name of the variable in shader code.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $values Value to set.
            */
            public SetComputeMatrixArrayParam ($computeShader: UnityEngine.ComputeShader, $nameID: number, $values: System.Array$1<UnityEngine.Matrix4x4>) : void
            /** Adds a command to select which Shader Pass to use when executing ray/geometry intersection shaders.
            * @param $rayTracingShader RayTracingShader to set parameter for.
            * @param $passName The Shader Pass to use when executing ray tracing shaders.
            */
            public SetRayTracingShaderPass ($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $passName: string) : void
            /** Clear all commands in the buffer.
            */
            public Clear () : void
            /** Clear random write targets for level pixel shaders.
            */
            public ClearRandomWriteTargets () : void
            /** Add a command to set the rendering viewport.
            * @param $pixelRect Viewport rectangle in pixel coordinates.
            */
            public SetViewport ($pixelRect: UnityEngine.Rect) : void
            /** Add a command to enable the hardware scissor rectangle.
            * @param $scissor Viewport rectangle in pixel coordinates.
            */
            public EnableScissorRect ($scissor: UnityEngine.Rect) : void
            /** Add a command to disable the hardware scissor rectangle.
            */
            public DisableScissorRect () : void
            public GetTemporaryRT ($nameID: number, $width: number, $height: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $antiAliasing: number, $enableRandomWrite: boolean, $memorylessMode: UnityEngine.RenderTextureMemoryless, $useDynamicScale: boolean) : void
            public GetTemporaryRT ($nameID: number, $width: number, $height: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $antiAliasing: number, $enableRandomWrite: boolean, $memorylessMode: UnityEngine.RenderTextureMemoryless) : void
            public GetTemporaryRT ($nameID: number, $width: number, $height: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $antiAliasing: number, $enableRandomWrite: boolean) : void
            public GetTemporaryRT ($nameID: number, $width: number, $height: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $antiAliasing: number) : void
            public GetTemporaryRT ($nameID: number, $width: number, $height: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.Experimental.Rendering.GraphicsFormat) : void
            public GetTemporaryRT ($nameID: number, $width: number, $height: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite, $antiAliasing: number, $enableRandomWrite: boolean, $memorylessMode: UnityEngine.RenderTextureMemoryless, $useDynamicScale: boolean) : void
            public GetTemporaryRT ($nameID: number, $width: number, $height: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite, $antiAliasing: number, $enableRandomWrite: boolean, $memorylessMode: UnityEngine.RenderTextureMemoryless) : void
            /** Add a "get a temporary render texture" command.
            * @param $nameID Shader property name for this texture.
            * @param $width Width in pixels, or -1 for "camera pixel width".
            * @param $height Height in pixels, or -1 for "camera pixel height".
            * @param $depthBuffer Depth buffer bits (0, 16 or 24).
            * @param $filter Texture filtering mode (default is Point).
            * @param $format Format of the render texture (default is ARGB32).
            * @param $readWrite Color space conversion mode.
            * @param $antiAliasing Anti-aliasing (default is no anti-aliasing).
            * @param $enableRandomWrite Should random-write access into the texture be enabled (default is false).
            * @param $desc Use this RenderTextureDescriptor for the settings when creating the temporary RenderTexture.
            * @param $memorylessMode Render texture memoryless mode.
            */
            public GetTemporaryRT ($nameID: number, $width: number, $height: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite, $antiAliasing: number, $enableRandomWrite: boolean) : void
            public GetTemporaryRT ($nameID: number, $width: number, $height: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite, $antiAliasing: number) : void
            public GetTemporaryRT ($nameID: number, $width: number, $height: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite) : void
            public GetTemporaryRT ($nameID: number, $width: number, $height: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.RenderTextureFormat) : void
            public GetTemporaryRT ($nameID: number, $width: number, $height: number, $depthBuffer: number, $filter: UnityEngine.FilterMode) : void
            public GetTemporaryRT ($nameID: number, $width: number, $height: number, $depthBuffer: number) : void
            public GetTemporaryRT ($nameID: number, $width: number, $height: number) : void
            /** Add a "get a temporary render texture" command.
            * @param $nameID Shader property name for this texture.
            * @param $width Width in pixels, or -1 for "camera pixel width".
            * @param $height Height in pixels, or -1 for "camera pixel height".
            * @param $depthBuffer Depth buffer bits (0, 16 or 24).
            * @param $filter Texture filtering mode (default is Point).
            * @param $format Format of the render texture (default is ARGB32).
            * @param $readWrite Color space conversion mode.
            * @param $antiAliasing Anti-aliasing (default is no anti-aliasing).
            * @param $enableRandomWrite Should random-write access into the texture be enabled (default is false).
            * @param $desc Use this RenderTextureDescriptor for the settings when creating the temporary RenderTexture.
            * @param $memorylessMode Render texture memoryless mode.
            */
            public GetTemporaryRT ($nameID: number, $desc: UnityEngine.RenderTextureDescriptor, $filter: UnityEngine.FilterMode) : void
            public GetTemporaryRT ($nameID: number, $desc: UnityEngine.RenderTextureDescriptor) : void
            public GetTemporaryRTArray ($nameID: number, $width: number, $height: number, $slices: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $antiAliasing: number, $enableRandomWrite: boolean, $useDynamicScale: boolean) : void
            public GetTemporaryRTArray ($nameID: number, $width: number, $height: number, $slices: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $antiAliasing: number, $enableRandomWrite: boolean) : void
            public GetTemporaryRTArray ($nameID: number, $width: number, $height: number, $slices: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $antiAliasing: number) : void
            public GetTemporaryRTArray ($nameID: number, $width: number, $height: number, $slices: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.Experimental.Rendering.GraphicsFormat) : void
            /** Add a "get a temporary render texture array" command.
            * @param $nameID Shader property name for this texture.
            * @param $width Width in pixels, or -1 for "camera pixel width".
            * @param $height Height in pixels, or -1 for "camera pixel height".
            * @param $slices Number of slices in texture array.
            * @param $depthBuffer Depth buffer bits (0, 16 or 24).
            * @param $filter Texture filtering mode (default is Point).
            * @param $format Format of the render texture (default is ARGB32).
            * @param $readWrite Color space conversion mode.
            * @param $antiAliasing Anti-aliasing (default is no anti-aliasing).
            * @param $enableRandomWrite Should random-write access into the texture be enabled (default is false).
            */
            public GetTemporaryRTArray ($nameID: number, $width: number, $height: number, $slices: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite, $antiAliasing: number, $enableRandomWrite: boolean) : void
            public GetTemporaryRTArray ($nameID: number, $width: number, $height: number, $slices: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite, $antiAliasing: number) : void
            public GetTemporaryRTArray ($nameID: number, $width: number, $height: number, $slices: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite) : void
            public GetTemporaryRTArray ($nameID: number, $width: number, $height: number, $slices: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.RenderTextureFormat) : void
            public GetTemporaryRTArray ($nameID: number, $width: number, $height: number, $slices: number, $depthBuffer: number, $filter: UnityEngine.FilterMode) : void
            public GetTemporaryRTArray ($nameID: number, $width: number, $height: number, $slices: number, $depthBuffer: number) : void
            public GetTemporaryRTArray ($nameID: number, $width: number, $height: number, $slices: number) : void
            /** Add a "release a temporary render texture" command.
            * @param $nameID Shader property name for this texture.
            */
            public ReleaseTemporaryRT ($nameID: number) : void
            /** Adds a "clear render target" command.
            * @param $clearDepth Whether to clear both the depth buffer and the stencil buffer.
            * @param $clearColor Whether to clear the color buffer.
            * @param $clearFlags Which render targets to clear, defined using a bitwise OR combination of RTClearFlags values.
            * @param $backgroundColor Color to clear with.
            * @param $backgroundColors Colors to clear with.
            * @param $depth Depth to clear with (default is 1.0).
            * @param $stencil Stencil to clear with (default is 0).
            */
            public ClearRenderTarget ($clearDepth: boolean, $clearColor: boolean, $backgroundColor: UnityEngine.Color) : void
            /** Adds a "clear render target" command.
            * @param $clearDepth Whether to clear both the depth buffer and the stencil buffer.
            * @param $clearColor Whether to clear the color buffer.
            * @param $clearFlags Which render targets to clear, defined using a bitwise OR combination of RTClearFlags values.
            * @param $backgroundColor Color to clear with.
            * @param $backgroundColors Colors to clear with.
            * @param $depth Depth to clear with (default is 1.0).
            * @param $stencil Stencil to clear with (default is 0).
            */
            public ClearRenderTarget ($clearDepth: boolean, $clearColor: boolean, $backgroundColor: UnityEngine.Color, $depth: number) : void
            /** Adds a "clear render target" command.
            * @param $clearDepth Whether to clear both the depth buffer and the stencil buffer.
            * @param $clearColor Whether to clear the color buffer.
            * @param $clearFlags Which render targets to clear, defined using a bitwise OR combination of RTClearFlags values.
            * @param $backgroundColor Color to clear with.
            * @param $backgroundColors Colors to clear with.
            * @param $depth Depth to clear with (default is 1.0).
            * @param $stencil Stencil to clear with (default is 0).
            */
            public ClearRenderTarget ($clearDepth: boolean, $clearColor: boolean, $backgroundColor: UnityEngine.Color, $depth?: number, $stencil?: number) : void
            /** Adds a "clear render target" command.
            * @param $clearDepth Whether to clear both the depth buffer and the stencil buffer.
            * @param $clearColor Whether to clear the color buffer.
            * @param $clearFlags Which render targets to clear, defined using a bitwise OR combination of RTClearFlags values.
            * @param $backgroundColor Color to clear with.
            * @param $backgroundColors Colors to clear with.
            * @param $depth Depth to clear with (default is 1.0).
            * @param $stencil Stencil to clear with (default is 0).
            */
            public ClearRenderTarget ($clearFlags: UnityEngine.Rendering.RTClearFlags, $backgroundColor: UnityEngine.Color, $depth?: number, $stencil?: number) : void
            /** Adds a "clear render target" command.
            * @param $clearDepth Whether to clear both the depth buffer and the stencil buffer.
            * @param $clearColor Whether to clear the color buffer.
            * @param $clearFlags Which render targets to clear, defined using a bitwise OR combination of RTClearFlags values.
            * @param $backgroundColor Color to clear with.
            * @param $backgroundColors Colors to clear with.
            * @param $depth Depth to clear with (default is 1.0).
            * @param $stencil Stencil to clear with (default is 0).
            */
            public ClearRenderTarget ($clearFlags: UnityEngine.Rendering.RTClearFlags, $backgroundColors: System.Array$1<UnityEngine.Color>, $depth?: number, $stencil?: number) : void
            /** Add a "set global shader float property" command.
            */
            public SetGlobalFloat ($nameID: number, $value: number) : void
            /** Adds a command to set the value of a given property for all Shaders, where the property has a type of Int in ShaderLab code.
            */
            public SetGlobalInt ($nameID: number, $value: number) : void
            /** Adds a command to set the value of a given property for all Shaders, where the property is an integer.
            */
            public SetGlobalInteger ($nameID: number, $value: number) : void
            /** Add a "set global shader vector property" command.
            */
            public SetGlobalVector ($nameID: number, $value: UnityEngine.Vector4) : void
            /** Add a "set global shader color property" command.
            */
            public SetGlobalColor ($nameID: number, $value: UnityEngine.Color) : void
            /** Add a "set global shader matrix property" command.
            */
            public SetGlobalMatrix ($nameID: number, $value: UnityEngine.Matrix4x4) : void
            /** Adds a command to enable a global keyword with a given name.
            * @param $keyword Name of a global shader keyword to enable.
            */
            public EnableShaderKeyword ($keyword: string) : void
            /** Adds a command to enable a global or local shader keyword.
            * @param $keyword The global or local shader keyword to enable.
            * @param $material The material on which to enable the local shader keyword.
            * @param $computeShader The compute shader for which to enable the local shader keyword.
            */
            public EnableKeyword ($keyword: $Ref<UnityEngine.Rendering.GlobalKeyword>) : void
            /** Adds a command to enable a global or local shader keyword.
            * @param $keyword The global or local shader keyword to enable.
            * @param $material The material on which to enable the local shader keyword.
            * @param $computeShader The compute shader for which to enable the local shader keyword.
            */
            public EnableKeyword ($material: UnityEngine.Material, $keyword: $Ref<UnityEngine.Rendering.LocalKeyword>) : void
            /** Adds a command to enable a global or local shader keyword.
            * @param $keyword The global or local shader keyword to enable.
            * @param $material The material on which to enable the local shader keyword.
            * @param $computeShader The compute shader for which to enable the local shader keyword.
            */
            public EnableKeyword ($computeShader: UnityEngine.ComputeShader, $keyword: $Ref<UnityEngine.Rendering.LocalKeyword>) : void
            /** Adds a command to disable a global shader keyword with a given name.
            * @param $keyword Name of a global keyword to disable.
            */
            public DisableShaderKeyword ($keyword: string) : void
            /** Adds a command to disable a global or local shader keyword.
            * @param $keyword The global or local shader keyword to disable.
            * @param $material The material on which to disable the local shader keyword.
            * @param $computeShader The compute shader for which to disable the local shader keyword.
            */
            public DisableKeyword ($keyword: $Ref<UnityEngine.Rendering.GlobalKeyword>) : void
            /** Adds a command to disable a global or local shader keyword.
            * @param $keyword The global or local shader keyword to disable.
            * @param $material The material on which to disable the local shader keyword.
            * @param $computeShader The compute shader for which to disable the local shader keyword.
            */
            public DisableKeyword ($material: UnityEngine.Material, $keyword: $Ref<UnityEngine.Rendering.LocalKeyword>) : void
            /** Adds a command to disable a global or local shader keyword.
            * @param $keyword The global or local shader keyword to disable.
            * @param $material The material on which to disable the local shader keyword.
            * @param $computeShader The compute shader for which to disable the local shader keyword.
            */
            public DisableKeyword ($computeShader: UnityEngine.ComputeShader, $keyword: $Ref<UnityEngine.Rendering.LocalKeyword>) : void
            /** Adds a command to set the state of a global or local shader keyword.
            * @param $keyword The local or global shader keyword to set the state for.
            * @param $material The material for which to set the state of the local shader keyword.
            * @param $computeShader The compute shader for which to set the state of the local shader keyword.
            * @param $value The state to set the shader keyword state to.
            */
            public SetKeyword ($keyword: $Ref<UnityEngine.Rendering.GlobalKeyword>, $value: boolean) : void
            /** Adds a command to set the state of a global or local shader keyword.
            * @param $keyword The local or global shader keyword to set the state for.
            * @param $material The material for which to set the state of the local shader keyword.
            * @param $computeShader The compute shader for which to set the state of the local shader keyword.
            * @param $value The state to set the shader keyword state to.
            */
            public SetKeyword ($material: UnityEngine.Material, $keyword: $Ref<UnityEngine.Rendering.LocalKeyword>, $value: boolean) : void
            /** Adds a command to set the state of a global or local shader keyword.
            * @param $keyword The local or global shader keyword to set the state for.
            * @param $material The material for which to set the state of the local shader keyword.
            * @param $computeShader The compute shader for which to set the state of the local shader keyword.
            * @param $value The state to set the shader keyword state to.
            */
            public SetKeyword ($computeShader: UnityEngine.ComputeShader, $keyword: $Ref<UnityEngine.Rendering.LocalKeyword>, $value: boolean) : void
            /** Add a command to set the view matrix.
            * @param $view View (world to camera space) matrix.
            */
            public SetViewMatrix ($view: UnityEngine.Matrix4x4) : void
            /** Add a command to set the projection matrix.
            * @param $proj Projection (camera to clip space) matrix.
            */
            public SetProjectionMatrix ($proj: UnityEngine.Matrix4x4) : void
            /** Add a command to set the view and projection matrices.
            * @param $view View (world to camera space) matrix.
            * @param $proj Projection (camera to clip space) matrix.
            */
            public SetViewProjectionMatrices ($view: UnityEngine.Matrix4x4, $proj: UnityEngine.Matrix4x4) : void
            /** Adds a command to set the global depth bias.
            * @param $bias Scales the GPU's minimum resolvable depth buffer value to produce a constant depth offset. The minimum resolvable depth buffer value varies by device.
            Set to a negative value to draw geometry closer to the camera, or a positive value to draw geometry further away from the camera.
            * @param $slopeBias Scales the maximum Z slope, also called the depth slope, to produce a variable depth offset for each polygon.
            Polygons that are not parallel to the near and far clip planes have Z slope. Adjust this value to avoid visual artifacts on such polygons.
            */
            public SetGlobalDepthBias ($bias: number, $slopeBias: number) : void
            /** Set flags describing the intention for how the command buffer will be executed.
            * @param $flags The flags to set.
            */
            public SetExecutionFlags ($flags: UnityEngine.Rendering.CommandBufferExecutionFlags) : void
            /** Add a "set global shader float array property" command.
            */
            public SetGlobalFloatArray ($nameID: number, $values: System.Array$1<number>) : void
            /** Add a "set global shader vector array property" command.
            */
            public SetGlobalVectorArray ($nameID: number, $values: System.Array$1<UnityEngine.Vector4>) : void
            /** Add a "set global shader matrix array property" command.
            */
            public SetGlobalMatrixArray ($nameID: number, $values: System.Array$1<UnityEngine.Matrix4x4>) : void
            /** Set the current stereo projection matrices for late latching. Stereo matrices is passed in as an array of two matrices.
            * @param $projectionMat Stereo projection matrices.
            */
            public SetLateLatchProjectionMatrices ($projectionMat: System.Array$1<UnityEngine.Matrix4x4>) : void
            /** Mark a global shader property id to be late latched.  Possible shader properties include view, inverseView, viewProjection, and inverseViewProjection matrices. The Universal Render Pipeline (URP) uses this function to support late latching of shader properties. If you call this function when using built-in Unity rendering or the High-Definition Rendering Pipeline (HDRP), the results are ignored.
            * @param $matrixPropertyType Camera matrix property type to be late latched.
            * @param $shaderPropertyID Shader property name id.
            */
            public MarkLateLatchMatrixShaderPropertyID ($matrixPropertyType: UnityEngine.Rendering.CameraLateLatchMatrixType, $shaderPropertyID: number) : void
            /** Unmark a global shader property for late latching. After unmarking, the shader property will no longer be late latched.  This function is intended for the Universal Render Pipeline (URP) to specify late latched shader properties.
            * @param $matrixPropertyType Camera matrix property type to be unmarked for late latching.
            */
            public UnmarkLateLatchMatrix ($matrixPropertyType: UnityEngine.Rendering.CameraLateLatchMatrixType) : void
            /** Adds a command to begin profile sampling.
            * @param $name Name of the profile information used for sampling.
            * @param $sampler The CustomSampler that the CommandBuffer uses for sampling.
            * @param $marker The ProfilerMarker that the CommandBuffer uses for sampling.
            */
            public BeginSample ($name: string) : void
            /** Adds a command to end profile sampling.
            * @param $name Name of the profile information used for sampling.
            * @param $sampler The CustomSampler that the CommandBuffer uses for sampling.
            * @param $marker The ProfilerMarker that the CommandBuffer uses for sampling.
            */
            public EndSample ($name: string) : void
            /** Adds a command to begin profile sampling.
            * @param $name Name of the profile information used for sampling.
            * @param $sampler The CustomSampler that the CommandBuffer uses for sampling.
            * @param $marker The ProfilerMarker that the CommandBuffer uses for sampling.
            */
            public BeginSample ($sampler: UnityEngine.Profiling.CustomSampler) : void
            /** Adds a command to end profile sampling.
            * @param $name Name of the profile information used for sampling.
            * @param $sampler The CustomSampler that the CommandBuffer uses for sampling.
            * @param $marker The ProfilerMarker that the CommandBuffer uses for sampling.
            */
            public EndSample ($sampler: UnityEngine.Profiling.CustomSampler) : void
            public BeginSample ($marker: Unity.Profiling.ProfilerMarker) : void
            public EndSample ($marker: Unity.Profiling.ProfilerMarker) : void
            /** Increments the updateCount property of a Texture.
            * @param $dest Increments the updateCount for this Texture.
            */
            public IncrementUpdateCount ($dest: UnityEngine.Rendering.RenderTargetIdentifier) : void
            /** Adds a command to multiply the instance count of every draw call by a specific multiplier.
            */
            public SetInstanceMultiplier ($multiplier: number) : void
            /** Adds a command to set the mode to use for foveated rendering.
            * @param $foveatedRenderingMode The mode to set.
            */
            public SetFoveatedRenderingMode ($foveatedRenderingMode: UnityEngine.Rendering.FoveatedRenderingMode) : void
            /** Add a "set wireframe" command to the buffer.
            * @param $enable A boolean indicating whether to enable wireframe mode.
            */
            public SetWireframe ($enable: boolean) : void
            /** Adds a command to configure foveated rendering.
            * @param $platformData The native pointer from XR.XRDisplaySubsystem.XRRenderPass.foveatedRenderingInfo.
            */
            public ConfigureFoveatedRendering ($platformData: System.IntPtr) : void
            /** Add a "set active render target" command.
            * @param $rt Render target to set for both color & depth buffers.
            * @param $color Render target to set as a color buffer.
            * @param $colors Render targets to set as color buffers (MRT).
            * @param $depth Render target to set as a depth buffer.
            * @param $mipLevel The mip level of the render target to render into.
            * @param $cubemapFace The cubemap face of a cubemap render target to render into.
            * @param $depthSlice Slice of a 3D or array render target to set.
            * @param $loadAction Load action that is used for color and depth/stencil buffers.
            * @param $storeAction Store action that is used for color and depth/stencil buffers.
            * @param $colorLoadAction Load action that is used for the color buffer.
            * @param $colorStoreAction Store action that is used for the color buffer.
            * @param $depthLoadAction Load action that is used for the depth/stencil buffer.
            * @param $depthStoreAction Store action that is used for the depth/stencil buffer.
            */
            public SetRenderTarget ($rt: UnityEngine.Rendering.RenderTargetIdentifier) : void
            /** Add a "set active render target" command.
            * @param $rt Render target to set for both color & depth buffers.
            * @param $color Render target to set as a color buffer.
            * @param $colors Render targets to set as color buffers (MRT).
            * @param $depth Render target to set as a depth buffer.
            * @param $mipLevel The mip level of the render target to render into.
            * @param $cubemapFace The cubemap face of a cubemap render target to render into.
            * @param $depthSlice Slice of a 3D or array render target to set.
            * @param $loadAction Load action that is used for color and depth/stencil buffers.
            * @param $storeAction Store action that is used for color and depth/stencil buffers.
            * @param $colorLoadAction Load action that is used for the color buffer.
            * @param $colorStoreAction Store action that is used for the color buffer.
            * @param $depthLoadAction Load action that is used for the depth/stencil buffer.
            * @param $depthStoreAction Store action that is used for the depth/stencil buffer.
            */
            public SetRenderTarget ($rt: UnityEngine.Rendering.RenderTargetIdentifier, $loadAction: UnityEngine.Rendering.RenderBufferLoadAction, $storeAction: UnityEngine.Rendering.RenderBufferStoreAction) : void
            /** Add a "set active render target" command.
            * @param $rt Render target to set for both color & depth buffers.
            * @param $color Render target to set as a color buffer.
            * @param $colors Render targets to set as color buffers (MRT).
            * @param $depth Render target to set as a depth buffer.
            * @param $mipLevel The mip level of the render target to render into.
            * @param $cubemapFace The cubemap face of a cubemap render target to render into.
            * @param $depthSlice Slice of a 3D or array render target to set.
            * @param $loadAction Load action that is used for color and depth/stencil buffers.
            * @param $storeAction Store action that is used for color and depth/stencil buffers.
            * @param $colorLoadAction Load action that is used for the color buffer.
            * @param $colorStoreAction Store action that is used for the color buffer.
            * @param $depthLoadAction Load action that is used for the depth/stencil buffer.
            * @param $depthStoreAction Store action that is used for the depth/stencil buffer.
            */
            public SetRenderTarget ($rt: UnityEngine.Rendering.RenderTargetIdentifier, $colorLoadAction: UnityEngine.Rendering.RenderBufferLoadAction, $colorStoreAction: UnityEngine.Rendering.RenderBufferStoreAction, $depthLoadAction: UnityEngine.Rendering.RenderBufferLoadAction, $depthStoreAction: UnityEngine.Rendering.RenderBufferStoreAction) : void
            /** Add a "set active render target" command.
            * @param $rt Render target to set for both color & depth buffers.
            * @param $color Render target to set as a color buffer.
            * @param $colors Render targets to set as color buffers (MRT).
            * @param $depth Render target to set as a depth buffer.
            * @param $mipLevel The mip level of the render target to render into.
            * @param $cubemapFace The cubemap face of a cubemap render target to render into.
            * @param $depthSlice Slice of a 3D or array render target to set.
            * @param $loadAction Load action that is used for color and depth/stencil buffers.
            * @param $storeAction Store action that is used for color and depth/stencil buffers.
            * @param $colorLoadAction Load action that is used for the color buffer.
            * @param $colorStoreAction Store action that is used for the color buffer.
            * @param $depthLoadAction Load action that is used for the depth/stencil buffer.
            * @param $depthStoreAction Store action that is used for the depth/stencil buffer.
            */
            public SetRenderTarget ($rt: UnityEngine.Rendering.RenderTargetIdentifier, $mipLevel: number) : void
            /** Add a "set active render target" command.
            * @param $rt Render target to set for both color & depth buffers.
            * @param $color Render target to set as a color buffer.
            * @param $colors Render targets to set as color buffers (MRT).
            * @param $depth Render target to set as a depth buffer.
            * @param $mipLevel The mip level of the render target to render into.
            * @param $cubemapFace The cubemap face of a cubemap render target to render into.
            * @param $depthSlice Slice of a 3D or array render target to set.
            * @param $loadAction Load action that is used for color and depth/stencil buffers.
            * @param $storeAction Store action that is used for color and depth/stencil buffers.
            * @param $colorLoadAction Load action that is used for the color buffer.
            * @param $colorStoreAction Store action that is used for the color buffer.
            * @param $depthLoadAction Load action that is used for the depth/stencil buffer.
            * @param $depthStoreAction Store action that is used for the depth/stencil buffer.
            */
            public SetRenderTarget ($rt: UnityEngine.Rendering.RenderTargetIdentifier, $mipLevel: number, $cubemapFace: UnityEngine.CubemapFace) : void
            /** Add a "set active render target" command.
            * @param $rt Render target to set for both color & depth buffers.
            * @param $color Render target to set as a color buffer.
            * @param $colors Render targets to set as color buffers (MRT).
            * @param $depth Render target to set as a depth buffer.
            * @param $mipLevel The mip level of the render target to render into.
            * @param $cubemapFace The cubemap face of a cubemap render target to render into.
            * @param $depthSlice Slice of a 3D or array render target to set.
            * @param $loadAction Load action that is used for color and depth/stencil buffers.
            * @param $storeAction Store action that is used for color and depth/stencil buffers.
            * @param $colorLoadAction Load action that is used for the color buffer.
            * @param $colorStoreAction Store action that is used for the color buffer.
            * @param $depthLoadAction Load action that is used for the depth/stencil buffer.
            * @param $depthStoreAction Store action that is used for the depth/stencil buffer.
            */
            public SetRenderTarget ($rt: UnityEngine.Rendering.RenderTargetIdentifier, $mipLevel: number, $cubemapFace: UnityEngine.CubemapFace, $depthSlice: number) : void
            /** Add a "set active render target" command.
            * @param $rt Render target to set for both color & depth buffers.
            * @param $color Render target to set as a color buffer.
            * @param $colors Render targets to set as color buffers (MRT).
            * @param $depth Render target to set as a depth buffer.
            * @param $mipLevel The mip level of the render target to render into.
            * @param $cubemapFace The cubemap face of a cubemap render target to render into.
            * @param $depthSlice Slice of a 3D or array render target to set.
            * @param $loadAction Load action that is used for color and depth/stencil buffers.
            * @param $storeAction Store action that is used for color and depth/stencil buffers.
            * @param $colorLoadAction Load action that is used for the color buffer.
            * @param $colorStoreAction Store action that is used for the color buffer.
            * @param $depthLoadAction Load action that is used for the depth/stencil buffer.
            * @param $depthStoreAction Store action that is used for the depth/stencil buffer.
            */
            public SetRenderTarget ($color: UnityEngine.Rendering.RenderTargetIdentifier, $depth: UnityEngine.Rendering.RenderTargetIdentifier) : void
            /** Add a "set active render target" command.
            * @param $rt Render target to set for both color & depth buffers.
            * @param $color Render target to set as a color buffer.
            * @param $colors Render targets to set as color buffers (MRT).
            * @param $depth Render target to set as a depth buffer.
            * @param $mipLevel The mip level of the render target to render into.
            * @param $cubemapFace The cubemap face of a cubemap render target to render into.
            * @param $depthSlice Slice of a 3D or array render target to set.
            * @param $loadAction Load action that is used for color and depth/stencil buffers.
            * @param $storeAction Store action that is used for color and depth/stencil buffers.
            * @param $colorLoadAction Load action that is used for the color buffer.
            * @param $colorStoreAction Store action that is used for the color buffer.
            * @param $depthLoadAction Load action that is used for the depth/stencil buffer.
            * @param $depthStoreAction Store action that is used for the depth/stencil buffer.
            */
            public SetRenderTarget ($color: UnityEngine.Rendering.RenderTargetIdentifier, $depth: UnityEngine.Rendering.RenderTargetIdentifier, $mipLevel: number) : void
            /** Add a "set active render target" command.
            * @param $rt Render target to set for both color & depth buffers.
            * @param $color Render target to set as a color buffer.
            * @param $colors Render targets to set as color buffers (MRT).
            * @param $depth Render target to set as a depth buffer.
            * @param $mipLevel The mip level of the render target to render into.
            * @param $cubemapFace The cubemap face of a cubemap render target to render into.
            * @param $depthSlice Slice of a 3D or array render target to set.
            * @param $loadAction Load action that is used for color and depth/stencil buffers.
            * @param $storeAction Store action that is used for color and depth/stencil buffers.
            * @param $colorLoadAction Load action that is used for the color buffer.
            * @param $colorStoreAction Store action that is used for the color buffer.
            * @param $depthLoadAction Load action that is used for the depth/stencil buffer.
            * @param $depthStoreAction Store action that is used for the depth/stencil buffer.
            */
            public SetRenderTarget ($color: UnityEngine.Rendering.RenderTargetIdentifier, $depth: UnityEngine.Rendering.RenderTargetIdentifier, $mipLevel: number, $cubemapFace: UnityEngine.CubemapFace) : void
            /** Add a "set active render target" command.
            * @param $rt Render target to set for both color & depth buffers.
            * @param $color Render target to set as a color buffer.
            * @param $colors Render targets to set as color buffers (MRT).
            * @param $depth Render target to set as a depth buffer.
            * @param $mipLevel The mip level of the render target to render into.
            * @param $cubemapFace The cubemap face of a cubemap render target to render into.
            * @param $depthSlice Slice of a 3D or array render target to set.
            * @param $loadAction Load action that is used for color and depth/stencil buffers.
            * @param $storeAction Store action that is used for color and depth/stencil buffers.
            * @param $colorLoadAction Load action that is used for the color buffer.
            * @param $colorStoreAction Store action that is used for the color buffer.
            * @param $depthLoadAction Load action that is used for the depth/stencil buffer.
            * @param $depthStoreAction Store action that is used for the depth/stencil buffer.
            */
            public SetRenderTarget ($color: UnityEngine.Rendering.RenderTargetIdentifier, $depth: UnityEngine.Rendering.RenderTargetIdentifier, $mipLevel: number, $cubemapFace: UnityEngine.CubemapFace, $depthSlice: number) : void
            /** Add a "set active render target" command.
            * @param $rt Render target to set for both color & depth buffers.
            * @param $color Render target to set as a color buffer.
            * @param $colors Render targets to set as color buffers (MRT).
            * @param $depth Render target to set as a depth buffer.
            * @param $mipLevel The mip level of the render target to render into.
            * @param $cubemapFace The cubemap face of a cubemap render target to render into.
            * @param $depthSlice Slice of a 3D or array render target to set.
            * @param $loadAction Load action that is used for color and depth/stencil buffers.
            * @param $storeAction Store action that is used for color and depth/stencil buffers.
            * @param $colorLoadAction Load action that is used for the color buffer.
            * @param $colorStoreAction Store action that is used for the color buffer.
            * @param $depthLoadAction Load action that is used for the depth/stencil buffer.
            * @param $depthStoreAction Store action that is used for the depth/stencil buffer.
            */
            public SetRenderTarget ($color: UnityEngine.Rendering.RenderTargetIdentifier, $colorLoadAction: UnityEngine.Rendering.RenderBufferLoadAction, $colorStoreAction: UnityEngine.Rendering.RenderBufferStoreAction, $depth: UnityEngine.Rendering.RenderTargetIdentifier, $depthLoadAction: UnityEngine.Rendering.RenderBufferLoadAction, $depthStoreAction: UnityEngine.Rendering.RenderBufferStoreAction) : void
            /** Add a "set active render target" command.
            * @param $rt Render target to set for both color & depth buffers.
            * @param $color Render target to set as a color buffer.
            * @param $colors Render targets to set as color buffers (MRT).
            * @param $depth Render target to set as a depth buffer.
            * @param $mipLevel The mip level of the render target to render into.
            * @param $cubemapFace The cubemap face of a cubemap render target to render into.
            * @param $depthSlice Slice of a 3D or array render target to set.
            * @param $loadAction Load action that is used for color and depth/stencil buffers.
            * @param $storeAction Store action that is used for color and depth/stencil buffers.
            * @param $colorLoadAction Load action that is used for the color buffer.
            * @param $colorStoreAction Store action that is used for the color buffer.
            * @param $depthLoadAction Load action that is used for the depth/stencil buffer.
            * @param $depthStoreAction Store action that is used for the depth/stencil buffer.
            */
            public SetRenderTarget ($colors: System.Array$1<UnityEngine.Rendering.RenderTargetIdentifier>, $depth: UnityEngine.Rendering.RenderTargetIdentifier) : void
            /** Add a "set active render target" command.
            * @param $rt Render target to set for both color & depth buffers.
            * @param $color Render target to set as a color buffer.
            * @param $colors Render targets to set as color buffers (MRT).
            * @param $depth Render target to set as a depth buffer.
            * @param $mipLevel The mip level of the render target to render into.
            * @param $cubemapFace The cubemap face of a cubemap render target to render into.
            * @param $depthSlice Slice of a 3D or array render target to set.
            * @param $loadAction Load action that is used for color and depth/stencil buffers.
            * @param $storeAction Store action that is used for color and depth/stencil buffers.
            * @param $colorLoadAction Load action that is used for the color buffer.
            * @param $colorStoreAction Store action that is used for the color buffer.
            * @param $depthLoadAction Load action that is used for the depth/stencil buffer.
            * @param $depthStoreAction Store action that is used for the depth/stencil buffer.
            */
            public SetRenderTarget ($colors: System.Array$1<UnityEngine.Rendering.RenderTargetIdentifier>, $depth: UnityEngine.Rendering.RenderTargetIdentifier, $mipLevel: number, $cubemapFace: UnityEngine.CubemapFace, $depthSlice: number) : void
            /** Add a "set active render target" command.
            * @param $rt Render target to set for both color & depth buffers.
            * @param $color Render target to set as a color buffer.
            * @param $colors Render targets to set as color buffers (MRT).
            * @param $depth Render target to set as a depth buffer.
            * @param $mipLevel The mip level of the render target to render into.
            * @param $cubemapFace The cubemap face of a cubemap render target to render into.
            * @param $depthSlice Slice of a 3D or array render target to set.
            * @param $loadAction Load action that is used for color and depth/stencil buffers.
            * @param $storeAction Store action that is used for color and depth/stencil buffers.
            * @param $colorLoadAction Load action that is used for the color buffer.
            * @param $colorStoreAction Store action that is used for the color buffer.
            * @param $depthLoadAction Load action that is used for the depth/stencil buffer.
            * @param $depthStoreAction Store action that is used for the depth/stencil buffer.
            */
            public SetRenderTarget ($binding: UnityEngine.Rendering.RenderTargetBinding, $mipLevel: number, $cubemapFace: UnityEngine.CubemapFace, $depthSlice: number) : void
            /** Add a "set active render target" command.
            * @param $rt Render target to set for both color & depth buffers.
            * @param $color Render target to set as a color buffer.
            * @param $colors Render targets to set as color buffers (MRT).
            * @param $depth Render target to set as a depth buffer.
            * @param $mipLevel The mip level of the render target to render into.
            * @param $cubemapFace The cubemap face of a cubemap render target to render into.
            * @param $depthSlice Slice of a 3D or array render target to set.
            * @param $loadAction Load action that is used for color and depth/stencil buffers.
            * @param $storeAction Store action that is used for color and depth/stencil buffers.
            * @param $colorLoadAction Load action that is used for the color buffer.
            * @param $colorStoreAction Store action that is used for the color buffer.
            * @param $depthLoadAction Load action that is used for the depth/stencil buffer.
            * @param $depthStoreAction Store action that is used for the depth/stencil buffer.
            */
            public SetRenderTarget ($binding: UnityEngine.Rendering.RenderTargetBinding) : void
            /** Adds a command to set the buffer with values from an array.
            * @param $buffer The destination buffer.
            * @param $data Array of values to fill the buffer.
            */
            public SetBufferData ($buffer: UnityEngine.ComputeBuffer, $data: System.Array) : void
            /** Adds a command to process a partial copy of data values from an array into the buffer.
            * @param $buffer The destination buffer.
            * @param $data Array of values to fill the buffer.
            * @param $managedBufferStartIndex The first element index in data to copy to the compute buffer.
            * @param $graphicsBufferStartIndex The first element index in compute buffer to receive the data.
            * @param $count The number of elements to copy.
            * @param $nativeBufferStartIndex The first element index in data to copy to the compute buffer.
            */
            public SetBufferData ($buffer: UnityEngine.ComputeBuffer, $data: System.Array, $managedBufferStartIndex: number, $graphicsBufferStartIndex: number, $count: number) : void
            /** Adds a command to set the counter value of append/consume buffer.
            * @param $buffer The destination buffer.
            * @param $counterValue Value of the append/consume counter.
            */
            public SetBufferCounterValue ($buffer: UnityEngine.ComputeBuffer, $counterValue: number) : void
            /** Adds a command to set the buffer with values from an array.
            * @param $buffer The destination buffer.
            * @param $data Array of values to fill the buffer.
            */
            public SetBufferData ($buffer: UnityEngine.GraphicsBuffer, $data: System.Array) : void
            /** Adds a command to process a partial copy of data values from an array into the buffer.
            * @param $buffer The destination buffer.
            * @param $data Array of values to fill the buffer.
            * @param $managedBufferStartIndex The first element index in data to copy to the compute buffer.
            * @param $graphicsBufferStartIndex The first element index in compute buffer to receive the data.
            * @param $count The number of elements to copy.
            * @param $nativeBufferStartIndex The first element index in data to copy to the compute buffer.
            */
            public SetBufferData ($buffer: UnityEngine.GraphicsBuffer, $data: System.Array, $managedBufferStartIndex: number, $graphicsBufferStartIndex: number, $count: number) : void
            /** Adds a command to set the counter value of append/consume buffer.
            * @param $buffer The destination buffer.
            * @param $counterValue Value of the append/consume counter.
            */
            public SetBufferCounterValue ($buffer: UnityEngine.GraphicsBuffer, $counterValue: number) : void
            public BeginRenderPass ($width: number, $height: number, $samples: number, $attachments: Unity.Collections.NativeArray$1<UnityEngine.Rendering.AttachmentDescriptor>, $depthAttachmentIndex: number, $subPasses: Unity.Collections.NativeArray$1<UnityEngine.Rendering.SubPassDescriptor>) : void
            public BeginRenderPass ($width: number, $height: number, $volumeDepth: number, $samples: number, $attachments: Unity.Collections.NativeArray$1<UnityEngine.Rendering.AttachmentDescriptor>, $depthAttachmentIndex: number, $subPasses: Unity.Collections.NativeArray$1<UnityEngine.Rendering.SubPassDescriptor>) : void
            /** Start the next native subpass as discribed by CommandBuffer.BeginRenderPass.
            */
            public NextSubPass () : void
            /** Terminate the active native renderpass.
            */
            public EndRenderPass () : void
            /** Schedules the setup of Camera specific global Shader variables.
            * @param $camera Camera to setup shader variables for.
            */
            public SetupCameraProperties ($camera: UnityEngine.Camera) : void
            /** Schedules an invocation of the OnRenderObject callback for MonoBehaviour scripts.
            */
            public InvokeOnRenderObjectCallbacks () : void
            public Dispose () : void
            public Release () : void
            /** Shortcut for calling CommandBuffer.CreateGraphicsFence with Rendering.GraphicsFenceType.AsyncQueueSynchronisation as the first parameter.
            * @param $stage Which SynchronisationStage to insert the fence after.
            * @returns Returns a new GraphicsFence. 
            */
            public CreateAsyncGraphicsFence () : UnityEngine.Rendering.GraphicsFence
            /** Shortcut for calling CommandBuffer.CreateGraphicsFence with Rendering.GraphicsFenceType.AsyncQueueSynchronisation as the first parameter.
            * @param $stage Which SynchronisationStage to insert the fence after.
            * @returns Returns a new GraphicsFence. 
            */
            public CreateAsyncGraphicsFence ($stage: UnityEngine.Rendering.SynchronisationStage) : UnityEngine.Rendering.GraphicsFence
            /** Creates a GraphicsFence.
            * @param $fenceType The Rendering.GraphicsFenceType to create. Currently the only supported value is Rendering.GraphicsFenceType.AsyncQueueSynchronisation.
            * @param $stage Which SynchronisationStage to insert the fence after.
            * @returns Returns a new GraphicsFence. 
            */
            public CreateGraphicsFence ($fenceType: UnityEngine.Rendering.GraphicsFenceType, $stage: UnityEngine.Rendering.SynchronisationStageFlags) : UnityEngine.Rendering.GraphicsFence
            /** Instructs the GPU to pause processing of the queue until it passes through the GraphicsFence fence.
            * @param $fence The GraphicsFence the GPU waits for. The fenceType of the graphics fence must be Rendering.GraphicsFenceType.AsyncQueueSynchronisation.
            * @param $stage Which SynchronisationStage to wait for.
            */
            public WaitOnAsyncGraphicsFence ($fence: UnityEngine.Rendering.GraphicsFence) : void
            /** Instructs the GPU to pause processing of the queue until it passes through the GraphicsFence fence.
            * @param $fence The GraphicsFence the GPU waits for. The fenceType of the graphics fence must be Rendering.GraphicsFenceType.AsyncQueueSynchronisation.
            * @param $stage Which SynchronisationStage to wait for.
            */
            public WaitOnAsyncGraphicsFence ($fence: UnityEngine.Rendering.GraphicsFence, $stage: UnityEngine.Rendering.SynchronisationStage) : void
            public WaitOnAsyncGraphicsFence ($fence: UnityEngine.Rendering.GraphicsFence, $stage: UnityEngine.Rendering.SynchronisationStageFlags) : void
            /** Adds a command to set a float parameter on a ComputeShader.
            * @param $computeShader ComputeShader to set parameter for.
            * @param $name Name of the variable in shader code.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $val Value to set.
            */
            public SetComputeFloatParam ($computeShader: UnityEngine.ComputeShader, $name: string, $val: number) : void
            /** Adds a command to set an integer parameter on a ComputeShader.
            * @param $computeShader ComputeShader to set parameter for.
            * @param $name Name of the variable in shader code.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $val Value to set.
            */
            public SetComputeIntParam ($computeShader: UnityEngine.ComputeShader, $name: string, $val: number) : void
            /** Adds a command to set a vector parameter on a ComputeShader.
            * @param $computeShader ComputeShader to set parameter for.
            * @param $name Name of the variable in shader code.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $val Value to set.
            */
            public SetComputeVectorParam ($computeShader: UnityEngine.ComputeShader, $name: string, $val: UnityEngine.Vector4) : void
            /** Adds a command to set a vector array parameter on a ComputeShader.
            * @param $computeShader ComputeShader to set parameter for.
            * @param $name Property name.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $values Value to set.
            */
            public SetComputeVectorArrayParam ($computeShader: UnityEngine.ComputeShader, $name: string, $values: System.Array$1<UnityEngine.Vector4>) : void
            /** Adds a command to set a matrix parameter on a ComputeShader.
            * @param $computeShader ComputeShader to set parameter for.
            * @param $name Name of the variable in shader code.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $val Value to set.
            */
            public SetComputeMatrixParam ($computeShader: UnityEngine.ComputeShader, $name: string, $val: UnityEngine.Matrix4x4) : void
            /** Adds a command to set a matrix array parameter on a ComputeShader.
            * @param $computeShader ComputeShader to set parameter for.
            * @param $name Name of the variable in shader code.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $values Value to set.
            */
            public SetComputeMatrixArrayParam ($computeShader: UnityEngine.ComputeShader, $name: string, $values: System.Array$1<UnityEngine.Matrix4x4>) : void
            /** Adds a command to set multiple consecutive float parameters on a ComputeShader.
            * @param $computeShader ComputeShader to set parameter for.
            * @param $name Name of the variable in shader code.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $values Values to set.
            */
            public SetComputeFloatParams ($computeShader: UnityEngine.ComputeShader, $name: string, ...values: number[]) : void
            /** Adds a command to set multiple consecutive float parameters on a ComputeShader.
            * @param $computeShader ComputeShader to set parameter for.
            * @param $name Name of the variable in shader code.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $values Values to set.
            */
            public SetComputeFloatParams ($computeShader: UnityEngine.ComputeShader, $nameID: number, ...values: number[]) : void
            /** Adds a command to set multiple consecutive integer parameters on a ComputeShader.
            * @param $computeShader ComputeShader to set parameter for.
            * @param $name Name of the variable in shader code.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $values Values to set.
            */
            public SetComputeIntParams ($computeShader: UnityEngine.ComputeShader, $name: string, ...values: number[]) : void
            /** Adds a command to set multiple consecutive integer parameters on a ComputeShader.
            * @param $computeShader ComputeShader to set parameter for.
            * @param $name Name of the variable in shader code.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $values Values to set.
            */
            public SetComputeIntParams ($computeShader: UnityEngine.ComputeShader, $nameID: number, ...values: number[]) : void
            /** Adds a command to set a texture parameter on a ComputeShader.
            * @param $computeShader ComputeShader to set parameter for.
            * @param $kernelIndex Which kernel the texture is being set for. See ComputeShader.FindKernel.
            * @param $name Name of the texture variable in shader code.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $rt Texture value or identifier to set, see RenderTargetIdentifier.
            * @param $mipLevel Optional mipmap level of the read-write texture.
            * @param $element Optional parameter that specifies the type of data to set from the RenderTexture.
            */
            public SetComputeTextureParam ($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $name: string, $rt: UnityEngine.Rendering.RenderTargetIdentifier) : void
            /** Adds a command to set a texture parameter on a ComputeShader.
            * @param $computeShader ComputeShader to set parameter for.
            * @param $kernelIndex Which kernel the texture is being set for. See ComputeShader.FindKernel.
            * @param $name Name of the texture variable in shader code.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $rt Texture value or identifier to set, see RenderTargetIdentifier.
            * @param $mipLevel Optional mipmap level of the read-write texture.
            * @param $element Optional parameter that specifies the type of data to set from the RenderTexture.
            */
            public SetComputeTextureParam ($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $nameID: number, $rt: UnityEngine.Rendering.RenderTargetIdentifier) : void
            /** Adds a command to set a texture parameter on a ComputeShader.
            * @param $computeShader ComputeShader to set parameter for.
            * @param $kernelIndex Which kernel the texture is being set for. See ComputeShader.FindKernel.
            * @param $name Name of the texture variable in shader code.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $rt Texture value or identifier to set, see RenderTargetIdentifier.
            * @param $mipLevel Optional mipmap level of the read-write texture.
            * @param $element Optional parameter that specifies the type of data to set from the RenderTexture.
            */
            public SetComputeTextureParam ($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $name: string, $rt: UnityEngine.Rendering.RenderTargetIdentifier, $mipLevel: number) : void
            /** Adds a command to set a texture parameter on a ComputeShader.
            * @param $computeShader ComputeShader to set parameter for.
            * @param $kernelIndex Which kernel the texture is being set for. See ComputeShader.FindKernel.
            * @param $name Name of the texture variable in shader code.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $rt Texture value or identifier to set, see RenderTargetIdentifier.
            * @param $mipLevel Optional mipmap level of the read-write texture.
            * @param $element Optional parameter that specifies the type of data to set from the RenderTexture.
            */
            public SetComputeTextureParam ($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $nameID: number, $rt: UnityEngine.Rendering.RenderTargetIdentifier, $mipLevel: number) : void
            /** Adds a command to set a texture parameter on a ComputeShader.
            * @param $computeShader ComputeShader to set parameter for.
            * @param $kernelIndex Which kernel the texture is being set for. See ComputeShader.FindKernel.
            * @param $name Name of the texture variable in shader code.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $rt Texture value or identifier to set, see RenderTargetIdentifier.
            * @param $mipLevel Optional mipmap level of the read-write texture.
            * @param $element Optional parameter that specifies the type of data to set from the RenderTexture.
            */
            public SetComputeTextureParam ($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $name: string, $rt: UnityEngine.Rendering.RenderTargetIdentifier, $mipLevel: number, $element: UnityEngine.Rendering.RenderTextureSubElement) : void
            /** Adds a command to set a texture parameter on a ComputeShader.
            * @param $computeShader ComputeShader to set parameter for.
            * @param $kernelIndex Which kernel the texture is being set for. See ComputeShader.FindKernel.
            * @param $name Name of the texture variable in shader code.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $rt Texture value or identifier to set, see RenderTargetIdentifier.
            * @param $mipLevel Optional mipmap level of the read-write texture.
            * @param $element Optional parameter that specifies the type of data to set from the RenderTexture.
            */
            public SetComputeTextureParam ($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $nameID: number, $rt: UnityEngine.Rendering.RenderTargetIdentifier, $mipLevel: number, $element: UnityEngine.Rendering.RenderTextureSubElement) : void
            /** Adds a command to set an input or output buffer parameter on a ComputeShader.
            * @param $computeShader ComputeShader to set parameter for.
            * @param $kernelIndex Which kernel the buffer is being set for. See ComputeShader.FindKernel.
            * @param $name Name of the buffer variable in shader code.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $buffer Buffer to set.
            * @param $bufferHandle The handle of the buffer to set.
            */
            public SetComputeBufferParam ($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $nameID: number, $buffer: UnityEngine.ComputeBuffer) : void
            /** Adds a command to set an input or output buffer parameter on a ComputeShader.
            * @param $computeShader ComputeShader to set parameter for.
            * @param $kernelIndex Which kernel the buffer is being set for. See ComputeShader.FindKernel.
            * @param $name Name of the buffer variable in shader code.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $buffer Buffer to set.
            * @param $bufferHandle The handle of the buffer to set.
            */
            public SetComputeBufferParam ($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $name: string, $buffer: UnityEngine.ComputeBuffer) : void
            /** Adds a command to set an input or output buffer parameter on a ComputeShader.
            * @param $computeShader ComputeShader to set parameter for.
            * @param $kernelIndex Which kernel the buffer is being set for. See ComputeShader.FindKernel.
            * @param $name Name of the buffer variable in shader code.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $buffer Buffer to set.
            * @param $bufferHandle The handle of the buffer to set.
            */
            public SetComputeBufferParam ($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $nameID: number, $bufferHandle: UnityEngine.GraphicsBufferHandle) : void
            /** Adds a command to set an input or output buffer parameter on a ComputeShader.
            * @param $computeShader ComputeShader to set parameter for.
            * @param $kernelIndex Which kernel the buffer is being set for. See ComputeShader.FindKernel.
            * @param $name Name of the buffer variable in shader code.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $buffer Buffer to set.
            * @param $bufferHandle The handle of the buffer to set.
            */
            public SetComputeBufferParam ($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $name: string, $bufferHandle: UnityEngine.GraphicsBufferHandle) : void
            /** Adds a command to set an input or output buffer parameter on a ComputeShader.
            * @param $computeShader ComputeShader to set parameter for.
            * @param $kernelIndex Which kernel the buffer is being set for. See ComputeShader.FindKernel.
            * @param $name Name of the buffer variable in shader code.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $buffer Buffer to set.
            * @param $bufferHandle The handle of the buffer to set.
            */
            public SetComputeBufferParam ($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $nameID: number, $buffer: UnityEngine.GraphicsBuffer) : void
            /** Adds a command to set an input or output buffer parameter on a ComputeShader.
            * @param $computeShader ComputeShader to set parameter for.
            * @param $kernelIndex Which kernel the buffer is being set for. See ComputeShader.FindKernel.
            * @param $name Name of the buffer variable in shader code.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $buffer Buffer to set.
            * @param $bufferHandle The handle of the buffer to set.
            */
            public SetComputeBufferParam ($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $name: string, $buffer: UnityEngine.GraphicsBuffer) : void
            /** Adds a command to set a constant buffer on a ComputeShader.
            * @param $computeShader The ComputeShader to set parameter for.
            * @param $nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
            * @param $name The name of the constant buffer in shaders code.
            * @param $buffer The buffer to bind as constant buffer.
            * @param $offset The offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
            * @param $size The number of bytes to bind.
            */
            public SetComputeConstantBufferParam ($computeShader: UnityEngine.ComputeShader, $nameID: number, $buffer: UnityEngine.ComputeBuffer, $offset: number, $size: number) : void
            /** Adds a command to set a constant buffer on a ComputeShader.
            * @param $computeShader The ComputeShader to set parameter for.
            * @param $nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
            * @param $name The name of the constant buffer in shaders code.
            * @param $buffer The buffer to bind as constant buffer.
            * @param $offset The offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
            * @param $size The number of bytes to bind.
            */
            public SetComputeConstantBufferParam ($computeShader: UnityEngine.ComputeShader, $name: string, $buffer: UnityEngine.ComputeBuffer, $offset: number, $size: number) : void
            /** Adds a command to set a constant buffer on a ComputeShader.
            * @param $computeShader The ComputeShader to set parameter for.
            * @param $nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
            * @param $name The name of the constant buffer in shaders code.
            * @param $buffer The buffer to bind as constant buffer.
            * @param $offset The offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
            * @param $size The number of bytes to bind.
            */
            public SetComputeConstantBufferParam ($computeShader: UnityEngine.ComputeShader, $nameID: number, $buffer: UnityEngine.GraphicsBuffer, $offset: number, $size: number) : void
            /** Adds a command to set a constant buffer on a ComputeShader.
            * @param $computeShader The ComputeShader to set parameter for.
            * @param $nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
            * @param $name The name of the constant buffer in shaders code.
            * @param $buffer The buffer to bind as constant buffer.
            * @param $offset The offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
            * @param $size The number of bytes to bind.
            */
            public SetComputeConstantBufferParam ($computeShader: UnityEngine.ComputeShader, $name: string, $buffer: UnityEngine.GraphicsBuffer, $offset: number, $size: number) : void
            /** Sets the parameters for a compute shader kernel from a Material.
            * @param $computeShader The ComputeShader to set parameters for.
            * @param $kernelIndex The index of the kernel to set the material parameters. See ComputeShader.FindKernel.
            * @param $material The material to set the compute parameters.
            */
            public SetComputeParamsFromMaterial ($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $material: UnityEngine.Material) : void
            /** Add a command to execute a ComputeShader.
            * @param $computeShader ComputeShader to execute.
            * @param $kernelIndex Kernel index to execute, see ComputeShader.FindKernel.
            * @param $threadGroupsX Number of work groups in the X dimension.
            * @param $threadGroupsY Number of work groups in the Y dimension.
            * @param $threadGroupsZ Number of work groups in the Z dimension.
            * @param $indirectBuffer ComputeBuffer with dispatch arguments.
            * @param $argsOffset Byte offset indicating the location of the dispatch arguments in the buffer.
            */
            public DispatchCompute ($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $threadGroupsX: number, $threadGroupsY: number, $threadGroupsZ: number) : void
            /** Add a command to execute a ComputeShader.
            * @param $computeShader ComputeShader to execute.
            * @param $kernelIndex Kernel index to execute, see ComputeShader.FindKernel.
            * @param $threadGroupsX Number of work groups in the X dimension.
            * @param $threadGroupsY Number of work groups in the Y dimension.
            * @param $threadGroupsZ Number of work groups in the Z dimension.
            * @param $indirectBuffer ComputeBuffer with dispatch arguments.
            * @param $argsOffset Byte offset indicating the location of the dispatch arguments in the buffer.
            */
            public DispatchCompute ($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $indirectBuffer: UnityEngine.ComputeBuffer, $argsOffset: number) : void
            /** Add a command to execute a ComputeShader.
            * @param $computeShader ComputeShader to execute.
            * @param $kernelIndex Kernel index to execute, see ComputeShader.FindKernel.
            * @param $threadGroupsX Number of work groups in the X dimension.
            * @param $threadGroupsY Number of work groups in the Y dimension.
            * @param $threadGroupsZ Number of work groups in the Z dimension.
            * @param $indirectBuffer ComputeBuffer with dispatch arguments.
            * @param $argsOffset Byte offset indicating the location of the dispatch arguments in the buffer.
            */
            public DispatchCompute ($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $indirectBuffer: UnityEngine.GraphicsBuffer, $argsOffset: number) : void
            /** Adds a command to build the RayTracingAccelerationStructure to be used in a ray tracing dispatch or when using inline ray tracing (ray queries).
            * @param $accelerationStructure The RayTracingAccelerationStructure to be generated.
            */
            public BuildRayTracingAccelerationStructure ($accelerationStructure: UnityEngine.Rendering.RayTracingAccelerationStructure) : void
            /** Adds a command to build the RayTracingAccelerationStructure to be used in a ray tracing dispatch or when using inline ray tracing (ray queries).
            * @param $accelerationStructure The RayTracingAccelerationStructure to be generated.
            */
            public BuildRayTracingAccelerationStructure ($accelerationStructure: UnityEngine.Rendering.RayTracingAccelerationStructure, $relativeOrigin: UnityEngine.Vector3) : void
            public BuildRayTracingAccelerationStructure ($accelerationStructure: UnityEngine.Rendering.RayTracingAccelerationStructure, $buildSettings: UnityEngine.Rendering.RayTracingAccelerationStructure.BuildSettings) : void
            /** Adds a command to set the RayTracingAccelerationStructure to be used in a RayTracingShader or a ComputeShader.
            * @param $rayTracingShader The RayTracingShader to set parameter for.
            * @param $name The name of the acceleration structure in the shader code.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $rayTracingAccelerationStructure The RayTracingAccelerationStructure object to be set.
            * @param $computeShader The ComputeShader object to set the parameter for.
            * @param $kernelIndex Which kernel the acceleration structure is being set for.
            */
            public SetRayTracingAccelerationStructure ($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $name: string, $rayTracingAccelerationStructure: UnityEngine.Rendering.RayTracingAccelerationStructure) : void
            /** Adds a command to set the RayTracingAccelerationStructure to be used in a RayTracingShader or a ComputeShader.
            * @param $rayTracingShader The RayTracingShader to set parameter for.
            * @param $name The name of the acceleration structure in the shader code.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $rayTracingAccelerationStructure The RayTracingAccelerationStructure object to be set.
            * @param $computeShader The ComputeShader object to set the parameter for.
            * @param $kernelIndex Which kernel the acceleration structure is being set for.
            */
            public SetRayTracingAccelerationStructure ($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $nameID: number, $rayTracingAccelerationStructure: UnityEngine.Rendering.RayTracingAccelerationStructure) : void
            /** Adds a command to set the RayTracingAccelerationStructure to be used in a RayTracingShader or a ComputeShader.
            * @param $rayTracingShader The RayTracingShader to set parameter for.
            * @param $name The name of the acceleration structure in the shader code.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $rayTracingAccelerationStructure The RayTracingAccelerationStructure object to be set.
            * @param $computeShader The ComputeShader object to set the parameter for.
            * @param $kernelIndex Which kernel the acceleration structure is being set for.
            */
            public SetRayTracingAccelerationStructure ($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $name: string, $rayTracingAccelerationStructure: UnityEngine.Rendering.RayTracingAccelerationStructure) : void
            /** Adds a command to set the RayTracingAccelerationStructure to be used in a RayTracingShader or a ComputeShader.
            * @param $rayTracingShader The RayTracingShader to set parameter for.
            * @param $name The name of the acceleration structure in the shader code.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $rayTracingAccelerationStructure The RayTracingAccelerationStructure object to be set.
            * @param $computeShader The ComputeShader object to set the parameter for.
            * @param $kernelIndex Which kernel the acceleration structure is being set for.
            */
            public SetRayTracingAccelerationStructure ($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $nameID: number, $rayTracingAccelerationStructure: UnityEngine.Rendering.RayTracingAccelerationStructure) : void
            /** Adds a command to set an input or output buffer parameter on a RayTracingShader.
            * @param $rayTracingShader The RayTracingShader to set parameter for.
            * @param $name The name of the buffer in shader code.
            * @param $nameID The ID of the property name for the buffer in shader code. Use Shader.PropertyToID to get this ID.
            * @param $buffer The buffer to set.
            * @param $bufferHandle The handle of the buffer to set.
            */
            public SetRayTracingBufferParam ($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $name: string, $buffer: UnityEngine.ComputeBuffer) : void
            /** Adds a command to set an input or output buffer parameter on a RayTracingShader.
            * @param $rayTracingShader The RayTracingShader to set parameter for.
            * @param $name The name of the buffer in shader code.
            * @param $nameID The ID of the property name for the buffer in shader code. Use Shader.PropertyToID to get this ID.
            * @param $buffer The buffer to set.
            * @param $bufferHandle The handle of the buffer to set.
            */
            public SetRayTracingBufferParam ($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $nameID: number, $buffer: UnityEngine.ComputeBuffer) : void
            /** Adds a command to set an input or output buffer parameter on a RayTracingShader.
            * @param $rayTracingShader The RayTracingShader to set parameter for.
            * @param $name The name of the buffer in shader code.
            * @param $nameID The ID of the property name for the buffer in shader code. Use Shader.PropertyToID to get this ID.
            * @param $buffer The buffer to set.
            * @param $bufferHandle The handle of the buffer to set.
            */
            public SetRayTracingBufferParam ($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $name: string, $buffer: UnityEngine.GraphicsBuffer) : void
            /** Adds a command to set an input or output buffer parameter on a RayTracingShader.
            * @param $rayTracingShader The RayTracingShader to set parameter for.
            * @param $name The name of the buffer in shader code.
            * @param $nameID The ID of the property name for the buffer in shader code. Use Shader.PropertyToID to get this ID.
            * @param $buffer The buffer to set.
            * @param $bufferHandle The handle of the buffer to set.
            */
            public SetRayTracingBufferParam ($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $nameID: number, $buffer: UnityEngine.GraphicsBuffer) : void
            /** Adds a command to set an input or output buffer parameter on a RayTracingShader.
            * @param $rayTracingShader The RayTracingShader to set parameter for.
            * @param $name The name of the buffer in shader code.
            * @param $nameID The ID of the property name for the buffer in shader code. Use Shader.PropertyToID to get this ID.
            * @param $buffer The buffer to set.
            * @param $bufferHandle The handle of the buffer to set.
            */
            public SetRayTracingBufferParam ($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $name: string, $bufferHandle: UnityEngine.GraphicsBufferHandle) : void
            /** Adds a command to set an input or output buffer parameter on a RayTracingShader.
            * @param $rayTracingShader The RayTracingShader to set parameter for.
            * @param $name The name of the buffer in shader code.
            * @param $nameID The ID of the property name for the buffer in shader code. Use Shader.PropertyToID to get this ID.
            * @param $buffer The buffer to set.
            * @param $bufferHandle The handle of the buffer to set.
            */
            public SetRayTracingBufferParam ($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $nameID: number, $bufferHandle: UnityEngine.GraphicsBufferHandle) : void
            /** Adds a command to set a constant buffer on a RayTracingShader.
            * @param $rayTracingShader The RayTracingShader to set parameter for.
            * @param $nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
            * @param $name The name of the constant buffer in shader code.
            * @param $buffer The buffer to bind as constant buffer.
            * @param $offset The offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
            * @param $size The number of bytes to bind.
            */
            public SetRayTracingConstantBufferParam ($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $nameID: number, $buffer: UnityEngine.ComputeBuffer, $offset: number, $size: number) : void
            /** Adds a command to set a constant buffer on a RayTracingShader.
            * @param $rayTracingShader The RayTracingShader to set parameter for.
            * @param $nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
            * @param $name The name of the constant buffer in shader code.
            * @param $buffer The buffer to bind as constant buffer.
            * @param $offset The offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
            * @param $size The number of bytes to bind.
            */
            public SetRayTracingConstantBufferParam ($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $name: string, $buffer: UnityEngine.ComputeBuffer, $offset: number, $size: number) : void
            /** Adds a command to set a constant buffer on a RayTracingShader.
            * @param $rayTracingShader The RayTracingShader to set parameter for.
            * @param $nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
            * @param $name The name of the constant buffer in shader code.
            * @param $buffer The buffer to bind as constant buffer.
            * @param $offset The offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
            * @param $size The number of bytes to bind.
            */
            public SetRayTracingConstantBufferParam ($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $nameID: number, $buffer: UnityEngine.GraphicsBuffer, $offset: number, $size: number) : void
            /** Adds a command to set a constant buffer on a RayTracingShader.
            * @param $rayTracingShader The RayTracingShader to set parameter for.
            * @param $nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
            * @param $name The name of the constant buffer in shader code.
            * @param $buffer The buffer to bind as constant buffer.
            * @param $offset The offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
            * @param $size The number of bytes to bind.
            */
            public SetRayTracingConstantBufferParam ($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $name: string, $buffer: UnityEngine.GraphicsBuffer, $offset: number, $size: number) : void
            /** Adds a command to set a texture parameter on a RayTracingShader.
            * @param $rayTracingShader RayTracingShader to set parameter for.
            * @param $name Name of the texture variable in shader code.
            * @param $nameID The ID of the property name for the texture in shader code. Use Shader.PropertyToID to get this ID.
            * @param $rt Texture value or identifier to set, see RenderTargetIdentifier.
            */
            public SetRayTracingTextureParam ($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $name: string, $rt: UnityEngine.Rendering.RenderTargetIdentifier) : void
            /** Adds a command to set a texture parameter on a RayTracingShader.
            * @param $rayTracingShader RayTracingShader to set parameter for.
            * @param $name Name of the texture variable in shader code.
            * @param $nameID The ID of the property name for the texture in shader code. Use Shader.PropertyToID to get this ID.
            * @param $rt Texture value or identifier to set, see RenderTargetIdentifier.
            */
            public SetRayTracingTextureParam ($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $nameID: number, $rt: UnityEngine.Rendering.RenderTargetIdentifier) : void
            /** Adds a command to set a float parameter on a RayTracingShader.
            * @param $rayTracingShader RayTracingShader to set parameter for.
            * @param $name Name of the variable in shader code.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $val Value to set.
            */
            public SetRayTracingFloatParam ($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $name: string, $val: number) : void
            /** Adds a command to set a float parameter on a RayTracingShader.
            * @param $rayTracingShader RayTracingShader to set parameter for.
            * @param $name Name of the variable in shader code.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $val Value to set.
            */
            public SetRayTracingFloatParam ($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $nameID: number, $val: number) : void
            /** Adds a command to set multiple consecutive float parameters on a RayTracingShader.
            * @param $rayTracingShader RayTracingShader to set parameter for.
            * @param $name Name of the variable in shader code.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $values Values to set.
            */
            public SetRayTracingFloatParams ($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $name: string, ...values: number[]) : void
            /** Adds a command to set multiple consecutive float parameters on a RayTracingShader.
            * @param $rayTracingShader RayTracingShader to set parameter for.
            * @param $name Name of the variable in shader code.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $values Values to set.
            */
            public SetRayTracingFloatParams ($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $nameID: number, ...values: number[]) : void
            /** Adds a command to set an integer parameter on a RayTracingShader.
            * @param $rayTracingShader RayTracingShader to set parameter for.
            * @param $name Name of the variable in shader code.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $val Value to set.
            */
            public SetRayTracingIntParam ($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $name: string, $val: number) : void
            /** Adds a command to set an integer parameter on a RayTracingShader.
            * @param $rayTracingShader RayTracingShader to set parameter for.
            * @param $name Name of the variable in shader code.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $val Value to set.
            */
            public SetRayTracingIntParam ($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $nameID: number, $val: number) : void
            /** Adds a command to set multiple consecutive integer parameters on a RayTracingShader.
            * @param $rayTracingShader RayTracingShader to set parameter for.
            * @param $name Name of the variable in shader code.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $values Values to set.
            */
            public SetRayTracingIntParams ($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $name: string, ...values: number[]) : void
            /** Adds a command to set multiple consecutive integer parameters on a RayTracingShader.
            * @param $rayTracingShader RayTracingShader to set parameter for.
            * @param $name Name of the variable in shader code.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $values Values to set.
            */
            public SetRayTracingIntParams ($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $nameID: number, ...values: number[]) : void
            /** Adds a command to set a vector parameter on a RayTracingShader.
            * @param $rayTracingShader RayTracingShader to set parameter for.
            * @param $name Name of the variable in shader code.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $val Value to set.
            */
            public SetRayTracingVectorParam ($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $name: string, $val: UnityEngine.Vector4) : void
            /** Adds a command to set a vector parameter on a RayTracingShader.
            * @param $rayTracingShader RayTracingShader to set parameter for.
            * @param $name Name of the variable in shader code.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $val Value to set.
            */
            public SetRayTracingVectorParam ($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $nameID: number, $val: UnityEngine.Vector4) : void
            /** Adds a command to set a vector array parameter on a RayTracingShader.
            * @param $rayTracingShader RayTracingShader to set parameter for.
            * @param $name Property name.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $values Value to set.
            */
            public SetRayTracingVectorArrayParam ($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $name: string, ...values: UnityEngine.Vector4[]) : void
            /** Adds a command to set a vector array parameter on a RayTracingShader.
            * @param $rayTracingShader RayTracingShader to set parameter for.
            * @param $name Property name.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $values Value to set.
            */
            public SetRayTracingVectorArrayParam ($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $nameID: number, ...values: UnityEngine.Vector4[]) : void
            /** Adds a command to set a matrix parameter on a RayTracingShader.
            * @param $rayTracingShader RayTracingShader to set parameter for.
            * @param $name Name of the variable in shader code.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $val Value to set.
            */
            public SetRayTracingMatrixParam ($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $name: string, $val: UnityEngine.Matrix4x4) : void
            /** Adds a command to set a matrix parameter on a RayTracingShader.
            * @param $rayTracingShader RayTracingShader to set parameter for.
            * @param $name Name of the variable in shader code.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $val Value to set.
            */
            public SetRayTracingMatrixParam ($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $nameID: number, $val: UnityEngine.Matrix4x4) : void
            /** Adds a command to set a matrix array parameter on a RayTracingShader.
            * @param $rayTracingShader RayTracingShader to set parameter for.
            * @param $name Name of the variable in shader code.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $values Value to set.
            */
            public SetRayTracingMatrixArrayParam ($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $name: string, ...values: UnityEngine.Matrix4x4[]) : void
            /** Adds a command to set a matrix array parameter on a RayTracingShader.
            * @param $rayTracingShader RayTracingShader to set parameter for.
            * @param $name Name of the variable in shader code.
            * @param $nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param $values Value to set.
            */
            public SetRayTracingMatrixArrayParam ($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $nameID: number, ...values: UnityEngine.Matrix4x4[]) : void
            /** Adds a command to execute a RayTracingShader.
            * @param $rayTracingShader RayTracingShader to execute.
            * @param $rayGenName The name of the ray generation shader.
            * @param $width The width of the ray generation shader thread grid.
            * @param $height The height of the ray generation shader thread grid.
            * @param $depth The depth of the ray generation shader thread grid.
            * @param $camera Optional parameter used to setup camera-related built-in shader variables.
            */
            public DispatchRays ($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $rayGenName: string, $width: number, $height: number, $depth: number, $camera?: UnityEngine.Camera) : void
            /** Generate mipmap levels of a render texture.
            * @param $rt The render texture requiring mipmaps generation.
            */
            public GenerateMips ($rt: UnityEngine.Rendering.RenderTargetIdentifier) : void
            /** Generate mipmap levels of a render texture.
            * @param $rt The render texture requiring mipmaps generation.
            */
            public GenerateMips ($rt: UnityEngine.RenderTexture) : void
            /** Force an antialiased render texture to be resolved.
            * @param $rt The antialiased render texture to resolve.
            * @param $target The render texture to resolve into.  If set, the target render texture must have the same dimensions and format as the source.
            */
            public ResolveAntiAliasedSurface ($rt: UnityEngine.RenderTexture, $target?: UnityEngine.RenderTexture) : void
            /** Add a "draw mesh" command.
            * @param $mesh Mesh to draw.
            * @param $matrix Transformation matrix to use.
            * @param $material Material to use.
            * @param $submeshIndex Which subset of the mesh to render.
            * @param $shaderPass Which pass of the shader to use (default is -1, which renders all passes).
            * @param $properties Additional Material properties to apply onto the Material just before this Mesh is drawn. See MaterialPropertyBlock.
            */
            public DrawMesh ($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $submeshIndex: number, $shaderPass: number, $properties: UnityEngine.MaterialPropertyBlock) : void
            /** Add a "draw mesh" command.
            * @param $mesh Mesh to draw.
            * @param $matrix Transformation matrix to use.
            * @param $material Material to use.
            * @param $submeshIndex Which subset of the mesh to render.
            * @param $shaderPass Which pass of the shader to use (default is -1, which renders all passes).
            * @param $properties Additional Material properties to apply onto the Material just before this Mesh is drawn. See MaterialPropertyBlock.
            */
            public DrawMesh ($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $submeshIndex: number, $shaderPass: number) : void
            /** Add a "draw mesh" command.
            * @param $mesh Mesh to draw.
            * @param $matrix Transformation matrix to use.
            * @param $material Material to use.
            * @param $submeshIndex Which subset of the mesh to render.
            * @param $shaderPass Which pass of the shader to use (default is -1, which renders all passes).
            * @param $properties Additional Material properties to apply onto the Material just before this Mesh is drawn. See MaterialPropertyBlock.
            */
            public DrawMesh ($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $submeshIndex: number) : void
            /** Add a "draw mesh" command.
            * @param $mesh Mesh to draw.
            * @param $matrix Transformation matrix to use.
            * @param $material Material to use.
            * @param $submeshIndex Which subset of the mesh to render.
            * @param $shaderPass Which pass of the shader to use (default is -1, which renders all passes).
            * @param $properties Additional Material properties to apply onto the Material just before this Mesh is drawn. See MaterialPropertyBlock.
            */
            public DrawMesh ($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material) : void
            public DrawMultipleMeshes ($matrices: System.Array$1<UnityEngine.Matrix4x4>, $meshes: System.Array$1<UnityEngine.Mesh>, $subsetIndices: System.Array$1<number>, $count: number, $material: UnityEngine.Material, $shaderPass: number, $properties: UnityEngine.MaterialPropertyBlock) : void
            /** Add a "draw renderer" command.
            * @param $renderer Renderer to draw.
            * @param $material Material to use.
            * @param $submeshIndex Which subset of the mesh to render.
            * @param $shaderPass Which pass of the shader to use (default is -1, which renders all passes).
            */
            public DrawRenderer ($renderer: UnityEngine.Renderer, $material: UnityEngine.Material, $submeshIndex: number, $shaderPass: number) : void
            /** Add a "draw renderer" command.
            * @param $renderer Renderer to draw.
            * @param $material Material to use.
            * @param $submeshIndex Which subset of the mesh to render.
            * @param $shaderPass Which pass of the shader to use (default is -1, which renders all passes).
            */
            public DrawRenderer ($renderer: UnityEngine.Renderer, $material: UnityEngine.Material, $submeshIndex: number) : void
            /** Add a "draw renderer" command.
            * @param $renderer Renderer to draw.
            * @param $material Material to use.
            * @param $submeshIndex Which subset of the mesh to render.
            * @param $shaderPass Which pass of the shader to use (default is -1, which renders all passes).
            */
            public DrawRenderer ($renderer: UnityEngine.Renderer, $material: UnityEngine.Material) : void
            /** Adds a "draw renderer list" command.
            * @param $rendererList The RendererList to draw.
            */
            public DrawRendererList ($rendererList: UnityEngine.Rendering.RendererList) : void
            /** Add a "draw procedural geometry" command.
            * @param $matrix Transformation matrix to use.
            * @param $material Material to use.
            * @param $shaderPass Which pass of the shader to use (or -1 for all passes).
            * @param $topology Topology of the procedural geometry.
            * @param $vertexCount Vertex count to render.
            * @param $instanceCount Instance count to render.
            * @param $properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
            */
            public DrawProcedural ($matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $vertexCount: number, $instanceCount: number, $properties: UnityEngine.MaterialPropertyBlock) : void
            /** Add a "draw procedural geometry" command.
            * @param $matrix Transformation matrix to use.
            * @param $material Material to use.
            * @param $shaderPass Which pass of the shader to use (or -1 for all passes).
            * @param $topology Topology of the procedural geometry.
            * @param $vertexCount Vertex count to render.
            * @param $instanceCount Instance count to render.
            * @param $properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
            */
            public DrawProcedural ($matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $vertexCount: number, $instanceCount: number) : void
            /** Add a "draw procedural geometry" command.
            * @param $matrix Transformation matrix to use.
            * @param $material Material to use.
            * @param $shaderPass Which pass of the shader to use (or -1 for all passes).
            * @param $topology Topology of the procedural geometry.
            * @param $vertexCount Vertex count to render.
            * @param $instanceCount Instance count to render.
            * @param $properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
            */
            public DrawProcedural ($matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $vertexCount: number) : void
            /** Add a "draw procedural geometry" command.
            * @param $matrix Transformation matrix to use.
            * @param $material Material to use.
            * @param $shaderPass Which pass of the shader to use (or -1 for all passes).
            * @param $topology Topology of the procedural geometry.
            * @param $indexCount Index count to render.
            * @param $instanceCount Instance count to render.
            * @param $indexBuffer The index buffer used to submit vertices to the GPU.
            * @param $properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
            */
            public DrawProcedural ($indexBuffer: UnityEngine.GraphicsBuffer, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $indexCount: number, $instanceCount: number, $properties: UnityEngine.MaterialPropertyBlock) : void
            /** Add a "draw procedural geometry" command.
            * @param $matrix Transformation matrix to use.
            * @param $material Material to use.
            * @param $shaderPass Which pass of the shader to use (or -1 for all passes).
            * @param $topology Topology of the procedural geometry.
            * @param $indexCount Index count to render.
            * @param $instanceCount Instance count to render.
            * @param $indexBuffer The index buffer used to submit vertices to the GPU.
            * @param $properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
            */
            public DrawProcedural ($indexBuffer: UnityEngine.GraphicsBuffer, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $indexCount: number, $instanceCount: number) : void
            /** Add a "draw procedural geometry" command.
            * @param $matrix Transformation matrix to use.
            * @param $material Material to use.
            * @param $shaderPass Which pass of the shader to use (or -1 for all passes).
            * @param $topology Topology of the procedural geometry.
            * @param $indexCount Index count to render.
            * @param $instanceCount Instance count to render.
            * @param $indexBuffer The index buffer used to submit vertices to the GPU.
            * @param $properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
            */
            public DrawProcedural ($indexBuffer: UnityEngine.GraphicsBuffer, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $indexCount: number) : void
            /** Add a "draw procedural geometry" command.
            * @param $matrix Transformation matrix to use.
            * @param $material Material to use.
            * @param $shaderPass Which pass of the shader to use (or -1 for all passes).
            * @param $topology Topology of the procedural geometry.
            * @param $properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
            * @param $bufferWithArgs Buffer with draw arguments.
            * @param $argsOffset Byte offset where in the buffer the draw arguments are.
            */
            public DrawProceduralIndirect ($matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset: number, $properties: UnityEngine.MaterialPropertyBlock) : void
            /** Add a "draw procedural geometry" command.
            * @param $matrix Transformation matrix to use.
            * @param $material Material to use.
            * @param $shaderPass Which pass of the shader to use (or -1 for all passes).
            * @param $topology Topology of the procedural geometry.
            * @param $properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
            * @param $bufferWithArgs Buffer with draw arguments.
            * @param $argsOffset Byte offset where in the buffer the draw arguments are.
            */
            public DrawProceduralIndirect ($matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset: number) : void
            /** Add a "draw procedural geometry" command.
            * @param $matrix Transformation matrix to use.
            * @param $material Material to use.
            * @param $shaderPass Which pass of the shader to use (or -1 for all passes).
            * @param $topology Topology of the procedural geometry.
            * @param $properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
            * @param $bufferWithArgs Buffer with draw arguments.
            * @param $argsOffset Byte offset where in the buffer the draw arguments are.
            */
            public DrawProceduralIndirect ($matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.ComputeBuffer) : void
            /** Add a "draw procedural geometry" command.
            * @param $indexBuffer Index buffer used to submit vertices to the GPU.
            * @param $matrix Transformation matrix to use.
            * @param $material Material to use.
            * @param $shaderPass Which pass of the shader to use (or -1 for all passes).
            * @param $topology Topology of the procedural geometry.
            * @param $bufferWithArgs Buffer with draw arguments.
            * @param $argsOffset Byte offset where in the buffer the draw arguments are.
            * @param $properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
            */
            public DrawProceduralIndirect ($indexBuffer: UnityEngine.GraphicsBuffer, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset: number, $properties: UnityEngine.MaterialPropertyBlock) : void
            /** Add a "draw procedural geometry" command.
            * @param $indexBuffer Index buffer used to submit vertices to the GPU.
            * @param $matrix Transformation matrix to use.
            * @param $material Material to use.
            * @param $shaderPass Which pass of the shader to use (or -1 for all passes).
            * @param $topology Topology of the procedural geometry.
            * @param $bufferWithArgs Buffer with draw arguments.
            * @param $argsOffset Byte offset where in the buffer the draw arguments are.
            * @param $properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
            */
            public DrawProceduralIndirect ($indexBuffer: UnityEngine.GraphicsBuffer, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset: number) : void
            /** Add a "draw procedural geometry" command.
            * @param $indexBuffer Index buffer used to submit vertices to the GPU.
            * @param $matrix Transformation matrix to use.
            * @param $material Material to use.
            * @param $shaderPass Which pass of the shader to use (or -1 for all passes).
            * @param $topology Topology of the procedural geometry.
            * @param $bufferWithArgs Buffer with draw arguments.
            * @param $argsOffset Byte offset where in the buffer the draw arguments are.
            * @param $properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
            */
            public DrawProceduralIndirect ($indexBuffer: UnityEngine.GraphicsBuffer, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.ComputeBuffer) : void
            /** Add a "draw procedural geometry" command.
            * @param $matrix Transformation matrix to use.
            * @param $material Material to use.
            * @param $shaderPass Which pass of the shader to use (or -1 for all passes).
            * @param $topology Topology of the procedural geometry.
            * @param $properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
            * @param $bufferWithArgs Buffer with draw arguments.
            * @param $argsOffset Byte offset where in the buffer the draw arguments are.
            */
            public DrawProceduralIndirect ($matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset: number, $properties: UnityEngine.MaterialPropertyBlock) : void
            /** Add a "draw procedural geometry" command.
            * @param $matrix Transformation matrix to use.
            * @param $material Material to use.
            * @param $shaderPass Which pass of the shader to use (or -1 for all passes).
            * @param $topology Topology of the procedural geometry.
            * @param $properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
            * @param $bufferWithArgs Buffer with draw arguments.
            * @param $argsOffset Byte offset where in the buffer the draw arguments are.
            */
            public DrawProceduralIndirect ($matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset: number) : void
            /** Add a "draw procedural geometry" command.
            * @param $matrix Transformation matrix to use.
            * @param $material Material to use.
            * @param $shaderPass Which pass of the shader to use (or -1 for all passes).
            * @param $topology Topology of the procedural geometry.
            * @param $properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
            * @param $bufferWithArgs Buffer with draw arguments.
            * @param $argsOffset Byte offset where in the buffer the draw arguments are.
            */
            public DrawProceduralIndirect ($matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.GraphicsBuffer) : void
            /** Add a "draw procedural geometry" command.
            * @param $indexBuffer Index buffer used to submit vertices to the GPU.
            * @param $matrix Transformation matrix to use.
            * @param $material Material to use.
            * @param $shaderPass Which pass of the shader to use (or -1 for all passes).
            * @param $topology Topology of the procedural geometry.
            * @param $bufferWithArgs Buffer with draw arguments.
            * @param $argsOffset Byte offset where in the buffer the draw arguments are.
            * @param $properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
            */
            public DrawProceduralIndirect ($indexBuffer: UnityEngine.GraphicsBuffer, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset: number, $properties: UnityEngine.MaterialPropertyBlock) : void
            /** Add a "draw procedural geometry" command.
            * @param $indexBuffer Index buffer used to submit vertices to the GPU.
            * @param $matrix Transformation matrix to use.
            * @param $material Material to use.
            * @param $shaderPass Which pass of the shader to use (or -1 for all passes).
            * @param $topology Topology of the procedural geometry.
            * @param $bufferWithArgs Buffer with draw arguments.
            * @param $argsOffset Byte offset where in the buffer the draw arguments are.
            * @param $properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
            */
            public DrawProceduralIndirect ($indexBuffer: UnityEngine.GraphicsBuffer, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset: number) : void
            /** Add a "draw procedural geometry" command.
            * @param $indexBuffer Index buffer used to submit vertices to the GPU.
            * @param $matrix Transformation matrix to use.
            * @param $material Material to use.
            * @param $shaderPass Which pass of the shader to use (or -1 for all passes).
            * @param $topology Topology of the procedural geometry.
            * @param $bufferWithArgs Buffer with draw arguments.
            * @param $argsOffset Byte offset where in the buffer the draw arguments are.
            * @param $properties Additional material properties to apply just before rendering. See MaterialPropertyBlock.
            */
            public DrawProceduralIndirect ($indexBuffer: UnityEngine.GraphicsBuffer, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.GraphicsBuffer) : void
            /** Adds a "draw mesh with instancing" command.
            The mesh will be just drawn once, it won't be per-pixel lit and will not cast or receive realtime shadows.
            The command will not immediately fail and throw an exception if Material.enableInstancing is false, but it will log an error and skips rendering each time the command is being executed if such a condition is detected.
            InvalidOperationException will be thrown if the current platform doesn't support this API (i.e. if GPU instancing is not available). See SystemInfo.supportsInstancing.
            * @param $mesh The Mesh to draw.
            * @param $submeshIndex Which subset of the mesh to draw. This only applies to meshes that are composed of several materials.
            * @param $material Material to use.
            * @param $shaderPass Which pass of the shader to use, or -1 which renders all passes.
            * @param $matrices The array of object transformation matrices.
            * @param $count The number of instances to be drawn.
            * @param $properties Additional Material properties to apply onto the Material just before this Mesh is drawn. See MaterialPropertyBlock.
            */
            public DrawMeshInstanced ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $shaderPass: number, $matrices: System.Array$1<UnityEngine.Matrix4x4>, $count: number, $properties: UnityEngine.MaterialPropertyBlock) : void
            /** Adds a "draw mesh with instancing" command.
            The mesh will be just drawn once, it won't be per-pixel lit and will not cast or receive realtime shadows.
            The command will not immediately fail and throw an exception if Material.enableInstancing is false, but it will log an error and skips rendering each time the command is being executed if such a condition is detected.
            InvalidOperationException will be thrown if the current platform doesn't support this API (i.e. if GPU instancing is not available). See SystemInfo.supportsInstancing.
            * @param $mesh The Mesh to draw.
            * @param $submeshIndex Which subset of the mesh to draw. This only applies to meshes that are composed of several materials.
            * @param $material Material to use.
            * @param $shaderPass Which pass of the shader to use, or -1 which renders all passes.
            * @param $matrices The array of object transformation matrices.
            * @param $count The number of instances to be drawn.
            * @param $properties Additional Material properties to apply onto the Material just before this Mesh is drawn. See MaterialPropertyBlock.
            */
            public DrawMeshInstanced ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $shaderPass: number, $matrices: System.Array$1<UnityEngine.Matrix4x4>, $count: number) : void
            /** Adds a "draw mesh with instancing" command.
            The mesh will be just drawn once, it won't be per-pixel lit and will not cast or receive realtime shadows.
            The command will not immediately fail and throw an exception if Material.enableInstancing is false, but it will log an error and skips rendering each time the command is being executed if such a condition is detected.
            InvalidOperationException will be thrown if the current platform doesn't support this API (i.e. if GPU instancing is not available). See SystemInfo.supportsInstancing.
            * @param $mesh The Mesh to draw.
            * @param $submeshIndex Which subset of the mesh to draw. This only applies to meshes that are composed of several materials.
            * @param $material Material to use.
            * @param $shaderPass Which pass of the shader to use, or -1 which renders all passes.
            * @param $matrices The array of object transformation matrices.
            * @param $count The number of instances to be drawn.
            * @param $properties Additional Material properties to apply onto the Material just before this Mesh is drawn. See MaterialPropertyBlock.
            */
            public DrawMeshInstanced ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $shaderPass: number, $matrices: System.Array$1<UnityEngine.Matrix4x4>) : void
            /** Add a "draw mesh with instancing" command.
            Draw a mesh using Procedural Instancing. This is similar to Graphics.DrawMeshInstancedIndirect, except that when the instance count is known from script, it can be supplied directly using this method, rather than via a ComputeBuffer.
            If Material.enableInstancing is false, the command logs an error and skips rendering each time the command is executed; the command does not immediately fail and throw an exception.
            InvalidOperationException will be thrown if the current platform doesn't support this API (for example, if GPU instancing is not available). See SystemInfo.supportsInstancing.
            * @param $mesh The Mesh to draw.
            * @param $submeshIndex Which subset of the mesh to draw. This only applies to meshes that are composed of several materials.
            * @param $material Material to use.
            * @param $shaderPass Which pass of the shader to use, or -1 which renders all passes.
            * @param $count The number of instances to be drawn.
            * @param $properties Additional Material properties to apply onto the Material just before this Mesh is drawn. See MaterialPropertyBlock.
            */
            public DrawMeshInstancedProcedural ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $shaderPass: number, $count: number, $properties?: UnityEngine.MaterialPropertyBlock) : void
            /** Add a "draw mesh with indirect instancing" command.
            * @param $mesh The Mesh to draw.
            * @param $submeshIndex Which subset of the mesh to draw. This only applies to meshes that are composed of several materials.
            * @param $material Material to use.
            * @param $shaderPass Which pass of the shader to use, or -1 which renders all passes.
            * @param $properties Additional Material properties to apply onto the Material just before this Mesh is drawn. See MaterialPropertyBlock.
            * @param $bufferWithArgs The GPU buffer containing the arguments for how many instances of this mesh to draw.
            * @param $argsOffset The byte offset into the buffer, where the draw arguments start.
            */
            public DrawMeshInstancedIndirect ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $shaderPass: number, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset: number, $properties: UnityEngine.MaterialPropertyBlock) : void
            /** Add a "draw mesh with indirect instancing" command.
            * @param $mesh The Mesh to draw.
            * @param $submeshIndex Which subset of the mesh to draw. This only applies to meshes that are composed of several materials.
            * @param $material Material to use.
            * @param $shaderPass Which pass of the shader to use, or -1 which renders all passes.
            * @param $properties Additional Material properties to apply onto the Material just before this Mesh is drawn. See MaterialPropertyBlock.
            * @param $bufferWithArgs The GPU buffer containing the arguments for how many instances of this mesh to draw.
            * @param $argsOffset The byte offset into the buffer, where the draw arguments start.
            */
            public DrawMeshInstancedIndirect ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $shaderPass: number, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset: number) : void
            /** Add a "draw mesh with indirect instancing" command.
            * @param $mesh The Mesh to draw.
            * @param $submeshIndex Which subset of the mesh to draw. This only applies to meshes that are composed of several materials.
            * @param $material Material to use.
            * @param $shaderPass Which pass of the shader to use, or -1 which renders all passes.
            * @param $properties Additional Material properties to apply onto the Material just before this Mesh is drawn. See MaterialPropertyBlock.
            * @param $bufferWithArgs The GPU buffer containing the arguments for how many instances of this mesh to draw.
            * @param $argsOffset The byte offset into the buffer, where the draw arguments start.
            */
            public DrawMeshInstancedIndirect ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $shaderPass: number, $bufferWithArgs: UnityEngine.ComputeBuffer) : void
            /** Add a "draw mesh with indirect instancing" command.
            * @param $mesh The Mesh to draw.
            * @param $submeshIndex Which subset of the mesh to draw. This only applies to meshes that are composed of several materials.
            * @param $material Material to use.
            * @param $shaderPass Which pass of the shader to use, or -1 which renders all passes.
            * @param $properties Additional Material properties to apply onto the Material just before this Mesh is drawn. See MaterialPropertyBlock.
            * @param $bufferWithArgs The GPU buffer containing the arguments for how many instances of this mesh to draw.
            * @param $argsOffset The byte offset into the buffer, where the draw arguments start.
            */
            public DrawMeshInstancedIndirect ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $shaderPass: number, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset: number, $properties: UnityEngine.MaterialPropertyBlock) : void
            /** Add a "draw mesh with indirect instancing" command.
            * @param $mesh The Mesh to draw.
            * @param $submeshIndex Which subset of the mesh to draw. This only applies to meshes that are composed of several materials.
            * @param $material Material to use.
            * @param $shaderPass Which pass of the shader to use, or -1 which renders all passes.
            * @param $properties Additional Material properties to apply onto the Material just before this Mesh is drawn. See MaterialPropertyBlock.
            * @param $bufferWithArgs The GPU buffer containing the arguments for how many instances of this mesh to draw.
            * @param $argsOffset The byte offset into the buffer, where the draw arguments start.
            */
            public DrawMeshInstancedIndirect ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $shaderPass: number, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset: number) : void
            /** Add a "draw mesh with indirect instancing" command.
            * @param $mesh The Mesh to draw.
            * @param $submeshIndex Which subset of the mesh to draw. This only applies to meshes that are composed of several materials.
            * @param $material Material to use.
            * @param $shaderPass Which pass of the shader to use, or -1 which renders all passes.
            * @param $properties Additional Material properties to apply onto the Material just before this Mesh is drawn. See MaterialPropertyBlock.
            * @param $bufferWithArgs The GPU buffer containing the arguments for how many instances of this mesh to draw.
            * @param $argsOffset The byte offset into the buffer, where the draw arguments start.
            */
            public DrawMeshInstancedIndirect ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $shaderPass: number, $bufferWithArgs: UnityEngine.GraphicsBuffer) : void
            /** Adds a command onto the commandbuffer to draw the VR Device's occlusion mesh to the current render target.
            * @param $normalizedCamViewport The viewport of the camera currently being rendered.
            */
            public DrawOcclusionMesh ($normalizedCamViewport: UnityEngine.RectInt) : void
            /** Set random write target for level pixel shaders.
            * @param $index Index of the random write target in the shader.
            * @param $buffer Buffer to set as the write target.
            * @param $preserveCounterValue Whether to leave the append/consume counter value unchanged.
            * @param $rt RenderTargetIdentifier to set as the write target.
            */
            public SetRandomWriteTarget ($index: number, $rt: UnityEngine.Rendering.RenderTargetIdentifier) : void
            /** Set random write target for level pixel shaders.
            * @param $index Index of the random write target in the shader.
            * @param $buffer Buffer to set as the write target.
            * @param $preserveCounterValue Whether to leave the append/consume counter value unchanged.
            * @param $rt RenderTargetIdentifier to set as the write target.
            */
            public SetRandomWriteTarget ($index: number, $buffer: UnityEngine.ComputeBuffer, $preserveCounterValue: boolean) : void
            /** Set random write target for level pixel shaders.
            * @param $index Index of the random write target in the shader.
            * @param $buffer Buffer to set as the write target.
            * @param $preserveCounterValue Whether to leave the append/consume counter value unchanged.
            * @param $rt RenderTargetIdentifier to set as the write target.
            */
            public SetRandomWriteTarget ($index: number, $buffer: UnityEngine.ComputeBuffer) : void
            /** Set random write target for level pixel shaders.
            * @param $index Index of the random write target in the shader.
            * @param $buffer Buffer to set as the write target.
            * @param $preserveCounterValue Whether to leave the append/consume counter value unchanged.
            * @param $rt RenderTargetIdentifier to set as the write target.
            */
            public SetRandomWriteTarget ($index: number, $buffer: UnityEngine.GraphicsBuffer, $preserveCounterValue: boolean) : void
            /** Set random write target for level pixel shaders.
            * @param $index Index of the random write target in the shader.
            * @param $buffer Buffer to set as the write target.
            * @param $preserveCounterValue Whether to leave the append/consume counter value unchanged.
            * @param $rt RenderTargetIdentifier to set as the write target.
            */
            public SetRandomWriteTarget ($index: number, $buffer: UnityEngine.GraphicsBuffer) : void
            /** Adds a command to copy ComputeBuffer or GraphicsBuffer counter value.
            * @param $src Append/consume buffer to copy the counter from.
            * @param $dst A buffer to copy the counter to.
            * @param $dstOffsetBytes Target byte offset in dst buffer.
            */
            public CopyCounterValue ($src: UnityEngine.ComputeBuffer, $dst: UnityEngine.ComputeBuffer, $dstOffsetBytes: number) : void
            /** Adds a command to copy ComputeBuffer or GraphicsBuffer counter value.
            * @param $src Append/consume buffer to copy the counter from.
            * @param $dst A buffer to copy the counter to.
            * @param $dstOffsetBytes Target byte offset in dst buffer.
            */
            public CopyCounterValue ($src: UnityEngine.GraphicsBuffer, $dst: UnityEngine.ComputeBuffer, $dstOffsetBytes: number) : void
            /** Adds a command to copy ComputeBuffer or GraphicsBuffer counter value.
            * @param $src Append/consume buffer to copy the counter from.
            * @param $dst A buffer to copy the counter to.
            * @param $dstOffsetBytes Target byte offset in dst buffer.
            */
            public CopyCounterValue ($src: UnityEngine.ComputeBuffer, $dst: UnityEngine.GraphicsBuffer, $dstOffsetBytes: number) : void
            /** Adds a command to copy ComputeBuffer or GraphicsBuffer counter value.
            * @param $src Append/consume buffer to copy the counter from.
            * @param $dst A buffer to copy the counter to.
            * @param $dstOffsetBytes Target byte offset in dst buffer.
            */
            public CopyCounterValue ($src: UnityEngine.GraphicsBuffer, $dst: UnityEngine.GraphicsBuffer, $dstOffsetBytes: number) : void
            /** Adds a command to copy pixel data from one texture to another.
            * @param $src The source texture or RenderTargetIdentifier.
            * @param $dst The destination texture or RenderTargetIdentifier.
            * @param $srcElement The element in the source texture to copy from. For example, the CubemapFace in a Cubemap or the slice in a texture array. Set the value to 0 if src is a 2D texture.
            * @param $srcMip The mipmap level to copy from. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @param $dstElement The element in the source texture to copy to. For example, the CubemapFace in a Cubemap or the slice in a texture array. Set the value to 0 if `dst` is a 2D texture.
            * @param $dstMip The mipmap level to write to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @param $srcX The starting x coordinate of src to copy from. 0 is the left of the texture.
            * @param $srcY The starting y coordinate of src to copy from. 0 is the bottom of the texture.
            * @param $srcWidth The width of src to copy.
            * @param $srcHeight The height of src to copy.
            * @param $dstX The x coordinate of dst to copy to.
            * @param $dstY The y coordinate to dst to copy to.
            */
            public CopyTexture ($src: UnityEngine.Rendering.RenderTargetIdentifier, $dst: UnityEngine.Rendering.RenderTargetIdentifier) : void
            /** Adds a command to copy pixel data from one texture to another.
            * @param $src The source texture or RenderTargetIdentifier.
            * @param $dst The destination texture or RenderTargetIdentifier.
            * @param $srcElement The element in the source texture to copy from. For example, the CubemapFace in a Cubemap or the slice in a texture array. Set the value to 0 if src is a 2D texture.
            * @param $srcMip The mipmap level to copy from. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @param $dstElement The element in the source texture to copy to. For example, the CubemapFace in a Cubemap or the slice in a texture array. Set the value to 0 if `dst` is a 2D texture.
            * @param $dstMip The mipmap level to write to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @param $srcX The starting x coordinate of src to copy from. 0 is the left of the texture.
            * @param $srcY The starting y coordinate of src to copy from. 0 is the bottom of the texture.
            * @param $srcWidth The width of src to copy.
            * @param $srcHeight The height of src to copy.
            * @param $dstX The x coordinate of dst to copy to.
            * @param $dstY The y coordinate to dst to copy to.
            */
            public CopyTexture ($src: UnityEngine.Rendering.RenderTargetIdentifier, $srcElement: number, $dst: UnityEngine.Rendering.RenderTargetIdentifier, $dstElement: number) : void
            /** Adds a command to copy pixel data from one texture to another.
            * @param $src The source texture or RenderTargetIdentifier.
            * @param $dst The destination texture or RenderTargetIdentifier.
            * @param $srcElement The element in the source texture to copy from. For example, the CubemapFace in a Cubemap or the slice in a texture array. Set the value to 0 if src is a 2D texture.
            * @param $srcMip The mipmap level to copy from. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @param $dstElement The element in the source texture to copy to. For example, the CubemapFace in a Cubemap or the slice in a texture array. Set the value to 0 if `dst` is a 2D texture.
            * @param $dstMip The mipmap level to write to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @param $srcX The starting x coordinate of src to copy from. 0 is the left of the texture.
            * @param $srcY The starting y coordinate of src to copy from. 0 is the bottom of the texture.
            * @param $srcWidth The width of src to copy.
            * @param $srcHeight The height of src to copy.
            * @param $dstX The x coordinate of dst to copy to.
            * @param $dstY The y coordinate to dst to copy to.
            */
            public CopyTexture ($src: UnityEngine.Rendering.RenderTargetIdentifier, $srcElement: number, $srcMip: number, $dst: UnityEngine.Rendering.RenderTargetIdentifier, $dstElement: number, $dstMip: number) : void
            /** Adds a command to copy pixel data from one texture to another.
            * @param $src The source texture or RenderTargetIdentifier.
            * @param $dst The destination texture or RenderTargetIdentifier.
            * @param $srcElement The element in the source texture to copy from. For example, the CubemapFace in a Cubemap or the slice in a texture array. Set the value to 0 if src is a 2D texture.
            * @param $srcMip The mipmap level to copy from. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @param $dstElement The element in the source texture to copy to. For example, the CubemapFace in a Cubemap or the slice in a texture array. Set the value to 0 if `dst` is a 2D texture.
            * @param $dstMip The mipmap level to write to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @param $srcX The starting x coordinate of src to copy from. 0 is the left of the texture.
            * @param $srcY The starting y coordinate of src to copy from. 0 is the bottom of the texture.
            * @param $srcWidth The width of src to copy.
            * @param $srcHeight The height of src to copy.
            * @param $dstX The x coordinate of dst to copy to.
            * @param $dstY The y coordinate to dst to copy to.
            */
            public CopyTexture ($src: UnityEngine.Rendering.RenderTargetIdentifier, $srcElement: number, $srcMip: number, $srcX: number, $srcY: number, $srcWidth: number, $srcHeight: number, $dst: UnityEngine.Rendering.RenderTargetIdentifier, $dstElement: number, $dstMip: number, $dstX: number, $dstY: number) : void
            /** Adds a command to use a shader to copy the pixel data from a texture into a render texture.
            * @param $source The source texture or RenderTargetIdentifier.
            * @param $dest The destination RenderTargetIdentifier.
            * @param $mat The material to use. If you don't provide mat, Unity uses a default material.
            * @param $pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
            * @param $scale The scale to apply.
            * @param $offset The offset to apply.
            * @param $sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
            * @param $destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
            */
            public Blit ($source: UnityEngine.Texture, $dest: UnityEngine.Rendering.RenderTargetIdentifier) : void
            /** Adds a command to use a shader to copy the pixel data from a texture into a render texture.
            * @param $source The source texture or RenderTargetIdentifier.
            * @param $dest The destination RenderTargetIdentifier.
            * @param $mat The material to use. If you don't provide mat, Unity uses a default material.
            * @param $pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
            * @param $scale The scale to apply.
            * @param $offset The offset to apply.
            * @param $sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
            * @param $destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
            */
            public Blit ($source: UnityEngine.Texture, $dest: UnityEngine.Rendering.RenderTargetIdentifier, $scale: UnityEngine.Vector2, $offset: UnityEngine.Vector2) : void
            /** Adds a command to use a shader to copy the pixel data from a texture into a render texture.
            * @param $source The source texture or RenderTargetIdentifier.
            * @param $dest The destination RenderTargetIdentifier.
            * @param $mat The material to use. If you don't provide mat, Unity uses a default material.
            * @param $pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
            * @param $scale The scale to apply.
            * @param $offset The offset to apply.
            * @param $sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
            * @param $destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
            */
            public Blit ($source: UnityEngine.Texture, $dest: UnityEngine.Rendering.RenderTargetIdentifier, $mat: UnityEngine.Material) : void
            /** Adds a command to use a shader to copy the pixel data from a texture into a render texture.
            * @param $source The source texture or RenderTargetIdentifier.
            * @param $dest The destination RenderTargetIdentifier.
            * @param $mat The material to use. If you don't provide mat, Unity uses a default material.
            * @param $pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
            * @param $scale The scale to apply.
            * @param $offset The offset to apply.
            * @param $sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
            * @param $destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
            */
            public Blit ($source: UnityEngine.Texture, $dest: UnityEngine.Rendering.RenderTargetIdentifier, $mat: UnityEngine.Material, $pass: number) : void
            /** Adds a command to use a shader to copy the pixel data from a texture into a render texture.
            * @param $source The source texture or RenderTargetIdentifier.
            * @param $dest The destination RenderTargetIdentifier.
            * @param $mat The material to use. If you don't provide mat, Unity uses a default material.
            * @param $pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
            * @param $scale The scale to apply.
            * @param $offset The offset to apply.
            * @param $sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
            * @param $destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
            */
            public Blit ($source: UnityEngine.Rendering.RenderTargetIdentifier, $dest: UnityEngine.Rendering.RenderTargetIdentifier) : void
            /** Adds a command to use a shader to copy the pixel data from a texture into a render texture.
            * @param $source The source texture or RenderTargetIdentifier.
            * @param $dest The destination RenderTargetIdentifier.
            * @param $mat The material to use. If you don't provide mat, Unity uses a default material.
            * @param $pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
            * @param $scale The scale to apply.
            * @param $offset The offset to apply.
            * @param $sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
            * @param $destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
            */
            public Blit ($source: UnityEngine.Rendering.RenderTargetIdentifier, $dest: UnityEngine.Rendering.RenderTargetIdentifier, $scale: UnityEngine.Vector2, $offset: UnityEngine.Vector2) : void
            /** Adds a command to use a shader to copy the pixel data from a texture into a render texture.
            * @param $source The source texture or RenderTargetIdentifier.
            * @param $dest The destination RenderTargetIdentifier.
            * @param $mat The material to use. If you don't provide mat, Unity uses a default material.
            * @param $pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
            * @param $scale The scale to apply.
            * @param $offset The offset to apply.
            * @param $sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
            * @param $destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
            */
            public Blit ($source: UnityEngine.Rendering.RenderTargetIdentifier, $dest: UnityEngine.Rendering.RenderTargetIdentifier, $mat: UnityEngine.Material) : void
            /** Adds a command to use a shader to copy the pixel data from a texture into a render texture.
            * @param $source The source texture or RenderTargetIdentifier.
            * @param $dest The destination RenderTargetIdentifier.
            * @param $mat The material to use. If you don't provide mat, Unity uses a default material.
            * @param $pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
            * @param $scale The scale to apply.
            * @param $offset The offset to apply.
            * @param $sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
            * @param $destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
            */
            public Blit ($source: UnityEngine.Rendering.RenderTargetIdentifier, $dest: UnityEngine.Rendering.RenderTargetIdentifier, $mat: UnityEngine.Material, $pass: number) : void
            /** Adds a command to use a shader to copy the pixel data from a texture into a render texture.
            * @param $source The source texture or RenderTargetIdentifier.
            * @param $dest The destination RenderTargetIdentifier.
            * @param $mat The material to use. If you don't provide mat, Unity uses a default material.
            * @param $pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
            * @param $scale The scale to apply.
            * @param $offset The offset to apply.
            * @param $sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
            * @param $destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
            */
            public Blit ($source: UnityEngine.Rendering.RenderTargetIdentifier, $dest: UnityEngine.Rendering.RenderTargetIdentifier, $sourceDepthSlice: number, $destDepthSlice: number) : void
            /** Adds a command to use a shader to copy the pixel data from a texture into a render texture.
            * @param $source The source texture or RenderTargetIdentifier.
            * @param $dest The destination RenderTargetIdentifier.
            * @param $mat The material to use. If you don't provide mat, Unity uses a default material.
            * @param $pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
            * @param $scale The scale to apply.
            * @param $offset The offset to apply.
            * @param $sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
            * @param $destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
            */
            public Blit ($source: UnityEngine.Rendering.RenderTargetIdentifier, $dest: UnityEngine.Rendering.RenderTargetIdentifier, $scale: UnityEngine.Vector2, $offset: UnityEngine.Vector2, $sourceDepthSlice: number, $destDepthSlice: number) : void
            /** Adds a command to use a shader to copy the pixel data from a texture into a render texture.
            * @param $source The source texture or RenderTargetIdentifier.
            * @param $dest The destination RenderTargetIdentifier.
            * @param $mat The material to use. If you don't provide mat, Unity uses a default material.
            * @param $pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
            * @param $scale The scale to apply.
            * @param $offset The offset to apply.
            * @param $sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
            * @param $destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
            */
            public Blit ($source: UnityEngine.Rendering.RenderTargetIdentifier, $dest: UnityEngine.Rendering.RenderTargetIdentifier, $mat: UnityEngine.Material, $pass: number, $destDepthSlice: number) : void
            /** Add a "set global shader float property" command.
            */
            public SetGlobalFloat ($name: string, $value: number) : void
            /** Adds a command to set the value of a given property for all Shaders, where the property has a type of Int in ShaderLab code.
            */
            public SetGlobalInt ($name: string, $value: number) : void
            /** Adds a command to set the value of a given property for all Shaders, where the property is an integer.
            */
            public SetGlobalInteger ($name: string, $value: number) : void
            /** Add a "set global shader vector property" command.
            */
            public SetGlobalVector ($name: string, $value: UnityEngine.Vector4) : void
            /** Add a "set global shader color property" command.
            */
            public SetGlobalColor ($name: string, $value: UnityEngine.Color) : void
            /** Add a "set global shader matrix property" command.
            */
            public SetGlobalMatrix ($name: string, $value: UnityEngine.Matrix4x4) : void
            public SetGlobalFloatArray ($propertyName: string, $values: System.Collections.Generic.List$1<number>) : void
            public SetGlobalFloatArray ($nameID: number, $values: System.Collections.Generic.List$1<number>) : void
            /** Add a "set global shader float array property" command.
            */
            public SetGlobalFloatArray ($propertyName: string, $values: System.Array$1<number>) : void
            public SetGlobalVectorArray ($propertyName: string, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>) : void
            public SetGlobalVectorArray ($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>) : void
            /** Add a "set global shader vector array property" command.
            */
            public SetGlobalVectorArray ($propertyName: string, $values: System.Array$1<UnityEngine.Vector4>) : void
            public SetGlobalMatrixArray ($propertyName: string, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>) : void
            public SetGlobalMatrixArray ($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>) : void
            /** Add a "set global shader matrix array property" command.
            */
            public SetGlobalMatrixArray ($propertyName: string, $values: System.Array$1<UnityEngine.Matrix4x4>) : void
            /** Add a "set global shader texture property" command, referencing a RenderTexture.
            */
            public SetGlobalTexture ($name: string, $value: UnityEngine.Rendering.RenderTargetIdentifier) : void
            /** Add a "set global shader texture property" command, referencing a RenderTexture.
            */
            public SetGlobalTexture ($nameID: number, $value: UnityEngine.Rendering.RenderTargetIdentifier) : void
            /** Add a "set global shader texture property" command, referencing a RenderTexture.
            */
            public SetGlobalTexture ($name: string, $value: UnityEngine.Rendering.RenderTargetIdentifier, $element: UnityEngine.Rendering.RenderTextureSubElement) : void
            /** Add a "set global shader texture property" command, referencing a RenderTexture.
            */
            public SetGlobalTexture ($nameID: number, $value: UnityEngine.Rendering.RenderTargetIdentifier, $element: UnityEngine.Rendering.RenderTextureSubElement) : void
            /** Add a "set global shader buffer property" command.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            * @param $value The buffer to set.
            */
            public SetGlobalBuffer ($name: string, $value: UnityEngine.ComputeBuffer) : void
            /** Add a "set global shader buffer property" command.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            * @param $value The buffer to set.
            */
            public SetGlobalBuffer ($nameID: number, $value: UnityEngine.ComputeBuffer) : void
            /** Add a "set global shader buffer property" command.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            * @param $value The buffer to set.
            */
            public SetGlobalBuffer ($name: string, $value: UnityEngine.GraphicsBuffer) : void
            /** Add a "set global shader buffer property" command.
            * @param $nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param $name The name of the property.
            * @param $value The buffer to set.
            */
            public SetGlobalBuffer ($nameID: number, $value: UnityEngine.GraphicsBuffer) : void
            /** Add a command to bind a global constant buffer.
            * @param $nameID The name ID of the constant buffer retrieved by Shader.PropertyToID.
            * @param $name The name of the constant buffer to override.
            * @param $buffer The buffer to bind.
            * @param $offset Offset from the start of the buffer in bytes.
            * @param $size Size in bytes of the area to bind.
            */
            public SetGlobalConstantBuffer ($buffer: UnityEngine.ComputeBuffer, $nameID: number, $offset: number, $size: number) : void
            /** Add a command to bind a global constant buffer.
            * @param $nameID The name ID of the constant buffer retrieved by Shader.PropertyToID.
            * @param $name The name of the constant buffer to override.
            * @param $buffer The buffer to bind.
            * @param $offset Offset from the start of the buffer in bytes.
            * @param $size Size in bytes of the area to bind.
            */
            public SetGlobalConstantBuffer ($buffer: UnityEngine.ComputeBuffer, $name: string, $offset: number, $size: number) : void
            /** Add a command to bind a global constant buffer.
            * @param $nameID The name ID of the constant buffer retrieved by Shader.PropertyToID.
            * @param $name The name of the constant buffer to override.
            * @param $buffer The buffer to bind.
            * @param $offset Offset from the start of the buffer in bytes.
            * @param $size Size in bytes of the area to bind.
            */
            public SetGlobalConstantBuffer ($buffer: UnityEngine.GraphicsBuffer, $nameID: number, $offset: number, $size: number) : void
            /** Add a command to bind a global constant buffer.
            * @param $nameID The name ID of the constant buffer retrieved by Shader.PropertyToID.
            * @param $name The name of the constant buffer to override.
            * @param $buffer The buffer to bind.
            * @param $offset Offset from the start of the buffer in bytes.
            * @param $size Size in bytes of the area to bind.
            */
            public SetGlobalConstantBuffer ($buffer: UnityEngine.GraphicsBuffer, $name: string, $offset: number, $size: number) : void
            /** Adds a command to bind the RayTracingAccelerationStructure object to all shader stages.
            * @param $name The name of the acceleration structure in shader code.
            * @param $nameID The name ID of the acceleration structure in shader code. Use Shader.PropertyToID to get this value.
            * @param $accelerationStructure The acceleration structure to set.
            */
            public SetGlobalRayTracingAccelerationStructure ($name: string, $accelerationStructure: UnityEngine.Rendering.RayTracingAccelerationStructure) : void
            /** Adds a command to bind the RayTracingAccelerationStructure object to all shader stages.
            * @param $name The name of the acceleration structure in shader code.
            * @param $nameID The name ID of the acceleration structure in shader code. Use Shader.PropertyToID to get this value.
            * @param $accelerationStructure The acceleration structure to set.
            */
            public SetGlobalRayTracingAccelerationStructure ($nameID: number, $accelerationStructure: UnityEngine.Rendering.RayTracingAccelerationStructure) : void
            /** Add a "set shadow sampling mode" command.
            * @param $shadowmap Shadowmap render target to change the sampling mode on.
            * @param $mode New sampling mode.
            */
            public SetShadowSamplingMode ($shadowmap: UnityEngine.Rendering.RenderTargetIdentifier, $mode: UnityEngine.Rendering.ShadowSamplingMode) : void
            public SetSinglePassStereo ($mode: UnityEngine.Rendering.SinglePassStereoMode) : void
            /** Send a user-defined event to a native code plugin.
            * @param $callback Native code callback to queue for Unity's renderer to invoke.
            * @param $eventID User defined id to send to the callback.
            */
            public IssuePluginEvent ($callback: System.IntPtr, $eventID: number) : void
            /** Send a user-defined event to a native code plugin with custom data.
            * @param $callback Native code callback to queue for Unity's renderer to invoke.
            * @param $data Custom data to pass to the native plugin callback.
            * @param $eventID Built in or user defined id to send to the callback.
            */
            public IssuePluginEventAndData ($callback: System.IntPtr, $eventID: number, $data: System.IntPtr) : void
            /** Send a user-defined event to a native code plugin with custom data and callback flags.
            * @param $callback Native code callback to queue for Unity's renderer to invoke.
            * @param $eventID Built in or user defined id to send to the callback.
            * @param $flags See CustomMarkerCallbackFlags for more details.
            * @param $data Custom data to pass to the native plugin callback.
            */
            public IssuePluginEventAndDataWithFlags ($callback: System.IntPtr, $eventID: number, $flags: UnityEngine.Rendering.CustomMarkerCallbackFlags, $data: System.IntPtr) : void
            /** Send a user-defined blit event to a native code plugin.
            * @param $callback Native code callback to queue for Unity's renderer to invoke.
            * @param $command User defined command id to send to the callback.
            * @param $source Source render target.
            * @param $dest Destination render target.
            * @param $commandParam User data command parameters.
            * @param $commandFlags User data command flags.
            */
            public IssuePluginCustomBlit ($callback: System.IntPtr, $command: number, $source: UnityEngine.Rendering.RenderTargetIdentifier, $dest: UnityEngine.Rendering.RenderTargetIdentifier, $commandParam: number, $commandFlags: number) : void
            /** Send a texture update event to a native code plugin.
            * @param $callback Native code callback to queue for Unity's renderer to invoke.
            * @param $targetTexture Texture resource to be updated.
            * @param $userData User data to send to the native plugin.
            */
            public IssuePluginCustomTextureUpdateV2 ($callback: System.IntPtr, $targetTexture: UnityEngine.Texture, $userData: number) : void
            public ProcessVTFeedback ($rt: UnityEngine.Rendering.RenderTargetIdentifier, $resolver: System.IntPtr, $slice: number, $x: number, $width: number, $y: number, $height: number, $mip: number) : void
            /** Adds a command to copy the contents of one GraphicsBuffer into another.
            * @param $source The source buffer.
            * @param $dest The destination buffer.
            */
            public CopyBuffer ($source: UnityEngine.GraphicsBuffer, $dest: UnityEngine.GraphicsBuffer) : void
            public constructor ()
        }
        /** Describes the desired characteristics with respect to prioritisation and load balancing of the queue that a command buffer being submitted via Graphics.ExecuteCommandBufferAsync or [[ScriptableRenderContext.ExecuteCommandBufferAsync] should be sent to.
        */
        enum ComputeQueueType
        { Default = 0, Background = 1, Urgent = 2 }
        /** Parameters that configure a culling operation in the Scriptable Render Pipeline.
        */
        class ScriptableCullingParameters extends System.ValueType implements System.IEquatable$1<UnityEngine.Rendering.ScriptableCullingParameters>
        {
            protected [__keep_incompatibility]: never;
            /** Maximum amount of culling planes that can be specified.
            */
            public static maximumCullingPlaneCount : number
            /** The amount of layers available.
            */
            public static layerCount : number
            /** This parameter controls how many visible lights are allowed.
            */
            public get maximumVisibleLights(): number;
            public set maximumVisibleLights(value: number);
            /** This property enables a conservative method for calculating the size and position of the minimal enclosing sphere around the frustum cascade corner points for shadow culling.
            */
            public get conservativeEnclosingSphere(): boolean;
            public set conservativeEnclosingSphere(value: boolean);
            public get numIterationsEnclosingSphere(): number;
            public set numIterationsEnclosingSphere(value: number);
            /** Number of culling planes to use.
            */
            public get cullingPlaneCount(): number;
            public set cullingPlaneCount(value: number);
            /** Is the cull orthographic.
            */
            public get isOrthographic(): boolean;
            public set isOrthographic(value: boolean);
            /** LODParameters for culling.
            */
            public get lodParameters(): UnityEngine.Rendering.LODParameters;
            public set lodParameters(value: UnityEngine.Rendering.LODParameters);
            /** The mask for the culling operation.
            */
            public get cullingMask(): number;
            public set cullingMask(value: number);
            /** The matrix for the culling operation.
            */
            public get cullingMatrix(): UnityEngine.Matrix4x4;
            public set cullingMatrix(value: UnityEngine.Matrix4x4);
            /** Position for the origin of the cull.
            */
            public get origin(): UnityEngine.Vector3;
            public set origin(value: UnityEngine.Vector3);
            /** Shadow distance to use for the cull.
            */
            public get shadowDistance(): number;
            public set shadowDistance(value: number);
            /** Offset to apply to the near camera plane when performing shadow map rendering.
            */
            public get shadowNearPlaneOffset(): number;
            public set shadowNearPlaneOffset(value: number);
            /** Flags to configure a culling operation in the Scriptable Render Pipeline.
            */
            public get cullingOptions(): UnityEngine.Rendering.CullingOptions;
            public set cullingOptions(value: UnityEngine.Rendering.CullingOptions);
            /** Reflection Probe Sort options for the cull.
            */
            public get reflectionProbeSortingCriteria(): UnityEngine.Rendering.ReflectionProbeSortingCriteria;
            public set reflectionProbeSortingCriteria(value: UnityEngine.Rendering.ReflectionProbeSortingCriteria);
            /** Camera Properties used for culling.
            */
            public get cameraProperties(): UnityEngine.Rendering.CameraProperties;
            public set cameraProperties(value: UnityEngine.Rendering.CameraProperties);
            /** The view matrix generated for single-pass stereo culling.
            */
            public get stereoViewMatrix(): UnityEngine.Matrix4x4;
            public set stereoViewMatrix(value: UnityEngine.Matrix4x4);
            /** The projection matrix generated for single-pass stereo culling.
            */
            public get stereoProjectionMatrix(): UnityEngine.Matrix4x4;
            public set stereoProjectionMatrix(value: UnityEngine.Matrix4x4);
            /** Distance between the virtual eyes.
            */
            public get stereoSeparationDistance(): number;
            public set stereoSeparationDistance(value: number);
            /** This parameter determines query distance for occlusion culling.
            */
            public get accurateOcclusionThreshold(): number;
            public set accurateOcclusionThreshold(value: number);
            /** This parameter controls how many active jobs contribute to occlusion culling.
            */
            public get maximumPortalCullingJobs(): number;
            public set maximumPortalCullingJobs(value: number);
            /** The lower limit to the value ScriptableCullingParameters.maximumPortalCullingJobs.
            */
            public static get cullingJobsLowerLimit(): number;
            /** The upper limit to the value ScriptableCullingParameters.maximumPortalCullingJobs.
            */
            public static get cullingJobsUpperLimit(): number;
            /** Get the distance for the culling of a specific layer.
            */
            public GetLayerCullingDistance ($layerIndex: number) : number
            /** Set the distance for the culling of a specific layer.
            */
            public SetLayerCullingDistance ($layerIndex: number, $distance: number) : void
            /** Fetch the culling plane at the given index.
            */
            public GetCullingPlane ($index: number) : UnityEngine.Plane
            /** Set the culling plane at a given index.
            */
            public SetCullingPlane ($index: number, $plane: UnityEngine.Plane) : void
            public Equals ($other: UnityEngine.Rendering.ScriptableCullingParameters) : boolean
            public Equals ($obj: any) : boolean
            public static op_Equality ($left: UnityEngine.Rendering.ScriptableCullingParameters, $right: UnityEngine.Rendering.ScriptableCullingParameters) : boolean
            public static op_Inequality ($left: UnityEngine.Rendering.ScriptableCullingParameters, $right: UnityEngine.Rendering.ScriptableCullingParameters) : boolean
        }
        enum ReflectionProbeType
        { Cube = 0, Card = 1 }
        /** Values for ReflectionProbe.clearFlags, determining what to clear when rendering a ReflectionProbe.
        */
        enum ReflectionProbeClearFlags
        { Skybox = 1, SolidColor = 2 }
        /** Reflection probe's update mode.
        */
        enum ReflectionProbeMode
        { Baked = 0, Realtime = 1, Custom = 2 }
        /** An enum describing the way a real-time reflection probe refreshes in the Player.
        */
        enum ReflectionProbeRefreshMode
        { OnAwake = 0, EveryFrame = 1, ViaScripting = 2 }
        /** When a probe's ReflectionProbe.refreshMode is set to ReflectionProbeRefreshMode.EveryFrame, this enum specify whether or not Unity should update the probe's cubemap over several frames or update the whole cubemap in one frame.
        Updating a probe's cubemap is a costly operation. Unity needs to render the entire Scene for each face of the cubemap, as well as perform special blurring in order to get glossy reflections. The impact on frame rate can be significant. Time-slicing helps maintaning a more constant frame rate during these updates by performing the rendering over several frames.
        */
        enum ReflectionProbeTimeSlicingMode
        { AllFacesAtOnce = 0, IndividualFaces = 1, NoTimeSlicing = 2 }
        /** Spherical harmonics up to the second order (3 bands, 9 coefficients).
        */
        class SphericalHarmonicsL2 extends System.ValueType implements System.IEquatable$1<UnityEngine.Rendering.SphericalHarmonicsL2>
        {
            protected [__keep_incompatibility]: never;
            /** Clears the spherical harmonics coefficients to zero.
            */
            public Clear () : void
            /** Add an ambient light to the spherical harmonics.
            */
            public AddAmbientLight ($color: UnityEngine.Color) : void
            /** Add a directional light to the spherical harmonics.
            * @param $direction The direction from the light probe to the light. The vector should be normalized for correct results.
            * @param $color The color of the light.
            * @param $intensity The intensity of the light.
            */
            public AddDirectionalLight ($direction: UnityEngine.Vector3, $color: UnityEngine.Color, $intensity: number) : void
            /** Evaluates the spherical harmonics for each given direction. The directions and results arrays must have the same size.
            * @param $directions Array of normalized directions in which to evaluate the spherical harmonics.
            * @param $results Output array for the evaluated values. The order of the results is the same as the directions array.
            */
            public Evaluate ($directions: System.Array$1<UnityEngine.Vector3>, $results: System.Array$1<UnityEngine.Color>) : void
            public Equals ($other: any) : boolean
            public Equals ($other: UnityEngine.Rendering.SphericalHarmonicsL2) : boolean
            public static op_Multiply ($lhs: UnityEngine.Rendering.SphericalHarmonicsL2, $rhs: number) : UnityEngine.Rendering.SphericalHarmonicsL2
            public static op_Multiply ($lhs: number, $rhs: UnityEngine.Rendering.SphericalHarmonicsL2) : UnityEngine.Rendering.SphericalHarmonicsL2
            public static op_Addition ($lhs: UnityEngine.Rendering.SphericalHarmonicsL2, $rhs: UnityEngine.Rendering.SphericalHarmonicsL2) : UnityEngine.Rendering.SphericalHarmonicsL2
            public static op_Equality ($lhs: UnityEngine.Rendering.SphericalHarmonicsL2, $rhs: UnityEngine.Rendering.SphericalHarmonicsL2) : boolean
            public static op_Inequality ($lhs: UnityEngine.Rendering.SphericalHarmonicsL2, $rhs: UnityEngine.Rendering.SphericalHarmonicsL2) : boolean
        }
        /** An enum that represents.
        */
        enum GraphicsTier
        { Tier1 = 0, Tier2 = 1, Tier3 = 2 }
        /** Specifies the OpenGL ES version.
        */
        enum OpenGLESVersion
        { None = 0, OpenGLES20 = 1, OpenGLES30 = 2, OpenGLES31 = 3, OpenGLES31AEP = 4, OpenGLES32 = 5 }
        /** Represents the view on a single texture resource that is uploaded to the graphics device.
        */
        class GraphicsTexture extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            /** Contains all the information Unity uses to create a GraphicsTexture.
            */
            public get descriptor(): UnityEngine.Rendering.GraphicsTextureDescriptor;
            /** The current state of a GraphicsTexture.
            */
            public get state(): UnityEngine.Rendering.GraphicsTextureState;
            /** Currently active graphics texture.
            */
            public static get active(): UnityEngine.Rendering.GraphicsTexture;
            public static set active(value: UnityEngine.Rendering.GraphicsTexture);
            public Dispose () : void
            public constructor ($desc: UnityEngine.Rendering.GraphicsTextureDescriptor)
        }
        /** Used to manage synchronisation between tasks on async compute queues and the graphics queue.
        */
        class GraphicsFence extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** true if GPU execution has passed the processing point where you inserted the GraphicsFence, otherwise false.
            */
            public get passed(): boolean;
        }
        /** The stages of the draw call processing on the GPU.
        */
        enum SynchronisationStage
        { VertexProcessing = 0, PixelProcessing = 1 }
        /** The type of GraphicFence.
        */
        enum GraphicsFenceType
        { AsyncQueueSynchronisation = 0, CPUSynchronisation = 1 }
        /** Describes the various stages of GPU processing against which the GraphicsFence can be set and waited against.
        */
        enum SynchronisationStageFlags
        { VertexProcessing = 1, PixelProcessing = 2, ComputeProcessing = 4, AllGPUOperations = 7 }
        /** How shadows are cast from this object.
        */
        enum ShadowCastingMode
        { Off = 0, On = 1, TwoSided = 2, ShadowsOnly = 3 }
        /** Light probe interpolation type.
        */
        enum LightProbeUsage
        { Off = 0, BlendProbes = 1, UseProxyVolume = 2, CustomProvided = 4 }
        /** This functionality is deprecated, and should no longer be used. Please use GraphicsFence.
        */
        class GPUFence extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** This functionality is deprecated, and should no longer be used. Please use GraphicsFence.passed.
            */
            public get passed(): boolean;
        }
        /** This enum describes what should be done on the render target when it is activated (loaded).
        */
        enum RenderBufferLoadAction
        { Load = 0, Clear = 1, DontCare = 2 }
        /** This enum describes what should be done on the render target when the GPU is done rendering into it.
        */
        enum RenderBufferStoreAction
        { Store = 0, Resolve = 1, StoreAndResolve = 2, DontCare = 3 }
        /** Reflection Probe usage.
        */
        enum ReflectionProbeUsage
        { Off = 0, BlendProbes = 1, BlendProbesAndSkybox = 2, Simple = 3 }
        /** An asset that produces a specific IRenderPipeline.
        */
        class RenderPipelineAsset extends UnityEngine.ScriptableObject
        {
            protected [__keep_incompatibility]: never;
            /** The render index for the terrain brush in the editor.
            * @returns Queue index. 
            */
            public get terrainBrushPassIndex(): number;
            /** Returns the names of the Rendering Layer Masks for this pipeline.
            * @returns An array of 32 Rendering Layer Mask names. 
            */
            public get renderingLayerMaskNames(): System.Array$1<string>;
            /** Returns the names of the Rendering Layer Masks for this pipeline, with each name prefixed by a unique numerical ID.
            * @returns Returns the mask names defined in renderingLayerMaskNames, but with each name prefixed by its index in the array, a colon, and a space. For example, if the element with an index of 2 has the name "Example Name", its value in this array is "2: Example Name". 
            */
            public get prefixedRenderingLayerMaskNames(): System.Array$1<string>;
            /** Return the default Material for this pipeline.
            * @returns Default material. 
            */
            public get defaultMaterial(): UnityEngine.Material;
            /** Retrieves the default Autodesk Interactive Shader for this pipeline.
            * @returns Returns the default shader. 
            */
            public get autodeskInteractiveShader(): UnityEngine.Shader;
            /** Retrieves the default Autodesk Interactive transparent Shader for this pipeline.
            * @returns Returns the default shader. 
            */
            public get autodeskInteractiveTransparentShader(): UnityEngine.Shader;
            /** Retrieves the default Autodesk Interactive masked Shader for this pipeline.
            * @returns Returns the default shader. 
            */
            public get autodeskInteractiveMaskedShader(): UnityEngine.Shader;
            /** Return the detail lit Shader for this pipeline.
            */
            public get terrainDetailLitShader(): UnityEngine.Shader;
            /** Return the detail grass Shader for this pipeline.
            */
            public get terrainDetailGrassShader(): UnityEngine.Shader;
            /** Return the detail grass billboard Shader for this pipeline.
            */
            public get terrainDetailGrassBillboardShader(): UnityEngine.Shader;
            /** Return the default particle Material for this pipeline.
            * @returns Default material. 
            */
            public get defaultParticleMaterial(): UnityEngine.Material;
            /** Return the default Line Material for this pipeline.
            * @returns Default material. 
            */
            public get defaultLineMaterial(): UnityEngine.Material;
            /** Return the default Terrain  Material for this pipeline.
            * @returns Default material. 
            */
            public get defaultTerrainMaterial(): UnityEngine.Material;
            /** Return the default UI Material for this pipeline.
            * @returns Default material. 
            */
            public get defaultUIMaterial(): UnityEngine.Material;
            /** Return the default UI overdraw Material for this pipeline.
            * @returns Default material. 
            */
            public get defaultUIOverdrawMaterial(): UnityEngine.Material;
            /** Return the default UI ETC1  Material for this pipeline.
            * @returns Default material. 
            */
            public get defaultUIETC1SupportedMaterial(): UnityEngine.Material;
            /** Return the default 2D Material for this pipeline.
            * @returns Default material. 
            */
            public get default2DMaterial(): UnityEngine.Material;
            /** Gets the default 2D Mask Material used by Sprite Masks in Universal Render Pipeline.
            * @returns Returns the default material. 
            */
            public get default2DMaskMaterial(): UnityEngine.Material;
            /** Return the default Shader for this pipeline.
            * @returns Default shader. 
            */
            public get defaultShader(): UnityEngine.Shader;
            /** Return the default SpeedTree v7 Shader for this pipeline.
            */
            public get defaultSpeedTree7Shader(): UnityEngine.Shader;
            /** Return the default SpeedTree v8 Shader for this pipeline.
            */
            public get defaultSpeedTree8Shader(): UnityEngine.Shader;
            /** Returns the Shader Tag value for the render pipeline that is described by this asset
            * @returns String with the Shader Tag 
            */
            public get renderPipelineShaderTag(): string;
            /** Returns a RenderPipeline type associated with the given RenderPipelineAsset instance.
            */
            public get pipelineType(): System.Type;
        }
        /** Format of the mesh index buffer data.
        */
        enum IndexFormat
        { UInt16 = 0, UInt32 = 1 }
        /** Information about a single VertexAttribute of a Mesh vertex.
        */
        class VertexAttributeDescriptor extends System.ValueType implements System.IEquatable$1<UnityEngine.Rendering.VertexAttributeDescriptor>
        {
            protected [__keep_incompatibility]: never;
            /** The vertex attribute.
            */
            public get attribute(): UnityEngine.Rendering.VertexAttribute;
            public set attribute(value: UnityEngine.Rendering.VertexAttribute);
            /** Format of the vertex attribute.
            */
            public get format(): UnityEngine.Rendering.VertexAttributeFormat;
            public set format(value: UnityEngine.Rendering.VertexAttributeFormat);
            /** Dimensionality of the vertex attribute.
            */
            public get dimension(): number;
            public set dimension(value: number);
            /** Which vertex buffer stream the attribute should be in.
            */
            public get stream(): number;
            public set stream(value: number);
            public Equals ($other: any) : boolean
            public Equals ($other: UnityEngine.Rendering.VertexAttributeDescriptor) : boolean
            public static op_Equality ($lhs: UnityEngine.Rendering.VertexAttributeDescriptor, $rhs: UnityEngine.Rendering.VertexAttributeDescriptor) : boolean
            public static op_Inequality ($lhs: UnityEngine.Rendering.VertexAttributeDescriptor, $rhs: UnityEngine.Rendering.VertexAttributeDescriptor) : boolean
            public constructor ($attribute?: UnityEngine.Rendering.VertexAttribute, $format?: UnityEngine.Rendering.VertexAttributeFormat, $dimension?: number, $stream?: number)
        }
        /** Possible attribute types that describe a vertex in a Mesh.
        */
        enum VertexAttribute
        { Position = 0, Normal = 1, Tangent = 2, Color = 3, TexCoord0 = 4, TexCoord1 = 5, TexCoord2 = 6, TexCoord3 = 7, TexCoord4 = 8, TexCoord5 = 9, TexCoord6 = 10, TexCoord7 = 11, BlendWeight = 12, BlendIndices = 13 }
        /** Data type of a VertexAttribute.
        */
        enum VertexAttributeFormat
        { Float32 = 0, Float16 = 1, UNorm8 = 2, SNorm8 = 3, UNorm16 = 4, SNorm16 = 5, UInt8 = 6, SInt8 = 7, UInt16 = 8, SInt16 = 9, UInt32 = 10, SInt32 = 11 }
        /** Contains information about a single sub-mesh of a Mesh.
        */
        class SubMeshDescriptor extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Bounding box of vertices in local space.
            */
            public get bounds(): UnityEngine.Bounds;
            public set bounds(value: UnityEngine.Bounds);
            /** Face topology of this sub-mesh.
            */
            public get topology(): UnityEngine.MeshTopology;
            public set topology(value: UnityEngine.MeshTopology);
            /** Starting point inside the whole Mesh index buffer where the face index data is found.
            */
            public get indexStart(): number;
            public set indexStart(value: number);
            /** Index count for this sub-mesh face data.
            */
            public get indexCount(): number;
            public set indexCount(value: number);
            /** Offset that is added to each value in the index buffer, to compute the final vertex index.
            */
            public get baseVertex(): number;
            public set baseVertex(value: number);
            /** First vertex in the index buffer for this sub-mesh.
            */
            public get firstVertex(): number;
            public set firstVertex(value: number);
            /** Number of vertices used by the index buffer of this sub-mesh.
            */
            public get vertexCount(): number;
            public set vertexCount(value: number);
            public constructor ($indexStart: number, $indexCount: number, $topology?: UnityEngine.MeshTopology)
        }
        /** Mesh data update flags.
        */
        enum MeshUpdateFlags
        { Default = 0, DontValidateIndices = 1, DontResetBoneBounds = 2, DontNotifyMeshUsers = 4, DontRecalculateBounds = 8 }
        /** Determines the data that Unity returns when you call Mesh.GetBlendShapeBuffer.
        */
        enum BlendShapeBufferLayout
        { PerShape = 0, PerVertex = 1 }
        /** Specifies how Unity builds the acceleration structure on the GPU.
        */
        enum RayTracingAccelerationStructureBuildFlags
        { None = 0, PreferFastTrace = 1, PreferFastBuild = 2, MinimizeMemory = 4 }
        /** ReflectionProbeBlendInfo contains information required for blending probes.
        */
        class ReflectionProbeBlendInfo extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Reflection Probe used in blending.
            */
            public probe : UnityEngine.ReflectionProbe
            /** Specifies the weight used in the interpolation between two probes, value varies from 0.0 to 1.0.
            */
            public weight : number
        }
        enum ShaderHardwareTier
        { Tier1 = 0, Tier2 = 1, Tier3 = 2 }
        /** Represents a global shader keyword.
        */
        class GlobalKeyword extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The name of the shader keyword. (Read Only)
            */
            public get name(): string;
            /** Creates and returns a Rendering.GlobalKeyword that represents a new or existing global shader keyword.
            * @param $name The name of the global shader keyword.
            * @returns Returns a new instance of the GlobalKeyword class. 
            */
            public static Create ($name: string) : UnityEngine.Rendering.GlobalKeyword
            public constructor ($name: string)
        }
        /** Represents the local keyword space of a Shader or ComputeShader.
        */
        class LocalKeywordSpace extends System.ValueType implements System.IEquatable$1<UnityEngine.Rendering.LocalKeywordSpace>
        {
            protected [__keep_incompatibility]: never;
            /** An array containing all Rendering.LocalKeyword structs in this local keyword space. (Read Only)
            */
            public get keywords(): System.Array$1<UnityEngine.Rendering.LocalKeyword>;
            /** An array containing the names of all local shader keywords in this local keyword space. (Read Only)
            */
            public get keywordNames(): System.Array$1<string>;
            /** The number of local shader keywords in this local keyword space. (Read Only)
            */
            public get keywordCount(): number;
            /** Searches for a local shader keyword with a given name in the keyword space.
            * @param $name The name of the shader keyword to search for.
            * @returns Returns a valid Rendering.LocalKeyword if it's present in the keyword space. Otherwise, returns an invalid Rendering.LocalKeyword. 
            */
            public FindKeyword ($name: string) : UnityEngine.Rendering.LocalKeyword
            public Equals ($o: any) : boolean
            public Equals ($rhs: UnityEngine.Rendering.LocalKeywordSpace) : boolean
            public static op_Equality ($lhs: UnityEngine.Rendering.LocalKeywordSpace, $rhs: UnityEngine.Rendering.LocalKeywordSpace) : boolean
            public static op_Inequality ($lhs: UnityEngine.Rendering.LocalKeywordSpace, $rhs: UnityEngine.Rendering.LocalKeywordSpace) : boolean
        }
        /** Shader tag ids are used to refer to various names in shaders.
        */
        class ShaderTagId extends System.ValueType implements System.IEquatable$1<UnityEngine.Rendering.ShaderTagId>
        {
            protected [__keep_incompatibility]: never;
            /** Describes a shader tag id not referring to any name.
            */
            public static none : UnityEngine.Rendering.ShaderTagId
            /** Gets the name of the tag referred to by the shader tag id.
            */
            public get name(): string;
            public Equals ($obj: any) : boolean
            public Equals ($other: UnityEngine.Rendering.ShaderTagId) : boolean
            public static op_Equality ($tag1: UnityEngine.Rendering.ShaderTagId, $tag2: UnityEngine.Rendering.ShaderTagId) : boolean
            public static op_Inequality ($tag1: UnityEngine.Rendering.ShaderTagId, $tag2: UnityEngine.Rendering.ShaderTagId) : boolean
            public static op_Explicit ($name: string) : UnityEngine.Rendering.ShaderTagId
            public static op_Explicit ($tagId: UnityEngine.Rendering.ShaderTagId) : string
            public constructor ($name: string)
        }
        /** Types of data that you can encapsulate within a render texture.
        */
        enum RenderTextureSubElement
        { Color = 0, Depth = 1, Stencil = 2, Default = 3 }
        /** A data structure used to represent the geometry in the Scene for GPU ray tracing.
        */
        class RayTracingAccelerationStructure extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            /** Destroys this RayTracingAccelerationStructure and frees the GPU memory used for storing acceleration structure data.
            */
            public Dispose () : void
            /** Destroys this RayTracingAccelerationStructure and frees the GPU memory used for storing acceleration structure data.
            */
            public Release () : void
            /** Builds acceleration structures on the GPU. Allocates any GPU memory required for storing acceleration structure data.
            */
            public Build () : void
            /** Builds acceleration structures on the GPU. Allocates any GPU memory required for storing acceleration structure data.
            */
            public Build ($relativeOrigin: UnityEngine.Vector3) : void
            /** Adds a ray tracing instance to the RayTracingAccelerationStructure.
            * @param $targetRenderer The Renderer to add to the RayTracingAccelerationStructure.
            * @param $enableTriangleCulling A bool that indicates whether front/back face culling for this ray tracing instance is enabled. The culling takes place when the GPU performs a ray-triangle intersection test. Culling is enabled (true) by default.
            * @param $frontTriangleCounterClockwise A bool that indicates whether to flip the way triangles face in this ray tracing instance. If this is set to true, front-facing triangles will become back-facing and vice versa. Set to false by default.
            * @param $mask An 8-bit mask you can use to selectively intersect the ray tracing instance associated with the target Renderer with rays that only pass the mask. All rays are enabled (0xff) by default.
            * @param $subMeshFlags A list of flags that control the shader execution behaviour when a ray intersects a sub-mesh geometry. See RayTracingSubMeshFlags for additional information.
            * @param $id An optional instance ID value accessed with InstanceID() HLSL function.
            * @returns A value representing a handle that you can use to perform later actions (e.g. RemoveInstance). 
            */
            public AddInstance ($targetRenderer: UnityEngine.Renderer, $subMeshFlags: System.Array$1<UnityEngine.Rendering.RayTracingSubMeshFlags>, $enableTriangleCulling?: boolean, $frontTriangleCounterClockwise?: boolean, $mask?: number, $id?: number) : number
            /** Adds a ray tracing instance associated with a list of axis-aligned bounding boxes (AABBs) to the RayTracingAccelerationStructure for procedural geometry generation using intersection shaders.
            * @param $config The common parameters that this AABBs ray tracing instance uses.
            * @param $matrix The transformation matrix of the ray tracing instance.
            * @param $id An optional instance ID value that you can access with InstanceID() HLSL function.
            * @returns A value representing a handle that can be used to perform later actions (e.g. RemoveInstance, UpdateInstancePropertyBlock or UpdateInstanceTransform). 
            */
            public AddInstance ($config: UnityEngine.Rendering.RayTracingAABBsInstanceConfig, $matrix: UnityEngine.Matrix4x4, $id?: number) : number
            public AddInstance ($config: $Ref<UnityEngine.Rendering.RayTracingMeshInstanceConfig>, $matrix: UnityEngine.Matrix4x4, $prevMatrix?: UnityEngine.Matrix4x4 | null, $id?: number) : number
            public AddInstance ($config: $Ref<UnityEngine.Rendering.RayTracingGeometryInstanceConfig>, $matrix: UnityEngine.Matrix4x4, $prevMatrix?: UnityEngine.Matrix4x4 | null, $id?: number) : number
            /** Removes a ray tracing instance associated with a Renderer from this RayTracingAccelerationStructure.
            * @param $targetRenderer The Renderer associated with the ray tracing instance.
            */
            public RemoveInstance ($targetRenderer: UnityEngine.Renderer) : void
            /** Removes a ray tracing instance associated with an axis-aligned bounding box (AABBs) GraphicsBuffer or a Mesh instance from this RayTracingAccelerationStructure.
            * @param $handle The handle associated with an AABB or Mesh ray tracing instance.
            */
            public RemoveInstance ($handle: number) : void
            /** Updates the transformation of a ray tracing instance.
            * @param $renderer The Renderer associated with a ray tracing instance.
            */
            public UpdateInstanceTransform ($renderer: UnityEngine.Renderer) : void
            /** Updates the transformation of a ray tracing instance.
            * @param $handle The handle associated with a AABB or Mesh ray tracing instance.
            * @param $matrix The new transformation matrix of the ray tracing instance.
            */
            public UpdateInstanceTransform ($handle: number, $matrix: UnityEngine.Matrix4x4) : void
            /** Updates the instance ID of a ray tracing instance.
            * @param $renderer The Renderer associated with the ray tracing instance.
            * @param $instanceID The new instance ID.
            */
            public UpdateInstanceID ($renderer: UnityEngine.Renderer, $instanceID: number) : void
            /** Updates the instance ID of a ray tracing instance.
            * @param $handle The handle associated with an AABB or Mesh ray tracing instance.
            * @param $instanceID The new instance ID.
            */
            public UpdateInstanceID ($handle: number, $instanceID: number) : void
            /** Updates the instance mask of a ray tracing instance.
            * @param $renderer The Renderer associated with the ray tracing instance.
            * @param $mask The new mask.
            */
            public UpdateInstanceMask ($renderer: UnityEngine.Renderer, $mask: number) : void
            /** Updates the instance mask of a ray tracing instance.
            * @param $handle The handle associated with an AABB or Mesh ray tracing instance.
            * @param $mask The new mask.
            */
            public UpdateInstanceMask ($handle: number, $mask: number) : void
            public Build ($buildSettings: UnityEngine.Rendering.RayTracingAccelerationStructure.BuildSettings) : void
            /** Adds the ray tracing instances associated with a VFXRenderer to the RayTracingAccelerationStructure.
            * @param $targetRenderer The Renderer to add to the RayTracingAccelerationStructure.
            * @param $vfxSystemMasks An array of 8-bit masks you can use to selectively intersect ray-traced VFX systems associated with the target Renderer with rays that only pass the mask. All rays are enabled (0xff) by default.
            */
            public AddVFXInstances ($targetRenderer: UnityEngine.Renderer, $vfxSystemMasks: System.Array$1<number>) : void
            /** Remove the ray tracing instances associated with a VFXRenderer from the RayTracingAccelerationStructure.
            * @param $targetRenderer The VFXRenderer whose instances will be removed.
            */
            public RemoveVFXInstances ($targetRenderer: UnityEngine.Renderer) : void
            /** Updates per ray tracing instance Material properties.
            * @param $handle The handle associated with a AABB or Mesh ray tracing instance.
            * @param $properties The additional material properties to apply onto the Material used by the ray tracing instance.
            */
            public UpdateInstancePropertyBlock ($handle: number, $properties: UnityEngine.MaterialPropertyBlock) : void
            /** Returns the total size of this RayTracingAccelerationStructure in GPU memory in bytes.
            * @returns The total size of the acceleration structure in GPU memory in bytes. 
            */
            public GetSize () : bigint
            /** Returns the number of ray tracing instances in the RayTracingAccelerationStructure.
            */
            public GetInstanceCount () : number
            /** Removes all ray tracing instances from the RayTracingAccelerationStructure.
            */
            public ClearInstances () : void
            /** Populates the RayTracingAccelerationStructure with ray tracing instances that Unity associates with Renderers in the Scene by using filtering and culling parameters.
            * @param $cullingConfig Parameters for culling and filtering ray tracing instances.
            * @returns Culling results. 
            */
            public CullInstances ($cullingConfig: $Ref<UnityEngine.Rendering.RayTracingInstanceCullingConfig>) : UnityEngine.Rendering.RayTracingInstanceCullingResults
            public constructor ($settings: UnityEngine.Rendering.RayTracingAccelerationStructure.Settings)
            public constructor ()
        }
        /** Type of a given shader property.
        */
        enum ShaderPropertyType
        { Color = 0, Vector = 1, Float = 2, Range = 3, Texture = 4, Int = 5 }
        /** Flags that control how a shader property behaves.
        */
        enum ShaderPropertyFlags
        { None = 0, HideInInspector = 1, PerRendererData = 2, NoScaleOffset = 4, Normal = 8, HDR = 16, Gamma = 32, NonModifiableTextureData = 64, MainTexture = 128, MainColor = 256 }
        /** Texture "dimension" (type).
        */
        enum TextureDimension
        { Unknown = -1, None = 0, Any = 1, Tex2D = 2, Tex3D = 3, Cube = 4, Tex2DArray = 5, CubeArray = 6 }
        /** Ambient lighting mode.
        */
        enum AmbientMode
        { Skybox = 0, Trilight = 1, Flat = 3, Custom = 4 }
        /** Default reflection mode.
        */
        enum DefaultReflectionMode
        { Skybox = 0, Custom = 1 }
        /** Represents a shader keyword declared in a shader source file.
        */
        class LocalKeyword extends System.ValueType implements System.IEquatable$1<UnityEngine.Rendering.LocalKeyword>
        {
            protected [__keep_incompatibility]: never;
            /** The name of the shader keyword (Read Only).
            */
            public get name(): string;
            /** Specifies whether this local shader keyword is used for dynamic branching (Read Only).
            */
            public get isDynamic(): boolean;
            /** Whether this local shader keyword can be overridden by a global shader keyword. (Read Only).
            */
            public get isOverridable(): boolean;
            /** Specifies whether this local shader keyword is valid (Read Only).
            */
            public get isValid(): boolean;
            /** The type of the shader keyword (Read Only).
            */
            public get type(): UnityEngine.Rendering.ShaderKeywordType;
            public Equals ($o: any) : boolean
            public Equals ($rhs: UnityEngine.Rendering.LocalKeyword) : boolean
            public static op_Equality ($lhs: UnityEngine.Rendering.LocalKeyword, $rhs: UnityEngine.Rendering.LocalKeyword) : boolean
            public static op_Inequality ($lhs: UnityEngine.Rendering.LocalKeyword, $rhs: UnityEngine.Rendering.LocalKeyword) : boolean
            public constructor ($shader: UnityEngine.Shader, $name: string)
            public constructor ($shader: UnityEngine.ComputeShader, $name: string)
        }
        /** Shadow resolution options for a Light.
        */
        enum LightShadowResolution
        { FromQualitySettings = -1, Low = 0, Medium = 1, High = 2, VeryHigh = 3 }
        /** Defines a place in light's rendering to attach Rendering.CommandBuffer objects to.
        */
        enum LightEvent
        { BeforeShadowMap = 0, AfterShadowMap = 1, BeforeScreenspaceMask = 2, AfterScreenspaceMask = 3, BeforeShadowMapPass = 4, AfterShadowMapPass = 5 }
        /** Allows precise control over which shadow map passes to execute Rendering.CommandBuffer objects attached using Light.AddCommandBuffer.
        */
        enum ShadowMapPass
        { PointlightPositiveX = 1, PointlightNegativeX = 2, PointlightPositiveY = 4, PointlightNegativeY = 8, PointlightPositiveZ = 16, PointlightNegativeZ = 32, DirectionalCascade0 = 64, DirectionalCascade1 = 128, DirectionalCascade2 = 256, DirectionalCascade3 = 512, Spotlight = 1024, AreaLight = 2048, Pointlight = 63, Directional = 960, All = 2047 }
        /** Used by CommandBuffer.SetShadowSamplingMode.
        */
        enum ShadowSamplingMode
        { CompareDepths = 0, RawDepth = 1, None = 2 }
        /** Shader pass type for Unity's lighting pipeline.
        */
        enum PassType
        { Normal = 0, Vertex = 1, VertexLM = 2, VertexLMRGBM = 3, ForwardBase = 4, ForwardAdd = 5, LightPrePassBase = 6, LightPrePassFinal = 7, ShadowCaster = 8, Deferred = 10, Meta = 11, MotionVectors = 12, ScriptableRenderPipeline = 13, ScriptableRenderPipelineDefaultUnlit = 14, GrabPass = 15 }
        /** Graphics device API type.
        */
        enum GraphicsDeviceType
        { OpenGL2 = 0, Direct3D9 = 1, Direct3D11 = 2, PlayStation3 = 3, Null = 4, Xbox360 = 6, OpenGLES2 = 8, OpenGLES3 = 11, PlayStationVita = 12, PlayStation4 = 13, XboxOne = 14, PlayStationMobile = 15, Metal = 16, OpenGLCore = 17, Direct3D12 = 18, N3DS = 19, Vulkan = 21, Switch = 22, XboxOneD3D12 = 23, GameCoreXboxOne = 24, GameCoreScarlett = -1, GameCoreXboxSeries = 25, PlayStation5 = 26, PlayStation5NGGC = 27, WebGPU = 28 }
        /** Options for the application's actual rendering threading mode.
        */
        enum RenderingThreadingMode
        { Direct = 0, SingleThreaded = 1, MultiThreaded = 2, LegacyJobified = 3, NativeGraphicsJobs = 4, NativeGraphicsJobsWithoutRenderThread = 5, NativeGraphicsJobsSplitThreading = 6 }
        /** Capabilities of the foveated rendering implementation.
        */
        enum FoveatedRenderingCaps
        { None = 0, FoveationImage = 1, NonUniformRaster = 2, ModeChangeOnlyBeforeRenderTargetSet = 4 }
        /** Support for various Graphics.CopyTexture cases.
        */
        enum CopyTextureSupport
        { None = 0, Basic = 1, Copy3D = 2, DifferentTypes = 4, TextureToRT = 8, RTToTexture = 16 }
        /** Represents an asynchronous request for a GPU resource.
        */
        class AsyncGPUReadbackRequest extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Checks whether the request has been processed.
            */
            public get done(): boolean;
            /** This property is true if the request has encountered an error.
            */
            public get hasError(): boolean;
            /** Number of layers in the current request.
            */
            public get layerCount(): number;
            /** The size in bytes of one layer of the readback data.
            */
            public get layerDataSize(): number;
            /** The width of the requested GPU data.
            */
            public get width(): number;
            /** When reading data from a ComputeBuffer, height is 1, otherwise, the property takes the value of the requested height from the texture.
            */
            public get height(): number;
            /** When reading data from a ComputeBuffer, depth is 1, otherwise, the property takes the value of the requested depth from the texture.
            */
            public get depth(): number;
            /** In the Editor, defines whether the Player loop is updated while the GPU request is in flight.
            */
            public get forcePlayerLoopUpdate(): boolean;
            public set forcePlayerLoopUpdate(value: boolean);
            /** Triggers an update of the request.
            */
            public Update () : void
            /** Waits for completion of the request.
            */
            public WaitForCompletion () : void
        }
        /** Allows the asynchronous read back of GPU resources.
        */
        class AsyncGPUReadback extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Waits until the completion of every request.
            */
            public static WaitAllRequests () : void
            public static Request ($src: UnityEngine.ComputeBuffer, $callback?: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>) : UnityEngine.Rendering.AsyncGPUReadbackRequest
            public static Request ($src: UnityEngine.ComputeBuffer, $size: number, $offset: number, $callback?: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>) : UnityEngine.Rendering.AsyncGPUReadbackRequest
            public static Request ($src: UnityEngine.GraphicsBuffer, $callback?: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>) : UnityEngine.Rendering.AsyncGPUReadbackRequest
            public static Request ($src: UnityEngine.GraphicsBuffer, $size: number, $offset: number, $callback?: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>) : UnityEngine.Rendering.AsyncGPUReadbackRequest
            public static Request ($src: UnityEngine.Texture, $mipIndex?: number, $callback?: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>) : UnityEngine.Rendering.AsyncGPUReadbackRequest
            public static Request ($src: UnityEngine.Texture, $mipIndex: number, $dstFormat: UnityEngine.TextureFormat, $callback?: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>) : UnityEngine.Rendering.AsyncGPUReadbackRequest
            public static Request ($src: UnityEngine.Texture, $mipIndex: number, $dstFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $callback?: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>) : UnityEngine.Rendering.AsyncGPUReadbackRequest
            public static Request ($src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $callback?: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>) : UnityEngine.Rendering.AsyncGPUReadbackRequest
            public static Request ($src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $dstFormat: UnityEngine.TextureFormat, $callback?: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>) : UnityEngine.Rendering.AsyncGPUReadbackRequest
            public static Request ($src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $dstFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $callback?: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>) : UnityEngine.Rendering.AsyncGPUReadbackRequest
            /** Retrieves data asynchronously from a GPU resource.
            * @param $src Resource to read the data from.
            * @param $size Size in bytes of the data to be retrieved from the ComputeBuffer or GraphicsBuffer.
            * @param $offset Offset in bytes in the ComputeBuffer or GraphicsBuffer.
            * @param $mipIndex Index of the mipmap to be fetched.
            * @param $dstFormat Target TextureFormat of the data. If the target format is different from the format stored on the GPU, the conversion is automatic.
            * @param $x Starting X coordinate in pixels of the Texture data to be fetched.
            * @param $width Width in pixels of the Texture data to be fetched.
            * @param $y Starting Y coordinate in pixels of the Texture data to be fetched.
            * @param $height Height in pixels of the Texture data to be fetched.
            * @param $z Depth in pixels for Texture3D being fetched. Number of layers for TextureCube, TextureArray and TextureCubeArray.
            * @param $depth Depth in pixels for Texture3D being fetched. Number of layers for TextureCube, TextureArray and TextureCubeArray.
            */
            public static RequestAsync ($src: UnityEngine.ComputeBuffer) : UnityEngine.Awaitable$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>
            /** Retrieves data asynchronously from a GPU resource.
            * @param $src Resource to read the data from.
            * @param $size Size in bytes of the data to be retrieved from the ComputeBuffer or GraphicsBuffer.
            * @param $offset Offset in bytes in the ComputeBuffer or GraphicsBuffer.
            * @param $mipIndex Index of the mipmap to be fetched.
            * @param $dstFormat Target TextureFormat of the data. If the target format is different from the format stored on the GPU, the conversion is automatic.
            * @param $x Starting X coordinate in pixels of the Texture data to be fetched.
            * @param $width Width in pixels of the Texture data to be fetched.
            * @param $y Starting Y coordinate in pixels of the Texture data to be fetched.
            * @param $height Height in pixels of the Texture data to be fetched.
            * @param $z Depth in pixels for Texture3D being fetched. Number of layers for TextureCube, TextureArray and TextureCubeArray.
            * @param $depth Depth in pixels for Texture3D being fetched. Number of layers for TextureCube, TextureArray and TextureCubeArray.
            */
            public static RequestAsync ($src: UnityEngine.ComputeBuffer, $size: number, $offset: number) : UnityEngine.Awaitable$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>
            /** Retrieves data asynchronously from a GPU resource.
            * @param $src Resource to read the data from.
            * @param $size Size in bytes of the data to be retrieved from the ComputeBuffer or GraphicsBuffer.
            * @param $offset Offset in bytes in the ComputeBuffer or GraphicsBuffer.
            * @param $mipIndex Index of the mipmap to be fetched.
            * @param $dstFormat Target TextureFormat of the data. If the target format is different from the format stored on the GPU, the conversion is automatic.
            * @param $x Starting X coordinate in pixels of the Texture data to be fetched.
            * @param $width Width in pixels of the Texture data to be fetched.
            * @param $y Starting Y coordinate in pixels of the Texture data to be fetched.
            * @param $height Height in pixels of the Texture data to be fetched.
            * @param $z Depth in pixels for Texture3D being fetched. Number of layers for TextureCube, TextureArray and TextureCubeArray.
            * @param $depth Depth in pixels for Texture3D being fetched. Number of layers for TextureCube, TextureArray and TextureCubeArray.
            */
            public static RequestAsync ($src: UnityEngine.GraphicsBuffer) : UnityEngine.Awaitable$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>
            /** Retrieves data asynchronously from a GPU resource.
            * @param $src Resource to read the data from.
            * @param $size Size in bytes of the data to be retrieved from the ComputeBuffer or GraphicsBuffer.
            * @param $offset Offset in bytes in the ComputeBuffer or GraphicsBuffer.
            * @param $mipIndex Index of the mipmap to be fetched.
            * @param $dstFormat Target TextureFormat of the data. If the target format is different from the format stored on the GPU, the conversion is automatic.
            * @param $x Starting X coordinate in pixels of the Texture data to be fetched.
            * @param $width Width in pixels of the Texture data to be fetched.
            * @param $y Starting Y coordinate in pixels of the Texture data to be fetched.
            * @param $height Height in pixels of the Texture data to be fetched.
            * @param $z Depth in pixels for Texture3D being fetched. Number of layers for TextureCube, TextureArray and TextureCubeArray.
            * @param $depth Depth in pixels for Texture3D being fetched. Number of layers for TextureCube, TextureArray and TextureCubeArray.
            */
            public static RequestAsync ($src: UnityEngine.GraphicsBuffer, $size: number, $offset: number) : UnityEngine.Awaitable$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>
            /** Retrieves data asynchronously from a GPU resource.
            * @param $src Resource to read the data from.
            * @param $size Size in bytes of the data to be retrieved from the ComputeBuffer or GraphicsBuffer.
            * @param $offset Offset in bytes in the ComputeBuffer or GraphicsBuffer.
            * @param $mipIndex Index of the mipmap to be fetched.
            * @param $dstFormat Target TextureFormat of the data. If the target format is different from the format stored on the GPU, the conversion is automatic.
            * @param $x Starting X coordinate in pixels of the Texture data to be fetched.
            * @param $width Width in pixels of the Texture data to be fetched.
            * @param $y Starting Y coordinate in pixels of the Texture data to be fetched.
            * @param $height Height in pixels of the Texture data to be fetched.
            * @param $z Depth in pixels for Texture3D being fetched. Number of layers for TextureCube, TextureArray and TextureCubeArray.
            * @param $depth Depth in pixels for Texture3D being fetched. Number of layers for TextureCube, TextureArray and TextureCubeArray.
            */
            public static RequestAsync ($src: UnityEngine.Texture, $mipIndex?: number) : UnityEngine.Awaitable$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>
            /** Retrieves data asynchronously from a GPU resource.
            * @param $src Resource to read the data from.
            * @param $size Size in bytes of the data to be retrieved from the ComputeBuffer or GraphicsBuffer.
            * @param $offset Offset in bytes in the ComputeBuffer or GraphicsBuffer.
            * @param $mipIndex Index of the mipmap to be fetched.
            * @param $dstFormat Target TextureFormat of the data. If the target format is different from the format stored on the GPU, the conversion is automatic.
            * @param $x Starting X coordinate in pixels of the Texture data to be fetched.
            * @param $width Width in pixels of the Texture data to be fetched.
            * @param $y Starting Y coordinate in pixels of the Texture data to be fetched.
            * @param $height Height in pixels of the Texture data to be fetched.
            * @param $z Depth in pixels for Texture3D being fetched. Number of layers for TextureCube, TextureArray and TextureCubeArray.
            * @param $depth Depth in pixels for Texture3D being fetched. Number of layers for TextureCube, TextureArray and TextureCubeArray.
            */
            public static RequestAsync ($src: UnityEngine.Texture, $mipIndex: number, $dstFormat: UnityEngine.TextureFormat) : UnityEngine.Awaitable$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>
            /** Retrieves data asynchronously from a GPU resource.
            * @param $src Resource to read the data from.
            * @param $size Size in bytes of the data to be retrieved from the ComputeBuffer or GraphicsBuffer.
            * @param $offset Offset in bytes in the ComputeBuffer or GraphicsBuffer.
            * @param $mipIndex Index of the mipmap to be fetched.
            * @param $dstFormat Target TextureFormat of the data. If the target format is different from the format stored on the GPU, the conversion is automatic.
            * @param $x Starting X coordinate in pixels of the Texture data to be fetched.
            * @param $width Width in pixels of the Texture data to be fetched.
            * @param $y Starting Y coordinate in pixels of the Texture data to be fetched.
            * @param $height Height in pixels of the Texture data to be fetched.
            * @param $z Depth in pixels for Texture3D being fetched. Number of layers for TextureCube, TextureArray and TextureCubeArray.
            * @param $depth Depth in pixels for Texture3D being fetched. Number of layers for TextureCube, TextureArray and TextureCubeArray.
            */
            public static RequestAsync ($src: UnityEngine.Texture, $mipIndex: number, $dstFormat: UnityEngine.Experimental.Rendering.GraphicsFormat) : UnityEngine.Awaitable$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>
            /** Retrieves data asynchronously from a GPU resource.
            * @param $src Resource to read the data from.
            * @param $size Size in bytes of the data to be retrieved from the ComputeBuffer or GraphicsBuffer.
            * @param $offset Offset in bytes in the ComputeBuffer or GraphicsBuffer.
            * @param $mipIndex Index of the mipmap to be fetched.
            * @param $dstFormat Target TextureFormat of the data. If the target format is different from the format stored on the GPU, the conversion is automatic.
            * @param $x Starting X coordinate in pixels of the Texture data to be fetched.
            * @param $width Width in pixels of the Texture data to be fetched.
            * @param $y Starting Y coordinate in pixels of the Texture data to be fetched.
            * @param $height Height in pixels of the Texture data to be fetched.
            * @param $z Depth in pixels for Texture3D being fetched. Number of layers for TextureCube, TextureArray and TextureCubeArray.
            * @param $depth Depth in pixels for Texture3D being fetched. Number of layers for TextureCube, TextureArray and TextureCubeArray.
            */
            public static RequestAsync ($src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number) : UnityEngine.Awaitable$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>
            /** Retrieves data asynchronously from a GPU resource.
            * @param $src Resource to read the data from.
            * @param $size Size in bytes of the data to be retrieved from the ComputeBuffer or GraphicsBuffer.
            * @param $offset Offset in bytes in the ComputeBuffer or GraphicsBuffer.
            * @param $mipIndex Index of the mipmap to be fetched.
            * @param $dstFormat Target TextureFormat of the data. If the target format is different from the format stored on the GPU, the conversion is automatic.
            * @param $x Starting X coordinate in pixels of the Texture data to be fetched.
            * @param $width Width in pixels of the Texture data to be fetched.
            * @param $y Starting Y coordinate in pixels of the Texture data to be fetched.
            * @param $height Height in pixels of the Texture data to be fetched.
            * @param $z Depth in pixels for Texture3D being fetched. Number of layers for TextureCube, TextureArray and TextureCubeArray.
            * @param $depth Depth in pixels for Texture3D being fetched. Number of layers for TextureCube, TextureArray and TextureCubeArray.
            */
            public static RequestAsync ($src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $dstFormat: UnityEngine.TextureFormat) : UnityEngine.Awaitable$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>
            /** Retrieves data asynchronously from a GPU resource.
            * @param $src Resource to read the data from.
            * @param $size Size in bytes of the data to be retrieved from the ComputeBuffer or GraphicsBuffer.
            * @param $offset Offset in bytes in the ComputeBuffer or GraphicsBuffer.
            * @param $mipIndex Index of the mipmap to be fetched.
            * @param $dstFormat Target TextureFormat of the data. If the target format is different from the format stored on the GPU, the conversion is automatic.
            * @param $x Starting X coordinate in pixels of the Texture data to be fetched.
            * @param $width Width in pixels of the Texture data to be fetched.
            * @param $y Starting Y coordinate in pixels of the Texture data to be fetched.
            * @param $height Height in pixels of the Texture data to be fetched.
            * @param $z Depth in pixels for Texture3D being fetched. Number of layers for TextureCube, TextureArray and TextureCubeArray.
            * @param $depth Depth in pixels for Texture3D being fetched. Number of layers for TextureCube, TextureArray and TextureCubeArray.
            */
            public static RequestAsync ($src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $dstFormat: UnityEngine.Experimental.Rendering.GraphicsFormat) : UnityEngine.Awaitable$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>
        }
        /** Provides an interface to control GPU frame capture in Microsoft's PIX software.
        */
        class PIX extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Begins a GPU frame capture in PIX. If not running via PIX, or as a development build, then it has no effect.
            */
            public static BeginGPUCapture () : void
            /** Ends the current GPU frame capture in PIX. If not running via PIX, or as a development build, then it has no effect.
            */
            public static EndGPUCapture () : void
            /** Returns true if running via PIX and in a development build.
            */
            public static IsAttached () : boolean
            public constructor ()
        }
        /** Whether to show undefined areas of the display that might cause rendering problems in your built application.
        */
        class LoadStoreActionDebugModeSettings extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Enables or disables Unity highlighting undefined areas of the display.
            */
            public static get LoadStoreDebugModeEnabled(): boolean;
            public static set LoadStoreDebugModeEnabled(value: boolean);
        }
        /** Options for the data type of a shader constant's members.
        */
        enum ShaderParamType
        { Float = 0, Int = 1, Bool = 2, Half = 3, Short = 4, UInt = 5 }
        /** Options for the shader constant value type.
        */
        enum ShaderConstantType
        { Vector = 0, Matrix = 1, Struct = 2 }
        /** Determine in which order objects are renderered.
        */
        enum RenderQueue
        { Background = 1000, Geometry = 2000, AlphaTest = 2450, GeometryLast = 2500, Transparent = 3000, Overlay = 4000 }
        /** Control Fast Memory render target layout.
        */
        enum FastMemoryFlags
        { None = 0, SpillTop = 1, SpillBottom = 2 }
        /** Blend mode for controlling the blending.
        */
        enum BlendMode
        { Zero = 0, One = 1, DstColor = 2, SrcColor = 3, OneMinusDstColor = 4, SrcAlpha = 5, OneMinusSrcColor = 6, DstAlpha = 7, OneMinusDstAlpha = 8, SrcAlphaSaturate = 9, OneMinusSrcAlpha = 10 }
        /** Blend operation.
        */
        enum BlendOp
        { Add = 0, Subtract = 1, ReverseSubtract = 2, Min = 3, Max = 4, LogicalClear = 5, LogicalSet = 6, LogicalCopy = 7, LogicalCopyInverted = 8, LogicalNoop = 9, LogicalInvert = 10, LogicalAnd = 11, LogicalNand = 12, LogicalOr = 13, LogicalNor = 14, LogicalXor = 15, LogicalEquivalence = 16, LogicalAndReverse = 17, LogicalAndInverted = 18, LogicalOrReverse = 19, LogicalOrInverted = 20, Multiply = 21, Screen = 22, Overlay = 23, Darken = 24, Lighten = 25, ColorDodge = 26, ColorBurn = 27, HardLight = 28, SoftLight = 29, Difference = 30, Exclusion = 31, HSLHue = 32, HSLSaturation = 33, HSLColor = 34, HSLLuminosity = 35 }
        /** Depth or stencil comparison function.
        */
        enum CompareFunction
        { Disabled = 0, Never = 1, Less = 2, Equal = 3, LessEqual = 4, Greater = 5, NotEqual = 6, GreaterEqual = 7, Always = 8 }
        /** Determines which faces Unity culls.
        */
        enum CullMode
        { Off = 0, Front = 1, Back = 2 }
        /** Specifies which color components will get written into the target framebuffer.
        */
        enum ColorWriteMask
        { Alpha = 1, Blue = 2, Green = 4, Red = 8, All = 15 }
        /** Specifies the operation that's performed on the stencil buffer when rendering.
        */
        enum StencilOp
        { Keep = 0, Zero = 1, Replace = 2, IncrementSaturate = 3, DecrementSaturate = 4, Invert = 5, IncrementWrap = 6, DecrementWrap = 7 }
        /** Determines how Unity will compress baked reflection cubemap.
        */
        enum ReflectionCubemapCompression
        { Uncompressed = 0, Compressed = 1, Auto = 2 }
        /** Built-in temporary render textures produced during camera's rendering.
        */
        enum BuiltinRenderTextureType
        { PropertyName = -4, BufferPtr = -3, RenderTexture = -2, BindableTexture = -1, None = 0, CurrentActive = 1, CameraTarget = 2, Depth = 3, DepthNormals = 4, ResolvedDepth = 5, PrepassNormalsSpec = 7, PrepassLight = 8, PrepassLightSpec = 9, GBuffer0 = 10, GBuffer1 = 11, GBuffer2 = 12, GBuffer3 = 13, Reflections = 14, MotionVectors = 15, GBuffer4 = 16, GBuffer5 = 17, GBuffer6 = 18, GBuffer7 = 19 }
        /** Graphics Format Swizzle.
        */
        enum FormatSwizzle
        { FormatSwizzleR = 0, FormatSwizzleG = 1, FormatSwizzleB = 2, FormatSwizzleA = 3, FormatSwizzle0 = 4, FormatSwizzle1 = 5 }
        /** Identifies a RenderTexture for a Rendering.CommandBuffer.
        */
        class RenderTargetIdentifier extends System.ValueType implements System.IEquatable$1<UnityEngine.Rendering.RenderTargetIdentifier>
        {
            protected [__keep_incompatibility]: never;
            /** All depth-slices of the render resource are bound for rendering. For textures which are neither array nor 3D, the default slice is bound.
            */
            public static AllDepthSlices : number
            public static op_Implicit ($type: UnityEngine.Rendering.BuiltinRenderTextureType) : UnityEngine.Rendering.RenderTargetIdentifier
            public static op_Implicit ($name: string) : UnityEngine.Rendering.RenderTargetIdentifier
            public static op_Implicit ($nameID: number) : UnityEngine.Rendering.RenderTargetIdentifier
            public static op_Implicit ($tex: UnityEngine.Texture) : UnityEngine.Rendering.RenderTargetIdentifier
            public static op_Implicit ($buf: UnityEngine.RenderBuffer) : UnityEngine.Rendering.RenderTargetIdentifier
            public Equals ($rhs: UnityEngine.Rendering.RenderTargetIdentifier) : boolean
            public Equals ($obj: any) : boolean
            public static op_Equality ($lhs: UnityEngine.Rendering.RenderTargetIdentifier, $rhs: UnityEngine.Rendering.RenderTargetIdentifier) : boolean
            public static op_Inequality ($lhs: UnityEngine.Rendering.RenderTargetIdentifier, $rhs: UnityEngine.Rendering.RenderTargetIdentifier) : boolean
            public constructor ($type: UnityEngine.Rendering.BuiltinRenderTextureType)
            public constructor ($type: UnityEngine.Rendering.BuiltinRenderTextureType, $mipLevel?: number, $cubeFace?: UnityEngine.CubemapFace, $depthSlice?: number)
            public constructor ($name: string)
            public constructor ($name: string, $mipLevel?: number, $cubeFace?: UnityEngine.CubemapFace, $depthSlice?: number)
            public constructor ($nameID: number)
            public constructor ($nameID: number, $mipLevel?: number, $cubeFace?: UnityEngine.CubemapFace, $depthSlice?: number)
            public constructor ($renderTargetIdentifier: UnityEngine.Rendering.RenderTargetIdentifier, $mipLevel: number, $cubeFace?: UnityEngine.CubemapFace, $depthSlice?: number)
            public constructor ($tex: UnityEngine.Texture)
            public constructor ($tex: UnityEngine.Texture, $mipLevel?: number, $cubeFace?: UnityEngine.CubemapFace, $depthSlice?: number)
            public constructor ($buf: UnityEngine.RenderBuffer, $mipLevel?: number, $cubeFace?: UnityEngine.CubemapFace, $depthSlice?: number)
        }
        /** This enum describes optional flags for the RenderTargetBinding structure.
        */
        enum RenderTargetFlags
        { None = 0, ReadOnlyDepth = 1, ReadOnlyStencil = 2, ReadOnlyDepthStencil = 3 }
        /** Describes a render target with one or more color buffers, a depthstencil buffer and the associated loadstore-actions that are applied when the render target is active.
        */
        class RenderTargetBinding extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Color buffers to use as render targets.
            */
            public get colorRenderTargets(): System.Array$1<UnityEngine.Rendering.RenderTargetIdentifier>;
            public set colorRenderTargets(value: System.Array$1<UnityEngine.Rendering.RenderTargetIdentifier>);
            /** Depth/stencil buffer to use as render target.
            */
            public get depthRenderTarget(): UnityEngine.Rendering.RenderTargetIdentifier;
            public set depthRenderTarget(value: UnityEngine.Rendering.RenderTargetIdentifier);
            /** Load actions for color buffers.
            */
            public get colorLoadActions(): System.Array$1<UnityEngine.Rendering.RenderBufferLoadAction>;
            public set colorLoadActions(value: System.Array$1<UnityEngine.Rendering.RenderBufferLoadAction>);
            /** Store actions for color buffers.
            */
            public get colorStoreActions(): System.Array$1<UnityEngine.Rendering.RenderBufferStoreAction>;
            public set colorStoreActions(value: System.Array$1<UnityEngine.Rendering.RenderBufferStoreAction>);
            /** Load action for the depth/stencil buffer.
            */
            public get depthLoadAction(): UnityEngine.Rendering.RenderBufferLoadAction;
            public set depthLoadAction(value: UnityEngine.Rendering.RenderBufferLoadAction);
            /** Store action for the depth/stencil buffer.
            */
            public get depthStoreAction(): UnityEngine.Rendering.RenderBufferStoreAction;
            public set depthStoreAction(value: UnityEngine.Rendering.RenderBufferStoreAction);
            /** Optional flags.
            */
            public get flags(): UnityEngine.Rendering.RenderTargetFlags;
            public set flags(value: UnityEngine.Rendering.RenderTargetFlags);
            public constructor ($colorRenderTargets: System.Array$1<UnityEngine.Rendering.RenderTargetIdentifier>, $colorLoadActions: System.Array$1<UnityEngine.Rendering.RenderBufferLoadAction>, $colorStoreActions: System.Array$1<UnityEngine.Rendering.RenderBufferStoreAction>, $depthRenderTarget: UnityEngine.Rendering.RenderTargetIdentifier, $depthLoadAction: UnityEngine.Rendering.RenderBufferLoadAction, $depthStoreAction: UnityEngine.Rendering.RenderBufferStoreAction)
            public constructor ($colorRenderTarget: UnityEngine.Rendering.RenderTargetIdentifier, $colorLoadAction: UnityEngine.Rendering.RenderBufferLoadAction, $colorStoreAction: UnityEngine.Rendering.RenderBufferStoreAction, $depthRenderTarget: UnityEngine.Rendering.RenderTargetIdentifier, $depthLoadAction: UnityEngine.Rendering.RenderBufferLoadAction, $depthStoreAction: UnityEngine.Rendering.RenderBufferStoreAction)
            public constructor ($setup: UnityEngine.RenderTargetSetup)
        }
        /** Built-in shader types used by Rendering.GraphicsSettings.
        */
        enum BuiltinShaderType
        { DeferredShading = 0, DeferredReflections = 1, LegacyDeferredLighting = 2, ScreenSpaceShadows = 3, DepthNormals = 4, MotionVectors = 5, LightHalo = 6, LensFlare = 7 }
        /** Built-in shader modes used by Rendering.GraphicsSettings.
        */
        enum BuiltinShaderMode
        { Disabled = 0, UseBuiltin = 1, UseCustom = 2 }
        /** Defines set by editor when compiling shaders, based on the target platform and GraphicsTier.
        */
        enum BuiltinShaderDefine
        { UNITY_NO_DXT5nm = 0, UNITY_NO_RGBM = 1, UNITY_USE_NATIVE_HDR = 2, UNITY_ENABLE_REFLECTION_BUFFERS = 3, UNITY_FRAMEBUFFER_FETCH_AVAILABLE = 4, UNITY_ENABLE_NATIVE_SHADOW_LOOKUPS = 5, UNITY_METAL_SHADOWS_USE_POINT_FILTERING = 6, UNITY_NO_CUBEMAP_ARRAY = 7, UNITY_NO_SCREENSPACE_SHADOWS = 8, UNITY_USE_DITHER_MASK_FOR_ALPHABLENDED_SHADOWS = 9, UNITY_PBS_USE_BRDF1 = 10, UNITY_PBS_USE_BRDF2 = 11, UNITY_PBS_USE_BRDF3 = 12, UNITY_NO_FULL_STANDARD_SHADER = 13, UNITY_SPECCUBE_BOX_PROJECTION = 14, UNITY_SPECCUBE_BLENDING = 15, UNITY_ENABLE_DETAIL_NORMALMAP = 16, SHADER_API_MOBILE = 17, SHADER_API_DESKTOP = 18, UNITY_HARDWARE_TIER1 = 19, UNITY_HARDWARE_TIER2 = 20, UNITY_HARDWARE_TIER3 = 21, UNITY_COLORSPACE_GAMMA = 22, UNITY_LIGHT_PROBE_PROXY_VOLUME = 23, UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS = 24, UNITY_LIGHTMAP_DLDR_ENCODING = 25, UNITY_LIGHTMAP_RGBM_ENCODING = 26, UNITY_LIGHTMAP_FULL_HDR = 27, UNITY_VIRTUAL_TEXTURING = 28, UNITY_PRETRANSFORM_TO_DISPLAY_ORIENTATION = 29, UNITY_ASTC_NORMALMAP_ENCODING = 30, SHADER_API_GLES30 = 31, UNITY_UNIFIED_SHADER_PRECISION_MODEL = 32, UNITY_PLATFORM_SUPPORTS_WAVE_32 = 33, UNITY_PLATFORM_SUPPORTS_WAVE_64 = 34, UNITY_NEEDS_RENDERPASS_FBFETCH_FALLBACK = 35 }
        /** Video shaders mode used by Rendering.GraphicsSettings.
        */
        enum VideoShadersIncludeMode
        { Never = 0, Referenced = 1, Always = 2 }
        /** The HDR mode to use for rendering.
        */
        enum CameraHDRMode
        { FP16 = 1, R11G11B10 = 2 }
        /** How much CPU usage to assign to the final lighting calculations at runtime.
        */
        enum RealtimeGICPUUsage
        { Low = 25, Medium = 50, High = 75, Unlimited = 100 }
        /** Defines the way Unity chooses a probe to light a Renderer that is lit by Light Probes but positioned outside the bounds of the Light Probe tetrahedral hull.
        */
        enum LightProbeOutsideHullStrategy
        { kLightProbeSearchTetrahedralHull = 0, kLightProbeUseAmbientProbe = 1 }
        /** Enum type defines the different stereo rendering modes available.
        */
        enum SinglePassStereoMode
        { None = 0, SideBySide = 1, Instancing = 2, Multiview = 3 }
        /** Operation mode for the foveated rendering system.
        */
        enum FoveatedRenderingMode
        { Disabled = 0, Enabled = 1 }
        /** Flags describing the intention for how the command buffer will be executed. Set these via CommandBuffer.SetExecutionFlags.
        */
        enum CommandBufferExecutionFlags
        { None = 0, AsyncCompute = 2 }
        /** Flags that determine which render targets Unity clears when you use CommandBuffer.ClearRenderTarget.
        */
        enum RTClearFlags
        { None = 0, Color = 1, Depth = 2, Stencil = 4, All = 7, DepthStencil = 6, ColorDepth = 3, ColorStencil = 5 }
        /** The types of camera matrices that support late latching.
        */
        enum CameraLateLatchMatrixType
        { View = 0, InverseView = 1, ViewProjection = 2, InverseViewProjection = 3 }
        /** Flags that determine what custom events get called when native plugin callback is issued.
        */
        enum CustomMarkerCallbackFlags
        { CustomMarkerCallbackDefault = 0, CustomMarkerCallbackForceInvalidateStateTracking = 4 }
        /** Script interface for.
        */
        class GraphicsSettings extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** Transparent object sorting mode.
            */
            public static get transparencySortMode(): UnityEngine.TransparencySortMode;
            public static set transparencySortMode(value: UnityEngine.TransparencySortMode);
            /** An axis that describes the direction along which the distances of objects are measured for the purpose of sorting.
            */
            public static get transparencySortAxis(): UnityEngine.Vector3;
            public static set transparencySortAxis(value: UnityEngine.Vector3);
            /** Is the current render pipeline capable of rendering direct lighting for rectangular area Lights?
            */
            public static get realtimeDirectRectangularAreaLights(): boolean;
            public static set realtimeDirectRectangularAreaLights(value: boolean);
            /** If this is true, Light intensity is multiplied against linear color values. If it is false, gamma color values are used.
            */
            public static get lightsUseLinearIntensity(): boolean;
            public static set lightsUseLinearIntensity(value: boolean);
            /** Whether to use a Light's color temperature when calculating the final color of that Light."
            */
            public static get lightsUseColorTemperature(): boolean;
            public static set lightsUseColorTemperature(value: boolean);
            /** Stores the default value for the RenderingLayerMask property of newly created Renderers.
            */
            public static get defaultRenderingLayerMask(): number;
            public static set defaultRenderingLayerMask(value: number);
            /** Stores the default value for the GateFit property of newly created Cameras.
            */
            public static get defaultGateFitMode(): UnityEngine.Camera.GateFitMode;
            public static set defaultGateFitMode(value: UnityEngine.Camera.GateFitMode);
            /** Enable/Disable SRP batcher (experimental) at runtime.
            */
            public static get useScriptableRenderPipelineBatching(): boolean;
            public static set useScriptableRenderPipelineBatching(value: boolean);
            /** If this is true, a log entry is made each time a shader is compiled at application runtime.
            */
            public static get logWhenShaderIsCompiled(): boolean;
            public static set logWhenShaderIsCompiled(value: boolean);
            /** Disables the built-in update loop for Custom Render Textures, so that you can write your own update loop.
            */
            public static get disableBuiltinCustomRenderTextureUpdate(): boolean;
            public static set disableBuiltinCustomRenderTextureUpdate(value: boolean);
            /** If and when to include video shaders in the build.
            */
            public static get videoShadersIncludeMode(): UnityEngine.Rendering.VideoShadersIncludeMode;
            public static set videoShadersIncludeMode(value: UnityEngine.Rendering.VideoShadersIncludeMode);
            /** Defines the way Unity chooses a probe to light a Renderer that is lit by Light Probes but positioned outside the bounds of the Light Probe tetrahedral hull.
            */
            public static get lightProbeOutsideHullStrategy(): UnityEngine.Rendering.LightProbeOutsideHullStrategy;
            public static set lightProbeOutsideHullStrategy(value: UnityEngine.Rendering.LightProbeOutsideHullStrategy);
            /** The RenderPipelineAsset that defines the active render pipeline for the current quality level.
            */
            public static get currentRenderPipeline(): UnityEngine.Rendering.RenderPipelineAsset;
            /** If the value is true, a Scriptable Render Pipeline is active.
            */
            public static get isScriptableRenderPipelineEnabled(): boolean;
            /** The type of the currently active RenderPipelineAsset, or null if there's no currently active Asset.
            */
            public static get currentRenderPipelineAssetType(): System.Type;
            /** Deprecated, use GraphicsSettings.defaultRenderPipeline instead.
            */
            public static get renderPipelineAsset(): UnityEngine.Rendering.RenderPipelineAsset;
            public static set renderPipelineAsset(value: UnityEngine.Rendering.RenderPipelineAsset);
            /** The RenderPipelineAsset that defines the default render pipeline.
            */
            public static get defaultRenderPipeline(): UnityEngine.Rendering.RenderPipelineAsset;
            public static set defaultRenderPipeline(value: UnityEngine.Rendering.RenderPipelineAsset);
            /** An array containing the RenderPipelineAsset instances that describe the default render pipeline and any quality level overrides.
            */
            public static get allConfiguredRenderPipelines(): System.Array$1<UnityEngine.Rendering.RenderPipelineAsset>;
            /** Enable or disable using the camera position as the reference point for culling lights.
            */
            public static get cameraRelativeLightCulling(): boolean;
            public static set cameraRelativeLightCulling(value: boolean);
            /** Enable or disable using the camera position as the reference point for culling shadows.
            */
            public static get cameraRelativeShadowCulling(): boolean;
            public static set cameraRelativeShadowCulling(value: boolean);
            /** Returns true if shader define was set when compiling shaders for current GraphicsTier. Graphics Tiers are only available in the Built-in Render Pipeline.
            */
            public static HasShaderDefine ($tier: UnityEngine.Rendering.GraphicsTier, $defineHash: UnityEngine.Rendering.BuiltinShaderDefine) : boolean
            /** Returns true if shader define was set when compiling shaders for a given GraphicsTier. Graphics Tiers are only available in the Built-in Render Pipeline.
            */
            public static HasShaderDefine ($defineHash: UnityEngine.Rendering.BuiltinShaderDefine) : boolean
            /** Provides a reference to the GraphicSettings object.
            * @returns Returns the GraphicsSettings object. 
            */
            public static GetGraphicsSettings () : UnityEngine.Object
            /** Set built-in shader mode.
            * @param $type Built-in shader type to change.
            * @param $mode Mode to use for built-in shader.
            */
            public static SetShaderMode ($type: UnityEngine.Rendering.BuiltinShaderType, $mode: UnityEngine.Rendering.BuiltinShaderMode) : void
            /** Get built-in shader mode.
            * @param $type Built-in shader type to query.
            * @returns Mode used for built-in shader. 
            */
            public static GetShaderMode ($type: UnityEngine.Rendering.BuiltinShaderType) : UnityEngine.Rendering.BuiltinShaderMode
            /** Set custom shader to use instead of a built-in shader.
            * @param $type Built-in shader type to set custom shader to.
            * @param $shader The shader to use.
            */
            public static SetCustomShader ($type: UnityEngine.Rendering.BuiltinShaderType, $shader: UnityEngine.Shader) : void
            /** Get custom shader used instead of a built-in shader.
            * @param $type Built-in shader type to query custom shader for.
            * @returns The shader used. 
            */
            public static GetCustomShader ($type: UnityEngine.Rendering.BuiltinShaderType) : UnityEngine.Shader
            /** Get the registered RenderPipelineGlobalSettings for the given RenderPipeline.
            * @param $renderPipelineType The type of RenderPipeline.
            * @returns RenderPipelineGlobalSettings asset that is registered for the given pipeline. 
            */
            public static GetSettingsForRenderPipeline ($renderPipelineType: System.Type) : UnityEngine.Rendering.RenderPipelineGlobalSettings
            /** Obtains the current active pipeline RenderPipelineGlobalSettings.
            * @param $currentRenderPipelineGlobalSettings The global setting if succeed.
            * @returns True, if the global setting has been found. 
            */
            public static TryGetCurrentRenderPipelineGlobalSettings ($asset: $Ref<UnityEngine.Rendering.RenderPipelineGlobalSettings>) : boolean
        }
        /** A ScriptableObject to associate with a RenderPipeline and store project-wide settings for that Pipeline.
        */
        class RenderPipelineGlobalSettings extends UnityEngine.ScriptableObject implements UnityEngine.ISerializationCallbackReceiver
        {
            protected [__keep_incompatibility]: never;
            /** Editor-only function that initializes the RenderPipelineGlobalSettings.
            * @param $source RenderPipelineGlobalSettings that Unity will copy values from. Optional.
            */
            public Initialize ($source?: UnityEngine.Rendering.RenderPipelineGlobalSettings) : void
            public OnBeforeSerialize () : void
            public OnAfterDeserialize () : void
        }
        interface IRenderPipelineGraphicsSettings
        {
            /** The version where this setting is currently on.
            */
            version : number
            /** If the setting is available in player build.
            */
            isAvailableInPlayerBuild : boolean
        }
        /** The rendering and read/write access mode of a GraphicsTexture.
        */
        enum GraphicsTextureDescriptorFlags
        { None = 0, RenderTarget = 1, RandomWriteTarget = 2 }
        /** Contains all the information Unity uses to create a GraphicsTexture.
        */
        class GraphicsTextureDescriptor extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The width of the GraphicsTexture in pixels when Unity uploads it to the GPU.
            */
            public width : number
            /** The height of the GraphicsTexture in pixels when Unity uploads it to the GPU.
            */
            public height : number
            /** The depth of a 3D GraphicsTexture.
            */
            public depth : number
            /** The number of textures in the GraphicsTexture array.
            */
            public arrayLength : number
            /** The color format for the GraphicsTexture expressed as a GraphicsFormat.
            */
            public format : UnityEngine.Experimental.Rendering.GraphicsFormat
            /** The dimensionality (type) of the GraphicsTexture.
            */
            public dimension : UnityEngine.Rendering.TextureDimension
            /** The number of mipmap levels in this GraphicsTexture.
            */
            public mipCount : number
            /** The number of samples per pixel in the GraphicsTexture.
            */
            public numSamples : number
            /** A set of GraphicsTextureDescriptorFlags that control how the texture can be rendered to or read from.
            */
            public flags : UnityEngine.Rendering.GraphicsTextureDescriptorFlags
        }
        /** The state of a GraphicsTexture.
        */
        enum GraphicsTextureState
        { Constructed = 0, Initializing = 1, InitializedOnRenderThread = 2, DestroyQueued = 3, Destroyed = 4 }
        /** Use the OnDemandRendering class to control and query information about your application's rendering speed independent from all other subsystems (such as physics, input, or animation).
        */
        class OnDemandRendering extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** True if the current frame will be rendered.
            */
            public static get willCurrentFrameRender(): boolean;
            /** Get or set the current frame rate interval. To restore rendering back to the value of Application.targetFrameRate or QualitySettings.vSyncCount set this to 0 or 1.
            */
            public static get renderFrameInterval(): number;
            public static set renderFrameInterval(value: number);
            /** The current estimated rate of rendering in frames per second rounded to the nearest integer.
            */
            public static get effectiveRenderFrameRate(): number;
            public constructor ()
        }
        /** Flags that determine how rays intersect the geometry for each submesh relative to Material type during ray tracing.
        */
        enum RayTracingSubMeshFlags
        { Disabled = 0, Enabled = 1, ClosestHitOnly = 2, UniqueAnyHitCalls = 4 }
        /** Flags used by RayTracingAccelerationStructure.CullInstances.
        */
        enum RayTracingInstanceCullingFlags
        { None = 0, EnableSphereCulling = 1, EnablePlaneCulling = 2, EnableLODCulling = 4, ComputeMaterialsCRC = 8, IgnoreReflectionProbes = 16 }
        /** A testing configuration used in RayTracingAccelerationStructure.CullInstances for adding Renderers to an acceleration structure based on their layer, Rendering.ShadowCastingMode and Material type.
        */
        class RayTracingInstanceCullingTest extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** An instance mask which affects ray-instance masking during ray tracing on the GPU.
            */
            public instanceMask : number
            /** A value that indicates which layers are accepted by this testing configuration.
            */
            public layerMask : number
            /** A value that indicates which Rendering.ShadowCastingMode values are acccepted by this testing configuration.
            */
            public shadowCastingModeMask : number
            /** Whether to allow Renderers that use opaque Materials.
            */
            public allowOpaqueMaterials : boolean
            /** Whether to allow Renderers that use transparent Materials.
            */
            public allowTransparentMaterials : boolean
            /** Whether to allow Renderers that use alpha tested Materials.
            */
            public allowAlphaTestedMaterials : boolean
            /** Whether to allow VFXRenderers.
            */
            public allowVisualEffects : boolean
        }
        /** A Shader Tag configuration used by RayTracingAccelerationStructure.CullInstances to filter and classify Materials.
        */
        class RayTracingInstanceCullingShaderTagConfig extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** A shader tag id. Use ShaderTagId constructor to create one (e.g. ShaderTagId("RenderPipeline").
            */
            public tagId : UnityEngine.Rendering.ShaderTagId
            /** A shader tag id value. Use ShaderTagId constructor to create one (e.g. ShaderTagId("UltraHDRP").
            */
            public tagValueId : UnityEngine.Rendering.ShaderTagId
        }
        /** This structure is used by RayTracingAccelerationStructure.CullInstances function to determine which types of Materials are used by Renderers when populating the acceleration structure with ray tracing instances.
        */
        class RayTracingInstanceMaterialConfig extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The lower limit of a render queue interval.
            */
            public renderQueueLowerBound : number
            /** The upper limit of a render queue interval.
            */
            public renderQueueUpperBound : number
            /** An array of Shader Tags used to determine the Material type.
            */
            public optionalShaderTags : System.Array$1<UnityEngine.Rendering.RayTracingInstanceCullingShaderTagConfig>
            /** An array of Shader Keyword names used to determine the Material type.
            */
            public optionalShaderKeywords : System.Array$1<string>
        }
        /** This structure is used by RayTracingAccelerationStructure.CullInstances function to avoid adding Renderers to the acceleration structure or to ignore individual sub-meshes in a Mesh based on Shaders used by Materials when building the acceleration structure.
        */
        class RayTracingInstanceCullingMaterialTest extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** An array of Shader Pass names used by RayTracingAccelerationStructure.CullInstances to ignore Renderers or individual sub-meshes.
            */
            public deniedShaderPasses : System.Array$1<string>
            /** An array of Shader Tags used by RayTracingAccelerationStructure.CullInstances to ignore Renderers or individual sub-meshes.
            */
            public requiredShaderTags : System.Array$1<UnityEngine.Rendering.RayTracingInstanceCullingShaderTagConfig>
        }
        /** This structure is used by RayTracingAccelerationStructure.CullInstances function to determine triangle culling and vertex winding order for ray tracing instances.
        */
        class RayTracingInstanceTriangleCullingConfig extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** An array of Shader Keywords for defining double-sided geometries.
            */
            public optionalDoubleSidedShaderKeywords : System.Array$1<string>
            /** This property reverses front and back facings triangles, which is useful if for example, the application’s natural winding order differs from the default.
            */
            public frontTriangleCounterClockwise : boolean
            /** Whether to check Material.doubleSidedGI property for determine if a ray tracing instance is considered having double sided geometry.
            */
            public checkDoubleSidedGIMaterial : boolean
            /** Disables triangle culling when rays encounter geometries during acceleration structure traversal on the GPU. All other options that affect triangle culling are ignored.
            */
            public forceDoubleSided : boolean
        }
        /** A structure used by RayTracingAccelerationStructure.CullInstances that defines the RayTracingSubMeshFlags values for different Material types.
        */
        class RayTracingSubMeshFlagsConfig extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The corresponding RayTracingSubMeshFlags value for opaque Materials.
            */
            public opaqueMaterials : UnityEngine.Rendering.RayTracingSubMeshFlags
            /** The corresponding RayTracingSubMeshFlags value for transparent Materials.
            */
            public transparentMaterials : UnityEngine.Rendering.RayTracingSubMeshFlags
            /** The corresponding RayTracingSubMeshFlags value for alpha tested Materials.
            */
            public alphaTestedMaterials : UnityEngine.Rendering.RayTracingSubMeshFlags
        }
        /** Parameters for culling and filtering ray tracing instances in RayTracingAccelerationStructure.CullInstances.
        */
        class RayTracingInstanceCullingConfig extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The flags that control different options in RayTracingAccelerationStructure.CullInstances function.
            */
            public flags : UnityEngine.Rendering.RayTracingInstanceCullingFlags
            /** The center of the sphere used for culling ray tracing instances associated with the Renderers in a Scene.
            */
            public sphereCenter : UnityEngine.Vector3
            /** The radius of the sphere used for culling ray tracing instances associated with the Renderers in a Scene.
            */
            public sphereRadius : number
            /** An array of planes used for culling ray tracing instances associated with the Renderers in a Scene.
            */
            public planes : System.Array$1<UnityEngine.Plane>
            /** An array of RayTracingInstanceCullingTest objects used add Renderers to the acceleration structure based on their layer, Rendering.ShadowCastingMode and Material type.
            */
            public instanceTests : System.Array$1<UnityEngine.Rendering.RayTracingInstanceCullingTest>
            /** A Material-based test used in RayTracingAccelerationStructure.CullInstances.
            */
            public materialTest : UnityEngine.Rendering.RayTracingInstanceCullingMaterialTest
            /** A configuration for defining when a Material is considered being transparent.
            */
            public transparentMaterialConfig : UnityEngine.Rendering.RayTracingInstanceMaterialConfig
            /** A configuration for defining when a Material is considered being alpha tested.
            */
            public alphaTestedMaterialConfig : UnityEngine.Rendering.RayTracingInstanceMaterialConfig
            /** The configuration that defines the RayTracingSubMeshFlags values for different types of Materials.
            */
            public subMeshFlagsConfig : UnityEngine.Rendering.RayTracingSubMeshFlagsConfig
            /** A structure used for specifying ray tracing instance triangle culling options and vertex winding.
            */
            public triangleCullingConfig : UnityEngine.Rendering.RayTracingInstanceTriangleCullingConfig
            /** Parameters used for LOD culling.
            */
            public lodParameters : UnityEngine.Rendering.LODParameters
        }
        /** LODGroup culling parameters.
        */
        class LODParameters extends System.ValueType implements System.IEquatable$1<UnityEngine.Rendering.LODParameters>
        {
            protected [__keep_incompatibility]: never;
            /** Indicates whether camera is orthographic.
            */
            public get isOrthographic(): boolean;
            public set isOrthographic(value: boolean);
            /** Camera position.
            */
            public get cameraPosition(): UnityEngine.Vector3;
            public set cameraPosition(value: UnityEngine.Vector3);
            /** Camera's field of view.
            */
            public get fieldOfView(): number;
            public set fieldOfView(value: number);
            /** Orhographic camera size.
            */
            public get orthoSize(): number;
            public set orthoSize(value: number);
            /** Rendering view height in pixels.
            */
            public get cameraPixelHeight(): number;
            public set cameraPixelHeight(value: number);
            public Equals ($other: UnityEngine.Rendering.LODParameters) : boolean
            public Equals ($obj: any) : boolean
            public static op_Equality ($left: UnityEngine.Rendering.LODParameters, $right: UnityEngine.Rendering.LODParameters) : boolean
            public static op_Inequality ($left: UnityEngine.Rendering.LODParameters, $right: UnityEngine.Rendering.LODParameters) : boolean
        }
        /** A Material instance id and CRC hash value pair. This information is returned by a RayTracingAccelerationStructure.CullInstances call.
        */
        class RayTracingInstanceMaterialCRC extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The Material instance id whose Material CRC was computed during the RayTracingAccelerationStructure.CullInstances call.
            */
            public instanceID : number
            /** The CRC hash value of a Material that was computed during a RayTracingAccelerationStructure.CullInstances call.
            */
            public crc : number
        }
        /** A structure containing results of the culling operation performed by RayTracingAccelerationStructure.CullInstances.
        */
        class RayTracingInstanceCullingResults extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** An array of Material CRC and instance id pairs generated by RayTracingAccelerationStructure.CullInstances when using RayTracingInstanceCullingFlags.ComputeMaterialsCRC flag.
            */
            public materialsCRC : System.Array$1<UnityEngine.Rendering.RayTracingInstanceMaterialCRC>
            /** This property is true if a Renderer in the Scene changed its Transform during the last frame. Renderers that use Ray Tracing Mode Off are not taken into account.
            */
            public transformsChanged : boolean
        }
        /** Parameters you can use to configure ray tracing Mesh instances that are part of a RayTracingAccelerationStructure.
        */
        class RayTracingMeshInstanceConfig extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The Mesh to add to a RayTracingAccelerationStructure.
            */
            public mesh : UnityEngine.Mesh
            /** The index of a sub-mesh when the Mesh contains multiple sub-meshes.
            */
            public subMeshIndex : number
            /** Flags that determine how rays intersect the geometry for each submesh relative to Material type during ray tracing.
            */
            public subMeshFlags : UnityEngine.Rendering.RayTracingSubMeshFlags
            /** Whether Unity considers the geometry animated or not.
            */
            public dynamicGeometry : boolean
            /** The Material the ray tracing instance uses.
            */
            public material : UnityEngine.Material
            /** Additional Material properties to apply onto Material.
            */
            public materialProperties : UnityEngine.MaterialPropertyBlock
            /** Whether front/back face culling for this ray tracing instance is enabled.
            */
            public enableTriangleCulling : boolean
            /** Whether to flip the way triangles face in this ray tracing instance.
            */
            public frontTriangleCounterClockwise : boolean
            /** The used by the ray tracing instance.
            */
            public layer : number
            /** A mask that you can access in HLSL with unity_RenderingLayer built-in shader uniform.
            */
            public renderingLayerMask : number
            /** The ray tracing instance mask.
            */
            public mask : number
            /** Motion vector mode.
            */
            public motionVectorMode : UnityEngine.MotionVectorGenerationMode
            /** The Light probe interpolation type for this instance.
            */
            public lightProbeUsage : UnityEngine.Rendering.LightProbeUsage
            /** The LightProbeProxyVolume the ray tracing instance uses.
            */
            public lightProbeProxyVolume : UnityEngine.LightProbeProxyVolume
            /** The flags Unity uses when it builds the acceleration structure for the geometry referenced by this ray tracing instance configuration.
            */
            public get accelerationStructureBuildFlags(): UnityEngine.Rendering.RayTracingAccelerationStructureBuildFlags;
            public set accelerationStructureBuildFlags(value: UnityEngine.Rendering.RayTracingAccelerationStructureBuildFlags);
            /** Whether to override the build flags specified when creating a RayTracingAccelerationStructure.
            */
            public get accelerationStructureBuildFlagsOverride(): boolean;
            public set accelerationStructureBuildFlagsOverride(value: boolean);
            public constructor ()
            public constructor ($mesh: UnityEngine.Mesh, $subMeshIndex: number, $material: UnityEngine.Material)
        }
        /** The parameters you use to add an instance of ray tracing axis-aligned bounding boxes (AABBs) to a RayTracingAccelerationStructure.
        */
        class RayTracingAABBsInstanceConfig extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The GraphicsBuffer that defines a list of axis-aligned bounding boxes (AABBs).
            */
            public get aabbBuffer(): UnityEngine.GraphicsBuffer;
            public set aabbBuffer(value: UnityEngine.GraphicsBuffer);
            /** The number of AABBs Unity uses when you build the acceleration structure for this ray tracing instance.
            */
            public get aabbCount(): number;
            public set aabbCount(value: number);
            /** The index of the first AABB Unity uses from RayTracingAABBsInstanceConfig.aabbBuffer.
            */
            public get aabbOffset(): number;
            public set aabbOffset(value: number);
            /** Whether the data in RayTracingAABBsInstanceConfig.aabbBuffer is dynamic.
            */
            public get dynamicGeometry(): boolean;
            public set dynamicGeometry(value: boolean);
            /** Determines whether Unity considers the material opaque.
            */
            public get opaqueMaterial(): boolean;
            public set opaqueMaterial(value: boolean);
            /** The Material the ray tracing instance uses.
            */
            public get material(): UnityEngine.Material;
            public set material(value: UnityEngine.Material);
            /** Additional MaterialPropertyBlock properties to apply to the Material.
            */
            public get materialProperties(): UnityEngine.MaterialPropertyBlock;
            public set materialProperties(value: UnityEngine.MaterialPropertyBlock);
            /** The used by the ray tracing instance.
            */
            public get layer(): number;
            public set layer(value: number);
            /** The ray tracing instance mask.
            */
            public get mask(): number;
            public set mask(value: number);
            /** The flags Unity uses when it builds the acceleration structure for the geometry referenced by this ray tracing instance configuration.
            */
            public get accelerationStructureBuildFlags(): UnityEngine.Rendering.RayTracingAccelerationStructureBuildFlags;
            public set accelerationStructureBuildFlags(value: UnityEngine.Rendering.RayTracingAccelerationStructureBuildFlags);
            /** Whether to override the build flags specified when creating a RayTracingAccelerationStructure.
            */
            public get accelerationStructureBuildFlagsOverride(): boolean;
            public set accelerationStructureBuildFlagsOverride(value: boolean);
            public constructor ()
            public constructor ($aabbBuffer: UnityEngine.GraphicsBuffer, $aabbCount: number, $dynamicGeometry: boolean, $material: UnityEngine.Material)
        }
        /** Parameters you can use to configure ray tracing triangle geometry instances that are part of a RayTracingAccelerationStructure.
        */
        class RayTracingGeometryInstanceConfig extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The vertex buffer that Unity uses to define the ray tracing geometry instance.
            */
            public get vertexBuffer(): UnityEngine.GraphicsBuffer;
            public set vertexBuffer(value: UnityEngine.GraphicsBuffer);
            /** An array of vertex attributes that define the vertex format of vertexBuffer.
            */
            public get vertexAttributes(): System.Array$1<UnityEngine.Rendering.VertexAttributeDescriptor>;
            public set vertexAttributes(value: System.Array$1<UnityEngine.Rendering.VertexAttributeDescriptor>);
            /** The index of the first vertex from vertexBuffer that defines this ray tracing geometry instance.
            */
            public get vertexStart(): number;
            public set vertexStart(value: number);
            /** The amount of vertices from vertexBuffer that defines this ray tracing geometry instance.
            */
            public get vertexCount(): number;
            public set vertexCount(value: number);
            /** The index buffer that Unity uses to define the ray tracing geometry instance.
            */
            public get indexBuffer(): UnityEngine.GraphicsBuffer;
            public set indexBuffer(value: UnityEngine.GraphicsBuffer);
            /** The first index from indexBuffer that defines this ray tracing geometry instance.
            */
            public get indexStart(): number;
            public set indexStart(value: number);
            /** The amount of indices from indexBuffer that defines this ray tracing geometry instance.
            */
            public get indexCount(): number;
            public set indexCount(value: number);
            /** Flags that determine the ray-geometry intersection behavior relative to Material type during ray tracing.
            */
            public get subMeshFlags(): UnityEngine.Rendering.RayTracingSubMeshFlags;
            public set subMeshFlags(value: UnityEngine.Rendering.RayTracingSubMeshFlags);
            /** Whether Unity considers the geometry animated or not.
            */
            public get dynamicGeometry(): boolean;
            public set dynamicGeometry(value: boolean);
            /** The Material the ray tracing instance uses.
            */
            public get material(): UnityEngine.Material;
            public set material(value: UnityEngine.Material);
            /** Additional Material properties to apply onto Material.
            */
            public get materialProperties(): UnityEngine.MaterialPropertyBlock;
            public set materialProperties(value: UnityEngine.MaterialPropertyBlock);
            /** Whether front/back face culling for this ray tracing instance is enabled.
            */
            public get enableTriangleCulling(): boolean;
            public set enableTriangleCulling(value: boolean);
            /** Whether to flip the way triangles face in this ray tracing instance.
            */
            public get frontTriangleCounterClockwise(): boolean;
            public set frontTriangleCounterClockwise(value: boolean);
            /** The used by the ray tracing instance.
            */
            public get layer(): number;
            public set layer(value: number);
            /** A mask that you can access in HLSL with unity_RenderingLayer built-in shader uniform.
            */
            public get renderingLayerMask(): number;
            public set renderingLayerMask(value: number);
            /** The ray tracing instance mask.
            */
            public get mask(): number;
            public set mask(value: number);
            /** Motion vector mode.
            */
            public get motionVectorMode(): UnityEngine.MotionVectorGenerationMode;
            public set motionVectorMode(value: UnityEngine.MotionVectorGenerationMode);
            /** The Light probe interpolation type for this instance.
            */
            public get lightProbeUsage(): UnityEngine.Rendering.LightProbeUsage;
            public set lightProbeUsage(value: UnityEngine.Rendering.LightProbeUsage);
            /** The LightProbeProxyVolume the ray tracing instance uses.
            */
            public get lightProbeProxyVolume(): UnityEngine.LightProbeProxyVolume;
            public set lightProbeProxyVolume(value: UnityEngine.LightProbeProxyVolume);
            /** The flags Unity uses when it builds the acceleration structure for the geometry referenced by this ray tracing instance configuration.
            */
            public get accelerationStructureBuildFlags(): UnityEngine.Rendering.RayTracingAccelerationStructureBuildFlags;
            public set accelerationStructureBuildFlags(value: UnityEngine.Rendering.RayTracingAccelerationStructureBuildFlags);
            /** Whether to override the build flags specified when creating a RayTracingAccelerationStructure.
            */
            public get accelerationStructureBuildFlagsOverride(): boolean;
            public set accelerationStructureBuildFlagsOverride(value: boolean);
            public constructor ()
            public constructor ($vertexBuffer: UnityEngine.GraphicsBuffer, $vertexAttributes: System.Array$1<UnityEngine.Rendering.VertexAttributeDescriptor>, $indexBuffer: UnityEngine.GraphicsBuffer, $material: UnityEngine.Material)
        }
        /** A shader for GPU ray tracing.
        */
        class RayTracingShader extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** The maximum number of ray bounces this shader can trace (Read Only).
            */
            public get maxRecursionDepth(): number;
            /** Sets the value of a float uniform.
            * @param $name The name of the property being set.
            * @param $nameID The ID of the property as given by Shader.PropertyToID.
            * @param $val The float value to set.
            */
            public SetFloat ($nameID: number, $val: number) : void
            /** Sets the value of a int uniform.
            * @param $name The name of the property being set.
            * @param $nameID The ID of the property as given by Shader.PropertyToID.
            * @param $val The int value to set.
            */
            public SetInt ($nameID: number, $val: number) : void
            /** Sets the value for a vector uniform.
            * @param $name The name of the property being set.
            * @param $nameID The ID of the property as given by Shader.PropertyToID.
            * @param $val The vector to set.
            */
            public SetVector ($nameID: number, $val: UnityEngine.Vector4) : void
            /** Sets the value of a matrix uniform.
            * @param $name The name of the property being set.
            * @param $nameID The ID of the property as given by Shader.PropertyToID.
            * @param $val The matrix to set.
            */
            public SetMatrix ($nameID: number, $val: UnityEngine.Matrix4x4) : void
            /** Sets a vector array uniform.
            * @param $name The name of the property being set.
            * @param $nameID The ID of the property as given by Shader.PropertyToID.
            * @param $values The array of vectors to set.
            */
            public SetVectorArray ($nameID: number, $values: System.Array$1<UnityEngine.Vector4>) : void
            /** Sets a matrix array uniform.
            * @param $name The name of the property being set.
            * @param $nameID The ID of the property as given by Shader.PropertyToID.
            * @param $values The matrix array to set.
            */
            public SetMatrixArray ($nameID: number, $values: System.Array$1<UnityEngine.Matrix4x4>) : void
            /** Binds a texture resource. This can be a input or an output texture (UAV).
            * @param $nameID The ID of the resource as given by Shader.PropertyToID.
            * @param $name The name of the texture being set.
            * @param $texture The texture to bind.
            */
            public SetTexture ($nameID: number, $texture: UnityEngine.Texture) : void
            /** Binds an input or output compute buffer.
            * @param $nameID The ID of the buffer name in shader code. Use Shader.PropertyToID to get this ID.
            * @param $name The name of the buffer in shader code.
            * @param $buffer The buffer to bind.
            * @param $bufferHandle The handle of the buffer to bind.
            */
            public SetBuffer ($nameID: number, $buffer: UnityEngine.ComputeBuffer) : void
            /** Sets the value for RayTracingAccelerationStructure property of this RayTracingShader.
            * @param $name The name of the RayTracingAccelerationStructure being set.
            * @param $nameID The ID of the RayTracingAccelerationStructure as given by Shader.PropertyToID.
            * @param $accelerationStructure The value to set the RayTracingAccelerationStructure to.
            */
            public SetAccelerationStructure ($nameID: number, $accelerationStructure: UnityEngine.Rendering.RayTracingAccelerationStructure) : void
            /** Selects which Shader Pass to use when executing ray/geometry intersection shaders.
            * @param $passName The Shader Pass to use when executing ray tracing shaders.
            */
            public SetShaderPass ($passName: string) : void
            /** Binds a global texture to a RayTracingShader.
            * @param $nameID The ID of the texture as given by Shader.PropertyToID.
            * @param $name The name of the texture to bind.
            * @param $globalTextureName The name of the global resource to bind to the RayTracingShader.
            * @param $globalTextureNameID The ID of the global resource as given by Shader.PropertyToID.
            */
            public SetTextureFromGlobal ($nameID: number, $globalTextureNameID: number) : void
            /** Dispatches this RayTracingShader.
            * @param $rayGenFunctionName The name of the ray generation shader.
            * @param $width The width of the ray generation shader thread grid.
            * @param $height The height of the ray generation shader thread grid.
            * @param $depth The depth of the ray generation shader thread grid.
            * @param $camera Optional parameter used to setup camera-related built-in shader variables.
            */
            public Dispatch ($rayGenFunctionName: string, $width: number, $height: number, $depth: number, $camera?: UnityEngine.Camera) : void
            /** Binds an input or output compute buffer.
            * @param $nameID The ID of the buffer name in shader code. Use Shader.PropertyToID to get this ID.
            * @param $name The name of the buffer in shader code.
            * @param $buffer The buffer to bind.
            * @param $bufferHandle The handle of the buffer to bind.
            */
            public SetBuffer ($nameID: number, $buffer: UnityEngine.GraphicsBuffer) : void
            /** Binds an input or output compute buffer.
            * @param $nameID The ID of the buffer name in shader code. Use Shader.PropertyToID to get this ID.
            * @param $name The name of the buffer in shader code.
            * @param $buffer The buffer to bind.
            * @param $bufferHandle The handle of the buffer to bind.
            */
            public SetBuffer ($nameID: number, $bufferHandle: UnityEngine.GraphicsBufferHandle) : void
            /** Sets the value of a float uniform.
            * @param $name The name of the property being set.
            * @param $nameID The ID of the property as given by Shader.PropertyToID.
            * @param $val The float value to set.
            */
            public SetFloat ($name: string, $val: number) : void
            /** Sets the value of a int uniform.
            * @param $name The name of the property being set.
            * @param $nameID The ID of the property as given by Shader.PropertyToID.
            * @param $val The int value to set.
            */
            public SetInt ($name: string, $val: number) : void
            /** Sets the value for a vector uniform.
            * @param $name The name of the property being set.
            * @param $nameID The ID of the property as given by Shader.PropertyToID.
            * @param $val The vector to set.
            */
            public SetVector ($name: string, $val: UnityEngine.Vector4) : void
            /** Sets the value of a matrix uniform.
            * @param $name The name of the property being set.
            * @param $nameID The ID of the property as given by Shader.PropertyToID.
            * @param $val The matrix to set.
            */
            public SetMatrix ($name: string, $val: UnityEngine.Matrix4x4) : void
            /** Sets a vector array uniform.
            * @param $name The name of the property being set.
            * @param $nameID The ID of the property as given by Shader.PropertyToID.
            * @param $values The array of vectors to set.
            */
            public SetVectorArray ($name: string, $values: System.Array$1<UnityEngine.Vector4>) : void
            /** Sets a matrix array uniform.
            * @param $name The name of the property being set.
            * @param $nameID The ID of the property as given by Shader.PropertyToID.
            * @param $values The matrix array to set.
            */
            public SetMatrixArray ($name: string, $values: System.Array$1<UnityEngine.Matrix4x4>) : void
            /** Sets the values for a float array uniform.
            * @param $name The name of the property being set.
            * @param $nameID The ID of the property as given by Shader.PropertyToID.
            * @param $values The float array to set.
            */
            public SetFloats ($name: string, ...values: number[]) : void
            /** Sets the values for a float array uniform.
            * @param $name The name of the property being set.
            * @param $nameID The ID of the property as given by Shader.PropertyToID.
            * @param $values The float array to set.
            */
            public SetFloats ($nameID: number, ...values: number[]) : void
            /** Sets the values for a int array uniform.
            * @param $name The name of the property being set.
            * @param $nameID The ID of the property as given by Shader.PropertyToID.
            * @param $values The int array to set.
            */
            public SetInts ($name: string, ...values: number[]) : void
            /** Sets the values for a int array uniform.
            * @param $name The name of the property being set.
            * @param $nameID The ID of the property as given by Shader.PropertyToID.
            * @param $values The int array to set.
            */
            public SetInts ($nameID: number, ...values: number[]) : void
            /** Sets the value of a boolean uniform.
            * @param $name The name of the property being set.
            * @param $nameID The ID of the property as given by Shader.PropertyToID.
            * @param $val The boolean value to set.
            */
            public SetBool ($name: string, $val: boolean) : void
            /** Sets the value of a boolean uniform.
            * @param $name The name of the property being set.
            * @param $nameID The ID of the property as given by Shader.PropertyToID.
            * @param $val The boolean value to set.
            */
            public SetBool ($nameID: number, $val: boolean) : void
            /** Binds a texture resource. This can be a input or an output texture (UAV).
            * @param $nameID The ID of the resource as given by Shader.PropertyToID.
            * @param $name The name of the texture being set.
            * @param $texture The texture to bind.
            */
            public SetTexture ($name: string, $texture: UnityEngine.Texture) : void
            /** Binds an input or output compute buffer.
            * @param $nameID The ID of the buffer name in shader code. Use Shader.PropertyToID to get this ID.
            * @param $name The name of the buffer in shader code.
            * @param $buffer The buffer to bind.
            * @param $bufferHandle The handle of the buffer to bind.
            */
            public SetBuffer ($name: string, $buffer: UnityEngine.ComputeBuffer) : void
            /** Binds an input or output compute buffer.
            * @param $nameID The ID of the buffer name in shader code. Use Shader.PropertyToID to get this ID.
            * @param $name The name of the buffer in shader code.
            * @param $buffer The buffer to bind.
            * @param $bufferHandle The handle of the buffer to bind.
            */
            public SetBuffer ($name: string, $buffer: UnityEngine.GraphicsBuffer) : void
            /** Binds an input or output compute buffer.
            * @param $nameID The ID of the buffer name in shader code. Use Shader.PropertyToID to get this ID.
            * @param $name The name of the buffer in shader code.
            * @param $buffer The buffer to bind.
            * @param $bufferHandle The handle of the buffer to bind.
            */
            public SetBuffer ($name: string, $bufferHandle: UnityEngine.GraphicsBufferHandle) : void
            /** Binds a constant buffer created through a ComputeBuffer or a GraphicsBuffer.
            * @param $nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
            * @param $name The name of the constant buffer in shader code.
            * @param $buffer The buffer to bind as constant buffer.
            * @param $offset The offset in bytes from the beginning of the ComputeBuffer or GraphicsBuffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
            * @param $size The number of bytes to bind.
            */
            public SetConstantBuffer ($nameID: number, $buffer: UnityEngine.ComputeBuffer, $offset: number, $size: number) : void
            /** Binds a constant buffer created through a ComputeBuffer or a GraphicsBuffer.
            * @param $nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
            * @param $name The name of the constant buffer in shader code.
            * @param $buffer The buffer to bind as constant buffer.
            * @param $offset The offset in bytes from the beginning of the ComputeBuffer or GraphicsBuffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
            * @param $size The number of bytes to bind.
            */
            public SetConstantBuffer ($name: string, $buffer: UnityEngine.ComputeBuffer, $offset: number, $size: number) : void
            /** Binds a constant buffer created through a ComputeBuffer or a GraphicsBuffer.
            * @param $nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
            * @param $name The name of the constant buffer in shader code.
            * @param $buffer The buffer to bind as constant buffer.
            * @param $offset The offset in bytes from the beginning of the ComputeBuffer or GraphicsBuffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
            * @param $size The number of bytes to bind.
            */
            public SetConstantBuffer ($nameID: number, $buffer: UnityEngine.GraphicsBuffer, $offset: number, $size: number) : void
            /** Binds a constant buffer created through a ComputeBuffer or a GraphicsBuffer.
            * @param $nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
            * @param $name The name of the constant buffer in shader code.
            * @param $buffer The buffer to bind as constant buffer.
            * @param $offset The offset in bytes from the beginning of the ComputeBuffer or GraphicsBuffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
            * @param $size The number of bytes to bind.
            */
            public SetConstantBuffer ($name: string, $buffer: UnityEngine.GraphicsBuffer, $offset: number, $size: number) : void
            /** Sets the value for RayTracingAccelerationStructure property of this RayTracingShader.
            * @param $name The name of the RayTracingAccelerationStructure being set.
            * @param $nameID The ID of the RayTracingAccelerationStructure as given by Shader.PropertyToID.
            * @param $accelerationStructure The value to set the RayTracingAccelerationStructure to.
            */
            public SetAccelerationStructure ($name: string, $accelerationStructure: UnityEngine.Rendering.RayTracingAccelerationStructure) : void
            /** Binds a global texture to a RayTracingShader.
            * @param $nameID The ID of the texture as given by Shader.PropertyToID.
            * @param $name The name of the texture to bind.
            * @param $globalTextureName The name of the global resource to bind to the RayTracingShader.
            * @param $globalTextureNameID The ID of the global resource as given by Shader.PropertyToID.
            */
            public SetTextureFromGlobal ($name: string, $globalTextureName: string) : void
        }
        /** A declaration of a single color or depth rendering surface to be attached into a RenderPass.
        */
        class AttachmentDescriptor extends System.ValueType implements System.IEquatable$1<UnityEngine.Rendering.AttachmentDescriptor>
        {
            protected [__keep_incompatibility]: never;
            /** The load action to be used on this attachment when the RenderPass starts.
            */
            public get loadAction(): UnityEngine.Rendering.RenderBufferLoadAction;
            public set loadAction(value: UnityEngine.Rendering.RenderBufferLoadAction);
            /** The store action to use with this attachment when the RenderPass ends. Only used when either ConfigureTarget or ConfigureResolveTarget has been called.
            */
            public get storeAction(): UnityEngine.Rendering.RenderBufferStoreAction;
            public set storeAction(value: UnityEngine.Rendering.RenderBufferStoreAction);
            /** The GraphicsFormat of this attachment. To use in place of format.
            */
            public get graphicsFormat(): UnityEngine.Experimental.Rendering.GraphicsFormat;
            public set graphicsFormat(value: UnityEngine.Experimental.Rendering.GraphicsFormat);
            /** The format of this attachment.
            */
            public get format(): UnityEngine.RenderTextureFormat;
            public set format(value: UnityEngine.RenderTextureFormat);
            /** The surface to use as the backing storage for this AttachmentDescriptor.
            */
            public get loadStoreTarget(): UnityEngine.Rendering.RenderTargetIdentifier;
            public set loadStoreTarget(value: UnityEngine.Rendering.RenderTargetIdentifier);
            /** When the renderpass that uses this attachment ends, resolve the MSAA surface into the given target.
            */
            public get resolveTarget(): UnityEngine.Rendering.RenderTargetIdentifier;
            public set resolveTarget(value: UnityEngine.Rendering.RenderTargetIdentifier);
            /** The currently assigned clear color for this attachment. Default is black.
            */
            public get clearColor(): UnityEngine.Color;
            public set clearColor(value: UnityEngine.Color);
            /** Currently assigned depth clear value for this attachment. Default value is 1.0.
            */
            public get clearDepth(): number;
            public set clearDepth(value: number);
            /** Currently assigned stencil clear value for this attachment. Default is 0.
            */
            public get clearStencil(): number;
            public set clearStencil(value: number);
            /** Binds this AttachmentDescriptor to the given target surface.
            * @param $tgt The surface to use as the backing storage for this AttachmentDescriptor.
            * @param $loadExistingContents Whether to read in the existing contents of the surface when the RenderPass starts.
            * @param $storeResults Whether to store the rendering results of the attachment when the RenderPass ends.
            */
            public ConfigureTarget ($target: UnityEngine.Rendering.RenderTargetIdentifier, $loadExistingContents: boolean, $storeResults: boolean) : void
            /** When the renderpass that uses this attachment ends, resolve the MSAA surface into the given target.
            * @param $tgt The target surface to receive the MSAA-resolved pixels.
            */
            public ConfigureResolveTarget ($target: UnityEngine.Rendering.RenderTargetIdentifier) : void
            /** When the RenderPass starts, clear this attachment into the color or depth/stencil values given (depending on the format of this attachment). Changes loadAction to RenderBufferLoadAction.Clear.
            * @param $clearCol Color clear value. Ignored on depth/stencil attachments.
            * @param $clearDep Depth clear value. Ignored on color surfaces.
            * @param $clearStenc Stencil clear value. Ignored on color or depth-only surfaces.
            */
            public ConfigureClear ($clearColor: UnityEngine.Color, $clearDepth?: number, $clearStencil?: number) : void
            public Equals ($other: UnityEngine.Rendering.AttachmentDescriptor) : boolean
            public Equals ($obj: any) : boolean
            public static op_Equality ($left: UnityEngine.Rendering.AttachmentDescriptor, $right: UnityEngine.Rendering.AttachmentDescriptor) : boolean
            public static op_Inequality ($left: UnityEngine.Rendering.AttachmentDescriptor, $right: UnityEngine.Rendering.AttachmentDescriptor) : boolean
            public constructor ($format: UnityEngine.Experimental.Rendering.GraphicsFormat)
            public constructor ($format: UnityEngine.RenderTextureFormat)
            public constructor ($format: UnityEngine.RenderTextureFormat, $target: UnityEngine.Rendering.RenderTargetIdentifier, $loadExistingContents?: boolean, $storeResults?: boolean, $resolve?: boolean)
        }
        /** Structure discribing a single native subpass.
        */
        class SubPassDescriptor extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Array of attachment indices to be used as input attachments in this sub pass. These are specificed as indices into the attachment array passed to CommandBuffer.BeginRenderPass.
            */
            public inputs : UnityEngine.Rendering.AttachmentIndexArray
            /** Array of attachment indices to be used as the color render targets in this sub pass. These are specificed as indices into the attachment array passed to CommandBuffer.BeginRenderPass.
            */
            public colorOutputs : UnityEngine.Rendering.AttachmentIndexArray
            /** Flags controlling specific reading behaviour of depth and stencil attachments.
            */
            public flags : UnityEngine.Rendering.SubPassFlags
        }
        /** Represents a set of visible GameObjects.
        */
        class RendererList extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Returns an empty RendererList.
            */
            public static nullRendererList : UnityEngine.Rendering.RendererList
            /** Indicates whether the RendererList is valid or not. If the RendererList is valid, this returns true. Otherwise, this returns false.
            */
            public get isValid(): boolean;
        }
        /** Static class providing extension methods for CommandBuffer.
        */
        class CommandBufferExtensions extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Adds a command to put a given render target into fast GPU memory.
            * @param $rid The render target to put into fast GPU memory.
            * @param $fastMemoryFlags The memory layout to use if only part of the render target is put into fast GPU memory, either because of the residency parameter or because of fast GPU memory availability.
            * @param $residency The amount of the render target to put into fast GPU memory. Valid values are 0.0f - 1.0f inclusive.
            A value of 0.0f is equal to none of the render target, and a value of 1.0f is equal to the whole render target.
            * @param $copyContents When this value is true, Unity copies the existing contents of the render target into fast memory.
            When this value is false, Unity does not copy the existing contents of the render target into fast memory.
            Set this value to true if you plan to add to the existing contents, and set it to false if you plan to overwrite or clear the existing contents.
            Where possible, set this value to false for better performance.
            */
            public static SwitchIntoFastMemory ($cmd: UnityEngine.Rendering.CommandBuffer, $rid: UnityEngine.Rendering.RenderTargetIdentifier, $fastMemoryFlags: UnityEngine.Rendering.FastMemoryFlags, $residency: number, $copyContents: boolean) : void
            /** Adds a command to remove a given render target from fast GPU memory.
            * @param $rid The render target to remove from fast GPU memory.
            * @param $copyContents When this value is true, Unity copies the existing contents of the render target when it removes it from fast GPU memory. When this value is false, Unity does not copy the existing contents of the render target when it removes it from fast GPU memory. Set this value to true if you plan to add to the existing contents, and set it to false if you plan to overwrite or clear the existing contents. Where possible, set this value to false for better performance.
            */
            public static SwitchOutOfFastMemory ($cmd: UnityEngine.Rendering.CommandBuffer, $rid: UnityEngine.Rendering.RenderTargetIdentifier, $copyContents: boolean) : void
        }
        /** Class that contains extensions for <see cref="IRenderPipelineGraphicsSettings"/>
        */
        class RenderPipelineGraphicsSettingsExtensions extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        /** Provides an interface to the Unity splash screen.
        */
        class SplashScreen extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Returns true once the splash screen has finished. This is once all logos have been shown for their specified duration.
            */
            public static get isFinished(): boolean;
            /** Initializes the splash screen so it is ready to begin drawing. Call this before you start calling Rendering.SplashScreen.Draw. Internally this function resets the timer and prepares the logos for drawing.
            */
            public static Begin () : void
            public static Stop ($stopBehavior: UnityEngine.Rendering.SplashScreen.StopBehavior) : void
            /** Immediately draws the splash screen. Ensure you have called Rendering.SplashScreen.Begin before you start calling this.
            */
            public static Draw () : void
            public constructor ()
        }
        /** Set which render pipelines make a class active.
        */
        class SupportedOnRenderPipelineAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            /** The Render Pipeline Assets that support the attribute.
            */
            public get renderPipelineTypes(): System.Array$1<System.Type>;
            /** The value is true if the current RenderPipelineAsset supports the attribute.
            */
            public get isSupportedOnCurrentPipeline(): boolean;
            /** Use SupportedOnRenderPipelineAttribute.GetSupportedMode to find out whether a RenderPipelineAsset supports the attribute.
            * @param $renderPipelineAssetType The RenderPipelineAsset you want to check.
            * @returns Whether the RenderPipelineAsset or its base RenderPipelineAsset supports the attribute. 
            */
            public GetSupportedMode ($renderPipelineAssetType: System.Type) : UnityEngine.Rendering.SupportedOnRenderPipelineAttribute.SupportedMode
            /** Use this method to determine whether a type has the SupportedOnRenderPipelineAttribute attribute and determine whether a RenderPipelineAsset type supports that attribute.
            * @param $type The type you want to check.
            * @param $renderPipelineAssetType RenderPipelineAsset type.
            * @returns Returns true if the provided type is supported on the provided RenderPipelineAsset type. 
            */
            public static IsTypeSupportedOnRenderPipeline ($type: System.Type, $renderPipelineAssetType: System.Type) : boolean
            public constructor ($renderPipeline: System.Type)
            public constructor (...renderPipeline: System.Type[])
        }
        /** The batch ID.
        */
        class BatchID extends System.ValueType implements System.IEquatable$1<UnityEngine.Rendering.BatchID>
        {
            protected [__keep_incompatibility]: never;
            public static Null : UnityEngine.Rendering.BatchID
            public value : number
            public Equals ($obj: any) : boolean
            public Equals ($other: UnityEngine.Rendering.BatchID) : boolean
            public CompareTo ($other: UnityEngine.Rendering.BatchID) : number
            public static op_Equality ($a: UnityEngine.Rendering.BatchID, $b: UnityEngine.Rendering.BatchID) : boolean
            public static op_Inequality ($a: UnityEngine.Rendering.BatchID, $b: UnityEngine.Rendering.BatchID) : boolean
        }
        /** The batch Material ID.
        */
        class BatchMaterialID extends System.ValueType implements System.IEquatable$1<UnityEngine.Rendering.BatchMaterialID>
        {
            protected [__keep_incompatibility]: never;
            public static Null : UnityEngine.Rendering.BatchMaterialID
            public value : number
            public Equals ($obj: any) : boolean
            public Equals ($other: UnityEngine.Rendering.BatchMaterialID) : boolean
            public CompareTo ($other: UnityEngine.Rendering.BatchMaterialID) : number
            public static op_Equality ($a: UnityEngine.Rendering.BatchMaterialID, $b: UnityEngine.Rendering.BatchMaterialID) : boolean
            public static op_Inequality ($a: UnityEngine.Rendering.BatchMaterialID, $b: UnityEngine.Rendering.BatchMaterialID) : boolean
        }
        /** The batch mesh ID.
        */
        class BatchMeshID extends System.ValueType implements System.IEquatable$1<UnityEngine.Rendering.BatchMeshID>
        {
            protected [__keep_incompatibility]: never;
            public static Null : UnityEngine.Rendering.BatchMeshID
            public value : number
            public Equals ($obj: any) : boolean
            public Equals ($other: UnityEngine.Rendering.BatchMeshID) : boolean
            public CompareTo ($other: UnityEngine.Rendering.BatchMeshID) : number
            public static op_Equality ($a: UnityEngine.Rendering.BatchMeshID, $b: UnityEngine.Rendering.BatchMeshID) : boolean
            public static op_Inequality ($a: UnityEngine.Rendering.BatchMeshID, $b: UnityEngine.Rendering.BatchMeshID) : boolean
        }
        /** Rendering options for the BatchDrawCommand struct.
        */
        enum BatchDrawCommandFlags
        { None = 0, FlipWinding = 1, HasMotion = 2, IsLightMapped = 4, HasSortingPosition = 8, LODCrossFade = 16 }
        /** Additional parameters for the current culling context
        */
        enum BatchCullingFlags
        { None = 0, CullLightmappedShadowCasters = 1 }
        /** The type of an object that is requesting culling.
        */
        enum BatchCullingViewType
        { Unknown = 0, Camera = 1, Light = 2, Picking = 3, SelectionOutline = 4 }
        /** The projection type of a view that is being culled.
        */
        enum BatchCullingProjectionType
        { Unknown = 0, Perspective = 1, Orthographic = 2 }
        /** Expected target for the buffer passed to BatchRendererGroup.AddBatch.
        */
        enum BatchBufferTarget
        { Unknown = 0, UnsupportedByUnderlyingGraphicsApi = -1, RawBuffer = 1, ConstantBuffer = 2 }
        /** The ID of the view from which Unity invoked the culling.
        */
        class BatchPackedCullingViewID extends System.ValueType implements System.IEquatable$1<UnityEngine.Rendering.BatchPackedCullingViewID>
        {
            protected [__keep_incompatibility]: never;
            /** Returns true if the ID in the argument equals this view ID.
            */
            public Equals ($other: UnityEngine.Rendering.BatchPackedCullingViewID) : boolean
            /** Returns true if the ID in the argument equals this view ID.
            */
            public Equals ($obj: any) : boolean
            public static op_Equality ($lhs: UnityEngine.Rendering.BatchPackedCullingViewID, $rhs: UnityEngine.Rendering.BatchPackedCullingViewID) : boolean
            public static op_Inequality ($lhs: UnityEngine.Rendering.BatchPackedCullingViewID, $rhs: UnityEngine.Rendering.BatchPackedCullingViewID) : boolean
            /** Returns the instance ID of the GameObject from which Unity performs the culling (for example, Camera, Light, etc.).
            */
            public GetInstanceID () : number
            /** Returns the slice index of the culled view. The slice index depends on the view type. For cameras, the slice index is always zero. For cascaded shadow maps, it is equal to the index of the cascade.
            */
            public GetSliceIndex () : number
            public constructor ($instanceID: number, $sliceIndex: number)
        }
        /** Represents a draw command for a Rendering.BatchRendererGroup. 
        */
        class BatchDrawCommand extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The index of the element in Rendering.BatchCullingOutputDrawCommands.visibleInstances that matches the first instance in this draw command.
            */
            public visibleOffset : number
            /** The number of instances to draw with this draw command. This must be a value greater than 1.
            */
            public visibleCount : number
            /** The batch ID that this draw command uses. Determines the metadata values that are available to a shader.
            */
            public batchID : UnityEngine.Rendering.BatchID
            /** Identifies which Material to use to render the instances in this draw command.
            */
            public materialID : UnityEngine.Rendering.BatchMaterialID
            /** Identifies which Mesh to use to render the instances in this draw command.
            */
            public meshID : UnityEngine.Rendering.BatchMeshID
            /** Specifies which sub-mesh of the Mesh identified by Rendering.BatchDrawCommand.meshID to use to render the instances in this draw command.
            */
            public submeshIndex : number
            /** Indicates which splits that the draw command is visible in.
            */
            public splitVisibilityMask : number
            /** Specifies rendering options for the draw command.
            */
            public flags : UnityEngine.Rendering.BatchDrawCommandFlags
            /** Together with Rendering.BatchDrawCommand.flags, this specifies how to depth sort the instances in this draw command.
            */
            public sortingPosition : number
        }
        /** Represents settings that Unity applies to draw commands in this Rendering.BatchDrawRange|draw range.
        */
        class BatchFilterSettings extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The rendering layer mask to use for draw commands in this draw range.
            */
            public renderingLayerMask : number
            /** The sorting priority to use for draw commands in this draw range.
            */
            public rendererPriority : number
            /** The layer to use for draw commands in this draw range.
            */
            public layer : number
            /** Specifies how to generate motion vectors in this draw range.
            */
            public get motionMode(): UnityEngine.MotionVectorGenerationMode;
            public set motionMode(value: UnityEngine.MotionVectorGenerationMode);
            /** Specifies how instances from the draw commands in this draw range cast shadows.
            */
            public get shadowCastingMode(): UnityEngine.Rendering.ShadowCastingMode;
            public set shadowCastingMode(value: UnityEngine.Rendering.ShadowCastingMode);
            /** Indicates whether instances from draw commands in this draw range should receive shadows.
            */
            public get receiveShadows(): boolean;
            public set receiveShadows(value: boolean);
            /** Indicates whether instances from the draw commands in this draw range render into cached shadow maps.
            */
            public get staticShadowCaster(): boolean;
            public set staticShadowCaster(value: boolean);
            /** Indicates whether all draw commands in the current draw range have the Rendering.BatchDrawCommandFlags.HasSortingPosition flag set.
            */
            public get allDepthSorted(): boolean;
            public set allDepthSorted(value: boolean);
            /** Use this bit mask to discard the draw commands in a particular context. A draw command is not discarded if the expression (1 << layer) & sceneCullingMask is true. This field is typically used when rendering Editor previews.
            */
            public get sceneCullingMask(): bigint;
            public set sceneCullingMask(value: bigint);
        }
        /** Specifies a draw range of Rendering.BatchFilterSettings|draw commands.
        */
        class BatchDrawRange extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The index of the first Rendering.BatchFilterSettings|draw command inside the Rendering.BatchCullingOutput.drawCommands array that this draw range applies to.
            */
            public drawCommandsBegin : number
            /** The number of Rendering.BatchFilterSettings|draw commands, starting from Rendering.BatchDrawRange.drawCommandsBegin, this draw range applies to.
            */
            public drawCommandsCount : number
            /** The Rendering.BatchFilterSettings that apply to draw commands in this draw range.
            */
            public filterSettings : UnityEngine.Rendering.BatchFilterSettings
        }
        /** Draw commands generated by the culling request.
        */
        class BatchCullingOutputDrawCommands extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The number of elements in the Rendering.BatchCullingOutputDrawCommands.drawCommands array.
            */
            public drawCommandCount : number
            /** The number of elements in the Rendering.BatchCullingOutputDrawCommands.visibleInstances array.
            */
            public visibleInstanceCount : number
            /** The number of elements in the Rendering.BatchCullingOutputDrawCommands.drawRanges array.
            */
            public drawRangeCount : number
            /** If Rendering.BatchDrawCommandFlags.HasSortingPosition is set for one or more draw commands, this contains float3 world-space positions that Unity uses for depth sorting.
            */
            public instanceSortingPositionFloatCount : number
        }
        /** Contains a single metadata value for a batch.
        */
        class MetadataValue extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The name ID of the property that the metadata value is tied to. To specify a value for a property declared with UNITY_DOTS_INSTANCED_PROP(float4, Example), pass Shader.PropertyToID("Example") here.
            */
            public NameID : number
            /** Unity passes this uint32 value to the shader for this property. The value is shared between all instances in the batch.
            Usage example: provide a buffer address for the property.
            */
            public Value : number
        }
        /** This struct contains the properties of a culling split.
        */
        class CullingSplit extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The center of the culling sphere.
            */
            public sphereCenter : UnityEngine.Vector3
            /** The radius of the culling sphere.
            */
            public sphereRadius : number
            /** The index of the first plane in this split in BatchCullingContext.cullingPlanes.
            */
            public cullingPlaneOffset : number
            /** The number of culling planes this split has in BatchCullingContext.cullingPlanes.
            */
            public cullingPlaneCount : number
            /** Cascade blend culling factor.
            */
            public cascadeBlendCullingFactor : number
            /** The near plane distance of the culling frustum.
            */
            public nearPlane : number
            /** Culling matrix.
            */
            public cullingMatrix : UnityEngine.Matrix4x4
        }
        /** Culling context for a batch.
        */
        class BatchCullingContext extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Planes to cull against.
            */
            public cullingPlanes : Unity.Collections.NativeArray$1<UnityEngine.Plane>
            /** The array of CullingSplit structs.
            */
            public cullingSplits : Unity.Collections.NativeArray$1<UnityEngine.Rendering.CullingSplit>
            /** Additional resources: LODParameters.
            */
            public lodParameters : UnityEngine.Rendering.LODParameters
            /** Local to world matrix.
            */
            public localToWorldMatrix : UnityEngine.Matrix4x4
            /** The type of the view from which the culling is invoked. Usage examples: skip culling, take different culling paths depending on the view type, etc.
            */
            public viewType : UnityEngine.Rendering.BatchCullingViewType
            /** The projection of the view from which the culling is invoked. Usage example: take different culling paths for orthographic vs perspective views.
            */
            public projectionType : UnityEngine.Rendering.BatchCullingProjectionType
            /** Additional culling information for the current context.
            */
            public cullingFlags : UnityEngine.Rendering.BatchCullingFlags
            /** The ID of the object from which the culling is invoked. Usage example: store culling-related data for each object.
            */
            public viewID : UnityEngine.Rendering.BatchPackedCullingViewID
            /** The cullingLayerMask value of the object from which the culling is invoked. The draw command is discarded by the internal culling if the expression (1 << layer) & cullingLayerMask is false. Using this field is optional, use it for performance or other optimization purposes.
            */
            public cullingLayerMask : number
            /** Use this bit mask to discard the draw commands in a particular context. A draw command is not discarded if the expression (1 << layer) & sceneCullingMask is true. This field is typically used when rendering Editor previews.
            */
            public sceneCullingMask : bigint
            /** The index of the first receiver plane in the BatchCullingContext.cullingPlanes array.
            */
            public receiverPlaneOffset : number
            /** The number of receiver planes.
            */
            public receiverPlaneCount : number
        }
        /** Contains the output data where OnPerformCulling will write draw commands into.
        */
        class BatchCullingOutput extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** A single-element array of BatchCullingOutputDrawCommands that OnPerformCulling can write into without unnecessary copying.
            */
            public drawCommands : Unity.Collections.NativeArray$1<UnityEngine.Rendering.BatchCullingOutputDrawCommands>
        }
        /** Thread-safe and Burst-safe API for interacting with a BatchRendererGroup from Burst jobs.
        */
        class ThreadedBatchContext extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** An internal handle to the BatchRendererGroup object that created this threaded context.
            */
            public batchRendererGroup : System.IntPtr
            public AddBatch ($batchMetadata: Unity.Collections.NativeArray$1<UnityEngine.Rendering.MetadataValue>, $buffer: UnityEngine.GraphicsBufferHandle) : UnityEngine.Rendering.BatchID
            public AddBatch ($batchMetadata: Unity.Collections.NativeArray$1<UnityEngine.Rendering.MetadataValue>, $buffer: UnityEngine.GraphicsBufferHandle, $bufferOffset: number, $windowSize: number) : UnityEngine.Rendering.BatchID
            /** Change the GraphicsBuffer associated with the given batch. Thread-safe alias for BatchRendererGroup.SetBatchBuffer.
            * @param $batchID Unity changes the batch with this ID.
            * @param $buffer The GraphicsBufferHandle of the GraphicsBuffer to be associated with the batch.
            */
            public SetBatchBuffer ($batchID: UnityEngine.Rendering.BatchID, $buffer: UnityEngine.GraphicsBufferHandle) : void
            /** Thread-safe alias for BatchRendererGroup.RemoveBatch.
            * @param $batchID Unity removes the batch with this ID.
            */
            public RemoveBatch ($batchID: UnityEngine.Rendering.BatchID) : void
        }
        /** A BatchRendererGroup is an object that lets you perform customizable high performance rendering.
        */
        class BatchRendererGroup extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            /** The buffer target BatchRendererGroup.AddBatch accepts for the active graphics API.
            */
            public static get BufferTarget(): UnityEngine.Rendering.BatchBufferTarget;
            /** Deletes a group.
            */
            public Dispose () : void
            /** Get the thread-safe API for interacting with a BatchRendererGroup from Burst jobs.
            * @returns Thread-safe and Burst-safe context. 
            */
            public GetThreadedBatchContext () : UnityEngine.Rendering.ThreadedBatchContext
            public AddBatch ($batchMetadata: Unity.Collections.NativeArray$1<UnityEngine.Rendering.MetadataValue>, $buffer: UnityEngine.GraphicsBufferHandle) : UnityEngine.Rendering.BatchID
            public AddBatch ($batchMetadata: Unity.Collections.NativeArray$1<UnityEngine.Rendering.MetadataValue>, $buffer: UnityEngine.GraphicsBufferHandle, $bufferOffset: number, $windowSize: number) : UnityEngine.Rendering.BatchID
            /** Delete a batch that was previously created with AddBatch.
            * @param $batchID Batch ID.
            */
            public RemoveBatch ($batchID: UnityEngine.Rendering.BatchID) : void
            /** Change the GraphicsBuffer associated with the given batch.
            * @param $batchID Unity changes the batch with this ID.
            * @param $buffer The GraphicsBufferHandle of the GraphicsBuffer to be associated with the batch.
            */
            public SetBatchBuffer ($batchID: UnityEngine.Rendering.BatchID, $buffer: UnityEngine.GraphicsBufferHandle) : void
            /** Registers a Material in BatchRendererGroup and returns its BatchMaterialID. Each registration of a specific Material increases its number of owners by 1.
            * @param $material Unity Material.
            * @returns BatchRendererGroup Material ID. 
            */
            public RegisterMaterial ($material: UnityEngine.Material) : UnityEngine.Rendering.BatchMaterialID
            /** Unregister the Material ID associated with BatchRendererGroup. Each deregistration of a specific Material reduces its number of owners by 1.
            * @param $material BatchRendererGroup Material ID.
            */
            public UnregisterMaterial ($material: UnityEngine.Rendering.BatchMaterialID) : void
            /** Returns the previously registered Material associated with this MaterialID.
            * @param $material BatchRendererGroup Material ID.
            * @returns Unity Material. 
            */
            public GetRegisteredMaterial ($material: UnityEngine.Rendering.BatchMaterialID) : UnityEngine.Material
            /** Registers a mesh in BatchRendererGroup and returns its BatchMeshID. Each registration of a specific mesh increases its number of owners by 1.
            * @param $mesh Unity mesh.
            * @returns BatchRendererGroup mesh ID. 
            */
            public RegisterMesh ($mesh: UnityEngine.Mesh) : UnityEngine.Rendering.BatchMeshID
            /** Unregister the mesh ID associated with BatchRendererGroup. Each deregistration of a specific mesh reduces its number of owners by 1.
            * @param $mesh BatchRendererGroup mesh ID.
            */
            public UnregisterMesh ($mesh: UnityEngine.Rendering.BatchMeshID) : void
            /** Returns the previously registered Mesh associated with this MeshID.
            * @param $mesh BatchRendererGroup Mesh ID.
            * @returns Unity Mesh. 
            */
            public GetRegisteredMesh ($mesh: UnityEngine.Rendering.BatchMeshID) : UnityEngine.Mesh
            /** Set the bounds of the BatchRendererGroup. The bounds should encapsulate the render bounds of every object rendered with this BatchRendererGroup. Unity uses these bounds internally for culling.
            * @param $bounds The center and the size of the global batch bounding box.
            */
            public SetGlobalBounds ($bounds: UnityEngine.Bounds) : void
            /** Set the material that Unity uses to render object picking data using the draw commands in the Scene view.
            * @param $material Unity Material.
            */
            public SetPickingMaterial ($material: UnityEngine.Material) : void
            /** Set the error material for the BatchRendererGroup. This material will be used internally by Unity to render the draw commands referring to erroneous shaders. You can also pass 'null' to this method to unset the material.
            * @param $material The material to display when there is a problem with a shader or material. If this value is null, Unity does not display anything.
            */
            public SetErrorMaterial ($material: UnityEngine.Material) : void
            /** Set the loading material for the BatchRendererGroup.
            * @param $material The material to display while a shader is compiling. If this value is null, Unity does not display anything.
            */
            public SetLoadingMaterial ($material: UnityEngine.Material) : void
            /** Set the combination of BatchCullingViewType for which this BatchRendererGroup should receive an OnPerformCulling callback.
            * @param $viewTypes The BatchCullingViewType array.
            */
            public SetEnabledViewTypes ($viewTypes: System.Array$1<UnityEngine.Rendering.BatchCullingViewType>) : void
            /** Defines the maxiumum amount (in bytes) the BatchRendererGroup constant buffer window size is visible from the shader.
            * @returns The maximum window size in bytes. 
            */
            public static GetConstantBufferMaxWindowSize () : number
            /**
            * @returns The alignment (in bytes) you should use to offset any data in the Uniform Buffer Object (UBO). 
            */
            public static GetConstantBufferOffsetAlignment () : number
            public constructor ($cullingCallback: UnityEngine.Rendering.BatchRendererGroup.OnPerformCulling, $userContext: System.IntPtr)
        }
        /** Flags to indicate specialized native subpass behaviour.
        */
        enum SubPassFlags
        { None = 0, ReadOnlyDepth = 2, ReadOnlyStencil = 4, ReadOnlyDepthStencil = 6 }
        /** Struct encapsulating a fixed list of attachment indices used when declaring native render passes.
        */
        class AttachmentIndexArray extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Utility to declare an empty index array.
            */
            public static Emtpy : UnityEngine.Rendering.AttachmentIndexArray
            /** Maximum number of indices this struct can hold. This is directly tied to the maximum number of attachments in a native render pass (8).
            */
            public static MaxAttachments : number
            /** Number of elements in the AttachmentIndexArrayp.
            */
            public get Length(): number;
            public get_Item ($index: number) : number
            public set_Item ($index: number, $value: number) : void
            public constructor ($numAttachments: number)
            public constructor ($attachments: System.Array$1<number>)
            public constructor ($attachments: Unity.Collections.NativeArray$1<number>)
        }
        /** Values for the blend state.
        */
        class BlendState extends System.ValueType implements System.IEquatable$1<UnityEngine.Rendering.BlendState>
        {
            protected [__keep_incompatibility]: never;
            /** Default values for the blend state.
            */
            public static get defaultValue(): UnityEngine.Rendering.BlendState;
            /** Determines whether each render target uses a separate blend state.
            */
            public get separateMRTBlendStates(): boolean;
            public set separateMRTBlendStates(value: boolean);
            /** Turns on alpha-to-coverage.
            */
            public get alphaToMask(): boolean;
            public set alphaToMask(value: boolean);
            /** Blend state for render target 0.
            */
            public get blendState0(): UnityEngine.Rendering.RenderTargetBlendState;
            public set blendState0(value: UnityEngine.Rendering.RenderTargetBlendState);
            /** Blend state for render target 1.
            */
            public get blendState1(): UnityEngine.Rendering.RenderTargetBlendState;
            public set blendState1(value: UnityEngine.Rendering.RenderTargetBlendState);
            /** Blend state for render target 2.
            */
            public get blendState2(): UnityEngine.Rendering.RenderTargetBlendState;
            public set blendState2(value: UnityEngine.Rendering.RenderTargetBlendState);
            /** Blend state for render target 3.
            */
            public get blendState3(): UnityEngine.Rendering.RenderTargetBlendState;
            public set blendState3(value: UnityEngine.Rendering.RenderTargetBlendState);
            /** Blend state for render target 4.
            */
            public get blendState4(): UnityEngine.Rendering.RenderTargetBlendState;
            public set blendState4(value: UnityEngine.Rendering.RenderTargetBlendState);
            /** Blend state for render target 5.
            */
            public get blendState5(): UnityEngine.Rendering.RenderTargetBlendState;
            public set blendState5(value: UnityEngine.Rendering.RenderTargetBlendState);
            /** Blend state for render target 6.
            */
            public get blendState6(): UnityEngine.Rendering.RenderTargetBlendState;
            public set blendState6(value: UnityEngine.Rendering.RenderTargetBlendState);
            /** Blend state for render target 7.
            */
            public get blendState7(): UnityEngine.Rendering.RenderTargetBlendState;
            public set blendState7(value: UnityEngine.Rendering.RenderTargetBlendState);
            public Equals ($other: UnityEngine.Rendering.BlendState) : boolean
            public Equals ($obj: any) : boolean
            public static op_Equality ($left: UnityEngine.Rendering.BlendState, $right: UnityEngine.Rendering.BlendState) : boolean
            public static op_Inequality ($left: UnityEngine.Rendering.BlendState, $right: UnityEngine.Rendering.BlendState) : boolean
            public constructor ($separateMRTBlend?: boolean, $alphaToMask?: boolean)
        }
        /** Values for the blend state.
        */
        class RenderTargetBlendState extends System.ValueType implements System.IEquatable$1<UnityEngine.Rendering.RenderTargetBlendState>
        {
            protected [__keep_incompatibility]: never;
            /** Default values for the blend state.
            */
            public static get defaultValue(): UnityEngine.Rendering.RenderTargetBlendState;
            /** Specifies which color components will get written into the target framebuffer.
            */
            public get writeMask(): UnityEngine.Rendering.ColorWriteMask;
            public set writeMask(value: UnityEngine.Rendering.ColorWriteMask);
            /** Blend factor used for the color (RGB) channel of the source.
            */
            public get sourceColorBlendMode(): UnityEngine.Rendering.BlendMode;
            public set sourceColorBlendMode(value: UnityEngine.Rendering.BlendMode);
            /** Blend factor used for the color (RGB) channel of the destination.
            */
            public get destinationColorBlendMode(): UnityEngine.Rendering.BlendMode;
            public set destinationColorBlendMode(value: UnityEngine.Rendering.BlendMode);
            /** Blend factor used for the alpha (A) channel of the source.
            */
            public get sourceAlphaBlendMode(): UnityEngine.Rendering.BlendMode;
            public set sourceAlphaBlendMode(value: UnityEngine.Rendering.BlendMode);
            /** Blend factor used for the alpha (A) channel of the destination.
            */
            public get destinationAlphaBlendMode(): UnityEngine.Rendering.BlendMode;
            public set destinationAlphaBlendMode(value: UnityEngine.Rendering.BlendMode);
            /** Operation used for blending the color (RGB) channel.
            */
            public get colorBlendOperation(): UnityEngine.Rendering.BlendOp;
            public set colorBlendOperation(value: UnityEngine.Rendering.BlendOp);
            /** Operation used for blending the alpha (A) channel.
            */
            public get alphaBlendOperation(): UnityEngine.Rendering.BlendOp;
            public set alphaBlendOperation(value: UnityEngine.Rendering.BlendOp);
            public Equals ($other: UnityEngine.Rendering.RenderTargetBlendState) : boolean
            public Equals ($obj: any) : boolean
            public static op_Equality ($left: UnityEngine.Rendering.RenderTargetBlendState, $right: UnityEngine.Rendering.RenderTargetBlendState) : boolean
            public static op_Inequality ($left: UnityEngine.Rendering.RenderTargetBlendState, $right: UnityEngine.Rendering.RenderTargetBlendState) : boolean
            public constructor ($writeMask?: UnityEngine.Rendering.ColorWriteMask, $sourceColorBlendMode?: UnityEngine.Rendering.BlendMode, $destinationColorBlendMode?: UnityEngine.Rendering.BlendMode, $sourceAlphaBlendMode?: UnityEngine.Rendering.BlendMode, $destinationAlphaBlendMode?: UnityEngine.Rendering.BlendMode, $colorBlendOperation?: UnityEngine.Rendering.BlendOp, $alphaBlendOperation?: UnityEngine.Rendering.BlendOp)
        }
        /** Camera related properties in CullingParameters.
        */
        class CameraProperties extends System.ValueType implements System.IEquatable$1<UnityEngine.Rendering.CameraProperties>
        {
            protected [__keep_incompatibility]: never;
            /** Get a shadow culling plane.
            * @param $index Plane index (up to 5).
            * @returns Shadow culling plane. 
            */
            public GetShadowCullingPlane ($index: number) : UnityEngine.Plane
            /** Set a shadow culling plane.
            * @param $index Plane index (up to 5).
            * @param $plane Shadow culling plane.
            */
            public SetShadowCullingPlane ($index: number, $plane: UnityEngine.Plane) : void
            /** Get a camera culling plane.
            * @param $index Plane index (up to 5).
            * @returns Camera culling plane. 
            */
            public GetCameraCullingPlane ($index: number) : UnityEngine.Plane
            /** Set a camera culling plane.
            * @param $index Plane index (up to 5).
            * @param $plane Camera culling plane.
            */
            public SetCameraCullingPlane ($index: number, $plane: UnityEngine.Plane) : void
            public Equals ($other: UnityEngine.Rendering.CameraProperties) : boolean
            public Equals ($obj: any) : boolean
            public static op_Equality ($left: UnityEngine.Rendering.CameraProperties, $right: UnityEngine.Rendering.CameraProperties) : boolean
            public static op_Inequality ($left: UnityEngine.Rendering.CameraProperties, $right: UnityEngine.Rendering.CameraProperties) : boolean
        }
        /** Flags used by ScriptableCullingParameters.cullingOptions to configure a culling operation.
        */
        enum CullingOptions
        { None = 0, ForceEvenIfCameraIsNotActive = 1, OcclusionCull = 2, NeedsLighting = 4, NeedsReflectionProbes = 8, Stereo = 16, DisablePerObjectCulling = 32, ShadowCasters = 64 }
        /** Visible reflection probes sorting options.
        */
        enum ReflectionProbeSortingCriteria
        { None = 0, Importance = 1, Size = 2, ImportanceThenSize = 3 }
        /** This structure contains the information to perform shadow caster culling for a given light.
        */
        class LightShadowCasterCullingInfo extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The range of Rendering.ShadowSplitData to use for this light.
            */
            public splitRange : UnityEngine.RangeInt
            /** The projection type of the shadow-casting light to be rendered. For example, directional light shadow-maps will have orthographic projection. Spot lights will usually have perspective projection, but you might want to implement orthographically-projected box-shaped spot lights in your scriptable renderer pipeline.
            */
            public projectionType : UnityEngine.Rendering.BatchCullingProjectionType
        }
        /** This structure contains the information to perform shadow casters culling for one camera.
        */
        class ShadowCastersCullingInfos extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** An array that works as a buffer to store all the Rendering.ShadowSplitData structs you want to use for shadow casters culling.
            */
            public splitBuffer : Unity.Collections.NativeArray$1<UnityEngine.Rendering.ShadowSplitData>
            /** An array of Rendering.LightShadowCasterCullingInfo.
            */
            public perLightInfos : Unity.Collections.NativeArray$1<UnityEngine.Rendering.LightShadowCasterCullingInfo>
        }
        /** Describes the culling information for a given shadow split (e.g. directional cascade).
        */
        class ShadowSplitData extends System.ValueType implements System.IEquatable$1<UnityEngine.Rendering.ShadowSplitData>
        {
            protected [__keep_incompatibility]: never;
            /** The maximum number of culling planes.
            */
            public static maximumCullingPlaneCount : number
            /** The number of culling planes.
            */
            public get cullingPlaneCount(): number;
            public set cullingPlaneCount(value: number);
            /** The culling sphere.  The first three components of the vector describe the sphere center, and the last component specifies the radius.
            */
            public get cullingSphere(): UnityEngine.Vector4;
            public set cullingSphere(value: UnityEngine.Vector4);
            /** The model view projection matrix Unity uses to cull objects it renders into this shadow map.
            */
            public get cullingMatrix(): UnityEngine.Matrix4x4;
            public set cullingMatrix(value: UnityEngine.Matrix4x4);
            /** The near plane distance that Unity uses to cull objects. Unity transforms the objects with ShadowSplitData.cullingMatrix, and then culls the ones that are farther than the near plane distance.
            */
            public get cullingNearPlane(): number;
            public set cullingNearPlane(value: number);
            /** 
            A multiplier applied to the radius of the culling sphere.
            Values must be in the range 0 to 1. With higher values, Unity culls more objects. Lower makes the cascades share more rendered objects. Using lower values allows blending between different cascades as they then share objects.
            */
            public get shadowCascadeBlendCullingFactor(): number;
            public set shadowCascadeBlendCullingFactor(value: number);
            /** Gets a culling plane.
            * @param $index The culling plane index.
            * @returns The culling plane. 
            */
            public GetCullingPlane ($index: number) : UnityEngine.Plane
            /** Sets a culling plane.
            * @param $index The index of the culling plane to set.
            * @param $plane The culling plane.
            */
            public SetCullingPlane ($index: number, $plane: UnityEngine.Plane) : void
            public Equals ($other: UnityEngine.Rendering.ShadowSplitData) : boolean
            public Equals ($obj: any) : boolean
            public static op_Equality ($left: UnityEngine.Rendering.ShadowSplitData, $right: UnityEngine.Rendering.ShadowSplitData) : boolean
            public static op_Inequality ($left: UnityEngine.Rendering.ShadowSplitData, $right: UnityEngine.Rendering.ShadowSplitData) : boolean
        }
        /** A struct containing the results of a culling operation.
        */
        class CullingResults extends System.ValueType implements System.IEquatable$1<UnityEngine.Rendering.CullingResults>
        {
            protected [__keep_incompatibility]: never;
            /** Array of visible lights.
            */
            public get visibleLights(): Unity.Collections.NativeArray$1<UnityEngine.Rendering.VisibleLight>;
            /** Off-screen lights that still affect visible vertices.
            */
            public get visibleOffscreenVertexLights(): Unity.Collections.NativeArray$1<UnityEngine.Rendering.VisibleLight>;
            /** Array of visible reflection probes.
            */
            public get visibleReflectionProbes(): Unity.Collections.NativeArray$1<UnityEngine.Rendering.VisibleReflectionProbe>;
            /** Gets the number of per-object light indices.
            * @returns The number of per-object light indices. 
            */
            public get lightIndexCount(): number;
            /** Gets the number of per-object reflection probe indices.
            * @returns The number of per-object reflection probe indices. 
            */
            public get reflectionProbeIndexCount(): number;
            /** Gets the number of per-object light and reflection probe indices.
            * @returns The number of per-object light and reflection probe indices. 
            */
            public get lightAndReflectionProbeIndexCount(): number;
            /** Fills a buffer with per-object light indices.
            * @param $computeBuffer The compute buffer object to fill.
            * @param $buffer The buffer object to fill.
            */
            public FillLightAndReflectionProbeIndices ($computeBuffer: UnityEngine.ComputeBuffer) : void
            /** Fills a buffer with per-object light indices.
            * @param $computeBuffer The compute buffer object to fill.
            * @param $buffer The buffer object to fill.
            */
            public FillLightAndReflectionProbeIndices ($buffer: UnityEngine.GraphicsBuffer) : void
            /** If a RenderPipeline sorts or otherwise modifies the VisibleLight list, an index remap will be necessary to properly make use of per-object light lists.
            * @param $allocator The allocator to use.
            * @returns Array of indices that map from VisibleLight indices to internal per-object light list indices. 
            */
            public GetLightIndexMap ($allocator: Unity.Collections.Allocator) : Unity.Collections.NativeArray$1<number>
            public SetLightIndexMap ($lightIndexMap: Unity.Collections.NativeArray$1<number>) : void
            /** If a RenderPipeline sorts or otherwise modifies the VisibleReflectionProbe list, an index remap will be necessary to properly make use of per-object reflection probe lists.
            * @param $allocator The allocator to use.
            * @returns Array of indices that map from VisibleReflectionProbe indices to internal per-object reflection probe list indices. 
            */
            public GetReflectionProbeIndexMap ($allocator: Unity.Collections.Allocator) : Unity.Collections.NativeArray$1<number>
            public SetReflectionProbeIndexMap ($lightIndexMap: Unity.Collections.NativeArray$1<number>) : void
            /** Returns the bounding box that encapsulates the visible shadow casters.  Can be used to, for instance, dynamically adjust cascade ranges.
            * @param $lightIndex The index of the shadow-casting light.
            * @param $outBounds The bounds to be computed.
            * @returns True if the light affects at least one shadow casting object in the Scene. 
            */
            public GetShadowCasterBounds ($lightIndex: number, $outBounds: $Ref<UnityEngine.Bounds>) : boolean
            /** Calculates the view and projection matrices and shadow split data for a spot light.
            * @param $activeLightIndex The index into the active light array.
            * @param $viewMatrix The computed view matrix.
            * @param $projMatrix The computed projection matrix.
            * @param $shadowSplitData The computed split data.
            * @returns If false, the shadow map for this light does not need to be rendered this frame. 
            */
            public ComputeSpotShadowMatricesAndCullingPrimitives ($activeLightIndex: number, $viewMatrix: $Ref<UnityEngine.Matrix4x4>, $projMatrix: $Ref<UnityEngine.Matrix4x4>, $shadowSplitData: $Ref<UnityEngine.Rendering.ShadowSplitData>) : boolean
            /** Calculates the view and projection matrices and shadow split data for a point light.
            * @param $activeLightIndex The index into the active light array.
            * @param $cubemapFace The cubemap face to be rendered.
            * @param $fovBias The amount by which to increase the camera FOV above 90 degrees.
            * @param $viewMatrix The computed view matrix.
            * @param $projMatrix The computed projection matrix.
            * @param $shadowSplitData The computed split data.
            * @returns If false, the shadow map for this light and cubemap face does not need to be rendered this frame. 
            */
            public ComputePointShadowMatricesAndCullingPrimitives ($activeLightIndex: number, $cubemapFace: UnityEngine.CubemapFace, $fovBias: number, $viewMatrix: $Ref<UnityEngine.Matrix4x4>, $projMatrix: $Ref<UnityEngine.Matrix4x4>, $shadowSplitData: $Ref<UnityEngine.Rendering.ShadowSplitData>) : boolean
            /** Calculates the view and projection matrices and shadow split data for a directional light.
            * @param $activeLightIndex The index into the active light array.
            * @param $splitIndex The cascade index.
            * @param $splitCount The number of cascades.
            * @param $splitRatio The cascade ratios.
            * @param $shadowResolution The resolution of the shadowmap.
            * @param $shadowNearPlaneOffset The near plane offset for the light.
            * @param $viewMatrix The computed view matrix.
            * @param $projMatrix The computed projection matrix.
            * @param $shadowSplitData The computed cascade data.
            * @returns If false, the shadow map for this cascade does not need to be rendered this frame. 
            */
            public ComputeDirectionalShadowMatricesAndCullingPrimitives ($activeLightIndex: number, $splitIndex: number, $splitCount: number, $splitRatio: UnityEngine.Vector3, $shadowResolution: number, $shadowNearPlaneOffset: number, $viewMatrix: $Ref<UnityEngine.Matrix4x4>, $projMatrix: $Ref<UnityEngine.Matrix4x4>, $shadowSplitData: $Ref<UnityEngine.Rendering.ShadowSplitData>) : boolean
            public Equals ($other: UnityEngine.Rendering.CullingResults) : boolean
            public Equals ($obj: any) : boolean
            public static op_Equality ($left: UnityEngine.Rendering.CullingResults, $right: UnityEngine.Rendering.CullingResults) : boolean
            public static op_Inequality ($left: UnityEngine.Rendering.CullingResults, $right: UnityEngine.Rendering.CullingResults) : boolean
        }
        /** Holds data of a visible light.
        */
        class VisibleLight extends System.ValueType implements System.IEquatable$1<UnityEngine.Rendering.VisibleLight>
        {
            protected [__keep_incompatibility]: never;
            /** Accessor to Light component.
            */
            public get light(): UnityEngine.Light;
            /** Light type.
            */
            public get lightType(): UnityEngine.LightType;
            public set lightType(value: UnityEngine.LightType);
            /** Light color multiplied by intensity.
            */
            public get finalColor(): UnityEngine.Color;
            public set finalColor(value: UnityEngine.Color);
            /** Light's influence rectangle on screen.
            */
            public get screenRect(): UnityEngine.Rect;
            public set screenRect(value: UnityEngine.Rect);
            /** Light transformation matrix.
            */
            public get localToWorldMatrix(): UnityEngine.Matrix4x4;
            public set localToWorldMatrix(value: UnityEngine.Matrix4x4);
            /** Light range.
            */
            public get range(): number;
            public set range(value: number);
            /** Spot light angle.
            */
            public get spotAngle(): number;
            public set spotAngle(value: number);
            /** Light intersects near clipping plane.
            */
            public get intersectsNearPlane(): boolean;
            public set intersectsNearPlane(value: boolean);
            /** Light intersects far clipping plane.
            */
            public get intersectsFarPlane(): boolean;
            public set intersectsFarPlane(value: boolean);
            public Equals ($other: UnityEngine.Rendering.VisibleLight) : boolean
            public Equals ($obj: any) : boolean
            public static op_Equality ($left: UnityEngine.Rendering.VisibleLight, $right: UnityEngine.Rendering.VisibleLight) : boolean
            public static op_Inequality ($left: UnityEngine.Rendering.VisibleLight, $right: UnityEngine.Rendering.VisibleLight) : boolean
        }
        /** Holds data of a visible reflection reflectionProbe.
        */
        class VisibleReflectionProbe extends System.ValueType implements System.IEquatable$1<UnityEngine.Rendering.VisibleReflectionProbe>
        {
            protected [__keep_incompatibility]: never;
            /** Probe texture.
            */
            public get texture(): UnityEngine.Texture;
            /** Accessor to ReflectionProbe component.
            */
            public get reflectionProbe(): UnityEngine.ReflectionProbe;
            /** The probe's world space axis-aligned bounding box in which the probe can contribute to reflections.
            */
            public get bounds(): UnityEngine.Bounds;
            public set bounds(value: UnityEngine.Bounds);
            /** Probe transformation matrix.
            */
            public get localToWorldMatrix(): UnityEngine.Matrix4x4;
            public set localToWorldMatrix(value: UnityEngine.Matrix4x4);
            /** Shader data for probe HDR texture decoding.
            */
            public get hdrData(): UnityEngine.Vector4;
            public set hdrData(value: UnityEngine.Vector4);
            /** The center of the probe's bounding box in which the probe can contribute to reflections. The center is relative to the position of the probe.
            */
            public get center(): UnityEngine.Vector3;
            public set center(value: UnityEngine.Vector3);
            /** Probe blending distance.
            */
            public get blendDistance(): number;
            public set blendDistance(value: number);
            /** Probe importance.
            */
            public get importance(): number;
            public set importance(value: number);
            /** Should probe use box projection.
            */
            public get isBoxProjection(): boolean;
            public set isBoxProjection(value: boolean);
            public Equals ($other: UnityEngine.Rendering.VisibleReflectionProbe) : boolean
            public Equals ($obj: any) : boolean
            public static op_Equality ($left: UnityEngine.Rendering.VisibleReflectionProbe, $right: UnityEngine.Rendering.VisibleReflectionProbe) : boolean
            public static op_Inequality ($left: UnityEngine.Rendering.VisibleReflectionProbe, $right: UnityEngine.Rendering.VisibleReflectionProbe) : boolean
        }
        /** Values for the depth state.
        */
        class DepthState extends System.ValueType implements System.IEquatable$1<UnityEngine.Rendering.DepthState>
        {
            protected [__keep_incompatibility]: never;
            /** Default values for the depth state.
            */
            public static get defaultValue(): UnityEngine.Rendering.DepthState;
            /** Controls whether pixels from this object are written to the depth buffer.
            */
            public get writeEnabled(): boolean;
            public set writeEnabled(value: boolean);
            /** How should depth testing be performed.
            */
            public get compareFunction(): UnityEngine.Rendering.CompareFunction;
            public set compareFunction(value: UnityEngine.Rendering.CompareFunction);
            public Equals ($other: UnityEngine.Rendering.DepthState) : boolean
            public Equals ($obj: any) : boolean
            public static op_Equality ($left: UnityEngine.Rendering.DepthState, $right: UnityEngine.Rendering.DepthState) : boolean
            public static op_Inequality ($left: UnityEngine.Rendering.DepthState, $right: UnityEngine.Rendering.DepthState) : boolean
            public constructor ($writeEnabled?: boolean, $compareFunction?: UnityEngine.Rendering.CompareFunction)
        }
        /** Settings for ScriptableRenderContext.DrawRenderers.
        */
        class DrawingSettings extends System.ValueType implements System.IEquatable$1<UnityEngine.Rendering.DrawingSettings>
        {
            protected [__keep_incompatibility]: never;
            /** The maxiumum number of passes that can be rendered in 1 DrawRenderers call.
            */
            public static maxShaderPasses : number
            /** How to sort objects during rendering.
            */
            public get sortingSettings(): UnityEngine.Rendering.SortingSettings;
            public set sortingSettings(value: UnityEngine.Rendering.SortingSettings);
            /** What kind of per-object data to setup during rendering.
            */
            public get perObjectData(): UnityEngine.Rendering.PerObjectData;
            public set perObjectData(value: UnityEngine.Rendering.PerObjectData);
            /** Controls whether dynamic batching is enabled.
            */
            public get enableDynamicBatching(): boolean;
            public set enableDynamicBatching(value: boolean);
            /** Controls whether instancing is enabled.
            */
            public get enableInstancing(): boolean;
            public set enableInstancing(value: boolean);
            /** Sets the Material to use for all drawers that would render in this group.
            */
            public get overrideMaterial(): UnityEngine.Material;
            public set overrideMaterial(value: UnityEngine.Material);
            /** Sets the shader to use for all drawers that would render in this group. Override shaders do not override existing material properties.
            */
            public get overrideShader(): UnityEngine.Shader;
            public set overrideShader(value: UnityEngine.Shader);
            /** Selects which pass of the override material to use.
            */
            public get overrideMaterialPassIndex(): number;
            public set overrideMaterialPassIndex(value: number);
            /** Selects which pass of the override shader to use.
            */
            public get overrideShaderPassIndex(): number;
            public set overrideShaderPassIndex(value: number);
            /** Sets the Material to use for any drawers in this group that don't meet the requirements.
            */
            public get fallbackMaterial(): UnityEngine.Material;
            public set fallbackMaterial(value: UnityEngine.Material);
            /** Configures what light should be used as main light.
            */
            public get mainLightIndex(): number;
            public set mainLightIndex(value: number);
            /** Get the name of the shader pass.
            * @param $index Index of the shader pass to use.
            */
            public GetShaderPassName ($index: number) : UnityEngine.Rendering.ShaderTagId
            /** Set the name of the shader pass.
            * @param $index Index of the shader pass to use.
            * @param $shaderPassName Name of the shader pass.
            */
            public SetShaderPassName ($index: number, $shaderPassName: UnityEngine.Rendering.ShaderTagId) : void
            public Equals ($other: UnityEngine.Rendering.DrawingSettings) : boolean
            public Equals ($obj: any) : boolean
            public static op_Equality ($left: UnityEngine.Rendering.DrawingSettings, $right: UnityEngine.Rendering.DrawingSettings) : boolean
            public static op_Inequality ($left: UnityEngine.Rendering.DrawingSettings, $right: UnityEngine.Rendering.DrawingSettings) : boolean
            public constructor ($shaderPassName: UnityEngine.Rendering.ShaderTagId, $sortingSettings: UnityEngine.Rendering.SortingSettings)
        }
        /** This struct describes the methods to sort objects during rendering.
        */
        class SortingSettings extends System.ValueType implements System.IEquatable$1<UnityEngine.Rendering.SortingSettings>
        {
            protected [__keep_incompatibility]: never;
            /** Used to calculate the distance to objects.
            */
            public get worldToCameraMatrix(): UnityEngine.Matrix4x4;
            public set worldToCameraMatrix(value: UnityEngine.Matrix4x4);
            /** Used to calculate the distance to objects.
            */
            public get cameraPosition(): UnityEngine.Vector3;
            public set cameraPosition(value: UnityEngine.Vector3);
            /** Used to calculate distance to objects, by comparing the positions of objects to this axis.
            */
            public get customAxis(): UnityEngine.Vector3;
            public set customAxis(value: UnityEngine.Vector3);
            /** What kind of sorting to do while rendering.
            */
            public get criteria(): UnityEngine.Rendering.SortingCriteria;
            public set criteria(value: UnityEngine.Rendering.SortingCriteria);
            /** Type of sorting to use while rendering.
            */
            public get distanceMetric(): UnityEngine.Rendering.DistanceMetric;
            public set distanceMetric(value: UnityEngine.Rendering.DistanceMetric);
            public Equals ($other: UnityEngine.Rendering.SortingSettings) : boolean
            public Equals ($obj: any) : boolean
            public static op_Equality ($left: UnityEngine.Rendering.SortingSettings, $right: UnityEngine.Rendering.SortingSettings) : boolean
            public static op_Inequality ($left: UnityEngine.Rendering.SortingSettings, $right: UnityEngine.Rendering.SortingSettings) : boolean
            public constructor ($camera: UnityEngine.Camera)
        }
        /** What kind of per-object data to setup during rendering.
        */
        enum PerObjectData
        { None = 0, LightProbe = 1, ReflectionProbes = 2, LightProbeProxyVolume = 4, Lightmaps = 8, LightData = 16, MotionVectors = 32, LightIndices = 64, ReflectionProbeData = 128, OcclusionProbe = 256, OcclusionProbeProxyVolume = 512, ShadowMask = 1024 }
        /** A struct that represents filtering settings for ScriptableRenderContext.DrawRenderers.
        */
        class FilteringSettings extends System.ValueType implements System.IEquatable$1<UnityEngine.Rendering.FilteringSettings>
        {
            protected [__keep_incompatibility]: never;
            /** Creates a FilteringSettings struct that contains default values for all properties. With these default values, Unity does not perform any filtering.
            */
            public static get defaultValue(): UnityEngine.Rendering.FilteringSettings;
            /** Unity renders objects whose Material.renderQueue value is within range specified by this Rendering.RenderQueueRange.
            */
            public get renderQueueRange(): UnityEngine.Rendering.RenderQueueRange;
            public set renderQueueRange(value: UnityEngine.Rendering.RenderQueueRange);
            /** Unity renders objects whose GameObject.layer value is enabled in this bit mask.
            */
            public get layerMask(): number;
            public set layerMask(value: number);
            /** Unity renders objects whose Renderer.renderingLayerMask value is enabled in this bit mask.
            */
            public get renderingLayerMask(): number;
            public set renderingLayerMask(value: number);
            /** Determines if Unity excludes GameObjects that are in motion from rendering. This refers to GameObjects that have an active Motion Vector pass assigned to their Material or have set the Motion Vector mode to per object motion (Menu: Mesh Renderer > Additional Settings > Motion Vectors > Per Object Motion).
            For Unity to exclude a GameObject from rendering, the GameObject must have moved since the last frame. To exclude a GameObject manually, enable a pass.
            */
            public get excludeMotionVectorObjects(): boolean;
            public set excludeMotionVectorObjects(value: boolean);
            /** Unity renders objects whose SortingLayer.value value is within range specified by this Rendering.SortingLayerRange.
            */
            public get sortingLayerRange(): UnityEngine.Rendering.SortingLayerRange;
            public set sortingLayerRange(value: UnityEngine.Rendering.SortingLayerRange);
            public Equals ($other: UnityEngine.Rendering.FilteringSettings) : boolean
            public Equals ($obj: any) : boolean
            public static op_Equality ($left: UnityEngine.Rendering.FilteringSettings, $right: UnityEngine.Rendering.FilteringSettings) : boolean
            public static op_Inequality ($left: UnityEngine.Rendering.FilteringSettings, $right: UnityEngine.Rendering.FilteringSettings) : boolean
            public constructor ($renderQueueRange?: UnityEngine.Rendering.RenderQueueRange | null, $layerMask?: number, $renderingLayerMask?: number, $excludeMotionVectorObjects?: number)
        }
        /** Describes a material render queue range.
        */
        class RenderQueueRange extends System.ValueType implements System.IEquatable$1<UnityEngine.Rendering.RenderQueueRange>
        {
            protected [__keep_incompatibility]: never;
            /** Minimum value that can be used as a bound.
            */
            public static minimumBound : number
            /** Maximum value that can be used as a bound.
            */
            public static maximumBound : number
            /** A range that includes all objects.
            */
            public static get all(): UnityEngine.Rendering.RenderQueueRange;
            /** A range that includes only opaque objects.
            */
            public static get opaque(): UnityEngine.Rendering.RenderQueueRange;
            /** A range that includes only transparent objects.
            */
            public static get transparent(): UnityEngine.Rendering.RenderQueueRange;
            /** Inclusive lower bound for the range.
            */
            public get lowerBound(): number;
            public set lowerBound(value: number);
            /** Inclusive upper bound for the range.
            */
            public get upperBound(): number;
            public set upperBound(value: number);
            public Equals ($other: UnityEngine.Rendering.RenderQueueRange) : boolean
            public Equals ($obj: any) : boolean
            public static op_Equality ($left: UnityEngine.Rendering.RenderQueueRange, $right: UnityEngine.Rendering.RenderQueueRange) : boolean
            public static op_Inequality ($left: UnityEngine.Rendering.RenderQueueRange, $right: UnityEngine.Rendering.RenderQueueRange) : boolean
            public constructor ($lowerBound: number, $upperBound: number)
        }
        /** Describes a renderer's sorting layer range.
        */
        class SortingLayerRange extends System.ValueType implements System.IEquatable$1<UnityEngine.Rendering.SortingLayerRange>
        {
            protected [__keep_incompatibility]: never;
            /** Inclusive lower bound for the range.
            */
            public get lowerBound(): number;
            public set lowerBound(value: number);
            /** Inclusive upper bound for the range.
            */
            public get upperBound(): number;
            public set upperBound(value: number);
            /** A range that includes all objects.
            */
            public static get all(): UnityEngine.Rendering.SortingLayerRange;
            public Equals ($other: UnityEngine.Rendering.SortingLayerRange) : boolean
            public Equals ($obj: any) : boolean
            public static op_Inequality ($lhs: UnityEngine.Rendering.SortingLayerRange, $rhs: UnityEngine.Rendering.SortingLayerRange) : boolean
            public static op_Equality ($lhs: UnityEngine.Rendering.SortingLayerRange, $rhs: UnityEngine.Rendering.SortingLayerRange) : boolean
            public constructor ($lowerBound: number, $upperBound: number)
        }
        /** Specifies whether gizmos render before or after postprocessing for a camera render.
        */
        enum GizmoSubset
        { PreImageEffects = 0, PostImageEffects = 1 }
        /** Exception raised by the Resource Loader on SRP's.
        */
        class InvalidImportException extends System.Exception implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ($message: string)
        }
        /** ObjectId request that can be used to determine the object corresponding to each pixel. Can be submitted using either Camera.SubmitRenderRequest or RenderPipeline.SubmitRenderRequest, and the results can be used either on the CPU in C# or the GPU in a shader.
        */
        class ObjectIdRequest extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** RenderTexture to store the rendering result of the request. The colors in this RenderTexture can be decoded to determine the object that was rendered at each pixel, first by decoding the color to an index using ObjectIdResult.DecodeIdFromColor and then by looking this index up in ObjectIdResult._idToObjectMapping.
            */
            public get destination(): UnityEngine.RenderTexture;
            public set destination(value: UnityEngine.RenderTexture);
            /** Target mipLevel to store the rendering output.
            */
            public get mipLevel(): number;
            public set mipLevel(value: number);
            /** Target Cubemap face to store the rendering result.
            */
            public get face(): UnityEngine.CubemapFace;
            public set face(value: UnityEngine.CubemapFace);
            /** Target slice to store the rendering output.
            */
            public get slice(): number;
            public set slice(value: number);
            /** A result field that is filled when the render request has been submitted and completed, containing the ObjectIdResult._idToObjectMapping that is needed to interpret the color-encoded object IDs that are rendered in the ObjectIdRequest._destination RenderTexture.
            */
            public get result(): UnityEngine.Rendering.ObjectIdResult;
            public constructor ($destination: UnityEngine.RenderTexture, $mipLevel?: number, $face?: UnityEngine.CubemapFace, $slice?: number)
        }
        /** The results of an ObjectIdRequest, stored in ObjectIdRequest._result, containing the ObjectIdResult.idToObjectMapping that is needed to interpret the color-encoded object IDs that are rendered in the ObjectIdRequest._destination RenderTexture.
        */
        class ObjectIdResult extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** 
            An array of Objects that can be used to deterimine the object at each pixel in ObjectIdRequest._destination, first by decoding colors from ObjectIdRequest._destination to an index using ObjectIdResult.DecodeIdFromColor, and then by looking up this index in this array.
            */
            public get idToObjectMapping(): System.Array$1<UnityEngine.Object>;
            /** 
            A utility function that can be used to decode colors from ObjectIdRequest._destination to an index that can then be looked up in ObjectIdResult._idToObjectMapping.
            */
            public static DecodeIdFromColor ($color: UnityEngine.Color) : number
        }
        /** Values for the raster state.
        */
        class RasterState extends System.ValueType implements System.IEquatable$1<UnityEngine.Rendering.RasterState>
        {
            protected [__keep_incompatibility]: never;
            /** Default values for the raster state.
            */
            public static defaultValue : UnityEngine.Rendering.RasterState
            /** Controls which sides of polygons should be culled (not drawn).
            */
            public get cullingMode(): UnityEngine.Rendering.CullMode;
            public set cullingMode(value: UnityEngine.Rendering.CullMode);
            /** Enable clipping based on depth.
            */
            public get depthClip(): boolean;
            public set depthClip(value: boolean);
            /** Enables conservative rasterization. Before using check for support via SystemInfo.supportsConservativeRaster property.
            */
            public get conservative(): boolean;
            public set conservative(value: boolean);
            /** Scales the minimum resolvable depth buffer value in the GPU's depth bias setting.
            */
            public get offsetUnits(): number;
            public set offsetUnits(value: number);
            /** Scales the maximum Z slope in the GPU's depth bias setting.
            */
            public get offsetFactor(): number;
            public set offsetFactor(value: number);
            public Equals ($other: UnityEngine.Rendering.RasterState) : boolean
            public Equals ($obj: any) : boolean
            public static op_Equality ($left: UnityEngine.Rendering.RasterState, $right: UnityEngine.Rendering.RasterState) : boolean
            public static op_Inequality ($left: UnityEngine.Rendering.RasterState, $right: UnityEngine.Rendering.RasterState) : boolean
            public constructor ($cullingMode?: UnityEngine.Rendering.CullMode, $offsetUnits?: number, $offsetFactor?: number, $depthClip?: boolean)
        }
        /** Options that represent the result of a ScriptableRenderContext.QueryRendererList operation.
        */
        enum RendererListStatus
        { kRendererListInvalid = -2, kRendererListProcessing = -1, kRendererListEmpty = 0, kRendererListPopulated = 1 }
        /** Struct holding the arguments that are needed to create a renderers RendererList.
        */
        class RendererListParams extends System.ValueType implements System.IEquatable$1<UnityEngine.Rendering.RendererListParams>
        {
            protected [__keep_incompatibility]: never;
            /** Returns an empty RendererListParams.
            */
            public static Invalid : UnityEngine.Rendering.RendererListParams
            /** The set of visible objects to draw. You typically obtain this from ScriptableRenderContext.Cull.
            */
            public cullingResults : UnityEngine.Rendering.CullingResults
            /** A struct that describes how to draw the objects.
            */
            public drawSettings : UnityEngine.Rendering.DrawingSettings
            /** A struct that describes how to filter the set of visible objects, so that Unity only draws a subset.
            */
            public filteringSettings : UnityEngine.Rendering.FilteringSettings
            /** The name of a.
            */
            public tagName : UnityEngine.Rendering.ShaderTagId
            /** If set to true, tagName specifies a.
            */
            public isPassTagName : boolean
            /** An array of ShaderTagId structs, where the ShaderTagId.name|name is the value of a given.
            */
            public tagValues : Unity.Collections.NativeArray$1<UnityEngine.Rendering.ShaderTagId> | null
            /** An array of structs that describe which parts of the GPU's render state to override.
            */
            public stateBlocks : Unity.Collections.NativeArray$1<UnityEngine.Rendering.RenderStateBlock> | null
            public Equals ($other: UnityEngine.Rendering.RendererListParams) : boolean
            public Equals ($obj: any) : boolean
            public static op_Equality ($left: UnityEngine.Rendering.RendererListParams, $right: UnityEngine.Rendering.RendererListParams) : boolean
            public static op_Inequality ($left: UnityEngine.Rendering.RendererListParams, $right: UnityEngine.Rendering.RendererListParams) : boolean
            public constructor ($cullingResults: UnityEngine.Rendering.CullingResults, $drawSettings: UnityEngine.Rendering.DrawingSettings, $filteringSettings: UnityEngine.Rendering.FilteringSettings)
        }
        /** A set of values that Unity uses to override the GPU's render state.
        */
        class RenderStateBlock extends System.ValueType implements System.IEquatable$1<UnityEngine.Rendering.RenderStateBlock>
        {
            protected [__keep_incompatibility]: never;
            /** Specifies the new blend state.
            */
            public get blendState(): UnityEngine.Rendering.BlendState;
            public set blendState(value: UnityEngine.Rendering.BlendState);
            /** Specifies the new raster state.
            */
            public get rasterState(): UnityEngine.Rendering.RasterState;
            public set rasterState(value: UnityEngine.Rendering.RasterState);
            /** Specifies the new depth state.
            */
            public get depthState(): UnityEngine.Rendering.DepthState;
            public set depthState(value: UnityEngine.Rendering.DepthState);
            /** Specifies the new stencil state.
            */
            public get stencilState(): UnityEngine.Rendering.StencilState;
            public set stencilState(value: UnityEngine.Rendering.StencilState);
            /** The value to be compared against and/or the value to be written to the buffer, based on the stencil state.
            */
            public get stencilReference(): number;
            public set stencilReference(value: number);
            /** Specifies which parts of the GPU's render state to override.
            */
            public get mask(): UnityEngine.Rendering.RenderStateMask;
            public set mask(value: UnityEngine.Rendering.RenderStateMask);
            public Equals ($other: UnityEngine.Rendering.RenderStateBlock) : boolean
            public Equals ($obj: any) : boolean
            public static op_Equality ($left: UnityEngine.Rendering.RenderStateBlock, $right: UnityEngine.Rendering.RenderStateBlock) : boolean
            public static op_Inequality ($left: UnityEngine.Rendering.RenderStateBlock, $right: UnityEngine.Rendering.RenderStateBlock) : boolean
            public constructor ($mask: UnityEngine.Rendering.RenderStateMask)
        }
        /** Defines a series of commands and settings that describes how Unity renders a frame.
        */
        class RenderPipeline extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Returns true when the RenderPipeline is invalid or destroyed.
            */
            public get disposed(): boolean;
            public get defaultSettings(): UnityEngine.Rendering.RenderPipelineGlobalSettings;
        }
        class RenderPipelineAsset$1<TRenderPipeline> extends UnityEngine.Rendering.RenderPipelineAsset
        {
            protected [__keep_incompatibility]: never;
            public get pipelineType(): System.Type;
        }
        /** Render Pipeline manager.
        */
        class RenderPipelineManager extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Returns the active RenderPipeline.
            */
            public static get currentPipeline(): UnityEngine.Rendering.RenderPipeline;
            /** Indicate when Render Pipeline switch is in progress.
            */
            public static get pipelineSwitchCompleted(): boolean;
            public static add_beginFrameRendering ($value: System.Action$2<UnityEngine.Rendering.ScriptableRenderContext, System.Array$1<UnityEngine.Camera>>) : void
            public static remove_beginFrameRendering ($value: System.Action$2<UnityEngine.Rendering.ScriptableRenderContext, System.Array$1<UnityEngine.Camera>>) : void
            public static add_endFrameRendering ($value: System.Action$2<UnityEngine.Rendering.ScriptableRenderContext, System.Array$1<UnityEngine.Camera>>) : void
            public static remove_endFrameRendering ($value: System.Action$2<UnityEngine.Rendering.ScriptableRenderContext, System.Array$1<UnityEngine.Camera>>) : void
            public static add_beginContextRendering ($value: System.Action$2<UnityEngine.Rendering.ScriptableRenderContext, System.Collections.Generic.List$1<UnityEngine.Camera>>) : void
            public static remove_beginContextRendering ($value: System.Action$2<UnityEngine.Rendering.ScriptableRenderContext, System.Collections.Generic.List$1<UnityEngine.Camera>>) : void
            public static add_endContextRendering ($value: System.Action$2<UnityEngine.Rendering.ScriptableRenderContext, System.Collections.Generic.List$1<UnityEngine.Camera>>) : void
            public static remove_endContextRendering ($value: System.Action$2<UnityEngine.Rendering.ScriptableRenderContext, System.Collections.Generic.List$1<UnityEngine.Camera>>) : void
            public static add_beginCameraRendering ($value: System.Action$2<UnityEngine.Rendering.ScriptableRenderContext, UnityEngine.Camera>) : void
            public static remove_beginCameraRendering ($value: System.Action$2<UnityEngine.Rendering.ScriptableRenderContext, UnityEngine.Camera>) : void
            public static add_endCameraRendering ($value: System.Action$2<UnityEngine.Rendering.ScriptableRenderContext, UnityEngine.Camera>) : void
            public static remove_endCameraRendering ($value: System.Action$2<UnityEngine.Rendering.ScriptableRenderContext, UnityEngine.Camera>) : void
            public static add_activeRenderPipelineTypeChanged ($value: System.Action) : void
            public static remove_activeRenderPipelineTypeChanged ($value: System.Action) : void
            public static add_activeRenderPipelineAssetChanged ($value: System.Action$2<UnityEngine.Rendering.RenderPipelineAsset, UnityEngine.Rendering.RenderPipelineAsset>) : void
            public static remove_activeRenderPipelineAssetChanged ($value: System.Action$2<UnityEngine.Rendering.RenderPipelineAsset, UnityEngine.Rendering.RenderPipelineAsset>) : void
            public static add_activeRenderPipelineCreated ($value: System.Action) : void
            public static remove_activeRenderPipelineCreated ($value: System.Action) : void
            public static add_activeRenderPipelineDisposed ($value: System.Action) : void
            public static remove_activeRenderPipelineDisposed ($value: System.Action) : void
        }
        /** Defines state and drawing commands that custom render pipelines use.
        */
        class ScriptableRenderContext extends System.ValueType implements System.IEquatable$1<UnityEngine.Rendering.ScriptableRenderContext>
        {
            protected [__keep_incompatibility]: never;
            /** Emits UI geometry into the Scene view for rendering.
            * @param $cullingCamera Camera to emit the geometry for.
            */
            public static EmitWorldGeometryForSceneView ($cullingCamera: UnityEngine.Camera) : void
            /** Emits UI geometry for rendering for the specified camera.
            * @param $camera Camera to emit the geometry for.
            */
            public static EmitGeometryForCamera ($camera: UnityEngine.Camera) : void
            public BeginRenderPass ($width: number, $height: number, $volumeDepth: number, $samples: number, $attachments: Unity.Collections.NativeArray$1<UnityEngine.Rendering.AttachmentDescriptor>, $depthAttachmentIndex?: number) : void
            public BeginRenderPass ($width: number, $height: number, $samples: number, $attachments: Unity.Collections.NativeArray$1<UnityEngine.Rendering.AttachmentDescriptor>, $depthAttachmentIndex?: number) : void
            public BeginScopedRenderPass ($width: number, $height: number, $samples: number, $attachments: Unity.Collections.NativeArray$1<UnityEngine.Rendering.AttachmentDescriptor>, $depthAttachmentIndex?: number) : UnityEngine.Rendering.ScopedRenderPass
            public BeginSubPass ($colors: Unity.Collections.NativeArray$1<number>, $inputs: Unity.Collections.NativeArray$1<number>, $isDepthReadOnly: boolean, $isStencilReadOnly: boolean) : void
            public BeginSubPass ($colors: Unity.Collections.NativeArray$1<number>, $inputs: Unity.Collections.NativeArray$1<number>, $isDepthStencilReadOnly?: boolean) : void
            public BeginSubPass ($colors: Unity.Collections.NativeArray$1<number>, $isDepthReadOnly: boolean, $isStencilReadOnly: boolean) : void
            public BeginSubPass ($colors: Unity.Collections.NativeArray$1<number>, $isDepthStencilReadOnly?: boolean) : void
            public BeginScopedSubPass ($colors: Unity.Collections.NativeArray$1<number>, $inputs: Unity.Collections.NativeArray$1<number>, $isDepthReadOnly: boolean, $isStencilReadOnly: boolean) : UnityEngine.Rendering.ScopedSubPass
            public BeginScopedSubPass ($colors: Unity.Collections.NativeArray$1<number>, $inputs: Unity.Collections.NativeArray$1<number>, $isDepthStencilReadOnly?: boolean) : UnityEngine.Rendering.ScopedSubPass
            public BeginScopedSubPass ($colors: Unity.Collections.NativeArray$1<number>, $isDepthReadOnly: boolean, $isStencilReadOnly: boolean) : UnityEngine.Rendering.ScopedSubPass
            public BeginScopedSubPass ($colors: Unity.Collections.NativeArray$1<number>, $isDepthStencilReadOnly?: boolean) : UnityEngine.Rendering.ScopedSubPass
            /** Schedules the end of the currently active sub pass.
            */
            public EndSubPass () : void
            /** Schedules the end of a currently active render pass.
            */
            public EndRenderPass () : void
            /** Submits all the scheduled commands to the rendering loop for execution.
            */
            public Submit () : void
            /** This method submits all the scheduled commands to the rendering loop for validation. The validation checks whether render passes that were started with the BeginRenderPass call can execute the scheduled commands.
            */
            public SubmitForRenderPassValidation () : boolean
            /** Check if any objects in the scene have OnRenderObject callbacks registered.
            * @returns True if there are OnRenderObject callbacks false if none. 
            */
            public HasInvokeOnRenderObjectCallbacks () : boolean
            /** Schedules the execution of a custom graphics Command Buffer.
            * @param $commandBuffer Specifies the Command Buffer to execute.
            */
            public ExecuteCommandBuffer ($commandBuffer: UnityEngine.Rendering.CommandBuffer) : void
            /** Schedules the execution of a Command Buffer on an async compute queue. The ComputeQueueType that you pass in determines the queue order.
            * @param $commandBuffer The CommandBuffer to be executed.
            * @param $queueType Describes the desired async compute queue the supplied CommandBuffer should be executed on.
            */
            public ExecuteCommandBufferAsync ($commandBuffer: UnityEngine.Rendering.CommandBuffer, $queueType: UnityEngine.Rendering.ComputeQueueType) : void
            /** Schedules the setup of Camera specific global Shader variables.
            * @param $camera Camera to setup shader variables for.
            * @param $stereoSetup Set up the stereo shader variables and state.
            * @param $eye The current eye to be rendered.
            */
            public SetupCameraProperties ($camera: UnityEngine.Camera, $stereoSetup?: boolean) : void
            /** Schedules the setup of Camera specific global Shader variables.
            * @param $camera Camera to setup shader variables for.
            * @param $stereoSetup Set up the stereo shader variables and state.
            * @param $eye The current eye to be rendered.
            */
            public SetupCameraProperties ($camera: UnityEngine.Camera, $stereoSetup: boolean, $eye: number) : void
            /** Schedule notification of completion of stereo rendering on a single frame.
            * @param $camera Camera to indicate completion of stereo rendering.
            * @param $eye The current eye to be rendered.
            */
            public StereoEndRender ($camera: UnityEngine.Camera) : void
            /** Schedule notification of completion of stereo rendering on a single frame.
            * @param $camera Camera to indicate completion of stereo rendering.
            * @param $eye The current eye to be rendered.
            */
            public StereoEndRender ($camera: UnityEngine.Camera, $eye: number) : void
            /** Schedule notification of completion of stereo rendering on a single frame.
            * @param $camera Camera to indicate completion of stereo rendering.
            * @param $eye The current eye to be rendered.
            */
            public StereoEndRender ($camera: UnityEngine.Camera, $eye: number, $isFinalPass: boolean) : void
            /** Schedules a fine-grained beginning of stereo rendering on the ScriptableRenderContext.
            * @param $camera Camera to enable stereo rendering on.
            * @param $eye The current eye to be rendered.
            */
            public StartMultiEye ($camera: UnityEngine.Camera) : void
            /** Schedules a fine-grained beginning of stereo rendering on the ScriptableRenderContext.
            * @param $camera Camera to enable stereo rendering on.
            * @param $eye The current eye to be rendered.
            */
            public StartMultiEye ($camera: UnityEngine.Camera, $eye: number) : void
            /** Schedules a stop of stereo rendering on the ScriptableRenderContext.
            * @param $camera Camera to disable stereo rendering on.
            */
            public StopMultiEye ($camera: UnityEngine.Camera) : void
            /** Schedules an invocation of the OnRenderObject callback for MonoBehaviour scripts.
            */
            public InvokeOnRenderObjectCallback () : void
            /** Schedules the drawing of a subset of Gizmos (before or after post-processing) for the given Camera.
            * @param $camera The camera of the current view.
            * @param $gizmoSubset Set to GizmoSubset.PreImageEffects to draw Gizmos that should be affected by postprocessing, or GizmoSubset.PostImageEffects to draw Gizmos that should not be affected by postprocessing. See also: GizmoSubset.
            */
            public DrawGizmos ($camera: UnityEngine.Camera, $gizmoSubset: UnityEngine.Rendering.GizmoSubset) : void
            /** Schedules the drawing of a wireframe overlay for a given Scene view Camera.
            * @param $camera The Scene view Camera to draw the overlay for.
            */
            public DrawWireOverlay ($camera: UnityEngine.Camera) : void
            /** Draw the UI overlay.
            * @param $camera The camera of the current view.
            */
            public DrawUIOverlay ($camera: UnityEngine.Camera) : void
            /** Performs culling based on the ScriptableCullingParameters typically obtained from the Camera currently being rendered.
            * @param $parameters Parameters for culling.
            * @returns Culling results. 
            */
            public Cull ($parameters: $Ref<UnityEngine.Rendering.ScriptableCullingParameters>) : UnityEngine.Rendering.CullingResults
            /** Performs shadow casters culling for all the visible lights.
            * @param $cullingResults Culling results to use.
            * @param $infos Shadow casters culling information.
            */
            public CullShadowCasters ($cullingResults: UnityEngine.Rendering.CullingResults, $infos: UnityEngine.Rendering.ShadowCastersCullingInfos) : void
            public Equals ($other: UnityEngine.Rendering.ScriptableRenderContext) : boolean
            public Equals ($obj: any) : boolean
            public static op_Equality ($left: UnityEngine.Rendering.ScriptableRenderContext, $right: UnityEngine.Rendering.ScriptableRenderContext) : boolean
            public static op_Inequality ($left: UnityEngine.Rendering.ScriptableRenderContext, $right: UnityEngine.Rendering.ScriptableRenderContext) : boolean
            /** Creates a new renderers RendererList.
            * @param $desc A high level descriptor that represents the set of GameObjects the RendererList contains.
            * @param $param The parameters used to derive the set of GameObjects the RendererList contains.
            * @returns Returns a new RendererList based on the descriptor or parameters you pass in. 
            */
            public CreateRendererList ($desc: UnityEngine.Rendering.RendererUtils.RendererListDesc) : UnityEngine.Rendering.RendererList
            /** Creates a new renderers RendererList.
            * @param $desc A high level descriptor that represents the set of GameObjects the RendererList contains.
            * @param $param The parameters used to derive the set of GameObjects the RendererList contains.
            * @returns Returns a new RendererList based on the descriptor or parameters you pass in. 
            */
            public CreateRendererList ($param: $Ref<UnityEngine.Rendering.RendererListParams>) : UnityEngine.Rendering.RendererList
            /** Creates a new shadow RendererList.
            * @param $settings The settings used to derive the set of GameObjects the RendererList contains when drawing shadows.
            * @returns Returns a new RendererList based on the settings you pass in. 
            */
            public CreateShadowRendererList ($settings: $Ref<UnityEngine.Rendering.ShadowDrawingSettings>) : UnityEngine.Rendering.RendererList
            /** Creates a new skybox RendererList.
            * @param $camera The camera that is used for rendering the skybox.
            * @param $projectionMatrix The projection matrix used during XR rendering of the skybox.
            * @param $viewMatrix The view matrix used during XR rendering of the skybox.
            * @param $projectionMatrixL The left eye projection matrix used during Legacy single pass XR rendering of the skybox.
            * @param $viewMatrixL The left eye view matrix used during Legacy single pass XR rendering of the skybox.
            * @param $projectionMatrixR The right eye projection matrix used during Legacy single pass XR rendering of the skybox.
            * @param $viewMatrixR The right eye view matrix used during Legacy single pass XR rendering of the skybox.
            * @returns Returns a new RendererList based on the settings you pass in. 
            */
            public CreateSkyboxRendererList ($camera: UnityEngine.Camera, $projectionMatrixL: UnityEngine.Matrix4x4, $viewMatrixL: UnityEngine.Matrix4x4, $projectionMatrixR: UnityEngine.Matrix4x4, $viewMatrixR: UnityEngine.Matrix4x4) : UnityEngine.Rendering.RendererList
            /** Creates a new skybox RendererList.
            * @param $camera The camera that is used for rendering the skybox.
            * @param $projectionMatrix The projection matrix used during XR rendering of the skybox.
            * @param $viewMatrix The view matrix used during XR rendering of the skybox.
            * @param $projectionMatrixL The left eye projection matrix used during Legacy single pass XR rendering of the skybox.
            * @param $viewMatrixL The left eye view matrix used during Legacy single pass XR rendering of the skybox.
            * @param $projectionMatrixR The right eye projection matrix used during Legacy single pass XR rendering of the skybox.
            * @param $viewMatrixR The right eye view matrix used during Legacy single pass XR rendering of the skybox.
            * @returns Returns a new RendererList based on the settings you pass in. 
            */
            public CreateSkyboxRendererList ($camera: UnityEngine.Camera, $projectionMatrix: UnityEngine.Matrix4x4, $viewMatrix: UnityEngine.Matrix4x4) : UnityEngine.Rendering.RendererList
            /** Creates a new skybox RendererList.
            * @param $camera The camera that is used for rendering the skybox.
            * @param $projectionMatrix The projection matrix used during XR rendering of the skybox.
            * @param $viewMatrix The view matrix used during XR rendering of the skybox.
            * @param $projectionMatrixL The left eye projection matrix used during Legacy single pass XR rendering of the skybox.
            * @param $viewMatrixL The left eye view matrix used during Legacy single pass XR rendering of the skybox.
            * @param $projectionMatrixR The right eye projection matrix used during Legacy single pass XR rendering of the skybox.
            * @param $viewMatrixR The right eye view matrix used during Legacy single pass XR rendering of the skybox.
            * @returns Returns a new RendererList based on the settings you pass in. 
            */
            public CreateSkyboxRendererList ($camera: UnityEngine.Camera) : UnityEngine.Rendering.RendererList
            /** Creates a new Gizmo RendererList.
            * @param $camera The camera that is used for rendering the Gizmo.
            * @param $gizmoSubset Specify how gizmos should be rendered.
            * @returns Returns a new RendererList based on the descriptor or parameters you pass in. 
            */
            public CreateGizmoRendererList ($camera: UnityEngine.Camera, $gizmoSubset: UnityEngine.Rendering.GizmoSubset) : UnityEngine.Rendering.RendererList
            /** Creates a new UIOverlay RendererList.
            * @param $camera The camera that is used for rendering the UIOverlay.
            * @returns Returns a new RendererList based on the settings you pass in. 
            */
            public CreateUIOverlayRendererList ($camera: UnityEngine.Camera) : UnityEngine.Rendering.RendererList
            /** Creates a new WireOverlay RendererList.
            * @param $camera The camera that is used for rendering the WireOverlay.
            * @returns Returns a new RendererList based on the settings you pass in. 
            */
            public CreateWireOverlayRendererList ($camera: UnityEngine.Camera) : UnityEngine.Rendering.RendererList
            public PrepareRendererListsAsync ($rendererLists: System.Collections.Generic.List$1<UnityEngine.Rendering.RendererList>) : void
            /** Queries the status of a RendererList.
            * @param $rendererList The RendererList to query.
            * @returns Returns the status of the RendererList. 
            */
            public QueryRendererListStatus ($rendererList: UnityEngine.Rendering.RendererList) : UnityEngine.Rendering.RendererListStatus
        }
        /** Values for the stencil state.
        */
        class StencilState extends System.ValueType implements System.IEquatable$1<UnityEngine.Rendering.StencilState>
        {
            protected [__keep_incompatibility]: never;
            /** Default values for the stencil state.
            */
            public static get defaultValue(): UnityEngine.Rendering.StencilState;
            /** Controls whether the stencil buffer is enabled.
            */
            public get enabled(): boolean;
            public set enabled(value: boolean);
            /** An 8 bit mask as an 0–255 integer, used when comparing the reference value with the contents of the buffer.
            */
            public get readMask(): number;
            public set readMask(value: number);
            /** An 8 bit mask as an 0–255 integer, used when writing to the buffer.
            */
            public get writeMask(): number;
            public set writeMask(value: number);
            /** The function used to compare the reference value to the current contents of the buffer for front-facing geometry.
            */
            public get compareFunctionFront(): UnityEngine.Rendering.CompareFunction;
            public set compareFunctionFront(value: UnityEngine.Rendering.CompareFunction);
            /** What to do with the contents of the buffer if the stencil test (and the depth test) passes for front-facing geometry.
            */
            public get passOperationFront(): UnityEngine.Rendering.StencilOp;
            public set passOperationFront(value: UnityEngine.Rendering.StencilOp);
            /** What to do with the contents of the buffer if the stencil test fails for front-facing geometry.
            */
            public get failOperationFront(): UnityEngine.Rendering.StencilOp;
            public set failOperationFront(value: UnityEngine.Rendering.StencilOp);
            /** What to do with the contents of the buffer if the stencil test passes, but the depth test fails for front-facing geometry.
            */
            public get zFailOperationFront(): UnityEngine.Rendering.StencilOp;
            public set zFailOperationFront(value: UnityEngine.Rendering.StencilOp);
            /** The function used to compare the reference value to the current contents of the buffer for back-facing geometry.
            */
            public get compareFunctionBack(): UnityEngine.Rendering.CompareFunction;
            public set compareFunctionBack(value: UnityEngine.Rendering.CompareFunction);
            /** What to do with the contents of the buffer if the stencil test (and the depth test) passes for back-facing geometry.
            */
            public get passOperationBack(): UnityEngine.Rendering.StencilOp;
            public set passOperationBack(value: UnityEngine.Rendering.StencilOp);
            /** What to do with the contents of the buffer if the stencil test fails for back-facing geometry.
            */
            public get failOperationBack(): UnityEngine.Rendering.StencilOp;
            public set failOperationBack(value: UnityEngine.Rendering.StencilOp);
            /** What to do with the contents of the buffer if the stencil test passes, but the depth test fails for back-facing geometry.
            */
            public get zFailOperationBack(): UnityEngine.Rendering.StencilOp;
            public set zFailOperationBack(value: UnityEngine.Rendering.StencilOp);
            /** The function used to compare the reference value to the current contents of the buffer.
            * @param $value The value to set.
            */
            public SetCompareFunction ($value: UnityEngine.Rendering.CompareFunction) : void
            /** What to do with the contents of the buffer if the stencil test (and the depth test) passes.
            * @param $value The value to set.
            */
            public SetPassOperation ($value: UnityEngine.Rendering.StencilOp) : void
            /** What to do with the contents of the buffer if the stencil test fails.
            * @param $value The value to set.
            */
            public SetFailOperation ($value: UnityEngine.Rendering.StencilOp) : void
            /** What to do with the contents of the buffer if the stencil test passes, but the depth test fails.
            * @param $value The value to set.
            */
            public SetZFailOperation ($value: UnityEngine.Rendering.StencilOp) : void
            public Equals ($other: UnityEngine.Rendering.StencilState) : boolean
            public Equals ($obj: any) : boolean
            public static op_Equality ($left: UnityEngine.Rendering.StencilState, $right: UnityEngine.Rendering.StencilState) : boolean
            public static op_Inequality ($left: UnityEngine.Rendering.StencilState, $right: UnityEngine.Rendering.StencilState) : boolean
            public constructor ($enabled?: boolean, $readMask?: number, $writeMask?: number, $compareFunction?: UnityEngine.Rendering.CompareFunction, $passOperation?: UnityEngine.Rendering.StencilOp, $failOperation?: UnityEngine.Rendering.StencilOp, $zFailOperation?: UnityEngine.Rendering.StencilOp)
            public constructor ($enabled: boolean, $readMask: number, $writeMask: number, $compareFunctionFront: UnityEngine.Rendering.CompareFunction, $passOperationFront: UnityEngine.Rendering.StencilOp, $failOperationFront: UnityEngine.Rendering.StencilOp, $zFailOperationFront: UnityEngine.Rendering.StencilOp, $compareFunctionBack: UnityEngine.Rendering.CompareFunction, $passOperationBack: UnityEngine.Rendering.StencilOp, $failOperationBack: UnityEngine.Rendering.StencilOp, $zFailOperationBack: UnityEngine.Rendering.StencilOp)
        }
        /** Specifies which parts of the render state that is overriden.
        */
        enum RenderStateMask
        { Nothing = 0, Blend = 1, Raster = 2, Depth = 4, Stencil = 8, Everything = 15 }
        /** Represents an active render pass until disposed.
        */
        class ScopedRenderPass extends System.ValueType implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            /** Ends the current render pass in the ScriptableRenderContext that was used to create the ScopedRenderPass.
            */
            public Dispose () : void
        }
        /** Represents an active sub pass until disposed.
        */
        class ScopedSubPass extends System.ValueType implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            /** Ends the current sub pass in the ScriptableRenderContext that was used to create the ScopedSubPass.
            */
            public Dispose () : void
        }
        /** Settings for ScriptableRenderContext.DrawShadows.
        */
        class ShadowDrawingSettings extends System.ValueType implements System.IEquatable$1<UnityEngine.Rendering.ShadowDrawingSettings>
        {
            protected [__keep_incompatibility]: never;
            /** Culling results to use.
            */
            public get cullingResults(): UnityEngine.Rendering.CullingResults;
            public set cullingResults(value: UnityEngine.Rendering.CullingResults);
            /** The index of the shadow-casting light to be rendered.
            */
            public get lightIndex(): number;
            public set lightIndex(value: number);
            /** Set this to true to make Unity filter Renderers during shadow rendering. Unity filters Renderers based on the Rendering Layer Mask of the Renderer itself, and the Rendering Layer Mask of each shadow casting Light.
            */
            public get useRenderingLayerMaskTest(): boolean;
            public set useRenderingLayerMaskTest(value: boolean);
            /** Specifies the filter Unity applies to GameObjects that it renders in the shadow pass.
            */
            public get objectsFilter(): UnityEngine.ShadowObjectsFilter;
            public set objectsFilter(value: UnityEngine.ShadowObjectsFilter);
            public Equals ($other: UnityEngine.Rendering.ShadowDrawingSettings) : boolean
            public Equals ($obj: any) : boolean
            public static op_Equality ($left: UnityEngine.Rendering.ShadowDrawingSettings, $right: UnityEngine.Rendering.ShadowDrawingSettings) : boolean
            public static op_Inequality ($left: UnityEngine.Rendering.ShadowDrawingSettings, $right: UnityEngine.Rendering.ShadowDrawingSettings) : boolean
            public constructor ($cullingResults: UnityEngine.Rendering.CullingResults, $lightIndex: number)
        }
        /** How to sort objects during rendering.
        */
        enum SortingCriteria
        { None = 0, SortingLayer = 1, RenderQueue = 2, BackToFront = 4, QuantizedFrontToBack = 8, OptimizeStateChanges = 16, CanvasOrder = 32, RendererPriority = 64, CommonOpaque = 59, CommonTransparent = 23 }
        /** Type of sorting to use while rendering.
        */
        enum DistanceMetric
        { Perspective = 0, Orthographic = 1, CustomAxis = 2 }
        /** Describes the rendering features supported by a given render pipeline.
        */
        class SupportedRenderingFeatures extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Get / Set a SupportedRenderingFeatures.
            */
            public static get active(): UnityEngine.Rendering.SupportedRenderingFeatures;
            public static set active(value: UnityEngine.Rendering.SupportedRenderingFeatures);
            /** Flags for supported reflection probes.
            */
            public get reflectionProbeModes(): UnityEngine.Rendering.SupportedRenderingFeatures.ReflectionProbeModes;
            public set reflectionProbeModes(value: UnityEngine.Rendering.SupportedRenderingFeatures.ReflectionProbeModes);
            /** This is the fallback mode if the mode the user had previously selected is no longer available. See SupportedRenderingFeatures.mixedLightingModes.
            */
            public get defaultMixedLightingModes(): UnityEngine.Rendering.SupportedRenderingFeatures.LightmapMixedBakeModes;
            public set defaultMixedLightingModes(value: UnityEngine.Rendering.SupportedRenderingFeatures.LightmapMixedBakeModes);
            /** Specifies what LightmapMixedBakeModes that are supported. Please define a SupportedRenderingFeatures.defaultMixedLightingModes in case multiple modes are supported.
            */
            public get mixedLightingModes(): UnityEngine.Rendering.SupportedRenderingFeatures.LightmapMixedBakeModes;
            public set mixedLightingModes(value: UnityEngine.Rendering.SupportedRenderingFeatures.LightmapMixedBakeModes);
            /** What baking types are supported. The unsupported ones will be hidden from the UI. See LightmapBakeType.
            */
            public get lightmapBakeTypes(): UnityEngine.LightmapBakeType;
            public set lightmapBakeTypes(value: UnityEngine.LightmapBakeType);
            /** Specifies what modes are supported. Has to be at least one. See LightmapsMode.
            */
            public get lightmapsModes(): UnityEngine.LightmapsMode;
            public set lightmapsModes(value: UnityEngine.LightmapsMode);
            /** Determines if Enlighten Realtime Global Illumination lightmapper is supported by the currently selected pipeline. If it is not supported, Enlighten-specific settings do not appear in the Editor, which then defaults to the CPU Lightmapper.
            */
            public get enlighten(): boolean;
            public set enlighten(value: boolean);
            /** Are light probe proxy volumes supported?
            */
            public get lightProbeProxyVolumes(): boolean;
            public set lightProbeProxyVolumes(value: boolean);
            /** Are motion vectors supported?
            */
            public get motionVectors(): boolean;
            public set motionVectors(value: boolean);
            /** Can renderers support receiving shadows?
            */
            public get receiveShadows(): boolean;
            public set receiveShadows(value: boolean);
            /** Are reflection probes supported?
            */
            public get reflectionProbes(): boolean;
            public set reflectionProbes(value: boolean);
            /** If this property is true, the blend distance field in the Reflection Probe Inspector window is editable.
            */
            public get reflectionProbesBlendDistance(): boolean;
            public set reflectionProbesBlendDistance(value: boolean);
            /** Determines if the renderer supports renderer priority sorting.
            */
            public get rendererPriority(): boolean;
            public set rendererPriority(value: boolean);
            /** Determines whether the function to render UI overlays is called by SRP and not by the engine.
            */
            public get rendersUIOverlay(): boolean;
            public set rendersUIOverlay(value: boolean);
            /** Determines if the renderer will override the Environment Lighting and will no longer need the built-in UI for it.
            */
            public get overridesEnvironmentLighting(): boolean;
            public set overridesEnvironmentLighting(value: boolean);
            /** Determines if the renderer will override the fog settings in the Lighting Panel and will no longer need the built-in UI for it.
            */
            public get overridesFog(): boolean;
            public set overridesFog(value: boolean);
            /** Specifies whether the render pipeline overrides the real-time Reflection Probes settings in the Quality settings. If It does, the render pipeline does not need the built-in UI for real-time Reflection Probes settings.
            */
            public get overridesRealtimeReflectionProbes(): boolean;
            public set overridesRealtimeReflectionProbes(value: boolean);
            /** Determines if the renderer will override halo and flare settings in the Lighting Panel and will no longer need the built-in UI for it.
            */
            public get overridesOtherLightingSettings(): boolean;
            public set overridesOtherLightingSettings(value: boolean);
            /** Determines whether the Scriptable Render Pipeline will override the default Material’s Render Queue settings and, if true, hides the Render Queue property in the Inspector.
            */
            public get editableMaterialRenderQueue(): boolean;
            public set editableMaterialRenderQueue(value: boolean);
            /** Specifies whether the renderer overrides the LOD bias settings in the Quality Settings Panel. If It does, the renderer does not need the built-in UI for LOD bias settings.
            */
            public get overridesLODBias(): boolean;
            public set overridesLODBias(value: boolean);
            /** Specifies whether the renderer overrides the maximum LOD level settings in the Quality Settings Panel. If It does, the renderer does not need the built-in UI for maximum LOD level settings.
            */
            public get overridesMaximumLODLevel(): boolean;
            public set overridesMaximumLODLevel(value: boolean);
            /** Specifies whether the renderer overrides the Enable LOD Cross Fade settings in the Quality Settings Panel. If It does, the renderer does not need the built-in UI for Enable LOD Cross Fade settings.
            */
            public get overridesEnableLODCrossFade(): boolean;
            public set overridesEnableLODCrossFade(value: boolean);
            /** Determines whether the Renderer supports probe lighting.
            */
            public get rendererProbes(): boolean;
            public set rendererProbes(value: boolean);
            /** Determines if the renderer supports Particle System GPU instancing.
            */
            public get particleSystemInstancing(): boolean;
            public set particleSystemInstancing(value: boolean);
            /** Determines if this renderer supports ambient probe baking.
            */
            public get ambientProbeBaking(): boolean;
            public set ambientProbeBaking(value: boolean);
            /** Specifies whether this renderer bakes a default Reflection Probe.
            */
            public get defaultReflectionProbeBaking(): boolean;
            public set defaultReflectionProbeBaking(value: boolean);
            /** Specifies whether the render pipeline overrides the Shadowmask settings in the Quality settings.
            */
            public get overridesShadowmask(): boolean;
            public set overridesShadowmask(value: boolean);
            /** Determines if the renderer will override the light probe system with a different one.
            */
            public get overridesLightProbeSystem(): boolean;
            public set overridesLightProbeSystem(value: boolean);
            /** If True, the renderer supports HDR display output.
            */
            public get supportsHDR(): boolean;
            public set supportsHDR(value: boolean);
            /** If True, the renderer supports cloud layers or volumetric clouds.
            */
            public get supportsClouds(): boolean;
            public set supportsClouds(value: boolean);
            /** The message to display in the LightProbeGroup editor if the light probe system is overridden by the renderer.
            */
            public get overridesLightProbeSystemWarningMessage(): string;
            public set overridesLightProbeSystemWarningMessage(value: string);
            public constructor ()
        }
        /** Type of a shader keyword, eg: built-in or user defined.
        */
        enum ShaderKeywordType
        { None = 0, BuiltinDefault = 2, BuiltinExtra = 6, BuiltinAutoStripped = 10, UserDefined = 16, Plugin = 32 }
        /** Represents an identifier of a specific Pass in a Shader.
        */
        class PassIdentifier extends System.ValueType implements System.IEquatable$1<UnityEngine.Rendering.PassIdentifier>
        {
            protected [__keep_incompatibility]: never;
            /** The index of the subshader within the shader (Read Only).
            */
            public get SubshaderIndex(): number;
            /** The index of the pass within the subshader (Read Only).
            */
            public get PassIndex(): number;
            public Equals ($o: any) : boolean
            public Equals ($rhs: UnityEngine.Rendering.PassIdentifier) : boolean
            public static op_Equality ($lhs: UnityEngine.Rendering.PassIdentifier, $rhs: UnityEngine.Rendering.PassIdentifier) : boolean
            public static op_Inequality ($lhs: UnityEngine.Rendering.PassIdentifier, $rhs: UnityEngine.Rendering.PassIdentifier) : boolean
            public constructor ($subshaderIndex: number, $passIndex: number)
        }
        /** A collection of Rendering.ShaderKeyword that represents a specific platform variant.
        */
        class PlatformKeywordSet extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Check whether a specific shader keyword is enabled.
            */
            public IsEnabled ($define: UnityEngine.Rendering.BuiltinShaderDefine) : boolean
            public Enable ($define: UnityEngine.Rendering.BuiltinShaderDefine) : void
            public Disable ($define: UnityEngine.Rendering.BuiltinShaderDefine) : void
        }
        /** Represents an identifier for a specific code path in a shader.
        */
        class ShaderKeyword extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The name of the shader keyword. (Read Only)
            */
            public get name(): string;
            /** The index of the shader keyword.
            */
            public get index(): number;
            /** Returns the type of global keyword: built-in or user defined.
            */
            public static GetGlobalKeywordType ($index: UnityEngine.Rendering.ShaderKeyword) : UnityEngine.Rendering.ShaderKeywordType
            /** Returns true if the keyword is local.
            */
            public static IsKeywordLocal ($keyword: UnityEngine.Rendering.ShaderKeyword) : boolean
            /** Checks whether the global shader keyword exists.
            * @returns Returns true if the global shader keyword exists. Otherwise, returns false. 
            */
            public IsValid () : boolean
            /** Checks whether the shader keyword exists in the compute shader you pass in.
            * @param $shader The shader that declares the keyword.
            * @returns Returns true if the shader keyword exists. Otherwise, returns false. 
            */
            public IsValid ($shader: UnityEngine.ComputeShader) : boolean
            /** Checks whether the shader keyword exists in the shader you pass in.
            * @param $shader The shader that declares the keyword.
            * @returns Returns true if the shader keyword exists. Otherwise, returns false. 
            */
            public IsValid ($shader: UnityEngine.Shader) : boolean
            public constructor ($keywordName: string)
            public constructor ($shader: UnityEngine.Shader, $keywordName: string)
            public constructor ($shader: UnityEngine.ComputeShader, $keywordName: string)
        }
        /** A collection of Rendering.ShaderKeyword that represents a specific shader variant.
        */
        class ShaderKeywordSet extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Check whether a specific shader keyword is enabled.
            */
            public IsEnabled ($keyword: UnityEngine.Rendering.ShaderKeyword) : boolean
            /** Check whether a specific shader keyword is enabled.
            */
            public IsEnabled ($keyword: UnityEngine.Rendering.GlobalKeyword) : boolean
            /** Check whether a specific shader keyword is enabled.
            */
            public IsEnabled ($keyword: UnityEngine.Rendering.LocalKeyword) : boolean
            /** Enable a specific shader keyword.
            */
            public Enable ($keyword: UnityEngine.Rendering.ShaderKeyword) : void
            /** Disable a specific shader keyword.
            */
            public Disable ($keyword: UnityEngine.Rendering.ShaderKeyword) : void
            /** Return an array with all the enabled keywords in the ShaderKeywordSet.
            */
            public GetShaderKeywords () : System.Array$1<UnityEngine.Rendering.ShaderKeyword>
        }
        /** Adding a SortingGroup component to a GameObject will ensure that all Renderers within the GameObject's descendants will be sorted and rendered together.
        */
        class SortingGroup extends UnityEngine.Behaviour
        {
            protected [__keep_incompatibility]: never;
            /** Name of the Renderer's sorting layer.
            */
            public get sortingLayerName(): string;
            public set sortingLayerName(value: string);
            /** Unique ID of the Renderer's sorting layer.
            */
            public get sortingLayerID(): number;
            public set sortingLayerID(value: number);
            /** Renderer's order within a sorting layer.
            */
            public get sortingOrder(): number;
            public set sortingOrder(value: number);
            /** Ignores any parent SortingGroup and sorts this and its descendant Renderers against other Renderers at the root level.
            */
            public get sortAtRoot(): boolean;
            public set sortAtRoot(value: boolean);
            /** Updates all Sorting Group immediately.
            */
            public static UpdateAllSortingGroups () : void
            public constructor ()
        }
    }
    namespace UnityEngine.SceneManagement {
        /** Run-time data structure for *.unity file.
        */
        class Scene extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get handle(): number;
            /** Returns the relative path of the Scene. For example: "AssetsMyScenesMyScene.unity".
            */
            public get path(): string;
            /** Returns the name of the Scene that is currently active in the game or app.
            */
            public get name(): string;
            public set name(value: string);
            /** IsLoaded is set to true after loading has completed and objects have been enabled.
            */
            public get isLoaded(): boolean;
            /** Return the index of the Scene in the Build Settings.
            */
            public get buildIndex(): number;
            /** Returns true if the Scene is modified.
            */
            public get isDirty(): boolean;
            /** The number of root transforms of this Scene.
            */
            public get rootCount(): number;
            public get isSubScene(): boolean;
            public set isSubScene(value: boolean);
            /** Whether this is a valid Scene.
            A Scene may be invalid if, for example, you tried to open a Scene that does not exist. In this case, the Scene returned from EditorSceneManager.OpenScene would return False for IsValid.
            * @returns Whether this is a valid Scene. 
            */
            public IsValid () : boolean
            /** Returns all the root game objects in the Scene.
            * @returns An array of game objects. 
            */
            public GetRootGameObjects () : System.Array$1<UnityEngine.GameObject>
            public GetRootGameObjects ($rootGameObjects: System.Collections.Generic.List$1<UnityEngine.GameObject>) : void
            public static op_Equality ($lhs: UnityEngine.SceneManagement.Scene, $rhs: UnityEngine.SceneManagement.Scene) : boolean
            public static op_Inequality ($lhs: UnityEngine.SceneManagement.Scene, $rhs: UnityEngine.SceneManagement.Scene) : boolean
        }
        /** Derive from this base class to provide alternative implementations to the C# behavior of specific SceneManagement.SceneManager methods.
        */
        class SceneManagerAPI extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** The specific SceneManagement.SceneManagerAPI instance to use to handle overridden SceneManagement.SceneManager methods.
            */
            public static get overrideAPI(): UnityEngine.SceneManagement.SceneManagerAPI;
            public static set overrideAPI(value: UnityEngine.SceneManagement.SceneManagerAPI);
        }
        /** Scene management at run-time.
        */
        class SceneManager extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** The current number of Scenes.
            */
            public static get sceneCount(): number;
            /** The number of loaded Scenes.
            */
            public static get loadedSceneCount(): number;
            /** Number of Scenes in Build Settings.
            */
            public static get sceneCountInBuildSettings(): number;
            /** Gets the currently active Scene.
            * @returns The active Scene. 
            */
            public static GetActiveScene () : UnityEngine.SceneManagement.Scene
            /** Set the Scene to be active.
            * @param $scene The Scene to be set.
            * @returns Returns false if the Scene is not loaded yet. 
            */
            public static SetActiveScene ($scene: UnityEngine.SceneManagement.Scene) : boolean
            /** Searches all Scenes loaded for a Scene that has the given asset path.
            * @param $scenePath Path of the Scene. Should be relative to the project folder. Like: "AssetsMyScenesMyScene.unity".
            * @returns A reference to the Scene, if valid. If not, an invalid Scene is returned. 
            */
            public static GetSceneByPath ($scenePath: string) : UnityEngine.SceneManagement.Scene
            /** Searches through the Scenes loaded for a Scene with the given name.
            * @param $name Name of Scene to find.
            * @returns A reference to the Scene, if valid. If not, an invalid Scene is returned. 
            */
            public static GetSceneByName ($name: string) : UnityEngine.SceneManagement.Scene
            /** Get a Scene struct from a build index.
            * @param $buildIndex Build index as shown in the Build Settings window.
            * @returns A reference to the Scene, if valid. If not, an invalid Scene is returned. 
            */
            public static GetSceneByBuildIndex ($buildIndex: number) : UnityEngine.SceneManagement.Scene
            /** Get the Scene at index in the SceneManager's list of loaded Scenes.
            * @param $index Index of the Scene to get. Index must be greater than or equal to 0 and less than SceneManager.sceneCount.
            * @returns A reference to the Scene at the index specified. 
            */
            public static GetSceneAt ($index: number) : UnityEngine.SceneManagement.Scene
            /** Create an empty new Scene at runtime with the given name.
            * @param $sceneName The name of the new Scene. It cannot be empty or null, or same as the name of the existing Scenes.
            * @param $parameters Various parameters used to create the Scene.
            * @returns A reference to the new Scene that was created, or an invalid Scene if creation failed. 
            */
            public static CreateScene ($sceneName: string, $parameters: UnityEngine.SceneManagement.CreateSceneParameters) : UnityEngine.SceneManagement.Scene
            /** This will merge the source Scene into the destinationScene.
            * @param $sourceScene The Scene that will be merged into the destination Scene.
            * @param $destinationScene Existing Scene to merge the source Scene into.
            */
            public static MergeScenes ($sourceScene: UnityEngine.SceneManagement.Scene, $destinationScene: UnityEngine.SceneManagement.Scene) : void
            /** Move a GameObject from its current Scene to a new Scene.
            * @param $go GameObject to move.
            * @param $scene Scene to move into.
            */
            public static MoveGameObjectToScene ($go: UnityEngine.GameObject, $scene: UnityEngine.SceneManagement.Scene) : void
            public static MoveGameObjectsToScene ($instanceIDs: Unity.Collections.NativeArray$1<number>, $scene: UnityEngine.SceneManagement.Scene) : void
            public static add_sceneLoaded ($value: UnityEngine.Events.UnityAction$2<UnityEngine.SceneManagement.Scene, UnityEngine.SceneManagement.LoadSceneMode>) : void
            public static remove_sceneLoaded ($value: UnityEngine.Events.UnityAction$2<UnityEngine.SceneManagement.Scene, UnityEngine.SceneManagement.LoadSceneMode>) : void
            public static add_sceneUnloaded ($value: UnityEngine.Events.UnityAction$1<UnityEngine.SceneManagement.Scene>) : void
            public static remove_sceneUnloaded ($value: UnityEngine.Events.UnityAction$1<UnityEngine.SceneManagement.Scene>) : void
            public static add_activeSceneChanged ($value: UnityEngine.Events.UnityAction$2<UnityEngine.SceneManagement.Scene, UnityEngine.SceneManagement.Scene>) : void
            public static remove_activeSceneChanged ($value: UnityEngine.Events.UnityAction$2<UnityEngine.SceneManagement.Scene, UnityEngine.SceneManagement.Scene>) : void
            /** Create an empty new Scene at runtime with the given name.
            * @param $sceneName The name of the new Scene. It cannot be empty or null, or same as the name of the existing Scenes.
            * @param $parameters Various parameters used to create the Scene.
            * @returns A reference to the new Scene that was created, or an invalid Scene if creation failed. 
            */
            public static CreateScene ($sceneName: string) : UnityEngine.SceneManagement.Scene
            /** Loads the Scene by its name or index in Build Settings.
            * @param $sceneName Name or path of the Scene to load.
            * @param $sceneBuildIndex Index of the Scene in the Build Settings to load.
            * @param $mode Allows you to specify whether or not to load the Scene additively. See SceneManagement.LoadSceneMode for more information about the options.
            */
            public static LoadScene ($sceneName: string, $mode: UnityEngine.SceneManagement.LoadSceneMode) : void
            public static LoadScene ($sceneName: string) : void
            /** Loads the Scene by its name or index in Build Settings.
            * @param $sceneName Name or path of the Scene to load.
            * @param $sceneBuildIndex Index of the Scene in the Build Settings to load.
            * @param $parameters Various parameters used to load the Scene.
            * @returns A handle to the Scene being loaded. 
            */
            public static LoadScene ($sceneName: string, $parameters: UnityEngine.SceneManagement.LoadSceneParameters) : UnityEngine.SceneManagement.Scene
            /** Loads the Scene by its name or index in Build Settings.
            * @param $sceneName Name or path of the Scene to load.
            * @param $sceneBuildIndex Index of the Scene in the Build Settings to load.
            * @param $mode Allows you to specify whether or not to load the Scene additively. See SceneManagement.LoadSceneMode for more information about the options.
            */
            public static LoadScene ($sceneBuildIndex: number, $mode: UnityEngine.SceneManagement.LoadSceneMode) : void
            public static LoadScene ($sceneBuildIndex: number) : void
            /** Loads the Scene by its name or index in Build Settings.
            * @param $sceneName Name or path of the Scene to load.
            * @param $sceneBuildIndex Index of the Scene in the Build Settings to load.
            * @param $parameters Various parameters used to load the Scene.
            * @returns A handle to the Scene being loaded. 
            */
            public static LoadScene ($sceneBuildIndex: number, $parameters: UnityEngine.SceneManagement.LoadSceneParameters) : UnityEngine.SceneManagement.Scene
            /** Loads the Scene asynchronously in the background.
            * @param $sceneName Name or path of the Scene to load.
            * @param $sceneBuildIndex Index of the Scene in the Build Settings to load.
            * @param $mode If LoadSceneMode.Single then all current Scenes will be unloaded before loading.
            * @param $parameters Struct that collects the various parameters into a single place except for the name and index.
            * @returns Use the AsyncOperation to determine if the operation has completed. 
            */
            public static LoadSceneAsync ($sceneBuildIndex: number, $mode: UnityEngine.SceneManagement.LoadSceneMode) : UnityEngine.AsyncOperation
            public static LoadSceneAsync ($sceneBuildIndex: number) : UnityEngine.AsyncOperation
            /** Loads the Scene asynchronously in the background.
            * @param $sceneName Name or path of the Scene to load.
            * @param $sceneBuildIndex Index of the Scene in the Build Settings to load.
            * @param $mode If LoadSceneMode.Single then all current Scenes will be unloaded before loading.
            * @param $parameters Struct that collects the various parameters into a single place except for the name and index.
            * @returns Use the AsyncOperation to determine if the operation has completed. 
            */
            public static LoadSceneAsync ($sceneBuildIndex: number, $parameters: UnityEngine.SceneManagement.LoadSceneParameters) : UnityEngine.AsyncOperation
            /** Loads the Scene asynchronously in the background.
            * @param $sceneName Name or path of the Scene to load.
            * @param $sceneBuildIndex Index of the Scene in the Build Settings to load.
            * @param $mode If LoadSceneMode.Single then all current Scenes will be unloaded before loading.
            * @param $parameters Struct that collects the various parameters into a single place except for the name and index.
            * @returns Use the AsyncOperation to determine if the operation has completed. 
            */
            public static LoadSceneAsync ($sceneName: string, $mode: UnityEngine.SceneManagement.LoadSceneMode) : UnityEngine.AsyncOperation
            public static LoadSceneAsync ($sceneName: string) : UnityEngine.AsyncOperation
            /** Loads the Scene asynchronously in the background.
            * @param $sceneName Name or path of the Scene to load.
            * @param $sceneBuildIndex Index of the Scene in the Build Settings to load.
            * @param $mode If LoadSceneMode.Single then all current Scenes will be unloaded before loading.
            * @param $parameters Struct that collects the various parameters into a single place except for the name and index.
            * @returns Use the AsyncOperation to determine if the operation has completed. 
            */
            public static LoadSceneAsync ($sceneName: string, $parameters: UnityEngine.SceneManagement.LoadSceneParameters) : UnityEngine.AsyncOperation
            /** Destroys all GameObjects associated with the given Scene and removes the Scene from the SceneManager.
            * @param $sceneBuildIndex Index of the Scene in BuildSettings.
            * @param $sceneName Name or path of the Scene to unload.
            * @param $scene Scene to unload.
            * @param $options Scene unloading options.
            * @returns Use the AsyncOperation to determine if the operation has completed. 
            */
            public static UnloadSceneAsync ($sceneBuildIndex: number) : UnityEngine.AsyncOperation
            /** Destroys all GameObjects associated with the given Scene and removes the Scene from the SceneManager.
            * @param $sceneBuildIndex Index of the Scene in BuildSettings.
            * @param $sceneName Name or path of the Scene to unload.
            * @param $scene Scene to unload.
            * @param $options Scene unloading options.
            * @returns Use the AsyncOperation to determine if the operation has completed. 
            */
            public static UnloadSceneAsync ($sceneName: string) : UnityEngine.AsyncOperation
            /** Destroys all GameObjects associated with the given Scene and removes the Scene from the SceneManager.
            * @param $sceneBuildIndex Index of the Scene in BuildSettings.
            * @param $sceneName Name or path of the Scene to unload.
            * @param $scene Scene to unload.
            * @param $options Scene unloading options.
            * @returns Use the AsyncOperation to determine if the operation has completed. 
            */
            public static UnloadSceneAsync ($scene: UnityEngine.SceneManagement.Scene) : UnityEngine.AsyncOperation
            /** Destroys all GameObjects associated with the given Scene and removes the Scene from the SceneManager.
            * @param $sceneBuildIndex Index of the Scene in BuildSettings.
            * @param $sceneName Name or path of the Scene to unload.
            * @param $scene Scene to unload.
            * @param $options Scene unloading options.
            * @returns Use the AsyncOperation to determine if the operation has completed. 
            */
            public static UnloadSceneAsync ($sceneBuildIndex: number, $options: UnityEngine.SceneManagement.UnloadSceneOptions) : UnityEngine.AsyncOperation
            /** Destroys all GameObjects associated with the given Scene and removes the Scene from the SceneManager.
            * @param $sceneBuildIndex Index of the Scene in BuildSettings.
            * @param $sceneName Name or path of the Scene to unload.
            * @param $scene Scene to unload.
            * @param $options Scene unloading options.
            * @returns Use the AsyncOperation to determine if the operation has completed. 
            */
            public static UnloadSceneAsync ($sceneName: string, $options: UnityEngine.SceneManagement.UnloadSceneOptions) : UnityEngine.AsyncOperation
            /** Destroys all GameObjects associated with the given Scene and removes the Scene from the SceneManager.
            * @param $sceneBuildIndex Index of the Scene in BuildSettings.
            * @param $sceneName Name or path of the Scene to unload.
            * @param $scene Scene to unload.
            * @param $options Scene unloading options.
            * @returns Use the AsyncOperation to determine if the operation has completed. 
            */
            public static UnloadSceneAsync ($scene: UnityEngine.SceneManagement.Scene, $options: UnityEngine.SceneManagement.UnloadSceneOptions) : UnityEngine.AsyncOperation
            public constructor ()
        }
        /** This struct collects all the CreateScene parameters in to a single place.
        */
        class CreateSceneParameters extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** See SceneManagement.LocalPhysicsMode.
            */
            public get localPhysicsMode(): UnityEngine.SceneManagement.LocalPhysicsMode;
            public set localPhysicsMode(value: UnityEngine.SceneManagement.LocalPhysicsMode);
            public constructor ($physicsMode: UnityEngine.SceneManagement.LocalPhysicsMode)
        }
        /** Used when loading a Scene in a player.
        */
        enum LoadSceneMode
        { Single = 0, Additive = 1 }
        /** This struct collects all the LoadScene parameters in to a single place.
        */
        class LoadSceneParameters extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** See LoadSceneMode.
            */
            public get loadSceneMode(): UnityEngine.SceneManagement.LoadSceneMode;
            public set loadSceneMode(value: UnityEngine.SceneManagement.LoadSceneMode);
            /** See SceneManagement.LocalPhysicsMode.
            */
            public get localPhysicsMode(): UnityEngine.SceneManagement.LocalPhysicsMode;
            public set localPhysicsMode(value: UnityEngine.SceneManagement.LocalPhysicsMode);
            public constructor ($mode: UnityEngine.SceneManagement.LoadSceneMode)
            public constructor ($mode: UnityEngine.SceneManagement.LoadSceneMode, $physicsMode: UnityEngine.SceneManagement.LocalPhysicsMode)
        }
        /** Scene unloading options passed to SceneManager.UnloadScene.
        */
        enum UnloadSceneOptions
        { None = 0, UnloadAllEmbeddedSceneObjects = 1 }
        /** Provides options for 2D and 3D local physics.
        */
        enum LocalPhysicsMode
        { None = 0, Physics2D = 1, Physics3D = 2 }
        /** Scene and Build Settings related utilities.
        */
        class SceneUtility extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Get the Scene path from a build index.
            * @returns Scene path (e.g "AssetsScenesScene1.unity"). 
            */
            public static GetScenePathByBuildIndex ($buildIndex: number) : string
            /** Get the build index from a Scene path.
            * @param $scenePath Scene path (e.g: "AssetsScenesScene1.unity").
            * @returns Build index. 
            */
            public static GetBuildIndexByScenePath ($scenePath: string) : number
        }
    }
    namespace UnityEngine.CullingGroup {
        interface StateChanged
        { 
        (sphere: UnityEngine.CullingGroupEvent) : void; 
        Invoke?: (sphere: UnityEngine.CullingGroupEvent) => void;
        }
        var StateChanged: { new (func: (sphere: UnityEngine.CullingGroupEvent) => void): StateChanged; }
    }
    namespace UnityEngine.ReflectionProbe {
        enum ReflectionProbeEvent
        { ReflectionProbeAdded = 0, ReflectionProbeRemoved = 1 }
    }
    namespace UnityEngine.Debug {
        class StartupLog extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public timestamp : bigint
            public logType : UnityEngine.LogType
            public message : string
        }
    }
    namespace UnityEngine.BoundsInt {
        class PositionEnumerator extends System.ValueType implements System.Collections.Generic.IEnumerator$1<UnityEngine.Vector3Int>, System.Collections.IEnumerator, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get Current(): UnityEngine.Vector3Int;
            public GetEnumerator () : UnityEngine.BoundsInt.PositionEnumerator
            public MoveNext () : boolean
            public Reset () : void
            public constructor ($min: UnityEngine.Vector3Int, $max: UnityEngine.Vector3Int)
        }
    }
    namespace UnityEngine.RectInt {
        class PositionEnumerator extends System.ValueType implements System.Collections.Generic.IEnumerator$1<UnityEngine.Vector2Int>, System.Collections.IEnumerator, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get Current(): UnityEngine.Vector2Int;
            public GetEnumerator () : UnityEngine.RectInt.PositionEnumerator
            public MoveNext () : boolean
            public Reset () : void
            public constructor ($min: UnityEngine.Vector2Int, $max: UnityEngine.Vector2Int)
        }
    }
    namespace UnityEngine.LightingSettings {
        enum Lightmapper
        { Enlighten = 0, ProgressiveCPU = 1, ProgressiveGPU = 2 }
        enum Sampling
        { Auto = 0, Fixed = 1 }
        enum FilterMode
        { None = 0, Auto = 1, Advanced = 2 }
        enum DenoiserType
        { None = 0, Optix = 1, OpenImage = 2, RadeonPro = 3 }
        enum FilterType
        { Gaussian = 0, ATrous = 1, None = 2 }
    }
    namespace UnityEngine.Display {
        interface DisplaysUpdatedDelegate
        { 
        () : void; 
        Invoke?: () => void;
        }
        var DisplaysUpdatedDelegate: { new (func: () => void): DisplaysUpdatedDelegate; }
    }
    namespace UnityEngine.Experimental.Rendering {
        /** Use this format to create either Textures or RenderTextures from scripts.
        */
        enum GraphicsFormat
        { None = 0, R8_SRGB = 1, R8G8_SRGB = 2, R8G8B8_SRGB = 3, R8G8B8A8_SRGB = 4, R8_UNorm = 5, R8G8_UNorm = 6, R8G8B8_UNorm = 7, R8G8B8A8_UNorm = 8, R8_SNorm = 9, R8G8_SNorm = 10, R8G8B8_SNorm = 11, R8G8B8A8_SNorm = 12, R8_UInt = 13, R8G8_UInt = 14, R8G8B8_UInt = 15, R8G8B8A8_UInt = 16, R8_SInt = 17, R8G8_SInt = 18, R8G8B8_SInt = 19, R8G8B8A8_SInt = 20, R16_UNorm = 21, R16G16_UNorm = 22, R16G16B16_UNorm = 23, R16G16B16A16_UNorm = 24, R16_SNorm = 25, R16G16_SNorm = 26, R16G16B16_SNorm = 27, R16G16B16A16_SNorm = 28, R16_UInt = 29, R16G16_UInt = 30, R16G16B16_UInt = 31, R16G16B16A16_UInt = 32, R16_SInt = 33, R16G16_SInt = 34, R16G16B16_SInt = 35, R16G16B16A16_SInt = 36, R32_UInt = 37, R32G32_UInt = 38, R32G32B32_UInt = 39, R32G32B32A32_UInt = 40, R32_SInt = 41, R32G32_SInt = 42, R32G32B32_SInt = 43, R32G32B32A32_SInt = 44, R16_SFloat = 45, R16G16_SFloat = 46, R16G16B16_SFloat = 47, R16G16B16A16_SFloat = 48, R32_SFloat = 49, R32G32_SFloat = 50, R32G32B32_SFloat = 51, R32G32B32A32_SFloat = 52, B8G8R8_SRGB = 56, B8G8R8A8_SRGB = 57, B8G8R8_UNorm = 58, B8G8R8A8_UNorm = 59, B8G8R8_SNorm = 60, B8G8R8A8_SNorm = 61, B8G8R8_UInt = 62, B8G8R8A8_UInt = 63, B8G8R8_SInt = 64, B8G8R8A8_SInt = 65, R4G4B4A4_UNormPack16 = 66, B4G4R4A4_UNormPack16 = 67, R5G6B5_UNormPack16 = 68, B5G6R5_UNormPack16 = 69, R5G5B5A1_UNormPack16 = 70, B5G5R5A1_UNormPack16 = 71, A1R5G5B5_UNormPack16 = 72, E5B9G9R9_UFloatPack32 = 73, B10G11R11_UFloatPack32 = 74, A2B10G10R10_UNormPack32 = 75, A2B10G10R10_UIntPack32 = 76, A2B10G10R10_SIntPack32 = 77, A2R10G10B10_UNormPack32 = 78, A2R10G10B10_UIntPack32 = 79, A2R10G10B10_SIntPack32 = 80, A2R10G10B10_XRSRGBPack32 = 81, A2R10G10B10_XRUNormPack32 = 82, R10G10B10_XRSRGBPack32 = 83, R10G10B10_XRUNormPack32 = 84, A10R10G10B10_XRSRGBPack32 = 85, A10R10G10B10_XRUNormPack32 = 86, D16_UNorm = 90, D24_UNorm = 91, D24_UNorm_S8_UInt = 92, D32_SFloat = 93, D32_SFloat_S8_UInt = 94, S8_UInt = 95, RGB_DXT1_SRGB = 96, RGBA_DXT1_SRGB = 96, RGB_DXT1_UNorm = 97, RGBA_DXT1_UNorm = 97, RGBA_DXT3_SRGB = 98, RGBA_DXT3_UNorm = 99, RGBA_DXT5_SRGB = 100, RGBA_DXT5_UNorm = 101, R_BC4_UNorm = 102, R_BC4_SNorm = 103, RG_BC5_UNorm = 104, RG_BC5_SNorm = 105, RGB_BC6H_UFloat = 106, RGB_BC6H_SFloat = 107, RGBA_BC7_SRGB = 108, RGBA_BC7_UNorm = 109, RGB_PVRTC_2Bpp_SRGB = 110, RGB_PVRTC_2Bpp_UNorm = 111, RGB_PVRTC_4Bpp_SRGB = 112, RGB_PVRTC_4Bpp_UNorm = 113, RGBA_PVRTC_2Bpp_SRGB = 114, RGBA_PVRTC_2Bpp_UNorm = 115, RGBA_PVRTC_4Bpp_SRGB = 116, RGBA_PVRTC_4Bpp_UNorm = 117, RGB_ETC_UNorm = 118, RGB_ETC2_SRGB = 119, RGB_ETC2_UNorm = 120, RGB_A1_ETC2_SRGB = 121, RGB_A1_ETC2_UNorm = 122, RGBA_ETC2_SRGB = 123, RGBA_ETC2_UNorm = 124, R_EAC_UNorm = 125, R_EAC_SNorm = 126, RG_EAC_UNorm = 127, RG_EAC_SNorm = 128, RGBA_ASTC4X4_SRGB = 129, RGBA_ASTC4X4_UNorm = 130, RGBA_ASTC5X5_SRGB = 131, RGBA_ASTC5X5_UNorm = 132, RGBA_ASTC6X6_SRGB = 133, RGBA_ASTC6X6_UNorm = 134, RGBA_ASTC8X8_SRGB = 135, RGBA_ASTC8X8_UNorm = 136, RGBA_ASTC10X10_SRGB = 137, RGBA_ASTC10X10_UNorm = 138, RGBA_ASTC12X12_SRGB = 139, RGBA_ASTC12X12_UNorm = 140, YUV2 = 141, DepthAuto = 142, ShadowAuto = 143, VideoAuto = 144, RGBA_ASTC4X4_UFloat = 145, RGBA_ASTC5X5_UFloat = 146, RGBA_ASTC6X6_UFloat = 147, RGBA_ASTC8X8_UFloat = 148, RGBA_ASTC10X10_UFloat = 149, RGBA_ASTC12X12_UFloat = 150, D16_UNorm_S8_UInt = 151 }
        /** Indicates how a Renderer is updated.
        */
        enum RayTracingMode
        { Off = 0, Static = 1, DynamicTransform = 2, DynamicGeometry = 3 }
        /** 
        Use a default format to create either Textures or RenderTextures from scripts based on platform specific capability.
        */
        enum DefaultFormat
        { LDR = 0, HDR = 1, DepthStencil = 2, Shadow = 3, Video = 4 }
        enum TextureCreationFlags
        { None = 0, MipChain = 1, DontInitializePixels = 4, Crunch = 64, DontUploadUponCreate = 1024, IgnoreMipmapLimit = 2048 }
        /** Obsolete. Use the GraphicsFormatUsage enum instead.
        */
        enum FormatUsage
        { Sample = 0, Linear = 1, Sparse = 2, Render = 4, Blend = 5, GetPixels = 6, SetPixels = 7, SetPixels32 = 8, ReadPixels = 9, LoadStore = 10, MSAA2x = 11, MSAA4x = 12, MSAA8x = 13, StencilSampling = 16 }
        /** Use this format usages to figure out the capabilities of specific GraphicsFormat
        */
        enum GraphicsFormatUsage
        { None = 0, Sample = 1, Linear = 2, Sparse = 4, Render = 16, Blend = 32, GetPixels = 64, SetPixels = 128, SetPixels32 = 256, ReadPixels = 512, LoadStore = 1024, MSAA2x = 2048, MSAA4x = 4096, MSAA8x = 8192, StencilSampling = 65536 }
        /** Empty implementation of IScriptableRuntimeReflectionSystem.
        */
        class ScriptableRuntimeReflectionSystem extends System.Object implements UnityEngine.Experimental.Rendering.IScriptableRuntimeReflectionSystem, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            /** Update the reflection probes.
            * @returns Whether a reflection probe was updated. 
            */
            public TickRealtimeProbes () : boolean
        }
        interface IScriptableRuntimeReflectionSystem extends System.IDisposable
        {
        }
        /** Global settings for the scriptable runtime reflection system.
        */
        class ScriptableRuntimeReflectionSystemSettings extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** The current scriptable runtime reflection system instance.
            */
            public static get system(): UnityEngine.Experimental.Rendering.IScriptableRuntimeReflectionSystem;
            public static set system(value: UnityEngine.Experimental.Rendering.IScriptableRuntimeReflectionSystem);
        }
        /** The ExternalGPUProfiler API allows developers to programatically take GPU frame captures in conjunction with supported external GPU profilers.
        GPU frame captures can be used to both analyze performance and debug graphics related issues.
        */
        class ExternalGPUProfiler extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Begins the current GPU frame capture in the external GPU profiler.
            */
            public static BeginGPUCapture () : void
            /** Ends the current GPU frame capture in the external GPU profiler.
            */
            public static EndGPUCapture () : void
            /** Returns true when a development build is launched by an external GPU profiler.
            */
            public static IsAttached () : boolean
        }
        enum WaitForPresentSyncPoint
        { BeginFrame = 0, EndFrame = 1 }
        enum GraphicsJobsSyncPoint
        { EndOfFrame = 0, AfterScriptUpdate = 1, AfterScriptLateUpdate = 2, WaitForPresent = 3 }
        class GraphicsDeviceSettings extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get waitForPresentSyncPoint(): UnityEngine.Experimental.Rendering.WaitForPresentSyncPoint;
            public static set waitForPresentSyncPoint(value: UnityEngine.Experimental.Rendering.WaitForPresentSyncPoint);
            public static get graphicsJobsSyncPoint(): UnityEngine.Experimental.Rendering.GraphicsJobsSyncPoint;
            public static set graphicsJobsSyncPoint(value: UnityEngine.Experimental.Rendering.GraphicsJobsSyncPoint);
        }
        /** This utility class contains helper functions that enable you to query properties of a TextureFormat, RenderTextureFormat, or GraphicsFormat. This class also includes format conversion and size calculation functions.
        */
        class GraphicsFormatUtility extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Translates RenderTextureFormat or TextureFormat into GraphicsFormat.
            */
            public static GetGraphicsFormat ($format: UnityEngine.TextureFormat, $isSRGB: boolean) : UnityEngine.Experimental.Rendering.GraphicsFormat
            /** Translates GraphicsFormat into TextureFormat.
            */
            public static GetTextureFormat ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : UnityEngine.TextureFormat
            /** Translates RenderTextureFormat or TextureFormat into GraphicsFormat.
            */
            public static GetGraphicsFormat ($format: UnityEngine.RenderTextureFormat, $isSRGB: boolean) : UnityEngine.Experimental.Rendering.GraphicsFormat
            /** Translates RenderTextureFormat or TextureFormat into GraphicsFormat.
            */
            public static GetGraphicsFormat ($format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite) : UnityEngine.Experimental.Rendering.GraphicsFormat
            /** Returns the number of bits per pixel this format contains for depth.
            * @param $format GraphicsFormat to use when retrieving the number of bits.
            */
            public static GetDepthBits ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : number
            /** Returns a supported depth stencil format that has 'minimumDepthBits' of bits or higher per pixel for the depth component if a compatible format exists on the current platform. If 'minimumStencilBits' is higher than 0, and a compatible format exists on the current platform, Unity returns a depth stencil format with 8 bits per pixel for the stencil component.
            * @param $minimumDepthBits Minimum number of bits that the format should have for the depth component.
            * @param $minimumStencilBits Minimum number of bits that the format should have for the stencil component.
            * @returns A GraphicFormat that has a depth and/or stencil component. 
            */
            public static GetDepthStencilFormat ($minimumDepthBits: number, $minimumStencilBits: number) : UnityEngine.Experimental.Rendering.GraphicsFormat
            /** Returns true if the format performs sRGB to linear on read and linear to sRGB on write. Returns false otherwise.
            */
            public static IsSRGBFormat ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : boolean
            /** Returns true if the format is not a RGBA format. Returns false otherwise.
            */
            public static IsSwizzleFormat ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : boolean
            /** Returns true if the format is not a RGBA format. Returns false otherwise.
            */
            public static IsSwizzleFormat ($format: UnityEngine.TextureFormat) : boolean
            /** Returns the equivalent sRGB format of a GraphicsFormat. For example, this function returns kFormatR8G8B8A8_SRGB if the input is kFormatR8G8B8A8_UNorm. If the input GraphicsFormat is already sRGB, this function returns the input GraphicsFormat. If there is no equivalent sRGB format, this function returns the input GraphicsFormat.
            */
            public static GetSRGBFormat ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : UnityEngine.Experimental.Rendering.GraphicsFormat
            /** Returns the equivalent linear format of a GraphicsFormat. For example, this function returns kFormatR8G8B8A8_UNorm if the input is kFormatR8G8B8A8_SRGB. If the input GraphicsFormat is already linear, this function returns the input GraphicsFormat.
            */
            public static GetLinearFormat ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : UnityEngine.Experimental.Rendering.GraphicsFormat
            /** Translates GraphicsFormat into RenderTextureFormat.
            */
            public static GetRenderTextureFormat ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : UnityEngine.RenderTextureFormat
            /** Returns the number of color components of the format.
            */
            public static GetColorComponentCount ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : number
            /** Returns the number of color components of the format.
            */
            public static GetColorComponentCount ($format: UnityEngine.TextureFormat) : number
            /** Returns the number of alpha components of the format.
            */
            public static GetAlphaComponentCount ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : number
            /** Returns the number of alpha components of the format.
            */
            public static GetAlphaComponentCount ($format: UnityEngine.TextureFormat) : number
            /** Returns the number of components this format has.
            * @param $format GraphicsFormat to use when retrieving the number of bits.
            */
            public static GetComponentCount ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : number
            /** Returns the number of components this format has.
            * @param $format GraphicsFormat to use when retrieving the number of bits.
            */
            public static GetComponentCount ($format: UnityEngine.TextureFormat) : number
            /** Returns a string that represents a format enum value.
            */
            public static GetFormatString ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : string
            /** Returns a string that represents a format enum value.
            */
            public static GetFormatString ($format: UnityEngine.TextureFormat) : string
            /** Returns true if the format is compressed. Returns false otherwise.
            */
            public static IsCompressedFormat ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : boolean
            /** Returns true if the format is compressed. Returns false otherwise.
            */
            public static IsCompressedFormat ($format: UnityEngine.TextureFormat) : boolean
            /** Returns true if the format is packed. Returns false otherwise.
            */
            public static IsPackedFormat ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : boolean
            /** Returns true if the format is packed. Returns false otherwise.
            */
            public static IsPackedFormat ($format: UnityEngine.TextureFormat) : boolean
            /** Returns true if the format is packed and a 16-bit format. Returns false otherwise.
            */
            public static Is16BitPackedFormat ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : boolean
            /** Returns true if the format is packed and a 16-bit format. Returns false otherwise.
            */
            public static Is16BitPackedFormat ($format: UnityEngine.TextureFormat) : boolean
            /** Input a GraphicsFormat to return an equivalent GraphicsFormat that includes an alpha component.
            */
            public static ConvertToAlphaFormat ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : UnityEngine.Experimental.Rendering.GraphicsFormat
            /** Input a TextureFormat to return an equivalent TextureFormat that includes an alpha component.
            */
            public static ConvertToAlphaFormat ($format: UnityEngine.TextureFormat) : UnityEngine.TextureFormat
            /** Returns true if the format only has an alpha component. Returns false otherwise.
            */
            public static IsAlphaOnlyFormat ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : boolean
            /** Returns true if the format only has an alpha component. Returns false otherwise.
            */
            public static IsAlphaOnlyFormat ($format: UnityEngine.TextureFormat) : boolean
            /** Returns true if the format has an alpha component with only 1 or 2 bits. Returns false otherwise.
            */
            public static IsAlphaTestFormat ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : boolean
            /** Returns true if the format has an alpha component with only 1 or 2 bits. Returns false otherwise.
            */
            public static IsAlphaTestFormat ($format: UnityEngine.TextureFormat) : boolean
            /** Returns true if the format has an alpha component. Returns false otherwise.
            */
            public static HasAlphaChannel ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : boolean
            /** Returns true if the format has an alpha component. Returns false otherwise.
            */
            public static HasAlphaChannel ($format: UnityEngine.TextureFormat) : boolean
            /** Returns true if the format is a depth format. Returns false otherwise.
            */
            public static IsDepthFormat ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : boolean
            /** Returns true if the format is a stencil format. Returns false otherwise.
            */
            public static IsStencilFormat ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : boolean
            /** Returns true if the format is a depth or stencil format. Returns false otherwise.
            */
            public static IsDepthStencilFormat ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : boolean
            /** Returns true if the format is a floating point format. Returns false otherwise.
            */
            public static IsIEEE754Format ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : boolean
            /** Returns true if the format is a single precision floating point format. Returns false otherwise.
            */
            public static IsFloatFormat ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : boolean
            /** Returns true if the format is a half precision floating point format. Returns false otherwise.
            */
            public static IsHalfFormat ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : boolean
            /** Returns true if the format is an unsigned format. Returns false otherwise.
            */
            public static IsUnsignedFormat ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : boolean
            /** Returns true if the format is an unsigned format. Returns false otherwise.
            */
            public static IsUnsignedFormat ($format: UnityEngine.TextureFormat) : boolean
            /** Returns true if the format is a signed format. Returns false otherwise.
            */
            public static IsSignedFormat ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : boolean
            /** Returns true if the format is a signed format. Returns false otherwise.
            */
            public static IsSignedFormat ($format: UnityEngine.TextureFormat) : boolean
            /** Returns true if the format is a normalized format. Returns false otherwise.
            */
            public static IsNormFormat ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : boolean
            /** Returns true if the format is an unsigned normalized format. Returns false otherwise.
            */
            public static IsUNormFormat ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : boolean
            /** Returns true if the format is a signed normalized format. Returns false otherwise.
            */
            public static IsSNormFormat ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : boolean
            /** Returns true if the format is an integer format. Returns false otherwise.
            */
            public static IsIntegerFormat ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : boolean
            /** Returns true if the format is an unsigned and integer format. Returns false otherwise.
            */
            public static IsUIntFormat ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : boolean
            /** Returns true if the format is a signed and integer format. Returns false otherwise.
            */
            public static IsSIntFormat ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : boolean
            /** Returns true if the format is an extended range format. With extended range format, the blue, green, and red components are linearly encoded, and their values range from -0.752941 to 1.25098. The alpha component is always clamped to a [0.0, 1.0] range in sampling, rendering, and writing operations, despite supporting values outside this range. Returns false otherwise.
            */
            public static IsXRFormat ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : boolean
            /** Returns true if the format uses DXTC. Returns false otherwise.
            */
            public static IsDXTCFormat ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : boolean
            /** Returns true if the format uses DXTC. Returns false otherwise.
            */
            public static IsDXTCFormat ($format: UnityEngine.TextureFormat) : boolean
            /** Returns true if the format uses RGTC. Returns false otherwise.
            */
            public static IsRGTCFormat ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : boolean
            /** Returns true if the format uses RGTC. Returns false otherwise.
            */
            public static IsRGTCFormat ($format: UnityEngine.TextureFormat) : boolean
            /** Returns true if the format uses BPTC. Returns false otherwise.
            */
            public static IsBPTCFormat ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : boolean
            /** Returns true if the format uses BPTC. Returns false otherwise.
            */
            public static IsBPTCFormat ($format: UnityEngine.TextureFormat) : boolean
            /** Returns true if the format is a DXTC, RGTC or BPTC format. Returns false otherwise.
            */
            public static IsBCFormat ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : boolean
            /** Returns true if the format is a DXTC, RGTC or BPTC format. Returns false otherwise.
            */
            public static IsBCFormat ($format: UnityEngine.TextureFormat) : boolean
            /** Returns true if the format uses PVRTC. Returns false otherwise.
            */
            public static IsPVRTCFormat ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : boolean
            /** Returns true if the format uses PVRTC. Returns false otherwise.
            */
            public static IsPVRTCFormat ($format: UnityEngine.TextureFormat) : boolean
            /** Returns true if the format uses ETC and ETC2. Returns false otherwise.
            */
            public static IsETCFormat ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : boolean
            /** Returns true if the format uses ETC and ETC2. Returns false otherwise.
            */
            public static IsETCFormat ($format: UnityEngine.TextureFormat) : boolean
            /** Returns true if the format uses EAC. Returns false otherwise.
            */
            public static IsEACFormat ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : boolean
            /** Returns true if the format uses EAC. Returns false otherwise.
            */
            public static IsEACFormat ($format: UnityEngine.TextureFormat) : boolean
            /** Returns true if the format uses ASTC. Returns false otherwise.
            */
            public static IsASTCFormat ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : boolean
            /** Returns true if the format uses ASTC. Returns false otherwise.
            */
            public static IsASTCFormat ($format: UnityEngine.TextureFormat) : boolean
            /** Returns true if the format is capable of representing HDR data. Returns false otherwise.
            */
            public static IsHDRFormat ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : boolean
            /** Returns true if the format is capable of representing HDR data. Returns false otherwise.
            */
            public static IsHDRFormat ($format: UnityEngine.TextureFormat) : boolean
            /** Returns true if the format data is compressed with Crunch. Returns false otherwise.
            */
            public static IsCrunchFormat ($format: UnityEngine.TextureFormat) : boolean
            /** Returns FormatSwizzle enum of which channel is mapped to the R channel for a given format.
            */
            public static GetSwizzleR ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : UnityEngine.Rendering.FormatSwizzle
            /** Returns FormatSwizzle enum of which channel is mapped to the R channel for a given format.
            */
            public static GetSwizzleR ($format: UnityEngine.TextureFormat) : UnityEngine.Rendering.FormatSwizzle
            /** Returns a FormatSwizzle enum that is mapped to the green channel for a given format.
            */
            public static GetSwizzleG ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : UnityEngine.Rendering.FormatSwizzle
            /** Returns a FormatSwizzle enum that is mapped to the green channel for a given format.
            */
            public static GetSwizzleG ($format: UnityEngine.TextureFormat) : UnityEngine.Rendering.FormatSwizzle
            /** Returns a FormatSwizzle enum that is mapped to the blue channel for a given format.
            */
            public static GetSwizzleB ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : UnityEngine.Rendering.FormatSwizzle
            /** Returns a FormatSwizzle enum that is mapped to the blue channel for a given format.
            */
            public static GetSwizzleB ($format: UnityEngine.TextureFormat) : UnityEngine.Rendering.FormatSwizzle
            /** Returns a FormatSwizzle enum that is mapped to the alpha channel for a given format.
            */
            public static GetSwizzleA ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : UnityEngine.Rendering.FormatSwizzle
            /** Returns a FormatSwizzle enum that is mapped to the alpha channel for a given format.
            */
            public static GetSwizzleA ($format: UnityEngine.TextureFormat) : UnityEngine.Rendering.FormatSwizzle
            /** Returns the memory size in bytes of a texel block.
            */
            public static GetBlockSize ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : number
            /** Returns the memory size in bytes of a texel block.
            */
            public static GetBlockSize ($format: UnityEngine.TextureFormat) : number
            /** Returns the width in texels of a texel block.
            */
            public static GetBlockWidth ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : number
            /** Returns the width in texels of a texel block.
            */
            public static GetBlockWidth ($format: UnityEngine.TextureFormat) : number
            /** Returns the height in texels of a texel block.
            */
            public static GetBlockHeight ($format: UnityEngine.Experimental.Rendering.GraphicsFormat) : number
            /** Returns the height in texels of a texel block.
            */
            public static GetBlockHeight ($format: UnityEngine.TextureFormat) : number
            /** Computes the memory size in bytes for a single mipmap.
            */
            public static ComputeMipmapSize ($width: number, $height: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat) : number
            /** Computes the memory size in bytes for a single mipmap.
            */
            public static ComputeMipmapSize ($width: number, $height: number, $format: UnityEngine.TextureFormat) : number
            /** Computes the memory size in bytes for a chain of mipmaps.
            * @param $mipCount Total number of mip levels to calculate. A value of -1 means Unity calculates the entire mip chain.
            */
            public static ComputeMipChainSize ($width: number, $height: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $mipCount?: number) : number
            /** Computes the memory size in bytes for a chain of mipmaps.
            * @param $mipCount Total number of mip levels to calculate. A value of -1 means Unity calculates the entire mip chain.
            */
            public static ComputeMipChainSize ($width: number, $height: number, $format: UnityEngine.TextureFormat, $mipCount?: number) : number
            /** Computes the memory size in bytes for a single mipmap.
            */
            public static ComputeMipmapSize ($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat) : number
            /** Computes the memory size in bytes for a single mipmap.
            */
            public static ComputeMipmapSize ($width: number, $height: number, $depth: number, $format: UnityEngine.TextureFormat) : number
            /** Computes the memory size in bytes for a chain of mipmaps.
            * @param $mipCount Total number of mip levels to calculate. A value of -1 means Unity calculates the entire mip chain.
            */
            public static ComputeMipChainSize ($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $mipCount?: number) : number
            /** Computes the memory size in bytes for a chain of mipmaps.
            * @param $mipCount Total number of mip levels to calculate. A value of -1 means Unity calculates the entire mip chain.
            */
            public static ComputeMipChainSize ($width: number, $height: number, $depth: number, $format: UnityEngine.TextureFormat, $mipCount?: number) : number
            public constructor ()
        }
        /** The rendering configuration to use when prewarming shader variants.
        */
        class ShaderWarmupSetup extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The vertex data layout to use when prewarming shader variants.
            */
            public vdecl : System.Array$1<UnityEngine.Rendering.VertexAttributeDescriptor>
        }
        /** Prewarms shaders in a way that is supported by all graphics APIs.
        */
        class ShaderWarmup extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Prewarms all shader variants for a given Shader, using a given rendering configuration.
            */
            public static WarmupShader ($shader: UnityEngine.Shader, $setup: UnityEngine.Experimental.Rendering.ShaderWarmupSetup) : void
            /** Prewarms the shader variants for a given Shader that are in a given ShaderVariantCollection, using a given rendering configuration.
            */
            public static WarmupShaderFromCollection ($collection: UnityEngine.ShaderVariantCollection, $shader: UnityEngine.Shader, $setup: UnityEngine.Experimental.Rendering.ShaderWarmupSetup) : void
        }
    }
    namespace UnityEngine.GraphicsBuffer {
        enum Target
        { Vertex = 1, Index = 2, CopySource = 4, CopyDestination = 8, Structured = 16, Raw = 32, Append = 64, Counter = 128, IndirectArguments = 256, Constant = 512 }
        enum UsageFlags
        { None = 0, LockBufferForWrite = 1 }
        class IndirectDrawArgs extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public static size : number
            public get vertexCountPerInstance(): number;
            public set vertexCountPerInstance(value: number);
            public get instanceCount(): number;
            public set instanceCount(value: number);
            public get startVertex(): number;
            public set startVertex(value: number);
            public get startInstance(): number;
            public set startInstance(value: number);
        }
        class IndirectDrawIndexedArgs extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public static size : number
            public get indexCountPerInstance(): number;
            public set indexCountPerInstance(value: number);
            public get instanceCount(): number;
            public set instanceCount(value: number);
            public get startIndex(): number;
            public set startIndex(value: number);
            public get baseVertexIndex(): number;
            public set baseVertexIndex(value: number);
            public get startInstance(): number;
            public set startInstance(value: number);
        }
    }
    namespace UnityEngine.Mesh {
        class MeshDataArray extends System.ValueType implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get Length(): number;
            public get_Item ($index: number) : UnityEngine.Mesh.MeshData
            public Dispose () : void
        }
        class MeshData extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get vertexCount(): number;
            public get vertexBufferCount(): number;
            public get indexFormat(): UnityEngine.Rendering.IndexFormat;
            public get subMeshCount(): number;
            public set subMeshCount(value: number);
            public GetVertexBufferStride ($stream: number) : number
            public HasVertexAttribute ($attr: UnityEngine.Rendering.VertexAttribute) : boolean
            public GetVertexAttributeDimension ($attr: UnityEngine.Rendering.VertexAttribute) : number
            public GetVertexAttributeFormat ($attr: UnityEngine.Rendering.VertexAttribute) : UnityEngine.Rendering.VertexAttributeFormat
            public GetVertexAttributeStream ($attr: UnityEngine.Rendering.VertexAttribute) : number
            public GetVertexAttributeOffset ($attr: UnityEngine.Rendering.VertexAttribute) : number
            public GetVertices ($outVertices: Unity.Collections.NativeArray$1<UnityEngine.Vector3>) : void
            public GetNormals ($outNormals: Unity.Collections.NativeArray$1<UnityEngine.Vector3>) : void
            public GetTangents ($outTangents: Unity.Collections.NativeArray$1<UnityEngine.Vector4>) : void
            public GetColors ($outColors: Unity.Collections.NativeArray$1<UnityEngine.Color>) : void
            public GetColors ($outColors: Unity.Collections.NativeArray$1<UnityEngine.Color32>) : void
            public GetUVs ($channel: number, $outUVs: Unity.Collections.NativeArray$1<UnityEngine.Vector2>) : void
            public GetUVs ($channel: number, $outUVs: Unity.Collections.NativeArray$1<UnityEngine.Vector3>) : void
            public GetUVs ($channel: number, $outUVs: Unity.Collections.NativeArray$1<UnityEngine.Vector4>) : void
            public SetVertexBufferParams ($vertexCount: number, ...attributes: UnityEngine.Rendering.VertexAttributeDescriptor[]) : void
            public SetVertexBufferParams ($vertexCount: number, $attributes: Unity.Collections.NativeArray$1<UnityEngine.Rendering.VertexAttributeDescriptor>) : void
            public SetIndexBufferParams ($indexCount: number, $format: UnityEngine.Rendering.IndexFormat) : void
            public GetIndices ($outIndices: Unity.Collections.NativeArray$1<number>, $submesh: number, $applyBaseVertex?: boolean) : void
            public GetSubMesh ($index: number) : UnityEngine.Rendering.SubMeshDescriptor
            public SetSubMesh ($index: number, $desc: UnityEngine.Rendering.SubMeshDescriptor, $flags?: UnityEngine.Rendering.MeshUpdateFlags) : void
        }
    }
    namespace UnityEngine.LightProbeProxyVolume {
        enum BoundingBoxMode
        { AutomaticLocal = 0, AutomaticWorld = 1, Custom = 2 }
        enum ResolutionMode
        { Automatic = 0, Custom = 1 }
        enum ProbePositionMode
        { CellCorner = 0, CellCenter = 1 }
        enum RefreshMode
        { Automatic = 0, EveryFrame = 1, ViaScripting = 2 }
        enum QualityMode
        { Low = 0, Normal = 1 }
        enum DataFormat
        { HalfFloat = 0, Float = 1 }
    }
    namespace UnityEngine.Texture2D {
        enum EXRFlags
        { None = 0, OutputAsFloat = 1, CompressZIP = 2, CompressRLE = 4, CompressPIZ = 8 }
    }
    namespace UnityEngine.iOS {
        /** ActivityIndicator Style (iOS Specific).
        */
        enum ActivityIndicatorStyle
        { DontShow = -1, WhiteLarge = 0, White = 1, Gray = 2 }
        /** ADBannerView is a wrapper around the ADBannerView class found in the Apple iAd framework and is only available on iOS.
        */
        class ADBannerView extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Checks if banner contents are loaded.
            */
            public get loaded(): boolean;
            /** Banner visibility. Initially banner is not visible.
            */
            public get visible(): boolean;
            public set visible(value: boolean);
            /** Banner layout.
            */
            public get layout(): UnityEngine.iOS.ADBannerView.Layout;
            public set layout(value: UnityEngine.iOS.ADBannerView.Layout);
            /** The position of the banner view.
            */
            public get position(): UnityEngine.Vector2;
            public set position(value: UnityEngine.Vector2);
            /** The size of the banner view.
            */
            public get size(): UnityEngine.Vector2;
            public static IsAvailable ($type: UnityEngine.iOS.ADBannerView.Type) : boolean
            public static add_onBannerWasClicked ($value: UnityEngine.iOS.ADBannerView.BannerWasClickedDelegate) : void
            public static remove_onBannerWasClicked ($value: UnityEngine.iOS.ADBannerView.BannerWasClickedDelegate) : void
            public static add_onBannerWasLoaded ($value: UnityEngine.iOS.ADBannerView.BannerWasLoadedDelegate) : void
            public static remove_onBannerWasLoaded ($value: UnityEngine.iOS.ADBannerView.BannerWasLoadedDelegate) : void
            public static add_onBannerFailedToLoad ($value: UnityEngine.iOS.ADBannerView.BannerFailedToLoadDelegate) : void
            public static remove_onBannerFailedToLoad ($value: UnityEngine.iOS.ADBannerView.BannerFailedToLoadDelegate) : void
            public constructor ($type: UnityEngine.iOS.ADBannerView.Type, $layout: UnityEngine.iOS.ADBannerView.Layout)
        }
        /** ADInterstitialAd is a wrapper around the ADInterstitialAd class found in the Apple iAd framework and is only available on iPad.
        */
        class ADInterstitialAd extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Checks if InterstitialAd is available (it is available on iPad since iOS 4.3, and on iPhone since iOS 7.0).
            */
            public static get isAvailable(): boolean;
            /** Has the interstitial ad object downloaded an advertisement? (Read Only)
            */
            public get loaded(): boolean;
            /** Shows full-screen advertisement to user.
            */
            public Show () : void
            /** Reload advertisement.
            */
            public ReloadAd () : void
            public static add_onInterstitialWasLoaded ($value: UnityEngine.iOS.ADInterstitialAd.InterstitialWasLoadedDelegate) : void
            public static remove_onInterstitialWasLoaded ($value: UnityEngine.iOS.ADInterstitialAd.InterstitialWasLoadedDelegate) : void
            public static add_onInterstitialWasViewed ($value: UnityEngine.iOS.ADInterstitialAd.InterstitialWasViewedDelegate) : void
            public static remove_onInterstitialWasViewed ($value: UnityEngine.iOS.ADInterstitialAd.InterstitialWasViewedDelegate) : void
            public constructor ($autoReload: boolean)
            public constructor ()
        }
        /** iOS device generation.
        */
        enum DeviceGeneration
        { Unknown = 0, iPhone = 1, iPhone3G = 2, iPhone3GS = 3, iPodTouch1Gen = 4, iPodTouch2Gen = 5, iPodTouch3Gen = 6, iPad1Gen = 7, iPhone4 = 8, iPodTouch4Gen = 9, iPad2Gen = 10, iPhone4S = 11, iPad3Gen = 12, iPhone5 = 13, iPodTouch5Gen = 14, iPadMini1Gen = 15, iPad4Gen = 16, iPhone5C = 17, iPhone5S = 18, iPadAir1 = 19, iPadMini2Gen = 20, iPhone6 = 21, iPhone6Plus = 22, iPadMini3Gen = 23, iPadAir2 = 24, iPhone6S = 25, iPhone6SPlus = 26, iPadPro1Gen = 27, iPadMini4Gen = 28, iPhoneSE1Gen = 29, iPadPro10Inch1Gen = 30, iPhone7 = 31, iPhone7Plus = 32, iPodTouch6Gen = 33, iPad5Gen = 34, iPadPro2Gen = 35, iPadPro10Inch2Gen = 36, iPhone8 = 37, iPhone8Plus = 38, iPhoneX = 39, iPhoneXS = 40, iPhoneXSMax = 41, iPhoneXR = 42, iPadPro11Inch = 43, iPadPro3Gen = 44, iPad6Gen = 45, iPadAir3Gen = 46, iPadMini5Gen = 47, iPhone11 = 48, iPhone11Pro = 49, iPhone11ProMax = 50, iPodTouch7Gen = 51, iPad7Gen = 52, iPhoneSE2Gen = 53, iPadPro11Inch2Gen = 54, iPadPro4Gen = 55, iPhone12Mini = 56, iPhone12 = 57, iPhone12Pro = 58, iPhone12ProMax = 59, iPad8Gen = 60, iPadAir4Gen = 61, iPad9Gen = 62, iPadMini6Gen = 63, iPhone13 = 64, iPhone13Mini = 65, iPhone13Pro = 66, iPhone13ProMax = 67, iPadPro5Gen = 68, iPadPro11Inch3Gen = 69, iPhoneSE3Gen = 70, iPadAir5Gen = 71, iPhone14 = 72, iPhone14Plus = 73, iPhone14Pro = 74, iPhone14ProMax = 75, iPadPro6Gen = 76, iPadPro11Inch4Gen = 77, iPad10Gen = 78, iPhone15 = 79, iPhone15Plus = 80, iPhone15Pro = 81, iPhone15ProMax = 82, iPhoneUnknown = 10001, iPadUnknown = 10002, iPodTouchUnknown = 10003 }
        /** Interface into iOS specific functionality.
        */
        class Device extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** iOS version.
            */
            public static get systemVersion(): string;
            /** The generation of the device. (Read Only)
            */
            public static get generation(): UnityEngine.iOS.DeviceGeneration;
            /** Vendor ID.
            */
            public static get vendorIdentifier(): string;
            /** Advertising ID.
            */
            public static get advertisingIdentifier(): string;
            /** Is advertising tracking enabled.
            */
            public static get advertisingTrackingEnabled(): boolean;
            /** Specifies whether the home button should be hidden in the iOS build of this application.
            */
            public static get hideHomeButton(): boolean;
            public static set hideHomeButton(value: boolean);
            /** Indicates whether Low Power Mode is enabled on the device.
            */
            public static get lowPowerModeEnabled(): boolean;
            /** Indicates whether the screen may be dimmed lower than the hardware is normally capable of by emulating it in software.
            */
            public static get wantsSoftwareDimming(): boolean;
            public static set wantsSoftwareDimming(value: boolean);
            /** Specifies whether app built for iOS is running on Mac.
            */
            public static get iosAppOnMac(): boolean;
            /** Defer system gestures until the second swipe on specific edges.
            */
            public static get deferSystemGesturesMode(): UnityEngine.iOS.SystemGestureDeferMode;
            public static set deferSystemGesturesMode(value: UnityEngine.iOS.SystemGestureDeferMode);
            /** Set file flag to be excluded from iCloudiTunes backup. This uses <a href="https:developer.apple.comdocumentationfoundationnsurlisexcludedfrombackupkey">NSURLIsExcludedFromBackupKey</a>. Note that you should set this property each time you save a file.
            */
            public static SetNoBackupFlag ($path: string) : void
            /** Set file flag to be included in iCloud/iTunes backup.
            */
            public static ResetNoBackupFlag ($path: string) : void
            /** Request App Store rating and review from the user.
            * @returns Value indicating whether the underlying API is available or not. False indicates that the iOS version isn't recent enough or that the StoreKit framework is not linked with the app. 
            */
            public static RequestStoreReview () : boolean
            public constructor ()
        }
        /** Bit-mask used to control the deferring of system gestures on iOS.
        */
        enum SystemGestureDeferMode
        { None = 0, TopEdge = 1, LeftEdge = 2, BottomEdge = 4, RightEdge = 8, All = 15 }
        /** Represents a request for On Demand Resources (ODR). It's an AsyncOperation and can be yielded in a coroutine.
        */
        class OnDemandResourcesRequest extends UnityEngine.AsyncOperation implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            /** Returns an error after operation is complete.
            */
            public get error(): string;
            /** Sets the priority for request.
            */
            public get loadingPriority(): number;
            public set loadingPriority(value: number);
            /** Gets file system's path to the resource available in On Demand Resources (ODR) request.
            * @param $resourceName Resource name.
            */
            public GetResourcePath ($resourceName: string) : string
            /** Release all resources kept alive by On Demand Resources (ODR) request.
            */
            public Dispose () : void
        }
        /** On Demand Resources API.
        */
        class OnDemandResources extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Indicates whether player was built with "Use On Demand Resources" player setting enabled.
            */
            public static get enabled(): boolean;
            /** Creates an On Demand Resources (ODR) request.
            * @param $tags Tags for On Demand Resources that should be included in the request.
            * @returns Object representing ODR request. 
            */
            public static PreloadAsync ($tags: System.Array$1<string>) : UnityEngine.iOS.OnDemandResourcesRequest
        }
    }
    namespace UnityEngine.ADBannerView {
        interface BannerWasClickedDelegate
        { 
        () : void; 
        Invoke?: () => void;
        }
        var BannerWasClickedDelegate: { new (func: () => void): BannerWasClickedDelegate; }
        interface BannerWasLoadedDelegate
        { 
        () : void; 
        Invoke?: () => void;
        }
        var BannerWasLoadedDelegate: { new (func: () => void): BannerWasLoadedDelegate; }
        enum Layout
        { Top = 0, Bottom = 1, TopLeft = 0, TopRight = 4, TopCenter = 8, BottomLeft = 1, BottomRight = 5, BottomCenter = 9, CenterLeft = 2, CenterRight = 6, Center = 10, Manual = -1 }
        enum Type
        { Banner = 0, MediumRect = 1 }
    }
    namespace UnityEngine.ADInterstitialAd {
        interface InterstitialWasLoadedDelegate
        { 
        () : void; 
        Invoke?: () => void;
        }
        var InterstitialWasLoadedDelegate: { new (func: () => void): InterstitialWasLoadedDelegate; }
    }
    namespace UnityEngine.Random {
        class State extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace UnityEngine.Awaitable {
        class Awaiter extends System.ValueType implements System.Runtime.CompilerServices.INotifyCompletion
        {
            protected [__keep_incompatibility]: never;
            public get IsCompleted(): boolean;
            public OnCompleted ($continuation: System.Action) : void
            public GetResult () : void
        }
        class AwaitableAsyncMethodBuilder extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get Task(): UnityEngine.Awaitable;
            public static Create () : UnityEngine.Awaitable.AwaitableAsyncMethodBuilder
            public SetStateMachine ($stateMachine: System.Runtime.CompilerServices.IAsyncStateMachine) : void
            public SetException ($e: System.Exception) : void
            public SetResult () : void
        }
        class AwaitableAsyncMethodBuilder$1<T> extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get Task(): UnityEngine.Awaitable$1<T>;
            public static Create () : any
            public SetResult ($value: T) : void
            public SetException ($e: System.Exception) : void
            public SetStateMachine ($stateMachine: System.Runtime.CompilerServices.IAsyncStateMachine) : void
        }
    }
    namespace UnityEngine.Awaitable$1 {
        class Awaiter<T> extends System.ValueType implements System.Runtime.CompilerServices.INotifyCompletion
        {
            protected [__keep_incompatibility]: never;
            public get IsCompleted(): boolean;
            public OnCompleted ($continuation: System.Action) : void
            public GetResult () : T
            public constructor ($coroutine: UnityEngine.Awaitable$1<T>)
        }
    }
    namespace UnityEngine.Scripting {
        /** PreserveAttribute prevents byte code stripping from removing a class, method, field, or property.
        */
        class PreserveAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Ensure an assembly is always processed during managed code stripping.
        */
        class AlwaysLinkAssemblyAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** API to control the garbage collector on the Mono and IL2CPP scripting backends.
        */
        class GarbageCollector extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Set and get global garbage collector operation mode.
            */
            public static get GCMode(): UnityEngine.Scripting.GarbageCollector.Mode;
            public static set GCMode(value: UnityEngine.Scripting.GarbageCollector.Mode);
            /** Reports whether incremental garbage collection is enabled.
            */
            public static get isIncremental(): boolean;
            /** The target duration of a collection step when performing incremental garbage collection.
            */
            public static get incrementalTimeSliceNanoseconds(): bigint;
            public static set incrementalTimeSliceNanoseconds(value: bigint);
            public static add_GCModeChanged ($value: System.Action$1<UnityEngine.Scripting.GarbageCollector.Mode>) : void
            public static remove_GCModeChanged ($value: System.Action$1<UnityEngine.Scripting.GarbageCollector.Mode>) : void
            /** Perform incremental garbage collection for the duration specified by the nanoseconds parameter.
            * @param $nanoseconds The maximum number of nanoseconds to spend in garbage collection.
            * @returns Returns true if additional garbage collection work remains when the method returns and false if garbage collection is complete. Also returns false if incremental garbage collection is not enabled or is not supported on the current platform. 
            */
            public static CollectIncremental ($nanoseconds?: bigint) : boolean
        }
        /** Only allowed on attribute types. If the attribute type is marked, then so too will all CustomAttributes of that type.
        */
        class RequireAttributeUsagesAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** When the type is marked, all types derived from that type will also be marked.
        */
        class RequireDerivedAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** When a type is marked, all interface implementations of the specified types will be marked.
        */
        class RequiredInterfaceAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ($interfaceType: System.Type)
        }
        /** When a type is marked, all of it's members with [RequiredMember] will be marked.
        */
        class RequiredMemberAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** When the interface type is marked, all types implementing that interface will be marked.
        */
        class RequireImplementorsAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
    }
    namespace UnityEngine.ShaderVariantCollection {
        class ShaderVariant extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public shader : UnityEngine.Shader
            public passType : UnityEngine.Rendering.PassType
            public keywords : System.Array$1<string>
            public constructor ($shader: UnityEngine.Shader, $passType: UnityEngine.Rendering.PassType, ...keywords: string[])
        }
    }
    namespace UnityEngine.TouchScreenKeyboard {
        enum Status
        { Visible = 0, Done = 1, Canceled = 2, LostFocus = 3 }
        class Android extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
    }
    namespace UnityEngine.RectTransform {
        interface ReapplyDrivenProperties
        { 
        (driven: UnityEngine.RectTransform) : void; 
        Invoke?: (driven: UnityEngine.RectTransform) => void;
        }
        var ReapplyDrivenProperties: { new (func: (driven: UnityEngine.RectTransform) => void): ReapplyDrivenProperties; }
        enum Edge
        { Left = 0, Right = 1, Top = 2, Bottom = 3 }
        enum Axis
        { Horizontal = 0, Vertical = 1 }
    }
    namespace UnityEngine.Sprites {
        /** Helper utilities for accessing Sprite data.
        */
        class DataUtility extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Inner UV's of the Sprite.
            */
            public static GetInnerUV ($sprite: UnityEngine.Sprite) : UnityEngine.Vector4
            /** Outer UV's of the Sprite.
            */
            public static GetOuterUV ($sprite: UnityEngine.Sprite) : UnityEngine.Vector4
            /** Return the padding on the sprite.
            */
            public static GetPadding ($sprite: UnityEngine.Sprite) : UnityEngine.Vector4
            /** Minimum width and height of the Sprite.
            */
            public static GetMinSize ($sprite: UnityEngine.Sprite) : UnityEngine.Vector2
            public constructor ()
        }
    }
    namespace UnityEngine.U2D {
        /** Provides a base class for 2D lights.
        */
        class Light2DBase extends UnityEngine.MonoBehaviour
        {
            protected [__keep_incompatibility]: never;
        }
        /** A collection of APIs that facilitate pixel perfect rendering of sprite-based renderers.
        */
        class PixelPerfectRendering extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** To achieve a pixel perfect render, Sprites must be displaced to discrete positions at render time. This value defines the minimum distance between these positions. This doesn’t affect the GameObject's transform position.
            */
            public static get pixelSnapSpacing(): number;
            public static set pixelSnapSpacing(value: number);
        }
        /** Stores a set of information that describes the bind pose of this Sprite.
        */
        class SpriteBone extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The name of the bone. This is useful when recreating bone hierarchy at editor or runtime. You can also use this as a way of resolving the bone path when a Sprite is bound to a more complex or richer hierarchy.
            */
            public get name(): string;
            public set name(value: string);
            /** The Unique GUID of this bone.
            */
            public get guid(): string;
            public set guid(value: string);
            /** The position in local space of this bone.
            */
            public get position(): UnityEngine.Vector3;
            public set position(value: UnityEngine.Vector3);
            /** The rotation of this bone in local space.
            */
            public get rotation(): UnityEngine.Quaternion;
            public set rotation(value: UnityEngine.Quaternion);
            /** The length of the bone. This is important for the leaf bones to describe their length without needing another bone as the terminal bone.
            */
            public get length(): number;
            public set length(value: number);
            /** The ID of the parent of this bone.
            */
            public get parentId(): number;
            public set parentId(value: number);
            /** Shows the color set for the bone in the Editor.
            */
            public get color(): UnityEngine.Color32;
            public set color(value: UnityEngine.Color32);
        }
        /** A list of methods designed for reading and writing to the rich internal data of a Sprite.
        */
        class SpriteDataAccessExtensions extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Returns an array of BindPoses.
            * @param $sprite The sprite to retrieve the bind pose from.
            * @returns A list of bind poses for this sprite. There is no need to dispose the returned NativeArray. 
            */
            public static GetBindPoses ($sprite: UnityEngine.Sprite) : Unity.Collections.NativeArray$1<UnityEngine.Matrix4x4>
            public static SetBindPoses ($sprite: UnityEngine.Sprite, $src: Unity.Collections.NativeArray$1<UnityEngine.Matrix4x4>) : void
            /** Returns a list of indices. This is the same as Sprite.triangle.
            * @returns A read-only list of indices indicating how the triangles are formed between the vertices. The array is marked as undisposable. 
            */
            public static GetIndices ($sprite: UnityEngine.Sprite) : Unity.Collections.NativeArray$1<number>
            public static SetIndices ($sprite: UnityEngine.Sprite, $src: Unity.Collections.NativeArray$1<number>) : void
            /** Returns a list of SpriteBone in this Sprite.
            * @param $sprite The sprite to get the list of SpriteBone from.
            * @returns An array of SpriteBone that belongs to this Sprite. 
            */
            public static GetBones ($sprite: UnityEngine.Sprite) : System.Array$1<UnityEngine.U2D.SpriteBone>
            /** Sets the SpriteBones for this Sprite.
            */
            public static SetBones ($sprite: UnityEngine.Sprite, $src: System.Array$1<UnityEngine.U2D.SpriteBone>) : void
            /** Checks if a specific channel exists for this Sprite.
            * @returns True if the channel exists. 
            */
            public static HasVertexAttribute ($sprite: UnityEngine.Sprite, $channel: UnityEngine.Rendering.VertexAttribute) : boolean
            /** Sets the vertex count. This resizes the internal buffer. It also preserves any configurations of VertexAttributes.
            */
            public static SetVertexCount ($sprite: UnityEngine.Sprite, $count: number) : void
            /** Returns the number of vertices in this Sprite.
            */
            public static GetVertexCount ($sprite: UnityEngine.Sprite) : number
        }
        /** A list of methods that allow the caller to override what the SpriteRenderer renders.
        */
        class SpriteRendererDataAccessExtensions extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Stop using the deformable buffer to render the Sprite and use the original mesh instead.
            */
            public static DeactivateDeformableBuffer ($renderer: UnityEngine.SpriteRenderer) : void
        }
        /** Manages SpriteAtlas during runtime.
        */
        class SpriteAtlasManager extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static add_atlasRequested ($value: System.Action$2<string, System.Action$1<UnityEngine.U2D.SpriteAtlas>>) : void
            public static remove_atlasRequested ($value: System.Action$2<string, System.Action$1<UnityEngine.U2D.SpriteAtlas>>) : void
            public static add_atlasRegistered ($value: System.Action$1<UnityEngine.U2D.SpriteAtlas>) : void
            public static remove_atlasRegistered ($value: System.Action$1<UnityEngine.U2D.SpriteAtlas>) : void
            public constructor ()
        }
        /** Sprite Atlas is an asset created within Unity. It is part of the built-in sprite packing solution.
        */
        class SpriteAtlas extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** Return true if this SpriteAtlas is a variant.
            */
            public get isVariant(): boolean;
            /** Get the tag of this SpriteAtlas.
            */
            public get tag(): string;
            /** Get the total number of Sprite packed into this atlas.
            */
            public get spriteCount(): number;
            /** Return true if Sprite is packed into this SpriteAtlas.
            */
            public CanBindTo ($sprite: UnityEngine.Sprite) : boolean
            /** Clone the first Sprite in this atlas that matches the name packed in this atlas and return it.
            * @param $name The name of the Sprite.
            */
            public GetSprite ($name: string) : UnityEngine.Sprite
            /** Clone all the Sprite in this atlas and fill them into the supplied array.
            * @param $sprites Array of Sprite that will be filled.
            * @returns The size of the returned array. 
            */
            public GetSprites ($sprites: System.Array$1<UnityEngine.Sprite>) : number
            /** Clone all the Sprite matching the name in this atlas and fill them into the supplied array.
            * @param $sprites Array of Sprite that will be filled.
            * @param $name The name of the Sprite.
            */
            public GetSprites ($sprites: System.Array$1<UnityEngine.Sprite>, $name: string) : number
            public constructor ()
        }
    }
    namespace UnityEngine.Profiling {
        /** The different areas of profiling, corresponding to the charts in ProfilerWindow.
        */
        enum ProfilerArea
        { CPU = 0, GPU = 1, Rendering = 2, Memory = 3, Audio = 4, Video = 5, Physics = 6, Physics2D = 7, NetworkMessages = 8, NetworkOperations = 9, UI = 10, UIDetails = 11, GlobalIllumination = 12, VirtualTexturing = 13 }
        /** Controls the from script.
        */
        class Profiler extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get supported(): boolean;
            /** Specifies the file to use when writing profiling data.
            */
            public static get logFile(): string;
            public static set logFile(value: string);
            /** Enables the logging of profiling data to a file.
            */
            public static get enableBinaryLog(): boolean;
            public static set enableBinaryLog(value: boolean);
            /** Sets the maximum amount of memory that Profiler uses for buffering data. This property is expressed in bytes.
            */
            public static get maxUsedMemory(): number;
            public static set maxUsedMemory(value: number);
            /** Enables the Profiler.
            */
            public static get enabled(): boolean;
            public static set enabled(value: boolean);
            /** Enables the recording of callstacks for managed allocations.
            */
            public static get enableAllocationCallstacks(): boolean;
            public static set enableAllocationCallstacks(value: boolean);
            /** The number of ProfilerArea|Profiler Areas that you can profile.
            */
            public static get areaCount(): number;
            /** Returns the number of bytes that Unity has allocated. This does not include bytes allocated by external libraries or drivers.
            * @returns Size of the memory allocated by Unity (or 0 if the profiler is disabled). 
            */
            public static get usedHeapSizeLong(): bigint;
            /** Enable or disable a given ProfilerArea.
            * @param $area The area you want to enable or disable.
            * @param $enabled Enable or disable the collection of data for this area.
            */
            public static SetAreaEnabled ($area: UnityEngine.Profiling.ProfilerArea, $enabled: boolean) : void
            /** Returns whether or not a given ProfilerArea is currently enabled.
            * @param $area Which area you want to check the state of.
            * @returns Returns whether or not a given ProfilerArea is currently enabled. 
            */
            public static GetAreaEnabled ($area: UnityEngine.Profiling.ProfilerArea) : boolean
            /** Displays the recorded profile data in the profiler.
            * @param $file The name of the file containing the frame data, including extension.
            */
            public static AddFramesFromFile ($file: string) : void
            /** Enables profiling on the thread from which you call this method.
            * @param $threadGroupName The name of the thread group to which the thread belongs.
            * @param $threadName The name of the thread.
            */
            public static BeginThreadProfiling ($threadGroupName: string, $threadName: string) : void
            /** Frees the internal resources used by the Profiler for the thread.
            */
            public static EndThreadProfiling () : void
            /** Begin profiling a piece of code with a custom label.
            * @param $name A string to identify the sample in the Profiler window.
            * @param $targetObject An object that provides context to the sample,.
            */
            public static BeginSample ($name: string) : void
            /** Begin profiling a piece of code with a custom label.
            * @param $name A string to identify the sample in the Profiler window.
            * @param $targetObject An object that provides context to the sample,.
            */
            public static BeginSample ($name: string, $targetObject: UnityEngine.Object) : void
            /** Ends the current profiling sample.
            */
            public static EndSample () : void
            /** Gathers the native-memory used by a Unity object.
            * @param $o The target Unity object.
            * @returns The amount of native-memory used by a Unity object. This returns 0 if the Profiler is not available. 
            */
            public static GetRuntimeMemorySizeLong ($o: UnityEngine.Object) : bigint
            /** Returns the size of the reserved space for managed-memory.
            * @returns The size of the managed heap. 
            */
            public static GetMonoHeapSizeLong () : bigint
            /** Gets the allocated managed memory for live objects and non-collected objects.
            * @returns Returns a long integer value of the memory in use. 
            */
            public static GetMonoUsedSizeLong () : bigint
            /** Sets the size of the temp allocator.
            * @param $size Size in bytes.
            * @returns Returns true if requested size was successfully set. Will return false if value is disallowed (too small). 
            */
            public static SetTempAllocatorRequestedSize ($size: number) : boolean
            /** Returns the size of the temp allocator.
            * @returns Size in bytes. 
            */
            public static GetTempAllocatorSize () : number
            /** The total memory allocated by the internal allocators in Unity. Unity reserves large pools of memory from the system; this includes double the required memory for textures because Unity keeps a copy of each texture on both the CPU and GPU. This function returns the amount of used memory in those pools.
            * @returns The amount of memory allocated by Unity. This returns 0 if the Profiler is not available. 
            */
            public static GetTotalAllocatedMemoryLong () : bigint
            /** Unity allocates memory in pools for usage when unity needs to allocate memory. This function returns the amount of unused memory in these pools.
            * @returns The amount of unused memory in the reserved pools. This returns 0 if the Profiler is not available. 
            */
            public static GetTotalUnusedReservedMemoryLong () : bigint
            /** The total memory Unity has reserved.
            * @returns Memory reserved by Unity in bytes. This returns 0 if the Profiler is not available. 
            */
            public static GetTotalReservedMemoryLong () : bigint
            public static GetTotalFragmentationInfo ($stats: Unity.Collections.NativeArray$1<number>) : bigint
            /** Returns the amount of allocated memory for the graphics driver, in bytes.
            Only available in development players and editor.
            */
            public static GetAllocatedMemoryForGraphicsDriver () : bigint
            /** Write metadata associated with the current frame to the Profiler stream.
            * @param $id Module identifier. Used to distinguish metadata streams between different plugins, packages or modules.
            * @param $tag Data stream index.
            * @param $data Binary data.
            */
            public static EmitFrameMetaData ($id: System.Guid, $tag: number, $data: System.Array) : void
            /** Write metadata associated with the whole Profiler session capture.
            * @param $id Unique identifier associated with the data.
            * @param $tag Data stream index.
            * @param $data Binary data.
            */
            public static EmitSessionMetaData ($id: System.Guid, $tag: number, $data: System.Array) : void
            /** Enable or disable a given ProfilerCategory.
            * @param $category The category you want to enable or disable.
            * @param $enabled Enable or disable the collection of data for this category.
            */
            public static SetCategoryEnabled ($category: Unity.Profiling.ProfilerCategory, $enabled: boolean) : void
            /** Returns whether or not a given ProfilerCategory is currently enabled.
            * @param $category Which category you want to check the state of.
            * @returns Returns whether or not a given ProfilerCategory is currently enabled. 
            */
            public static IsCategoryEnabled ($category: Unity.Profiling.ProfilerCategory) : boolean
            /** Returns number of ProfilerCategory registered in Profiler.
            * @returns Returns number of ProfilerCategory registered in Profiler. 
            */
            public static GetCategoriesCount () : number
            /** Returns all ProfilerCategory registered in Profiler.
            */
            public static GetAllCategories ($categories: System.Array$1<Unity.Profiling.ProfilerCategory>) : void
            public static GetAllCategories ($categories: Unity.Collections.NativeArray$1<Unity.Profiling.ProfilerCategory>) : void
        }
        /** Records profiling data produced by a specific Sampler.
        */
        class Recorder extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Returns true if Recorder is valid and can collect data. (Read Only)
            */
            public get isValid(): boolean;
            /** Enables recording.
            */
            public get enabled(): boolean;
            public set enabled(value: boolean);
            /** Accumulated time of Begin/End pairs for the previous frame in nanoseconds. (Read Only)
            */
            public get elapsedNanoseconds(): bigint;
            /** Gets the accumulated GPU time, in nanoseconds, for a frame. The Recorder has a three frame delay so this gives the timings for the frame that was three frames before the one that you access this property on. (Read Only).
            */
            public get gpuElapsedNanoseconds(): bigint;
            /** Number of time Begin/End pairs was called during the previous frame. (Read Only)
            */
            public get sampleBlockCount(): number;
            /** Gets the number of Begin/End time pairs that the GPU executed during a frame. The Recorder has a three frame delay so this gives the timings for the frame that was three frames before the one that you access this property on. (Read Only).
            */
            public get gpuSampleBlockCount(): number;
            /** Use this function to get a Recorder for the specific Profiler label.
            * @param $samplerName Sampler name.
            * @returns Recorder object for the specified Sampler. 
            */
            public static Get ($samplerName: string) : UnityEngine.Profiling.Recorder
            /** Configures the recorder to only collect data from the current thread.
            */
            public FilterToCurrentThread () : void
            /** Configures the recorder to collect samples from all threads.
            */
            public CollectFromAllThreads () : void
        }
        /** Provides control over a CPU Profiler label.
        */
        class Sampler extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Returns true if Sampler is valid. (Read Only)
            */
            public get isValid(): boolean;
            /** Sampler name. (Read Only)
            */
            public get name(): string;
            /** Returns Recorder associated with the Sampler.
            * @returns Recorder object associated with the Sampler. 
            */
            public GetRecorder () : UnityEngine.Profiling.Recorder
            /** Returns Sampler object for the specific CPU Profiler label.
            * @param $name Profiler Sampler name.
            * @returns Sampler object which represents specific profiler label. 
            */
            public static Get ($name: string) : UnityEngine.Profiling.Sampler
            public static GetNames ($names: System.Collections.Generic.List$1<string>) : number
        }
        /** Custom CPU Profiler label used for profiling arbitrary code blocks.
        */
        class CustomSampler extends UnityEngine.Profiling.Sampler
        {
            protected [__keep_incompatibility]: never;
            /** Creates a new CustomSampler for profiling parts of your code.
            * @param $name Name of the Sampler.
            * @param $collectGpuData Specifies whether this Sampler records GPU timings. If you want the Sampler to record GPU timings, set this to true.
            * @returns CustomSampler object or null if a built-in Sampler with the same name exists. 
            */
            public static Create ($name: string, $collectGpuData?: boolean) : UnityEngine.Profiling.CustomSampler
            /** Begin profiling a piece of code with a custom label defined by this instance of CustomSampler.
            */
            public Begin () : void
            /** Begin profiling a piece of code with a custom label defined by this instance of CustomSampler.
            */
            public Begin ($targetObject: UnityEngine.Object) : void
            /** End profiling a piece of code with a custom label.
            */
            public End () : void
        }
    }
    namespace UnityEngine.Profiling.Experimental {
        class DebugScreenCapture extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace UnityEngine.Profiling.Memory.Experimental {
        class MetaData extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        enum CaptureFlags
        { ManagedObjects = 1, NativeObjects = 2, NativeAllocations = 4, NativeAllocationSites = 8, NativeStackTraces = 16 }
        class MemoryProfiler extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static add_createMetaData ($value: System.Action$1<UnityEngine.Profiling.Memory.Experimental.MetaData>) : void
            public static remove_createMetaData ($value: System.Action$1<UnityEngine.Profiling.Memory.Experimental.MetaData>) : void
        }
    }
    namespace UnityEngine.Jobs {
        interface IJobParallelForTransform
        {
            /** Implement this method to perform work against a specific iteration index and transform.
            * @param $index The index of the Parallel-for-transform loop at which to perform work.
            * @param $transform The position, rotation and scale of the transforms passed into the job.
            */
            Execute ($index: number, $transform: UnityEngine.Jobs.TransformAccess) : void
        }
        /** Position, rotation and scale of an object.
        */
        class TransformAccess extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The position of the transform in world space.
            */
            public get position(): UnityEngine.Vector3;
            public set position(value: UnityEngine.Vector3);
            /** The rotation of the transform in world space stored as a Quaternion.
            */
            public get rotation(): UnityEngine.Quaternion;
            public set rotation(value: UnityEngine.Quaternion);
            /** The position of the transform relative to the parent.
            */
            public get localPosition(): UnityEngine.Vector3;
            public set localPosition(value: UnityEngine.Vector3);
            /** The rotation of the transform relative to the parent transform's rotation.
            */
            public get localRotation(): UnityEngine.Quaternion;
            public set localRotation(value: UnityEngine.Quaternion);
            /** The scale of the transform relative to the parent.
            */
            public get localScale(): UnityEngine.Vector3;
            public set localScale(value: UnityEngine.Vector3);
            /** Matrix that transforms a point from local space into world space (Read Only).
            */
            public get localToWorldMatrix(): UnityEngine.Matrix4x4;
            /** Matrix that transforms a point from world space into local space (Read Only).
            */
            public get worldToLocalMatrix(): UnityEngine.Matrix4x4;
            /** Use this to determine whether this instance refers to a valid Transform.
            */
            public get isValid(): boolean;
            /** Sets the world space position and rotation of the transform.
            */
            public SetPositionAndRotation ($position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion) : void
            /** Sets the position and rotation of the transform in local space (that is, relative to its parent transform).
            */
            public SetLocalPositionAndRotation ($localPosition: UnityEngine.Vector3, $localRotation: UnityEngine.Quaternion) : void
            /** Gets the position and rotation of the transform in world space.
            */
            public GetPositionAndRotation ($position: $Ref<UnityEngine.Vector3>, $rotation: $Ref<UnityEngine.Quaternion>) : void
            /** Gets the position and rotation of the transform in local space (that is, relative to its parent transform).
            */
            public GetLocalPositionAndRotation ($localPosition: $Ref<UnityEngine.Vector3>, $localRotation: $Ref<UnityEngine.Quaternion>) : void
        }
        /** Extension methods for IJobParallelForTransform.
        */
        class IJobParallelForTransformExtensions extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        /** TransformAccessArray.
        */
        class TransformAccessArray extends System.ValueType implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            /** isCreated.
            */
            public get isCreated(): boolean;
            /** Returns array capacity.
            */
            public get capacity(): number;
            public set capacity(value: number);
            /** Length.
            */
            public get length(): number;
            /** Allocate.
            * @param $capacity Capacity.
            * @param $desiredJobCount Desired job count.
            * @param $array TransformAccessArray.
            */
            public static Allocate ($capacity: number, $desiredJobCount: number, $array: $Ref<UnityEngine.Jobs.TransformAccessArray>) : void
            /** Dispose.
            */
            public Dispose () : void
            public get_Item ($index: number) : UnityEngine.Transform
            public set_Item ($index: number, $value: UnityEngine.Transform) : void
            /** Add.
            * @param $transform Transform or instance ID of a transform.
            */
            public Add ($transform: UnityEngine.Transform) : void
            /** Add.
            * @param $transform Transform or instance ID of a transform.
            */
            public Add ($instanceId: number) : void
            /** Remove item at index.
            * @param $index Index.
            */
            public RemoveAtSwapBack ($index: number) : void
            /** Set transforms.
            * @param $transforms Transforms.
            */
            public SetTransforms ($transforms: System.Array$1<UnityEngine.Transform>) : void
            public constructor ($transforms: System.Array$1<UnityEngine.Transform>, $desiredJobCount?: number)
            public constructor ($capacity: number, $desiredJobCount?: number)
        }
    }
    namespace UnityEngine.WSA {
        /** Delegate that can be invoked on specific thread.
        */
        interface AppCallbackItem
        { 
        () : void; 
        Invoke?: () => void;
        }
        var AppCallbackItem: { new (func: () => void): AppCallbackItem; }
        /** This event occurs when window rendering size changes.
        */
        interface WindowSizeChanged
        { 
        (width: number, height: number) : void; 
        Invoke?: (width: number, height: number) => void;
        }
        var WindowSizeChanged: { new (func: (width: number, height: number) => void): WindowSizeChanged; }
        /** Specifies the set of reasons that a windowActivated event was raised.
        */
        enum WindowActivationState
        { CodeActivated = 0, Deactivated = 1, PointerActivated = 2 }
        /** This event occurs when window completes activation or deactivation, it also fires up when you snap and unsnap the application.
        */
        interface WindowActivated
        { 
        (state: UnityEngine.WSA.WindowActivationState) : void; 
        Invoke?: (state: UnityEngine.WSA.WindowActivationState) => void;
        }
        var WindowActivated: { new (func: (state: UnityEngine.WSA.WindowActivationState) => void): WindowActivated; }
        /** Provides essential methods related to Window Store application.
        */
        class Application extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Arguments passed to application.
            */
            public static get arguments(): string;
            /** Advertising ID.
            */
            public static get advertisingIdentifier(): string;
            public static add_windowSizeChanged ($value: UnityEngine.WSA.WindowSizeChanged) : void
            public static remove_windowSizeChanged ($value: UnityEngine.WSA.WindowSizeChanged) : void
            public static add_windowActivated ($value: UnityEngine.WSA.WindowActivated) : void
            public static remove_windowActivated ($value: UnityEngine.WSA.WindowActivated) : void
            /** Executes callback item on application thread.
            * @param $item Item to execute.
            * @param $waitUntilDone Wait until item is executed.
            */
            public static InvokeOnAppThread ($item: UnityEngine.WSA.AppCallbackItem, $waitUntilDone: boolean) : void
            /** Executes callback item on UI thread.
            * @param $item Item to execute.
            * @param $waitUntilDone Wait until item is executed.
            */
            public static InvokeOnUIThread ($item: UnityEngine.WSA.AppCallbackItem, $waitUntilDone: boolean) : void
            /** Returns true if you're running on application thread.
            */
            public static RunningOnAppThread () : boolean
            /** Returns true if you're running on UI thread.
            */
            public static RunningOnUIThread () : boolean
            public constructor ()
        }
        /** Cursor API for Windows Store Apps.
        */
        class Cursor extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Set a custom cursor.
            * @param $id The cursor resource id.
            */
            public static SetCustomCursor ($id: number) : void
        }
        /** List of accessible folders on Windows Store Apps.
        */
        enum Folder
        { Installation = 0, Temporary = 1, Local = 2, Roaming = 3, CameraRoll = 4, DocumentsLibrary = 5, HomeGroup = 6, MediaServerDevices = 7, MusicLibrary = 8, PicturesLibrary = 9, Playlists = 10, RemovableDevices = 11, SavedPictures = 12, VideosLibrary = 13 }
        /** Class which is capable of launching user's default app for file type or a protocol. See also PlayerSettings where you can specify file or URI associations.
        */
        class Launcher extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Launches the default app associated with specified file.
            * @param $folder Folder type where the file is located.
            * @param $relativeFilePath Relative file path inside the specified folder.
            * @param $showWarning Shows user a warning that application will be switched.
            */
            public static LaunchFile ($folder: UnityEngine.WSA.Folder, $relativeFilePath: string, $showWarning: boolean) : void
            /** Opens a dialog for picking the file.
            * @param $fileExtension File extension.
            */
            public static LaunchFileWithPicker ($fileExtension: string) : void
            /** Starts the default app associated with the URI scheme name for the specified URI, using the specified options.
            * @param $uri The URI.
            * @param $showWarning Displays a warning that the URI is potentially unsafe.
            */
            public static LaunchUri ($uri: string, $showWarning: boolean) : void
            public constructor ()
        }
        /** Templates for various tile styles.
        */
        enum TileTemplate
        { TileSquare150x150Image = 0, TileSquare150x150Block = 1, TileSquare150x150Text01 = 2, TileSquare150x150Text02 = 3, TileSquare150x150Text03 = 4, TileSquare150x150Text04 = 5, TileSquare150x150PeekImageAndText01 = 6, TileSquare150x150PeekImageAndText02 = 7, TileSquare150x150PeekImageAndText03 = 8, TileSquare150x150PeekImageAndText04 = 9, TileWide310x150Image = 10, TileWide310x150ImageCollection = 11, TileWide310x150ImageAndText01 = 12, TileWide310x150ImageAndText02 = 13, TileWide310x150BlockAndText01 = 14, TileWide310x150BlockAndText02 = 15, TileWide310x150PeekImageCollection01 = 16, TileWide310x150PeekImageCollection02 = 17, TileWide310x150PeekImageCollection03 = 18, TileWide310x150PeekImageCollection04 = 19, TileWide310x150PeekImageCollection05 = 20, TileWide310x150PeekImageCollection06 = 21, TileWide310x150PeekImageAndText01 = 22, TileWide310x150PeekImageAndText02 = 23, TileWide310x150PeekImage01 = 24, TileWide310x150PeekImage02 = 25, TileWide310x150PeekImage03 = 26, TileWide310x150PeekImage04 = 27, TileWide310x150PeekImage05 = 28, TileWide310x150PeekImage06 = 29, TileWide310x150SmallImageAndText01 = 30, TileWide310x150SmallImageAndText02 = 31, TileWide310x150SmallImageAndText03 = 32, TileWide310x150SmallImageAndText04 = 33, TileWide310x150SmallImageAndText05 = 34, TileWide310x150Text01 = 35, TileWide310x150Text02 = 36, TileWide310x150Text03 = 37, TileWide310x150Text04 = 38, TileWide310x150Text05 = 39, TileWide310x150Text06 = 40, TileWide310x150Text07 = 41, TileWide310x150Text08 = 42, TileWide310x150Text09 = 43, TileWide310x150Text10 = 44, TileWide310x150Text11 = 45, TileSquare310x310BlockAndText01 = 46, TileSquare310x310BlockAndText02 = 47, TileSquare310x310Image = 48, TileSquare310x310ImageAndText01 = 49, TileSquare310x310ImageAndText02 = 50, TileSquare310x310ImageAndTextOverlay01 = 51, TileSquare310x310ImageAndTextOverlay02 = 52, TileSquare310x310ImageAndTextOverlay03 = 53, TileSquare310x310ImageCollectionAndText01 = 54, TileSquare310x310ImageCollectionAndText02 = 55, TileSquare310x310ImageCollection = 56, TileSquare310x310SmallImagesAndTextList01 = 57, TileSquare310x310SmallImagesAndTextList02 = 58, TileSquare310x310SmallImagesAndTextList03 = 59, TileSquare310x310SmallImagesAndTextList04 = 60, TileSquare310x310Text01 = 61, TileSquare310x310Text02 = 62, TileSquare310x310Text03 = 63, TileSquare310x310Text04 = 64, TileSquare310x310Text05 = 65, TileSquare310x310Text06 = 66, TileSquare310x310Text07 = 67, TileSquare310x310Text08 = 68, TileSquare310x310TextList01 = 69, TileSquare310x310TextList02 = 70, TileSquare310x310TextList03 = 71, TileSquare310x310SmallImageAndText01 = 72, TileSquare310x310SmallImagesAndTextList05 = 73, TileSquare310x310Text09 = 74, TileSquare71x71IconWithBadge = 75, TileSquare150x150IconWithBadge = 76, TileWide310x150IconWithBadgeAndText = 77, TileSquare71x71Image = 78, TileTall150x310Image = 79, TileSquare99x99IconWithBadge = 1000, TileSquare210x210IconWithBadge = 1001, TileWide432x210IconWithBadgeAndText = 1002 }
        /** Templates for various toast styles.
        */
        enum ToastTemplate
        { ToastImageAndText01 = 0, ToastImageAndText02 = 1, ToastImageAndText03 = 2, ToastImageAndText04 = 3, ToastText01 = 4, ToastText02 = 5, ToastText03 = 6, ToastText04 = 7 }
        /** Style for foreground text on a secondary tile.
        */
        enum TileForegroundText
        { Default = -1, Dark = 0, Light = 1 }
        /** Defines the default look of secondary tile.
        */
        class SecondaryTileData extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Arguments to be passed for application when secondary tile is activated.
            */
            public arguments : string
            /** Defines, whether backgroundColor should be used.
            */
            public backgroundColorSet : boolean
            /** Display name for secondary tile.
            */
            public displayName : string
            /** Defines the style for foreground text on a secondary tile.
            */
            public foregroundText : UnityEngine.WSA.TileForegroundText
            /** Uri to logo, shown for secondary tile on lock screen.
            */
            public lockScreenBadgeLogo : string
            /** Whether to show secondary tile on lock screen.
            */
            public lockScreenDisplayBadgeAndTileText : boolean
            /** Phonetic name for secondary tile.
            */
            public phoneticName : string
            /** Defines whether secondary tile is copied to another device when application is installed by the same users account.
            */
            public roamingEnabled : boolean
            /** Defines whether the displayName should be shown on a medium secondary tile.
            */
            public showNameOnSquare150x150Logo : boolean
            /** Defines whether the displayName should be shown on a large secondary tile.
            */
            public showNameOnSquare310x310Logo : boolean
            /** Defines whether the displayName should be shown on a wide secondary tile.
            */
            public showNameOnWide310x150Logo : boolean
            /** Uri to the logo for medium size tile.
            */
            public square150x150Logo : string
            /** Uri to the logo shown on tile
            */
            public square30x30Logo : string
            /** Uri to the logo for large size tile.
            */
            public square310x310Logo : string
            /** Uri to the logo for small size tile.
            */
            public square70x70Logo : string
            /** Unique identifier within application for a secondary tile.
            */
            public tileId : string
            /** Uri to the logo for wide tile.
            */
            public wide310x150Logo : string
            /** Defines background color for secondary tile.
            */
            public get backgroundColor(): UnityEngine.Color32;
            public set backgroundColor(value: UnityEngine.Color32);
            public constructor ($id: string, $displayName: string)
        }
        /** Represents tile on Windows start screen
        */
        class Tile extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Returns applications main tile
            */
            public static get main(): UnityEngine.WSA.Tile;
            /** A unique string, identifying secondary tile
            */
            public get id(): string;
            /** Whether secondary tile was approved (pinned to start screen) or rejected by user.
            */
            public get hasUserConsent(): boolean;
            /** Whether secondary tile is pinned to start screen.
            */
            public get exists(): boolean;
            /** Get template XML for tile notification.
            * @param $templ A template identifier.
            * @returns String, which is an empty XML document to be filled and used for tile notification. 
            */
            public static GetTemplate ($templ: UnityEngine.WSA.TileTemplate) : string
            /** Send a notification for tile (update tiles look).
            * @param $xml A string containing XML document for new tile look.
            * @param $medium An uri to 150x150 image, shown on medium tile.
            * @param $wide An uri to a 310x150 image to be shown on a wide tile (if such issupported).
            * @param $large An uri to a 310x310 image to be shown on a large tile (if such is supported).
            * @param $text A text to shown on a tile.
            */
            public Update ($xml: string) : void
            /** Send a notification for tile (update tiles look).
            * @param $xml A string containing XML document for new tile look.
            * @param $medium An uri to 150x150 image, shown on medium tile.
            * @param $wide An uri to a 310x150 image to be shown on a wide tile (if such issupported).
            * @param $large An uri to a 310x310 image to be shown on a large tile (if such is supported).
            * @param $text A text to shown on a tile.
            */
            public Update ($medium: string, $wide: string, $large: string, $text: string) : void
            /** Starts periodic update of a tile.
            * @param $uri a remote location fromwhere to retrieve tile update
            * @param $interval a time interval in minutes, will be rounded to a value, supported by the system
            */
            public PeriodicUpdate ($uri: string, $interval: number) : void
            /** Stops previously started periodic update of a tile.
            */
            public StopPeriodicUpdate () : void
            /** Sets or updates badge on a tile to an image.
            * @param $image Image identifier.
            */
            public UpdateBadgeImage ($image: string) : void
            /** Set or update a badge on a tile to a number.
            * @param $number Number to be shown on a badge.
            */
            public UpdateBadgeNumber ($number: number) : void
            /** Remove badge from tile.
            */
            public RemoveBadge () : void
            /** Starts periodic update of a  badge on a tile.
            * @param $uri A remote location from where to retrieve tile update
            * @param $interval A time interval in minutes, will be rounded to a value, supported by the system
            */
            public PeriodicBadgeUpdate ($uri: string, $interval: number) : void
            /** Stops previously started periodic update of a tile.
            */
            public StopPeriodicBadgeUpdate () : void
            /** Whether secondary tile is pinned to start screen.
            * @param $tileId An identifier for secondary tile.
            */
            public static Exists ($tileId: string) : boolean
            /** Creates new or updates existing secondary tile.
            * @param $data The data used to create or update secondary tile.
            * @param $pos The coordinates for a request to create new tile.
            * @param $area The area on the screen above which the request to create new tile will be displayed.
            * @returns New Tile object, that can be used for further work with the tile. 
            */
            public static CreateOrUpdateSecondary ($data: UnityEngine.WSA.SecondaryTileData) : UnityEngine.WSA.Tile
            /** Creates new or updates existing secondary tile.
            * @param $data The data used to create or update secondary tile.
            * @param $pos The coordinates for a request to create new tile.
            * @param $area The area on the screen above which the request to create new tile will be displayed.
            * @returns New Tile object, that can be used for further work with the tile. 
            */
            public static CreateOrUpdateSecondary ($data: UnityEngine.WSA.SecondaryTileData, $pos: UnityEngine.Vector2) : UnityEngine.WSA.Tile
            /** Creates new or updates existing secondary tile.
            * @param $data The data used to create or update secondary tile.
            * @param $pos The coordinates for a request to create new tile.
            * @param $area The area on the screen above which the request to create new tile will be displayed.
            * @returns New Tile object, that can be used for further work with the tile. 
            */
            public static CreateOrUpdateSecondary ($data: UnityEngine.WSA.SecondaryTileData, $area: UnityEngine.Rect) : UnityEngine.WSA.Tile
            /** Returns the secondary tile, identified by tile id.
            * @param $tileId A tile identifier.
            * @returns A Tile object or null if secondary tile does not exist (not pinned to start screen and user request is complete). 
            */
            public static GetSecondary ($tileId: string) : UnityEngine.WSA.Tile
            /** Gets all secondary tiles.
            * @returns An array of Tile objects. 
            */
            public static GetSecondaries () : System.Array$1<UnityEngine.WSA.Tile>
            /** Show a request to unpin secondary tile from start screen.
            * @param $pos The coordinates for a request to unpin tile.
            * @param $area The area on the screen above which the request to unpin tile will be displayed.
            */
            public Delete () : void
            /** Show a request to unpin secondary tile from start screen.
            * @param $tileId An identifier for secondary tile.
            * @param $pos The coordinates for a request to unpin tile.
            * @param $area The area on the screen above which the request to unpin tile will be displayed.
            */
            public static DeleteSecondary ($tileId: string) : void
            /** Show a request to unpin secondary tile from start screen.
            * @param $pos The coordinates for a request to unpin tile.
            * @param $area The area on the screen above which the request to unpin tile will be displayed.
            */
            public Delete ($pos: UnityEngine.Vector2) : void
            /** Show a request to unpin secondary tile from start screen.
            * @param $tileId An identifier for secondary tile.
            * @param $pos The coordinates for a request to unpin tile.
            * @param $area The area on the screen above which the request to unpin tile will be displayed.
            */
            public static DeleteSecondary ($tileId: string, $pos: UnityEngine.Vector2) : void
            /** Show a request to unpin secondary tile from start screen.
            * @param $pos The coordinates for a request to unpin tile.
            * @param $area The area on the screen above which the request to unpin tile will be displayed.
            */
            public Delete ($area: UnityEngine.Rect) : void
            /** Show a request to unpin secondary tile from start screen.
            * @param $tileId An identifier for secondary tile.
            * @param $pos The coordinates for a request to unpin tile.
            * @param $area The area on the screen above which the request to unpin tile will be displayed.
            */
            public static DeleteSecondary ($tileId: string, $area: UnityEngine.Rect) : void
        }
        /** Represents a toast notification in Windows Store Apps.
        */
        class Toast extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Arguments to be passed for application when toast notification is activated.
            */
            public get arguments(): string;
            public set arguments(value: string);
            /** true if toast was activated by user.
            */
            public get activated(): boolean;
            /** true if toast notification was dismissed (for any reason).
            */
            public get dismissed(): boolean;
            /** true if toast notification was explicitly dismissed by user.
            */
            public get dismissedByUser(): boolean;
            /** Get template XML for toast notification.
            * @param $templ A template identifier.
            * @returns string, which is an empty XML document to be filled and used for toast notification. 
            */
            public static GetTemplate ($templ: UnityEngine.WSA.ToastTemplate) : string
            /** Create toast notification.
            * @param $xml XML document with tile data.
            * @param $image Uri to image to show on a toast, can be empty, in that case text-only notification will be shown.
            * @param $text A text to display on a toast notification.
            * @returns A toast object for further work with created notification or null, if creation of toast failed. 
            */
            public static Create ($xml: string) : UnityEngine.WSA.Toast
            /** Create toast notification.
            * @param $xml XML document with tile data.
            * @param $image Uri to image to show on a toast, can be empty, in that case text-only notification will be shown.
            * @param $text A text to display on a toast notification.
            * @returns A toast object for further work with created notification or null, if creation of toast failed. 
            */
            public static Create ($image: string, $text: string) : UnityEngine.WSA.Toast
            /** Show toast notification.
            */
            public Show () : void
            /** Hide displayed toast notification.
            */
            public Hide () : void
        }
    }
    namespace UnityEngine.Windows {
        /** This class provides information regarding application's trial status and allows initiating application purchase.
        */
        class LicenseInformation extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Checks whether the application is installed in trial mode.
            */
            public static get isOnAppTrial(): boolean;
            /** Attempts to purchase the app if it is in installed in trial mode.
            * @returns Purchase receipt. 
            */
            public static PurchaseApp () : string
        }
        /** Exposes useful information related to crash reporting on Windows platforms.
        */
        class CrashReporting extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Returns the path to the crash report folder on Windows.
            */
            public static get crashReportFolder(): string;
        }
        /** Class representing cryptography algorithms.
        */
        class Crypto extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Computes MD5 hash value for the specified byte array.
            * @param $buffer The input to compute the hash code for.
            */
            public static ComputeMD5Hash ($buffer: System.Array$1<number>) : System.Array$1<number>
            /** Computes SHA1 hash value for the specified byte array.
            * @param $buffer The input to compute the hash code for.
            */
            public static ComputeSHA1Hash ($buffer: System.Array$1<number>) : System.Array$1<number>
        }
        /** Exposes static methods for directory operations.
        */
        class Directory extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Returns a path to temporary folder.
            */
            public static get temporaryFolder(): string;
            /** Returns a path to local folder.
            */
            public static get localFolder(): string;
            /** Returns a path to roaming folder.
            */
            public static get roamingFolder(): string;
            /** Creates directory in the specified path.
            * @param $path The directory path to create.
            */
            public static CreateDirectory ($path: string) : void
            /** Determines whether the given path refers to an existing directory.
            * @param $path The path to test.
            */
            public static Exists ($path: string) : boolean
            /** Deletes a directory from a specified path.
            * @param $path The name of the directory to remove.
            */
            public static Delete ($path: string) : void
        }
        /** Provides static methods for file operations.
        */
        class File extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Opens a binary file, reads the contents of the file into a byte array, and then closes the file.
            * @param $path The file to open for reading.
            */
            public static ReadAllBytes ($path: string) : System.Array$1<number>
            /** Creates a new file, writes the specified byte array to the file, and then closes the file. If the target file already exists, it is overwritten.
            * @param $path The file to write to.
            * @param $bytes The bytes to write to the file.
            */
            public static WriteAllBytes ($path: string, $bytes: System.Array$1<number>) : void
            /** Determines whether the specified file exists.
            * @param $path The file to check.
            */
            public static Exists ($path: string) : boolean
            /** Deletes the specified file.
            * @param $path The name of the file to be deleted.
            */
            public static Delete ($path: string) : void
        }
        /** Provides static methods for Windows specific input manipulation.
        */
        class Input extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Forwards raw input events to Unity.
            * @param $rawInputHeaderIndices Pointer to array of indices that specify the byte offsets of RAWINPUTHEADER structures in rawInputData.
            * @param $rawInputDataIndices Pointer to array of indices that specify the byte offsets of RAWINPUT::data field in rawInputData.
            * @param $indicesCount Number of RAWINPUT events.
            * @param $rawInputData Pointer to byte array containing RAWINPUT events.
            * @param $rawInputDataSize RawInputData array size in bytes.
            */
            public static ForwardRawInput ($rawInputHeaderIndices: System.IntPtr, $rawInputDataIndices: System.IntPtr, $indicesCount: number, $rawInputData: System.IntPtr, $rawInputDataSize: number) : void
        }
    }
    namespace UnityEngine.Windows.Speech {
        /** Phrase recognition system is responsible for managing phrase recognizers and dispatching recognition events to them.
        */
        class PhraseRecognitionSystem extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Returns whether speech recognition is supported on the machine that the application is running on.
            */
            public static get isSupported(): boolean;
            /** Returns the current status of the phrase recognition system.
            */
            public static get Status(): UnityEngine.Windows.Speech.SpeechSystemStatus;
            /** Attempts to restart the phrase recognition system.
            */
            public static Restart () : void
            /** Shuts phrase recognition system down.
            */
            public static Shutdown () : void
            public static add_OnError ($value: UnityEngine.Windows.Speech.PhraseRecognitionSystem.ErrorDelegate) : void
            public static remove_OnError ($value: UnityEngine.Windows.Speech.PhraseRecognitionSystem.ErrorDelegate) : void
            public static add_OnStatusChanged ($value: UnityEngine.Windows.Speech.PhraseRecognitionSystem.StatusDelegate) : void
            public static remove_OnStatusChanged ($value: UnityEngine.Windows.Speech.PhraseRecognitionSystem.StatusDelegate) : void
        }
        /** Represents the current status of the speech recognition system or a dictation recognizer.
        */
        enum SpeechSystemStatus
        { Stopped = 0, Running = 1, Failed = 2 }
        /** Represents an error in a speech recognition system.
        */
        enum SpeechError
        { NoError = 0, TopicLanguageNotSupported = 1, GrammarLanguageMismatch = 2, GrammarCompilationFailure = 3, AudioQualityFailure = 4, PauseLimitExceeded = 5, TimeoutExceeded = 6, NetworkFailure = 7, MicrophoneUnavailable = 8, UnknownError = 9 }
        /** A common base class for both keyword recognizer and grammar recognizer.
        */
        class PhraseRecognizer extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            /** Tells whether the phrase recognizer is listening for phrases.
            */
            public get IsRunning(): boolean;
            public add_OnPhraseRecognized ($value: UnityEngine.Windows.Speech.PhraseRecognizer.PhraseRecognizedDelegate) : void
            public remove_OnPhraseRecognized ($value: UnityEngine.Windows.Speech.PhraseRecognizer.PhraseRecognizedDelegate) : void
            /** Makes the phrase recognizer start listening to phrases.
            */
            public Start () : void
            /** Stops the phrase recognizer from listening to phrases.
            */
            public Stop () : void
            /** Disposes the resources used by phrase recognizer.
            */
            public Dispose () : void
        }
        /** Provides information about a phrase recognized event.
        */
        class PhraseRecognizedEventArgs extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** A measure of correct recognition certainty.
            */
            public confidence : UnityEngine.Windows.Speech.ConfidenceLevel
            /** A semantic meaning of recognized phrase.
            */
            public semanticMeanings : System.Array$1<UnityEngine.Windows.Speech.SemanticMeaning>
            /** The text that was recognized.
            */
            public text : string
            /** The moment in time when uttering of the phrase began.
            */
            public phraseStartTime : System.DateTime
            /** The time it took for the phrase to be uttered.
            */
            public phraseDuration : System.TimeSpan
        }
        /** DictationRecognizer listens to speech input and attempts to determine what phrase was uttered.
        */
        class DictationRecognizer extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            /** Indicates the status of dictation recognizer.
            */
            public get Status(): UnityEngine.Windows.Speech.SpeechSystemStatus;
            /** The time length in seconds before dictation recognizer session ends due to lack of audio input.
            */
            public get AutoSilenceTimeoutSeconds(): number;
            public set AutoSilenceTimeoutSeconds(value: number);
            /** The time length in seconds before dictation recognizer session ends due to lack of audio input in case there was no audio heard in the current session.
            */
            public get InitialSilenceTimeoutSeconds(): number;
            public set InitialSilenceTimeoutSeconds(value: number);
            public add_DictationHypothesis ($value: UnityEngine.Windows.Speech.DictationRecognizer.DictationHypothesisDelegate) : void
            public remove_DictationHypothesis ($value: UnityEngine.Windows.Speech.DictationRecognizer.DictationHypothesisDelegate) : void
            public add_DictationResult ($value: UnityEngine.Windows.Speech.DictationRecognizer.DictationResultDelegate) : void
            public remove_DictationResult ($value: UnityEngine.Windows.Speech.DictationRecognizer.DictationResultDelegate) : void
            public add_DictationComplete ($value: UnityEngine.Windows.Speech.DictationRecognizer.DictationCompletedDelegate) : void
            public remove_DictationComplete ($value: UnityEngine.Windows.Speech.DictationRecognizer.DictationCompletedDelegate) : void
            public add_DictationError ($value: UnityEngine.Windows.Speech.DictationRecognizer.DictationErrorHandler) : void
            public remove_DictationError ($value: UnityEngine.Windows.Speech.DictationRecognizer.DictationErrorHandler) : void
            /** Starts the dictation recognization session. Dictation recognizer can only be started if PhraseRecognitionSystem is not running.
            */
            public Start () : void
            /** Stops the dictation recognization session.
            */
            public Stop () : void
            /** Disposes the resources this dictation recognizer uses.
            */
            public Dispose () : void
            public constructor ()
            public constructor ($confidenceLevel: UnityEngine.Windows.Speech.ConfidenceLevel)
            public constructor ($topic: UnityEngine.Windows.Speech.DictationTopicConstraint)
            public constructor ($minimumConfidence: UnityEngine.Windows.Speech.ConfidenceLevel, $topic: UnityEngine.Windows.Speech.DictationTopicConstraint)
        }
        /** Used by KeywordRecognizer, GrammarRecognizer, DictationRecognizer. Phrases under the specified minimum level will be ignored.
        */
        enum ConfidenceLevel
        { High = 0, Medium = 1, Low = 2, Rejected = 3 }
        /** Represents the reason why dictation session has completed.
        */
        enum DictationCompletionCause
        { Complete = 0, AudioQualityFailure = 1, Canceled = 2, TimeoutExceeded = 3, PauseLimitExceeded = 4, NetworkFailure = 5, MicrophoneUnavailable = 6, UnknownError = 7 }
        /** DictationTopicConstraint enum specifies the scenario for which a specific dictation recognizer should optimize.
        */
        enum DictationTopicConstraint
        { WebSearch = 0, Form = 1, Dictation = 2 }
        /** Semantic meaning is a collection of semantic properties of a recognized phrase. These semantic properties can be specified in SRGS grammar files.
        */
        class SemanticMeaning extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** A key of semantic meaning.
            */
            public key : string
            /** Values of semantic property that the correspond to the semantic meaning key.
            */
            public values : System.Array$1<string>
        }
        /** KeywordRecognizer listens to speech input and attempts to match uttered phrases to a list of registered keywords.
        */
        class KeywordRecognizer extends UnityEngine.Windows.Speech.PhraseRecognizer implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            /** Returns the list of keywords which was supplied when the keyword recognizer was created.
            */
            public get Keywords(): System.Collections.Generic.IEnumerable$1<string>;
            public constructor ($keywords: System.Array$1<string>)
            public constructor ($keywords: System.Array$1<string>, $minimumConfidence: UnityEngine.Windows.Speech.ConfidenceLevel)
        }
        /** The GrammarRecognizer is a complement to the KeywordRecognizer. In many cases developers will find the KeywordRecognizer fills all their development needs. However, in some cases, more complex grammars will be better expressed in the form of an xml file on disk.
        The GrammarRecognizer uses Extensible Markup Language (XML) elements and attributes, as specified in the World Wide Web Consortium (W3C) Speech Recognition Grammar Specification (SRGS) Version 1.0. These XML elements and attributes represent the rule structures that define the words or phrases (commands) recognized by speech recognition engines.
        */
        class GrammarRecognizer extends UnityEngine.Windows.Speech.PhraseRecognizer implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            /** Returns the grammar file path which was supplied when the grammar recognizer was created.
            */
            public get GrammarFilePath(): string;
            public constructor ($grammarFilePath: string)
            public constructor ($grammarFilePath: string, $minimumConfidence: UnityEngine.Windows.Speech.ConfidenceLevel)
        }
    }
    namespace UnityEngine.Windows.Speech.PhraseRecognitionSystem {
        interface ErrorDelegate
        { 
        (errorCode: UnityEngine.Windows.Speech.SpeechError) : void; 
        Invoke?: (errorCode: UnityEngine.Windows.Speech.SpeechError) => void;
        }
        var ErrorDelegate: { new (func: (errorCode: UnityEngine.Windows.Speech.SpeechError) => void): ErrorDelegate; }
        interface StatusDelegate
        { 
        (status: UnityEngine.Windows.Speech.SpeechSystemStatus) : void; 
        Invoke?: (status: UnityEngine.Windows.Speech.SpeechSystemStatus) => void;
        }
        var StatusDelegate: { new (func: (status: UnityEngine.Windows.Speech.SpeechSystemStatus) => void): StatusDelegate; }
    }
    namespace UnityEngine.Windows.Speech.PhraseRecognizer {
        interface PhraseRecognizedDelegate
        { 
        (args: UnityEngine.Windows.Speech.PhraseRecognizedEventArgs) : void; 
        Invoke?: (args: UnityEngine.Windows.Speech.PhraseRecognizedEventArgs) => void;
        }
        var PhraseRecognizedDelegate: { new (func: (args: UnityEngine.Windows.Speech.PhraseRecognizedEventArgs) => void): PhraseRecognizedDelegate; }
    }
    namespace UnityEngine.Windows.Speech.DictationRecognizer {
        interface DictationHypothesisDelegate
        { 
        (text: string) : void; 
        Invoke?: (text: string) => void;
        }
        var DictationHypothesisDelegate: { new (func: (text: string) => void): DictationHypothesisDelegate; }
        interface DictationResultDelegate
        { 
        (text: string, confidence: UnityEngine.Windows.Speech.ConfidenceLevel) : void; 
        Invoke?: (text: string, confidence: UnityEngine.Windows.Speech.ConfidenceLevel) => void;
        }
        var DictationResultDelegate: { new (func: (text: string, confidence: UnityEngine.Windows.Speech.ConfidenceLevel) => void): DictationResultDelegate; }
        interface DictationCompletedDelegate
        { 
        (cause: UnityEngine.Windows.Speech.DictationCompletionCause) : void; 
        Invoke?: (cause: UnityEngine.Windows.Speech.DictationCompletionCause) => void;
        }
        var DictationCompletedDelegate: { new (func: (cause: UnityEngine.Windows.Speech.DictationCompletionCause) => void): DictationCompletedDelegate; }
        interface DictationErrorHandler
        { 
        (error: string, hresult: number) : void; 
        Invoke?: (error: string, hresult: number) => void;
        }
        var DictationErrorHandler: { new (func: (error: string, hresult: number) => void): DictationErrorHandler; }
    }
    namespace UnityEngine.Windows.WebCam {
        /** Image Encoding Format.
        */
        enum PhotoCaptureFileOutputFormat
        { PNG = 0, JPG = 1 }
        /** Captures a photo from the web camera and stores it in memory or on disk.
        */
        class PhotoCapture extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            /** A list of all the supported device resolutions for taking pictures.
            */
            public static get SupportedResolutions(): System.Collections.Generic.IEnumerable$1<UnityEngine.Resolution>;
            public static CreateAsync ($showHolograms: boolean, $onCreatedCallback: UnityEngine.Windows.WebCam.PhotoCapture.OnCaptureResourceCreatedCallback) : void
            public static CreateAsync ($onCreatedCallback: UnityEngine.Windows.WebCam.PhotoCapture.OnCaptureResourceCreatedCallback) : void
            public StartPhotoModeAsync ($setupParams: UnityEngine.Windows.WebCam.CameraParameters, $onPhotoModeStartedCallback: UnityEngine.Windows.WebCam.PhotoCapture.OnPhotoModeStartedCallback) : void
            public StopPhotoModeAsync ($onPhotoModeStoppedCallback: UnityEngine.Windows.WebCam.PhotoCapture.OnPhotoModeStoppedCallback) : void
            public TakePhotoAsync ($filename: string, $fileOutputFormat: UnityEngine.Windows.WebCam.PhotoCaptureFileOutputFormat, $onCapturedPhotoToDiskCallback: UnityEngine.Windows.WebCam.PhotoCapture.OnCapturedToDiskCallback) : void
            public TakePhotoAsync ($onCapturedPhotoToMemoryCallback: UnityEngine.Windows.WebCam.PhotoCapture.OnCapturedToMemoryCallback) : void
            /** Provides a COM pointer to the native IVideoDeviceController.
            * @returns A native COM pointer to the IVideoDeviceController. 
            */
            public GetUnsafePointerToVideoDeviceController () : System.IntPtr
            /** Dispose must be called to shutdown the PhotoCapture instance.
            */
            public Dispose () : void
        }
        /** When calling PhotoCapture.StartPhotoModeAsync, you must pass in a CameraParameters object that contains the various settings that the web camera will use.
        */
        class CameraParameters extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The opacity of captured holograms.
            */
            public get hologramOpacity(): number;
            public set hologramOpacity(value: number);
            /** The framerate at which to capture video.  This is only for use with VideoCapture.
            */
            public get frameRate(): number;
            public set frameRate(value: number);
            /** A valid width resolution for use with the web camera.
            */
            public get cameraResolutionWidth(): number;
            public set cameraResolutionWidth(value: number);
            /** A valid height resolution for use with the web camera.
            */
            public get cameraResolutionHeight(): number;
            public set cameraResolutionHeight(value: number);
            /** The pixel format used to capture and record your image data.
            */
            public get pixelFormat(): UnityEngine.Windows.WebCam.CapturePixelFormat;
            public set pixelFormat(value: UnityEngine.Windows.WebCam.CapturePixelFormat);
            public constructor ($webCamMode: UnityEngine.Windows.WebCam.WebCamMode)
        }
        /** Contains information captured from the web camera.
        */
        class PhotoCaptureFrame extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            /** The length of the raw IMFMediaBuffer which contains the image captured.
            */
            public get dataLength(): number;
            /** Specifies whether or not spatial data was captured.
            */
            public get hasLocationData(): boolean;
            /** The raw image data pixel format.
            */
            public get pixelFormat(): UnityEngine.Windows.WebCam.CapturePixelFormat;
            /** This method will return the camera to world matrix at the time the photo was captured if location data if available.
            * @param $cameraToWorldMatrix A matrix to be populated by the Camera to world Matrix.
            * @returns True if a valid matrix is returned or false otherwise.  This will be false if the frame has no location data. 
            */
            public TryGetCameraToWorldMatrix ($cameraToWorldMatrix: $Ref<UnityEngine.Matrix4x4>) : boolean
            /** This method will return the projection matrix at the time the photo was captured if location data if available.
            * @param $nearClipPlane The near clip plane distance.
            * @param $farClipPlane The far clip plane distance.
            * @param $projectionMatrix A matrix to be populated by the Projection Matrix.
            * @returns True if a valid matrix is returned or false otherwise.  This will be false if the frame has no location data. 
            */
            public TryGetProjectionMatrix ($projectionMatrix: $Ref<UnityEngine.Matrix4x4>) : boolean
            /** This method will return the projection matrix at the time the photo was captured if location data if available.
            * @param $nearClipPlane The near clip plane distance.
            * @param $farClipPlane The far clip plane distance.
            * @param $projectionMatrix A matrix to be populated by the Projection Matrix.
            * @returns True if a valid matrix is returned or false otherwise.  This will be false if the frame has no location data. 
            */
            public TryGetProjectionMatrix ($nearClipPlane: number, $farClipPlane: number, $projectionMatrix: $Ref<UnityEngine.Matrix4x4>) : boolean
            /** This method will copy the captured image data into a user supplied texture for use in Unity.
            * @param $targetTexture The target texture that the captured image data will be copied to.
            */
            public UploadImageDataToTexture ($targetTexture: UnityEngine.Texture2D) : void
            /** Provides a COM pointer to the native IMFMediaBuffer that contains the image data.
            * @returns A native COM pointer to the IMFMediaBuffer which contains the image data. 
            */
            public GetUnsafePointerToBuffer () : System.IntPtr
            public CopyRawImageDataIntoBuffer ($byteBuffer: System.Collections.Generic.List$1<number>) : void
            /** Disposes the PhotoCaptureFrame and any resources it uses.
            */
            public Dispose () : void
        }
        /** The encoded image or video pixel format to use for PhotoCapture and VideoCapture.
        */
        enum CapturePixelFormat
        { BGRA32 = 0, NV12 = 1, JPEG = 2, PNG = 3 }
        /** Records a video from the web camera directly to disk.
        */
        class VideoCapture extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            /** A list of all the supported device resolutions for recording videos.
            */
            public static get SupportedResolutions(): System.Collections.Generic.IEnumerable$1<UnityEngine.Resolution>;
            /** Indicates whether or not the VideoCapture instance is currently recording video.
            */
            public get IsRecording(): boolean;
            /** Returns the supported frame rates at which a video can be recorded given a resolution.
            * @param $resolution A recording resolution.
            * @returns The frame rates at which the video can be recorded. 
            */
            public static GetSupportedFrameRatesForResolution ($resolution: UnityEngine.Resolution) : System.Collections.Generic.IEnumerable$1<number>
            public static CreateAsync ($showHolograms: boolean, $onCreatedCallback: UnityEngine.Windows.WebCam.VideoCapture.OnVideoCaptureResourceCreatedCallback) : void
            public static CreateAsync ($onCreatedCallback: UnityEngine.Windows.WebCam.VideoCapture.OnVideoCaptureResourceCreatedCallback) : void
            public StartVideoModeAsync ($setupParams: UnityEngine.Windows.WebCam.CameraParameters, $audioState: UnityEngine.Windows.WebCam.VideoCapture.AudioState, $onVideoModeStartedCallback: UnityEngine.Windows.WebCam.VideoCapture.OnVideoModeStartedCallback) : void
            public StopVideoModeAsync ($onVideoModeStoppedCallback: UnityEngine.Windows.WebCam.VideoCapture.OnVideoModeStoppedCallback) : void
            public StartRecordingAsync ($filename: string, $onStartedRecordingVideoCallback: UnityEngine.Windows.WebCam.VideoCapture.OnStartedRecordingVideoCallback) : void
            public StopRecordingAsync ($onStoppedRecordingVideoCallback: UnityEngine.Windows.WebCam.VideoCapture.OnStoppedRecordingVideoCallback) : void
            /** Provides a COM pointer to the native IVideoDeviceController.
            * @returns A native COM pointer to the IVideoDeviceController. 
            */
            public GetUnsafePointerToVideoDeviceController () : System.IntPtr
            /** You must call Dispose to shutdown the VideoCapture instance and release the native WinRT objects.
            */
            public Dispose () : void
        }
        /** Describes the active mode of the Web Camera resource.
        */
        enum WebCamMode
        { None = 0, PhotoMode = 1, VideoMode = 2 }
        /** Contains general information about the current state of the web camera.
        */
        class WebCam extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Specifies what mode the Web Camera is currently in.
            */
            public static get Mode(): UnityEngine.Windows.WebCam.WebCamMode;
            public constructor ()
        }
    }
    namespace UnityEngine.Windows.WebCam.PhotoCapture {
        interface OnCaptureResourceCreatedCallback
        { 
        (captureObject: UnityEngine.Windows.WebCam.PhotoCapture) : void; 
        Invoke?: (captureObject: UnityEngine.Windows.WebCam.PhotoCapture) => void;
        }
        var OnCaptureResourceCreatedCallback: { new (func: (captureObject: UnityEngine.Windows.WebCam.PhotoCapture) => void): OnCaptureResourceCreatedCallback; }
        interface OnPhotoModeStartedCallback
        { 
        (result: UnityEngine.Windows.WebCam.PhotoCapture.PhotoCaptureResult) : void; 
        Invoke?: (result: UnityEngine.Windows.WebCam.PhotoCapture.PhotoCaptureResult) => void;
        }
        var OnPhotoModeStartedCallback: { new (func: (result: UnityEngine.Windows.WebCam.PhotoCapture.PhotoCaptureResult) => void): OnPhotoModeStartedCallback; }
        class PhotoCaptureResult extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public resultType : UnityEngine.Windows.WebCam.PhotoCapture.CaptureResultType
            public hResult : bigint
            public get success(): boolean;
        }
        interface OnPhotoModeStoppedCallback
        { 
        (result: UnityEngine.Windows.WebCam.PhotoCapture.PhotoCaptureResult) : void; 
        Invoke?: (result: UnityEngine.Windows.WebCam.PhotoCapture.PhotoCaptureResult) => void;
        }
        var OnPhotoModeStoppedCallback: { new (func: (result: UnityEngine.Windows.WebCam.PhotoCapture.PhotoCaptureResult) => void): OnPhotoModeStoppedCallback; }
        interface OnCapturedToDiskCallback
        { 
        (result: UnityEngine.Windows.WebCam.PhotoCapture.PhotoCaptureResult) : void; 
        Invoke?: (result: UnityEngine.Windows.WebCam.PhotoCapture.PhotoCaptureResult) => void;
        }
        var OnCapturedToDiskCallback: { new (func: (result: UnityEngine.Windows.WebCam.PhotoCapture.PhotoCaptureResult) => void): OnCapturedToDiskCallback; }
        interface OnCapturedToMemoryCallback
        { 
        (result: UnityEngine.Windows.WebCam.PhotoCapture.PhotoCaptureResult, photoCaptureFrame: UnityEngine.Windows.WebCam.PhotoCaptureFrame) : void; 
        Invoke?: (result: UnityEngine.Windows.WebCam.PhotoCapture.PhotoCaptureResult, photoCaptureFrame: UnityEngine.Windows.WebCam.PhotoCaptureFrame) => void;
        }
        var OnCapturedToMemoryCallback: { new (func: (result: UnityEngine.Windows.WebCam.PhotoCapture.PhotoCaptureResult, photoCaptureFrame: UnityEngine.Windows.WebCam.PhotoCaptureFrame) => void): OnCapturedToMemoryCallback; }
        enum CaptureResultType
        { Success = 0, UnknownError = 1 }
    }
    namespace UnityEngine.Windows.WebCam.VideoCapture {
        interface OnVideoCaptureResourceCreatedCallback
        { 
        (captureObject: UnityEngine.Windows.WebCam.VideoCapture) : void; 
        Invoke?: (captureObject: UnityEngine.Windows.WebCam.VideoCapture) => void;
        }
        var OnVideoCaptureResourceCreatedCallback: { new (func: (captureObject: UnityEngine.Windows.WebCam.VideoCapture) => void): OnVideoCaptureResourceCreatedCallback; }
        enum AudioState
        { MicAudio = 0, ApplicationAudio = 1, ApplicationAndMicAudio = 2, None = 3 }
        interface OnVideoModeStartedCallback
        { 
        (result: UnityEngine.Windows.WebCam.VideoCapture.VideoCaptureResult) : void; 
        Invoke?: (result: UnityEngine.Windows.WebCam.VideoCapture.VideoCaptureResult) => void;
        }
        var OnVideoModeStartedCallback: { new (func: (result: UnityEngine.Windows.WebCam.VideoCapture.VideoCaptureResult) => void): OnVideoModeStartedCallback; }
        class VideoCaptureResult extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public resultType : UnityEngine.Windows.WebCam.VideoCapture.CaptureResultType
            public hResult : bigint
            public get success(): boolean;
        }
        interface OnVideoModeStoppedCallback
        { 
        (result: UnityEngine.Windows.WebCam.VideoCapture.VideoCaptureResult) : void; 
        Invoke?: (result: UnityEngine.Windows.WebCam.VideoCapture.VideoCaptureResult) => void;
        }
        var OnVideoModeStoppedCallback: { new (func: (result: UnityEngine.Windows.WebCam.VideoCapture.VideoCaptureResult) => void): OnVideoModeStoppedCallback; }
        interface OnStartedRecordingVideoCallback
        { 
        (result: UnityEngine.Windows.WebCam.VideoCapture.VideoCaptureResult) : void; 
        Invoke?: (result: UnityEngine.Windows.WebCam.VideoCapture.VideoCaptureResult) => void;
        }
        var OnStartedRecordingVideoCallback: { new (func: (result: UnityEngine.Windows.WebCam.VideoCapture.VideoCaptureResult) => void): OnStartedRecordingVideoCallback; }
        interface OnStoppedRecordingVideoCallback
        { 
        (result: UnityEngine.Windows.WebCam.VideoCapture.VideoCaptureResult) : void; 
        Invoke?: (result: UnityEngine.Windows.WebCam.VideoCapture.VideoCaptureResult) => void;
        }
        var OnStoppedRecordingVideoCallback: { new (func: (result: UnityEngine.Windows.WebCam.VideoCapture.VideoCaptureResult) => void): OnStoppedRecordingVideoCallback; }
        enum CaptureResultType
        { Success = 0, UnknownError = 1 }
    }
    namespace UnityEngine.Serialization {
        /** Use this attribute to rename a field without losing its serialized value.
        */
        class FormerlySerializedAsAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            /** The name of the field before the rename.
            */
            public get oldName(): string;
            public constructor ($oldName: string)
        }
        /** Utility functions related to SerializeReference manipulation and access.
        */
        class ManagedReferenceUtility extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Special value, -1, used when the managed reference Id for an object is unknown, for example if GetManagedReferenceIdForObject is called with invalid arguments.
            */
            public static RefIdUnknown : bigint
            /** Special value, -2, used as the managed reference Id of any field decorated with SerializeReference that has no object assigned to it.
            */
            public static RefIdNull : bigint
            /** Assigns a managed reference Id to an object that is referenced using SerializeReference on a specified host.
            * @param $hostObj The "host" object that supports SerializeReference. For example, MonoBehaviour or ScriptableObject.
            * @param $refObj The C# object, to which the reference Id will be assigned.
            * @param $refId A positive number between 0 and Int64.MaxValue. This managed reference Id cannot be used by another object on the same host object. You can reuse the same managed reference Id on separate hosts.
            * @returns Returns true if the Id was successfully set false otherwise. 
            */
            public static SetManagedReferenceIdForObject ($obj: UnityEngine.Object, $scriptObj: any, $refId: bigint) : boolean
            /** Retrieves the managed reference Id for an object that is referenced using SerializeReference.
            * @param $hostObj The host object that supports SerializeReference. For example, MonoBehaviour or ScriptableObject.
            * @param $refObj The C# object, to which the reference Id is associated.
            * @returns Returns the managed reference Id. Returns ManagedReferenceUtility.RefIdUnknown if the managed reference Id has not been assigned yet. 
            */
            public static GetManagedReferenceIdForObject ($obj: UnityEngine.Object, $scriptObj: any) : bigint
            /** Retrieves an object based on its managed reference Id.
            * @param $hostObj The host object that supports SerializeReference. For example, MonoBehaviour or ScriptableObject.
            * @param $refId The managed reference Id.
            * @returns Returns the C# object referenced on the specified host and identified with provided Id. Returns null if no reference object is found. 
            */
            public static GetManagedReference ($obj: UnityEngine.Object, $id: bigint) : any
            /** Retrieves a list of managed reference Ids assigned to objects that are referenced using SerializeReference on a specified host.
            * @param $hostObj The host object that supports SerializeReference. For example, MonoBehaviour or ScriptableObject.
            * @returns Returns a list of the most recent serialization of the host object, including the most recent call to ManagedReferenceUtility.SetManagedReferenceIdForObject.
            An entry in the list is returned as ManagedReferenceUtility.RefIdNull if its SerialReference field is set to null.
            The returned list excludes objects with missing types since they cannot be deserialized. To retrieve objects with missing types, use SerializationUtility.GetManagedReferencesWithMissingTypes. 
            */
            public static GetManagedReferenceIds ($obj: UnityEngine.Object) : System.Array$1<bigint>
            public constructor ()
        }
        class UnitySurrogateSelector extends System.Object implements System.Runtime.Serialization.ISurrogateSelector
        {
            protected [__keep_incompatibility]: never;
            public GetSurrogate ($type: System.Type, $context: System.Runtime.Serialization.StreamingContext, $selector: $Ref<System.Runtime.Serialization.ISurrogateSelector>) : System.Runtime.Serialization.ISerializationSurrogate
            public ChainSelector ($selector: System.Runtime.Serialization.ISurrogateSelector) : void
            public GetNextSelector () : System.Runtime.Serialization.ISurrogateSelector
            public constructor ()
        }
    }
    namespace UnityEngine.Search {
        /** Search view flags used to open the Object Picker in various states.
        */
        enum SearchViewFlags
        { None = 0, Debug = 16, NoIndexing = 32, Packages = 256, OpenLeftSidePanel = 2048, OpenInspectorPreview = 4096, Centered = 8192, HideSearchBar = 16384, CompactView = 32768, ListView = 65536, GridView = 131072, TableView = 262144, EnableSearchQuery = 524288, DisableInspectorPreview = 1048576, DisableSavedSearchQuery = 2097152, OpenInBuilderMode = 4194304, OpenInTextMode = 8388608, DisableBuilderModeToggle = 16777216, Borderless = 33554432, DisableQueryHelpers = 67108864, DisableNoResultTips = 134217728, ContextSwitchPreservedMask = 33560576 }
        /** This attribute can be attached to a component object field in order to have the ObjectField use the advanced Object Picker.
        */
        class SearchContextAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            /** Initial search query used to open the Object Picker window.
            */
            public get query(): string;
            /** A list of Search Provider IDs that will be used to create the search context.
            */
            public get providerIds(): System.Array$1<string>;
            /** Search provider concrete types that will be instantiated and assigned to the Object Picker search context.
            */
            public get instantiableProviders(): System.Array$1<System.Type>;
            /** Search view flags used to open the Object Picker in various states.
            */
            public get flags(): UnityEngine.Search.SearchViewFlags;
            public constructor ($query: string)
            public constructor ($query: string, $flags: UnityEngine.Search.SearchViewFlags)
            public constructor ($query: string, $providerIdsCommaSeparated: string)
            public constructor ($query: string, $providerIdsCommaSeparated: string, $flags: UnityEngine.Search.SearchViewFlags)
            public constructor ($query: string, ...instantiableProviders: System.Type[])
            public constructor ($query: string, $flags: UnityEngine.Search.SearchViewFlags, ...instantiableProviders: System.Type[])
            public constructor ($query: string, $flags: UnityEngine.Search.SearchViewFlags, $providerIdsCommaSeparated: string, ...instantiableProviders: System.Type[])
        }
    }
    namespace UnityEngine.SearchService {
        /** A class attribute that allows you to define label constraints on a MonoBehavior or ScriptableObject's field in the object selector.
        */
        class ObjectSelectorHandlerWithLabelsAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            /** The labels to match.
            */
            public get labels(): System.Array$1<string>;
            /** Boolean that indicates whether all labels, or only one of them, should match. Default is true.
            */
            public get matchAll(): boolean;
            public constructor (...labels: string[])
            public constructor ($matchAll: boolean, ...labels: string[])
        }
        /** A class attribute that allows you to define tag constraints on a MonoBehavior or ScriptableObject's field in the object selector.
        */
        class ObjectSelectorHandlerWithTagsAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            /** The tags to match. Because a GameObject can only have one tag, only one of them must be present.
            */
            public get tags(): System.Array$1<string>;
            public constructor (...tags: string[])
        }
    }
    namespace UnityEngine.Scripting.GarbageCollector {
        enum Mode
        { Disabled = 0, Enabled = 1, Manual = 2 }
    }
    namespace UnityEngine.Scripting.APIUpdating {
        class MovedFromAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get IsInDifferentAssembly(): boolean;
            public constructor ($autoUpdateAPI: boolean, $sourceNamespace?: string, $sourceAssembly?: string, $sourceClassName?: string)
            public constructor ($sourceNamespace: string)
        }
    }
    namespace UnityEngine.LowLevel {
        /** The representation of a single system being updated by the player loop in Unity.
        */
        class PlayerLoopSystem extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** This property is used to identify which native system this belongs to, or to get the name of the managed system to show in the profiler.
            */
            public type : System.Type
            /** A list of sub systems which run as part of this item in the player loop.
            */
            public subSystemList : System.Array$1<UnityEngine.LowLevel.PlayerLoopSystem>
            /** A managed delegate. You can set this to create a new C# entrypoint in the player loop.
            */
            public updateDelegate : UnityEngine.LowLevel.PlayerLoopSystem.UpdateFunction
            /** A native engine system. To get a valid value for this, you must copy it from one of the PlayerLoopSystems returned by PlayerLoop.GetDefaultPlayerLoop.
            */
            public updateFunction : System.IntPtr
            /** The loop condition for a native engine system. To get a valid value for this, you must copy it from one of the PlayerLoopSystems returned by PlayerLoop.GetDefaultPlayerLoop.
            */
            public loopConditionFunction : System.IntPtr
        }
        /** The class representing the player loop in Unity.
        */
        class PlayerLoop extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Returns the default update order of all engine systems in Unity.
            */
            public static GetDefaultPlayerLoop () : UnityEngine.LowLevel.PlayerLoopSystem
            /** Returns the current update order of all engine systems in Unity.
            */
            public static GetCurrentPlayerLoop () : UnityEngine.LowLevel.PlayerLoopSystem
            /** Set a new custom update order of all engine systems in Unity.
            */
            public static SetPlayerLoop ($loop: UnityEngine.LowLevel.PlayerLoopSystem) : void
            public constructor ()
        }
    }
    namespace UnityEngine.LowLevel.PlayerLoopSystem {
        interface UpdateFunction
        { 
        () : void; 
        Invoke?: () => void;
        }
        var UpdateFunction: { new (func: () => void): UpdateFunction; }
    }
    namespace UnityEngine.PlayerLoop {
        /** Update phase in the native player loop that waits for the operating system (OS) to flip the back buffer to the display and update the time in the engine.
        */
        class TimeUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        /** Update phase in the native player loop.
        */
        class Initialization extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        /** Update phase in the native player loop.
        */
        class EarlyUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        /** Update phase in the native player loop.
        */
        class FixedUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        /** Update phase in the native player loop.
        */
        class PreUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        /** Update phase in the native player loop.
        */
        class Update extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        /** Update phase in the native player loop.
        */
        class PreLateUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        /** Update phase in the native player loop.
        */
        class PostLateUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace UnityEngine.PlayerLoop.TimeUpdate {
        class WaitForLastPresentationAndUpdateTime extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class ProfilerStartFrame extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace UnityEngine.PlayerLoop.Initialization {
        class ProfilerStartFrame extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class PlayerUpdateTime extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class UpdateCameraMotionVectors extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class DirectorSampleTime extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class AsyncUploadTimeSlicedUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class SynchronizeState extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class SynchronizeInputs extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class XREarlyUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace UnityEngine.PlayerLoop.EarlyUpdate {
        class PollPlayerConnection extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class ProfilerStartFrame extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class PollHtcsPlayerConnection extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class GpuTimestamp extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class AnalyticsCoreStatsUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class UnityWebRequestUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class UpdateStreamingManager extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class ExecuteMainThreadJobs extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class ProcessMouseInWindow extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class ClearIntermediateRenderers extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class ClearLines extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class PresentBeforeUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class ResetFrameStatsAfterPresent extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class UpdateAsyncReadbackManager extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class UpdateTextureStreamingManager extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class UpdatePreloading extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class UpdateContentLoading extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class RendererNotifyInvisible extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class PlayerCleanupCachedData extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class UpdateMainGameViewRect extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class UpdateCanvasRectTransform extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class UpdateInputManager extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class ProcessRemoteInput extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class XRUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class ScriptRunDelayedStartupFrame extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class UpdateKinect extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class DeliverIosPlatformEvents extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class DispatchEventQueueEvents extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class Physics2DEarlyUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class PhysicsResetInterpolatedTransformPosition extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class SpriteAtlasManagerUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class TangoUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class ARCoreUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class PerformanceAnalyticsUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace UnityEngine.PlayerLoop.FixedUpdate {
        class ClearLines extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class DirectorFixedSampleTime extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class AudioFixedUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class ScriptRunBehaviourFixedUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class DirectorFixedUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class LegacyFixedAnimationUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class XRFixedUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class PhysicsFixedUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class Physics2DFixedUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class DirectorFixedUpdatePostPhysics extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class ScriptRunDelayedFixedFrameRate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class NewInputFixedUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace UnityEngine.PlayerLoop.PreUpdate {
        class PhysicsUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class Physics2DUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class CheckTexFieldInput extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class IMGUISendQueuedEvents extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class SendMouseEvents extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class AIUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class WindUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class UpdateVideo extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class NewInputUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class InputForUIUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace UnityEngine.PlayerLoop.Update {
        class ScriptRunBehaviourUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class DirectorUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class ScriptRunDelayedDynamicFrameRate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class ScriptRunDelayedTasks extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace UnityEngine.PlayerLoop.PreLateUpdate {
        class Physics2DLateUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class PhysicsLateUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class AIUpdatePostScript extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class DirectorUpdateAnimationBegin extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class LegacyAnimationUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class DirectorUpdateAnimationEnd extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class DirectorDeferredEvaluate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class AccessibilityUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class UIElementsUpdatePanels extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class UpdateNetworkManager extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class UpdateMasterServerInterface extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class EndGraphicsJobsAfterScriptUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class ParticleSystemBeginUpdateAll extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class ScriptRunBehaviourLateUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class ConstraintManagerUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace UnityEngine.PlayerLoop.PostLateUpdate {
        class PlayerSendFrameStarted extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class UpdateRectTransform extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class UpdateCanvasRectTransform extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class PlayerUpdateCanvases extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class UpdateAudio extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class UpdateVideo extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class DirectorLateUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class ScriptRunDelayedDynamicFrameRate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class VFXUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class ParticleSystemEndUpdateAll extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class EndGraphicsJobsAfterScriptLateUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class UpdateSubstance extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class UpdateCustomRenderTextures extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class XRPostLateUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class UpdateAllRenderers extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class UpdateLightProbeProxyVolumes extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class EnlightenRuntimeUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class UpdateAllSkinnedMeshes extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class ProcessWebSendMessages extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class SortingGroupsUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class UpdateVideoTextures extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class DirectorRenderImage extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class PlayerEmitCanvasGeometry extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class FinishFrameRendering extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class BatchModeUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class PlayerSendFrameComplete extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class UpdateCaptureScreenshot extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class PresentAfterDraw extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class ClearImmediateRenderers extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class XRPostPresent extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class UpdateResolution extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class InputEndFrame extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class GUIClearEvents extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class ShaderHandleErrors extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class ResetInputAxis extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class ThreadedLoadingDebug extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class ProfilerSynchronizeStats extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class MemoryFrameMaintenance extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class ExecuteGameCenterCallbacks extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class XRPreEndFrame extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class ProfilerEndFrame extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class GraphicsWarmupPreloadedShaders extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class PlayerSendFramePostPresent extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class PhysicsSkinnedClothBeginUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class PhysicsSkinnedClothFinishUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class TriggerEndOfFrameCallbacks extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class ObjectDispatcherPostLateUpdate extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace UnityEngine.Pool {
        class CollectionPool$2<TCollection, TItem> extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static Get () : any
            public static Get ($value: any) : any
            public static Release ($toRelease: any) : any
            public constructor ()
        }
        class PooledObject$1<T> extends System.ValueType implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
        }
        class ListPool$1<T> extends UnityEngine.Pool.CollectionPool$2<System.Collections.Generic.List$1<T>, T>
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class DictionaryPool$2<TKey, TValue> extends UnityEngine.Pool.CollectionPool$2<System.Collections.Generic.Dictionary$2<TKey, TValue>, System.Collections.Generic.KeyValuePair$2<TKey, TValue>>
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class GenericPool$1<T> extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static Get () : any
            public static Get ($value: any) : any
            public static Release ($toRelease: any) : any
            public constructor ()
        }
        interface IObjectPool$1<T>
        {
            CountInactive : number
            Get () : T
            Get ($v: $Ref<T>) : UnityEngine.Pool.PooledObject$1<T>
            Release ($element: T) : void
            Clear () : void
        }
        class LinkedPool$1<T> extends System.Object implements UnityEngine.Pool.IObjectPool$1<T>, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get CountInactive(): number;
            public Get () : T
            public Get ($v: $Ref<T>) : UnityEngine.Pool.PooledObject$1<T>
            public Release ($item: T) : void
            public Clear () : void
            public Dispose () : void
            public constructor ($createFunc: System.Func$1<T>, $actionOnGet?: System.Action$1<T>, $actionOnRelease?: System.Action$1<T>, $actionOnDestroy?: System.Action$1<T>, $collectionCheck?: boolean, $maxSize?: number)
            public Release ($element: T) : void
        }
        class ObjectPool$1<T> extends System.Object implements UnityEngine.Pool.IObjectPool$1<T>, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get CountAll(): number;
            public get CountActive(): number;
            public get CountInactive(): number;
            public Get () : T
            public Get ($v: $Ref<T>) : UnityEngine.Pool.PooledObject$1<T>
            public Release ($element: T) : void
            public Clear () : void
            public Dispose () : void
            public constructor ($createFunc: System.Func$1<T>, $actionOnGet?: System.Action$1<T>, $actionOnRelease?: System.Action$1<T>, $actionOnDestroy?: System.Action$1<T>, $collectionCheck?: boolean, $defaultCapacity?: number, $maxSize?: number)
        }
        class UnsafeGenericPool$1<T> extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static Get () : any
            public static Get ($value: any) : any
            public static Release ($toRelease: any) : any
        }
    }
    namespace UnityEngine.Networking.PlayerConnection {
        /** The type of the connected target.
        */
        enum ConnectionTarget
        { None = 0, Player = 1, Editor = 2 }
        interface IConnectionState extends System.IDisposable
        {
            /** Supplies the type of the established connection, as in whether the target is a Player or an Editor.
            */
            connectedToTarget : UnityEngine.Networking.PlayerConnection.ConnectionTarget
            /** The name of the connected target.
            */
            connectionName : string
        }
        /** Arguments passed to Action callbacks registered in PlayerConnection.
        */
        class MessageEventArgs extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** The Player ID that the data is received from.
            */
            public playerId : number
            /** Data that is received.
            */
            public data : System.Array$1<number>
            public constructor ()
        }
        interface IEditorPlayerConnection
        {
            Register ($messageId: System.Guid, $callback: UnityEngine.Events.UnityAction$1<UnityEngine.Networking.PlayerConnection.MessageEventArgs>) : void
            Unregister ($messageId: System.Guid, $callback: UnityEngine.Events.UnityAction$1<UnityEngine.Networking.PlayerConnection.MessageEventArgs>) : void
            DisconnectAll () : void
            RegisterConnection ($callback: UnityEngine.Events.UnityAction$1<number>) : void
            RegisterDisconnection ($callback: UnityEngine.Events.UnityAction$1<number>) : void
            UnregisterConnection ($callback: UnityEngine.Events.UnityAction$1<number>) : void
            UnregisterDisconnection ($callback: UnityEngine.Events.UnityAction$1<number>) : void
            Send ($messageId: System.Guid, $data: System.Array$1<number>) : void
            TrySend ($messageId: System.Guid, $data: System.Array$1<number>) : boolean
        }
        /** Used for handling the network connection from the Player to the Editor.
        */
        class PlayerConnection extends UnityEngine.ScriptableObject implements UnityEngine.Networking.PlayerConnection.IEditorPlayerConnection
        {
            protected [__keep_incompatibility]: never;
            /** Returns a singleton instance of a PlayerConnection.
            */
            public static get instance(): UnityEngine.Networking.PlayerConnection.PlayerConnection;
            /** Returns true when the Editor is connected to the Player.
            */
            public get isConnected(): boolean;
            public OnEnable () : void
            public Register ($messageId: System.Guid, $callback: UnityEngine.Events.UnityAction$1<UnityEngine.Networking.PlayerConnection.MessageEventArgs>) : void
            public Unregister ($messageId: System.Guid, $callback: UnityEngine.Events.UnityAction$1<UnityEngine.Networking.PlayerConnection.MessageEventArgs>) : void
            public RegisterConnection ($callback: UnityEngine.Events.UnityAction$1<number>) : void
            public RegisterDisconnection ($callback: UnityEngine.Events.UnityAction$1<number>) : void
            public UnregisterConnection ($callback: UnityEngine.Events.UnityAction$1<number>) : void
            public UnregisterDisconnection ($callback: UnityEngine.Events.UnityAction$1<number>) : void
            /** Sends data to the Editor.
            * @param $messageId The type ID of the message that is sent to the Editor.
            */
            public Send ($messageId: System.Guid, $data: System.Array$1<number>) : void
            /** Attempt to sends data to the Editor.
            * @param $messageId The type ID of the message that is sent to the Editor.
            * @returns Returns true when the Player sends data successfully, and false when there is no space in the socket ring buffer or sending fails. 
            */
            public TrySend ($messageId: System.Guid, $data: System.Array$1<number>) : boolean
            /** Blocks the calling thread until either a message with the specified messageId is received or the specified time-out elapses.
            * @param $messageId The type ID of the message that is sent to the Editor.
            * @param $timeout The time-out specified in milliseconds.
            * @returns Returns true when the message is received and false if the call timed out. 
            */
            public BlockUntilRecvMsg ($messageId: System.Guid, $timeout: number) : boolean
            /** This disconnects all of the active connections.
            */
            public DisconnectAll () : void
            public constructor ()
        }
    }
    namespace UnityEngine.Lumin {
        /** This attribute provides a way to declaratively define a Lumin platform level requirement that is automatically added to the manifest at build time.
        */
        class UsesLuminPlatformLevelAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get platformLevel(): number;
            public constructor ($platformLevel: number)
        }
        /** This attribute provides a way to declaratively define a Lumin privilege requirement that is automatically added to the manifest at build time.
        */
        class UsesLuminPrivilegeAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get privilege(): string;
            public constructor ($privilege: string)
        }
    }
    namespace UnityEngine.tvOS {
        /** A class for Apple TV remote input configuration.
        */
        class Remote extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Configures how "Menu" button behaves on Apple TV Remote. If this property is set to true hitting "Menu" on Remote will exit to system home screen. When this property is false current application is responsible for handling "Menu" button. It is recommended to set this property to true on top level menus of your application.
            */
            public static get allowExitToHome(): boolean;
            public static set allowExitToHome(value: boolean);
            /** Configures if Apple TV Remote should autorotate all the inputs when Remote is being held in horizontal orientation. Default is false.
            */
            public static get allowRemoteRotation(): boolean;
            public static set allowRemoteRotation(value: boolean);
            /** Configures how touches are mapped to analog joystick axes in relative or absolute values. If set to true it will return +1 on Horizontal axis when very far right is being touched on Remote touch aread (and -1 when very left area is touched correspondingly). The same applies for Vertical axis too. When this property is set to false player should swipe instead of touching specific area of remote to generate Horizontal or Vertical input.
            */
            public static get reportAbsoluteDpadValues(): boolean;
            public static set reportAbsoluteDpadValues(value: boolean);
            /** Disables Apple TV Remote touch propagation to Unity Input.touches API. Useful for 3rd party frameworks, which do not respect Touch.type == Indirect.
            Default is false.
            */
            public static get touchesEnabled(): boolean;
            public static set touchesEnabled(value: boolean);
            public constructor ()
        }
        /** tvOS device generation.
        */
        enum DeviceGeneration
        { Unknown = 0, AppleTV1Gen = 1001, AppleTVHD = 1001, AppleTV2Gen = 1002, AppleTV4K = 1002, AppleTV4K2Gen = 1003, AppleTV4K3Gen = 1004 }
        /** Interface into tvOS specific functionality.
        */
        class Device extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** tvOS version.
            */
            public static get systemVersion(): string;
            /** The generation of the device. (Read Only)
            */
            public static get generation(): UnityEngine.tvOS.DeviceGeneration;
            /** Vendor ID.
            */
            public static get vendorIdentifier(): string;
            /** Advertising ID.
            */
            public static get advertisingIdentifier(): string;
            /** Is advertising tracking enabled.
            */
            public static get advertisingTrackingEnabled(): boolean;
            /** Set file flag to be excluded from iCloud/iTunes backup.
            */
            public static SetNoBackupFlag ($path: string) : void
            /** Reset "no backup" file flag: file will be synced with iCloud/iTunes backup and can be deleted by OS in low storage situations.
            */
            public static ResetNoBackupFlag ($path: string) : void
            public constructor ()
        }
    }
    namespace UnityEngine.iOS.ADBannerView {
        enum Type
        { Banner = 0, MediumRect = 1 }
        enum Layout
        { Top = 0, Bottom = 1, TopLeft = 0, TopRight = 4, TopCenter = 8, BottomLeft = 1, BottomRight = 5, BottomCenter = 9, CenterLeft = 2, CenterRight = 6, Center = 10, Manual = -1 }
        interface BannerWasClickedDelegate
        { 
        () : void; 
        Invoke?: () => void;
        }
        var BannerWasClickedDelegate: { new (func: () => void): BannerWasClickedDelegate; }
        interface BannerWasLoadedDelegate
        { 
        () : void; 
        Invoke?: () => void;
        }
        var BannerWasLoadedDelegate: { new (func: () => void): BannerWasLoadedDelegate; }
        interface BannerFailedToLoadDelegate
        { 
        () : void; 
        Invoke?: () => void;
        }
        var BannerFailedToLoadDelegate: { new (func: () => void): BannerFailedToLoadDelegate; }
    }
    namespace UnityEngine.iOS.ADInterstitialAd {
        interface InterstitialWasLoadedDelegate
        { 
        () : void; 
        Invoke?: () => void;
        }
        var InterstitialWasLoadedDelegate: { new (func: () => void): InterstitialWasLoadedDelegate; }
        interface InterstitialWasViewedDelegate
        { 
        () : void; 
        Invoke?: () => void;
        }
        var InterstitialWasViewedDelegate: { new (func: () => void): InterstitialWasViewedDelegate; }
    }
    namespace UnityEngine.Internal {
        class DefaultValueAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Value(): any;
            public constructor ($value: string)
        }
        class ExcludeFromDocsAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
    }
    namespace UnityEngine.Rendering.RayTracingAccelerationStructure {
        class BuildSettings extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get buildFlags(): UnityEngine.Rendering.RayTracingAccelerationStructureBuildFlags;
            public set buildFlags(value: UnityEngine.Rendering.RayTracingAccelerationStructureBuildFlags);
            public get relativeOrigin(): UnityEngine.Vector3;
            public set relativeOrigin(value: UnityEngine.Vector3);
            public constructor ()
            public constructor ($buildFlags: UnityEngine.Rendering.RayTracingAccelerationStructureBuildFlags, $relativeOrigin: UnityEngine.Vector3)
        }
        class Settings extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public managementMode : UnityEngine.Rendering.RayTracingAccelerationStructure.ManagementMode
            public rayTracingModeMask : UnityEngine.Rendering.RayTracingAccelerationStructure.RayTracingModeMask
            public layerMask : number
            public get buildFlagsStaticGeometries(): UnityEngine.Rendering.RayTracingAccelerationStructureBuildFlags;
            public set buildFlagsStaticGeometries(value: UnityEngine.Rendering.RayTracingAccelerationStructureBuildFlags);
            public get buildFlagsDynamicGeometries(): UnityEngine.Rendering.RayTracingAccelerationStructureBuildFlags;
            public set buildFlagsDynamicGeometries(value: UnityEngine.Rendering.RayTracingAccelerationStructureBuildFlags);
            public constructor ()
            public constructor ($sceneManagementMode: UnityEngine.Rendering.RayTracingAccelerationStructure.ManagementMode, $rayTracingModeMask: UnityEngine.Rendering.RayTracingAccelerationStructure.RayTracingModeMask, $layerMask: number)
            public constructor ($sceneManagementMode: UnityEngine.Rendering.RayTracingAccelerationStructure.ManagementMode, $rayTracingModeMask: UnityEngine.Rendering.RayTracingAccelerationStructure.RayTracingModeMask, $layerMask: number, $buildFlagsStaticGeometries: UnityEngine.Rendering.RayTracingAccelerationStructureBuildFlags, $buildFlagsDynamicGeometries: UnityEngine.Rendering.RayTracingAccelerationStructureBuildFlags)
        }
        enum RayTracingModeMask
        { Nothing = 0, Static = 2, DynamicTransform = 4, DynamicGeometry = 8, Everything = 14 }
        enum ManagementMode
        { Manual = 0, Automatic = 1 }
        class RASSettings extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public managementMode : UnityEngine.Rendering.RayTracingAccelerationStructure.ManagementMode
            public rayTracingModeMask : UnityEngine.Rendering.RayTracingAccelerationStructure.RayTracingModeMask
            public layerMask : number
            public constructor ($sceneManagementMode: UnityEngine.Rendering.RayTracingAccelerationStructure.ManagementMode, $rayTracingModeMask: UnityEngine.Rendering.RayTracingAccelerationStructure.RayTracingModeMask, $layerMask: number)
        }
    }
    namespace UnityEngine.Rendering.SplashScreen {
        enum StopBehavior
        { StopImmediate = 0, FadeOut = 1 }
    }
    namespace UnityEngine.Rendering.SupportedOnRenderPipelineAttribute {
        enum SupportedMode
        { Unsupported = 0, Supported = 1, SupportedByBaseClass = 2 }
    }
    namespace UnityEngine.Rendering.BatchRendererGroup {
        interface OnPerformCulling
        { 
        (rendererGroup: UnityEngine.Rendering.BatchRendererGroup, cullingContext: UnityEngine.Rendering.BatchCullingContext, cullingOutput: UnityEngine.Rendering.BatchCullingOutput, userContext: System.IntPtr) : Unity.Jobs.JobHandle; 
        Invoke?: (rendererGroup: UnityEngine.Rendering.BatchRendererGroup, cullingContext: UnityEngine.Rendering.BatchCullingContext, cullingOutput: UnityEngine.Rendering.BatchCullingOutput, userContext: System.IntPtr) => Unity.Jobs.JobHandle;
        }
        var OnPerformCulling: { new (func: (rendererGroup: UnityEngine.Rendering.BatchRendererGroup, cullingContext: UnityEngine.Rendering.BatchCullingContext, cullingOutput: UnityEngine.Rendering.BatchCullingOutput, userContext: System.IntPtr) => Unity.Jobs.JobHandle): OnPerformCulling; }
    }
    namespace UnityEngine.Rendering.RenderPipeline {
        class StandardRequest extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public destination : UnityEngine.RenderTexture
            public mipLevel : number
            public face : UnityEngine.CubemapFace
            public slice : number
            public constructor ()
        }
    }
    namespace UnityEngine.Rendering.RendererUtils {
        /** Represents the set of GameObjects that a RendererList contains.
        */
        class RendererListDesc extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The method Unity uses to sort the GameObjects in the RendererList. For more information, see Rendering.SortingCriteria.
            */
            public sortingCriteria : UnityEngine.Rendering.SortingCriteria
            /** The renderer configuration for the RendererList. For more information, see Rendering.PerObjectData.
            */
            public rendererConfiguration : UnityEngine.Rendering.PerObjectData
            /** The material render queue range to use for the RendererList. For more information, see Rendering.RenderQueueRange.
            */
            public renderQueueRange : UnityEngine.Rendering.RenderQueueRange
            /** An optional set of values to override the RendererLists render state. For more information, see Rendering.RenderStateBlock.
            */
            public stateBlock : UnityEngine.Rendering.RenderStateBlock | null
            /** The shader to render the RendererList's GameObjects with. This overrides the shader for each GameObject. Override shaders do not override existing material properties.
            */
            public overrideShader : UnityEngine.Shader
            /** The material to render the RendererList's GameObjects with. This overrides the material for each GameObject.
            */
            public overrideMaterial : UnityEngine.Material
            /** Indicates whether to exclude dynamic GameObjects from the RendererList.
            */
            public excludeObjectMotionVectors : boolean
            /** The layer mask to use for filtering this RendererList.
            */
            public layerMask : number
            /** The rendering layer mask to use for filtering this RendererList.
            */
            public renderingLayerMask : number
            /** Pass index for the override material.
            */
            public overrideMaterialPassIndex : number
            /** Selects which pass of the override shader to use.
            */
            public overrideShaderPassIndex : number
            /** Checks whether the RendererListDesc is valid.
            * @returns If the RendererListDesc is valid, this returns true. Otherwise, this returns false. 
            */
            public IsValid () : boolean
            /** Convert a given RendererListDesc to a RendererListParams struct with equivalent parameters.
            * @returns If the RendererListDesc is valid, this returns a RendererListParams struct. Otherwise, this returns RendererListParams.Invalid. 
            */
            public static ConvertToParameters ($desc: $Ref<UnityEngine.Rendering.RendererUtils.RendererListDesc>) : UnityEngine.Rendering.RendererListParams
            public constructor ($passName: UnityEngine.Rendering.ShaderTagId, $cullingResult: UnityEngine.Rendering.CullingResults, $camera: UnityEngine.Camera)
            public constructor ($passNames: System.Array$1<UnityEngine.Rendering.ShaderTagId>, $cullingResult: UnityEngine.Rendering.CullingResults, $camera: UnityEngine.Camera)
        }
    }
    namespace UnityEngine.Rendering.SupportedRenderingFeatures {
        enum ReflectionProbeModes
        { None = 0, Rotation = 1 }
        enum LightmapMixedBakeModes
        { None = 0, IndirectOnly = 1, Subtractive = 2, Shadowmask = 4 }
    }
    namespace UnityEngine.Playables {
        /** This structure contains the frame information a Playable receives in Playable.PrepareFrame.
        */
        class FrameData extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The current frame identifier.
            */
            public get frameId(): bigint;
            /** The interval between this frame and the preceding frame. The interval is unscaled and expressed in seconds.
            */
            public get deltaTime(): number;
            /** The weight of the current Playable.
            */
            public get weight(): number;
            /** The accumulated weight of the Playable during the PlayableGraph traversal.
            */
            public get effectiveWeight(): number;
            /** The accumulated speed of the parent Playable during the PlayableGraph traversal.
            */
            public get effectiveParentSpeed(): number;
            /** The accumulated speed of the Playable during the PlayableGraph traversal.
            */
            public get effectiveSpeed(): number;
            /** Indicates the type of evaluation that caused PlayableGraph.PrepareFrame to be called.
            */
            public get evaluationType(): UnityEngine.Playables.FrameData.EvaluationType;
            /** Indicates that the local time was explicitly set.
            */
            public get seekOccurred(): boolean;
            /** Indicates the local time wrapped because it has reached the duration and the extrapolation mode is set to Loop.
            */
            public get timeLooped(): boolean;
            /** Indicates the local time did not advance because it has reached the duration and the extrapolation mode is set to Hold.
            */
            public get timeHeld(): boolean;
            /** The PlayableOutput that initiated this graph traversal.
            */
            public get output(): UnityEngine.Playables.PlayableOutput;
            /** The accumulated play state of this playable.
            */
            public get effectivePlayState(): UnityEngine.Playables.PlayState;
        }
        /** See: Playables.IPlayableOutput.
        */
        class PlayableOutput extends System.ValueType implements UnityEngine.Playables.IPlayableOutput, System.IEquatable$1<UnityEngine.Playables.PlayableOutput>
        {
            protected [__keep_incompatibility]: never;
            /** Returns an invalid PlayableOutput.
            */
            public static get Null(): UnityEngine.Playables.PlayableOutput;
            public GetHandle () : UnityEngine.Playables.PlayableOutputHandle
            public GetPlayableOutputType () : System.Type
            public Equals ($other: UnityEngine.Playables.PlayableOutput) : boolean
        }
        interface IPlayableOutput
        {
            GetHandle () : UnityEngine.Playables.PlayableOutputHandle
        }
        /** Status of a Playable.
        */
        enum PlayState
        { Paused = 0, Playing = 1, Delayed = 2 }
        interface INotification
        {
            /** The identifier is a name that identifies this notifications, or class of notifications.
            */
            id : UnityEngine.PropertyName
        }
        interface INotificationReceiver
        {
            /** The method called when a notification is raised.
            * @param $origin The playable that sent the notification.
            * @param $notification The received notification.
            * @param $context User defined data that depends on the type of notification. Uses this to pass necessary information that can change with each invocation.
            */
            OnNotify ($origin: UnityEngine.Playables.Playable, $notification: UnityEngine.Playables.INotification, $context: any) : void
        }
        /** Playables are customizable runtime objects that can be connected together and are contained in a PlayableGraph to create complex behaviours.
        */
        class Playable extends System.ValueType implements UnityEngine.Playables.IPlayable, System.IEquatable$1<UnityEngine.Playables.Playable>
        {
            protected [__keep_incompatibility]: never;
            /** Returns an invalid Playable.
            */
            public static get Null(): UnityEngine.Playables.Playable;
            public static Create ($graph: UnityEngine.Playables.PlayableGraph, $inputCount?: number) : UnityEngine.Playables.Playable
            public GetHandle () : UnityEngine.Playables.PlayableHandle
            public GetPlayableType () : System.Type
            public Equals ($other: UnityEngine.Playables.Playable) : boolean
        }
        interface IPlayable
        {
            GetHandle () : UnityEngine.Playables.PlayableHandle
        }
        class PlayableHandle extends System.ValueType implements System.IEquatable$1<UnityEngine.Playables.PlayableHandle>
        {
            protected [__keep_incompatibility]: never;
            public static get Null(): UnityEngine.Playables.PlayableHandle;
            public static op_Equality ($x: UnityEngine.Playables.PlayableHandle, $y: UnityEngine.Playables.PlayableHandle) : boolean
            public static op_Inequality ($x: UnityEngine.Playables.PlayableHandle, $y: UnityEngine.Playables.PlayableHandle) : boolean
            public Equals ($p: any) : boolean
            public Equals ($other: UnityEngine.Playables.PlayableHandle) : boolean
        }
        interface IPlayableBehaviour
        {
            OnGraphStart ($playable: UnityEngine.Playables.Playable) : void
            OnGraphStop ($playable: UnityEngine.Playables.Playable) : void
            OnPlayableCreate ($playable: UnityEngine.Playables.Playable) : void
            OnPlayableDestroy ($playable: UnityEngine.Playables.Playable) : void
            OnBehaviourPlay ($playable: UnityEngine.Playables.Playable, $info: UnityEngine.Playables.FrameData) : void
            OnBehaviourPause ($playable: UnityEngine.Playables.Playable, $info: UnityEngine.Playables.FrameData) : void
            PrepareFrame ($playable: UnityEngine.Playables.Playable, $info: UnityEngine.Playables.FrameData) : void
            ProcessFrame ($playable: UnityEngine.Playables.Playable, $info: UnityEngine.Playables.FrameData, $playerData: any) : void
        }
        class PlayableOutputHandle extends System.ValueType implements System.IEquatable$1<UnityEngine.Playables.PlayableOutputHandle>
        {
            protected [__keep_incompatibility]: never;
            public static get Null(): UnityEngine.Playables.PlayableOutputHandle;
            public static op_Equality ($lhs: UnityEngine.Playables.PlayableOutputHandle, $rhs: UnityEngine.Playables.PlayableOutputHandle) : boolean
            public static op_Inequality ($lhs: UnityEngine.Playables.PlayableOutputHandle, $rhs: UnityEngine.Playables.PlayableOutputHandle) : boolean
            public Equals ($p: any) : boolean
            public Equals ($other: UnityEngine.Playables.PlayableOutputHandle) : boolean
        }
        /** Default implementation for Playable notifications.
        */
        class Notification extends System.Object implements UnityEngine.Playables.INotification
        {
            protected [__keep_incompatibility]: never;
            /** The name that identifies this notification.
            */
            public get id(): UnityEngine.PropertyName;
            public constructor ($name: string)
        }
        /** Wrap mode for Playables.
        */
        enum DirectorWrapMode
        { Hold = 0, Loop = 1, None = 2 }
        /** Use the PlayableGraph to manage Playable creations and destructions.
        */
        class PlayableGraph extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Returns the Playable with no output connections at the given index.
            * @param $index The index of the root Playable.
            */
            public GetRootPlayable ($index: number) : UnityEngine.Playables.Playable
            /** Get PlayableOutput at the given index in the graph.
            * @param $index The output index.
            * @returns The PlayableOutput at this given index, otherwise null. 
            */
            public GetOutput ($index: number) : UnityEngine.Playables.PlayableOutput
            /** Evaluates all the PlayableOutputs in the graph, and updates all the connected Playables in the graph.
            * @param $deltaTime The time in seconds by which to advance each Playable in the graph.
            */
            public Evaluate () : void
            /** Creates a PlayableGraph.
            * @param $name The name of the graph.
            * @returns The newly created PlayableGraph. 
            */
            public static Create () : UnityEngine.Playables.PlayableGraph
            /** Creates a PlayableGraph.
            * @param $name The name of the graph.
            * @returns The newly created PlayableGraph. 
            */
            public static Create ($name: string) : UnityEngine.Playables.PlayableGraph
            /** Destroys the graph.
            */
            public Destroy () : void
            /** Returns true if the PlayableGraph has been properly constructed using PlayableGraph.CreateGraph and is not deleted.
            * @returns A boolean indicating if the graph is invalid or not. 
            */
            public IsValid () : boolean
            /** Indicates that a graph is presently running.
            * @returns A boolean indicating if the graph is playing or not. 
            */
            public IsPlaying () : boolean
            /** Indicates that a graph has completed its operations.
            * @returns A boolean indicating if the graph is done playing or not. 
            */
            public IsDone () : boolean
            /** Plays the graph.
            */
            public Play () : void
            /** Stops the graph, if it is playing.
            */
            public Stop () : void
            /** Evaluates all the PlayableOutputs in the graph, and updates all the connected Playables in the graph.
            * @param $deltaTime The time in seconds by which to advance each Playable in the graph.
            */
            public Evaluate ($deltaTime: number) : void
            /** Returns how time is incremented when playing back.
            */
            public GetTimeUpdateMode () : UnityEngine.Playables.DirectorUpdateMode
            /** Changes how time is incremented when playing back.
            * @param $value The new DirectorUpdateMode.
            */
            public SetTimeUpdateMode ($value: UnityEngine.Playables.DirectorUpdateMode) : void
            /** Returns the table used by the graph to resolve ExposedReferences.
            */
            public GetResolver () : UnityEngine.IExposedPropertyTable
            /** Changes the table used by the graph to resolve ExposedReferences.
            */
            public SetResolver ($value: UnityEngine.IExposedPropertyTable) : void
            /** Returns the number of Playable owned by the Graph.
            */
            public GetPlayableCount () : number
            /** Returns the number of Playable owned by the Graph that have no connected outputs.
            */
            public GetRootPlayableCount () : number
            /** Returns the number of PlayableOutput in the graph.
            * @returns The number of PlayableOutput in the graph. 
            */
            public GetOutputCount () : number
            /** Returns the name of the PlayableGraph.
            */
            public GetEditorName () : string
        }
        interface IPlayableAsset
        {
            /** Duration in seconds.
            */
            duration : number
            /** A description of the PlayableOutputs generated by this asset.
            */
            outputs : System.Collections.Generic.IEnumerable$1<UnityEngine.Playables.PlayableBinding>
            /** Implement this method to have your asset inject playables into the given graph.
            * @param $graph The graph to inject playables into.
            * @param $owner The game object which initiated the build.
            * @returns The playable injected into the graph, or the root playable if multiple playables are injected. 
            */
            CreatePlayable ($graph: UnityEngine.Playables.PlayableGraph, $owner: UnityEngine.GameObject) : UnityEngine.Playables.Playable
        }
        /** Struct that holds information regarding an output of a PlayableAsset.
        */
        class PlayableBinding extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** A constant to represent a PlayableAsset has no bindings.
            */
            public static None : System.Array$1<UnityEngine.Playables.PlayableBinding>
            /** The default duration used when a PlayableOutput has no fixed duration.
            */
            public static DefaultDuration : number
            /** The name of the output or input stream.
            */
            public get streamName(): string;
            public set streamName(value: string);
            /** A reference to a UnityEngine.Object that acts a key for this binding.
            */
            public get sourceObject(): UnityEngine.Object;
            public set sourceObject(value: UnityEngine.Object);
            /** The type of target required by the PlayableOutput for this PlayableBinding.
            */
            public get outputTargetType(): System.Type;
        }
        /** A base class for assets that can be used to instantiate a Playable at runtime.
        */
        class PlayableAsset extends UnityEngine.ScriptableObject implements UnityEngine.Playables.IPlayableAsset
        {
            protected [__keep_incompatibility]: never;
            /** The playback duration in seconds of the instantiated Playable.
            */
            public get duration(): number;
            /** A description of the outputs of the instantiated Playable.
            */
            public get outputs(): System.Collections.Generic.IEnumerable$1<UnityEngine.Playables.PlayableBinding>;
            /** Implement this method to have your asset inject playables into the given graph.
            * @param $graph The graph to inject playables into.
            * @param $owner The game object which initiated the build.
            * @returns The playable injected into the graph, or the root playable if multiple playables are injected. 
            */
            public CreatePlayable ($graph: UnityEngine.Playables.PlayableGraph, $owner: UnityEngine.GameObject) : UnityEngine.Playables.Playable
        }
        /** PlayableBehaviour is the base class from which every custom playable script derives.
        */
        class PlayableBehaviour extends System.Object implements System.ICloneable, UnityEngine.Playables.IPlayableBehaviour
        {
            protected [__keep_incompatibility]: never;
            /** This function is called when the PlayableGraph that owns this PlayableBehaviour starts.
            * @param $playable The Playable that owns the current PlayableBehaviour.
            */
            public OnGraphStart ($playable: UnityEngine.Playables.Playable) : void
            /** This function is called when the PlayableGraph that owns this PlayableBehaviour stops.
            * @param $playable The Playable that owns the current PlayableBehaviour.
            */
            public OnGraphStop ($playable: UnityEngine.Playables.Playable) : void
            /** This function is called when the Playable that owns the PlayableBehaviour is created.
            * @param $playable The Playable that owns the current PlayableBehaviour.
            */
            public OnPlayableCreate ($playable: UnityEngine.Playables.Playable) : void
            /** This function is called when the Playable that owns the PlayableBehaviour is destroyed.
            * @param $playable The Playable that owns the current PlayableBehaviour.
            */
            public OnPlayableDestroy ($playable: UnityEngine.Playables.Playable) : void
            /** This function is called when the Playable play state is changed to Playables.PlayState.Playing.
            * @param $playable The Playable that owns the current PlayableBehaviour.
            * @param $info A FrameData structure that contains information about the current frame context.
            */
            public OnBehaviourPlay ($playable: UnityEngine.Playables.Playable, $info: UnityEngine.Playables.FrameData) : void
            /** This method is invoked when one of the following situations occurs:
            <br><br>
            The effective play state during traversal is changed to Playables.PlayState.Paused. This state is indicated by FrameData.effectivePlayState.<br><br>
            The PlayableGraph is stopped while the playable play state is Playing. This state is indicated by PlayableGraph.IsPlaying returning true.
            * @param $playable The Playable that owns the current PlayableBehaviour.
            * @param $info A FrameData structure that contains information about the current frame context.
            */
            public OnBehaviourPause ($playable: UnityEngine.Playables.Playable, $info: UnityEngine.Playables.FrameData) : void
            /** This function is called during the PrepareData phase of the PlayableGraph.
            * @param $playable The Playable that owns the current PlayableBehaviour.
            * @param $info A FrameData structure that contains information about the current frame context.
            */
            public PrepareData ($playable: UnityEngine.Playables.Playable, $info: UnityEngine.Playables.FrameData) : void
            /** This function is called during the PrepareFrame phase of the PlayableGraph.
            * @param $playable The Playable that owns the current PlayableBehaviour.
            * @param $info A FrameData structure that contains information about the current frame context.
            */
            public PrepareFrame ($playable: UnityEngine.Playables.Playable, $info: UnityEngine.Playables.FrameData) : void
            /** This function is called during the ProcessFrame phase of the PlayableGraph.
            * @param $playable The Playable that owns the current PlayableBehaviour.
            * @param $info A FrameData structure that contains information about the current frame context.
            * @param $playerData The user data of the ScriptPlayableOutput that initiated the process pass.
            */
            public ProcessFrame ($playable: UnityEngine.Playables.Playable, $info: UnityEngine.Playables.FrameData, $playerData: any) : void
            public Clone () : any
        }
        /** Describes the type of information that flows in and out of a Playable. This also specifies that this Playable is connectable to others of the same type.
        */
        enum DataStreamType
        { Animation = 0, Audio = 1, Texture = 2, None = 3 }
        /** Traversal mode for Playables.
        */
        enum PlayableTraversalMode
        { Mix = 0, Passthrough = 1 }
        /** Extensions for all the types that implements IPlayable.
        */
        class PlayableExtensions extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        /** Defines what time source is used to update a Director graph.
        */
        enum DirectorUpdateMode
        { DSPClock = 0, GameTime = 1, UnscaledGameTime = 2, Manual = 3 }
        /** Extensions for all the types that implements IPlayableOutput.
        */
        class PlayableOutputExtensions extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class ScriptPlayable$1<T> extends System.ValueType implements UnityEngine.Playables.IPlayable, System.IEquatable$1<UnityEngine.Playables.ScriptPlayable$1<T>>
        {
            protected [__keep_incompatibility]: never;
            public static get Null(): any;
            public static Create ($graph: any, $inputCount?: any) : any
            public static Create ($graph: any, $template: any, $inputCount?: any) : any
            public GetHandle () : UnityEngine.Playables.PlayableHandle
            public GetBehaviour () : T
            public static op_Implicit ($playable: any) : any
            public static op_Explicit ($playable: any) : any
            public Equals ($other: UnityEngine.Playables.ScriptPlayable$1<T>) : boolean
        }
        /** A PlayableBinding that contains information representing a ScriptingPlayableOutput.
        */
        class ScriptPlayableBinding extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Creates a PlayableBinding that contains information representing a ScriptPlayableOutput.
            * @param $key A reference to a UnityEngine.Object that acts as a key for this binding.
            * @param $type The type of object that will be bound to the ScriptPlayableOutput.
            * @param $name The name of the ScriptPlayableOutput.
            * @returns Returns a PlayableBinding that contains information that is used to create a ScriptPlayableOutput. 
            */
            public static Create ($name: string, $key: UnityEngine.Object, $type: System.Type) : UnityEngine.Playables.PlayableBinding
        }
        /** A IPlayableOutput implementation that contains a script output for the a PlayableGraph.
        */
        class ScriptPlayableOutput extends System.ValueType implements UnityEngine.Playables.IPlayableOutput
        {
            protected [__keep_incompatibility]: never;
            /** Returns an invalid ScriptPlayableOutput.
            */
            public static get Null(): UnityEngine.Playables.ScriptPlayableOutput;
            /** Creates a new ScriptPlayableOutput in the associated PlayableGraph.
            * @param $graph The PlayableGraph that will contain the ScriptPlayableOutput.
            * @param $name The name of this ScriptPlayableOutput.
            * @returns The created ScriptPlayableOutput. 
            */
            public static Create ($graph: UnityEngine.Playables.PlayableGraph, $name: string) : UnityEngine.Playables.ScriptPlayableOutput
            public GetHandle () : UnityEngine.Playables.PlayableOutputHandle
            public static op_Implicit ($output: UnityEngine.Playables.ScriptPlayableOutput) : UnityEngine.Playables.PlayableOutput
            public static op_Explicit ($output: UnityEngine.Playables.PlayableOutput) : UnityEngine.Playables.ScriptPlayableOutput
        }
    }
    namespace UnityEngine.Playables.FrameData {
        enum EvaluationType
        { Evaluate = 0, Playback = 1 }
    }
    namespace UnityEngine.Diagnostics {
        /** Specifies the category of crash to cause when calling ForceCrash().
        */
        enum ForcedCrashCategory
        { AccessViolation = 0, FatalError = 1, Abort = 2, PureVirtualFunction = 3, MonoAbort = 4 }
        /** A utility class that you can use for diagnostic purposes.
        */
        class Utils extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Manually causes an application crash in the specified category.
            */
            public static ForceCrash ($crashCategory: UnityEngine.Diagnostics.ForcedCrashCategory) : void
            /** Manually causes an assert that outputs the specified message to the log and registers an error.
            */
            public static NativeAssert ($message: string) : void
            /** Manually causes a native error that outputs the specified message to the log and registers an error.
            */
            public static NativeError ($message: string) : void
            /** Manually causes a warning that outputs the specified message to the log and registers an error.
            */
            public static NativeWarning ($message: string) : void
            /** Scans the managed heap to check for corrupted objects.
            */
            public static ValidateHeap () : void
        }
        class PlayerConnection extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace UnityEngine.Device {
        /** Access to platform-specific application runtime data.
        */
        class Application extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** This has the same functionality as Application.absoluteURL. At the moment, the Device Simulator doesn't support simulation of this property.
            */
            public static get absoluteURL(): string;
            /** This has the same functionality as Application.backgroundLoadingPriority. At the moment, the Device Simulator doesn't support simulation of this property.
            */
            public static get backgroundLoadingPriority(): UnityEngine.ThreadPriority;
            public static set backgroundLoadingPriority(value: UnityEngine.ThreadPriority);
            /** This has the same functionality as Application.buildGUID. At the moment, the Device Simulator doesn't support simulation of this property.
            */
            public static get buildGUID(): string;
            /** This has the same functionality as Application.cloudProjectId. At the moment, the Device Simulator doesn't support simulation of this property.
            */
            public static get cloudProjectId(): string;
            /** This has the same functionality as Application.companyName. At the moment, the Device Simulator doesn't support simulation of this property.
            */
            public static get companyName(): string;
            /** This has the same functionality as Application.consoleLogPath. At the moment, the Device Simulator doesn't support simulation of this property.
            */
            public static get consoleLogPath(): string;
            /** This has the same functionality as Application.dataPath. At the moment, the Device Simulator doesn't support simulation of this property.
            */
            public static get dataPath(): string;
            /** This has the same functionality as Application.genuine. At the moment, the Device Simulator doesn't support simulation of this property.
            */
            public static get genuine(): boolean;
            /** This has the same functionality as Application.genuineCheckAvailable. At the moment, the Device Simulator doesn't support simulation of this property.
            */
            public static get genuineCheckAvailable(): boolean;
            /** This has the same functionality as Application.identifier. At the moment, the Device Simulator doesn't support simulation of this property.
            */
            public static get identifier(): string;
            /** This has the same functionality as Application.installerName. At the moment, the Device Simulator doesn't support simulation of this property.
            */
            public static get installerName(): string;
            /** This has the same functionality as Application.installMode. At the moment, the Device Simulator doesn't support simulation of this property.
            */
            public static get installMode(): UnityEngine.ApplicationInstallMode;
            /** This has the same functionality as Application.internetReachability and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get internetReachability(): UnityEngine.NetworkReachability;
            /** This has the same functionality as Application.isBatchMode. At the moment, the Device Simulator doesn't support simulation of this property.
            */
            public static get isBatchMode(): boolean;
            /** This has the same functionality as Application.isConsolePlatform and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get isConsolePlatform(): boolean;
            /** This has the same functionality as Application.isEditor and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get isEditor(): boolean;
            /** This has the same functionality as Application.isFocused. At the moment, the Device Simulator doesn't support simulation of this property.
            */
            public static get isFocused(): boolean;
            /** This has the same functionality as Application.isMobilePlatform and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get isMobilePlatform(): boolean;
            /** This has the same functionality as Application.isPlaying. At the moment, the Device Simulator doesn't support simulation of this property.
            */
            public static get isPlaying(): boolean;
            /** This has the same functionality as Application.persistentDataPath. At the moment, the Device Simulator doesn't support simulation of this property.
            */
            public static get persistentDataPath(): string;
            /** This has the same functionality as Application.platform and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get platform(): UnityEngine.RuntimePlatform;
            /** This has the same functionality as Application.productName. At the moment, the Device Simulator doesn't support simulation of this property.
            */
            public static get productName(): string;
            /** This has the same functionality as Application.runInBackground. At the moment, the Device Simulator doesn't support simulation of this property.
            */
            public static get runInBackground(): boolean;
            public static set runInBackground(value: boolean);
            /** This has the same functionality as Application.sandboxType. At the moment, the Device Simulator doesn't support simulation of this property.
            */
            public static get sandboxType(): UnityEngine.ApplicationSandboxType;
            /** This has the same functionality as Application.streamingAssetsPath. At the moment, the Device Simulator doesn't support simulation of this property.
            */
            public static get streamingAssetsPath(): string;
            /** This has the same functionality as Application.systemLanguage and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get systemLanguage(): UnityEngine.SystemLanguage;
            /** This has the same functionality as Application.targetFrameRate. At the moment, the Device Simulator doesn't support simulation of this property.
            */
            public static get targetFrameRate(): number;
            public static set targetFrameRate(value: number);
            /** This has the same functionality as Application.temporaryCachePath. At the moment, the Device Simulator doesn't support simulation of this property.
            */
            public static get temporaryCachePath(): string;
            /** This has the same functionality as Application.unityVersion. At the moment, the Device Simulator doesn't support simulation of this property.
            */
            public static get unityVersion(): string;
            /** This has the same functionality as Application.version. At the moment, the Device Simulator doesn't support simulation of this property.
            */
            public static get version(): string;
            /** Cancellation token raised on exiting play mode (editor) or on quitting the application (Read Only).
            */
            public static get exitCancellationToken(): System.Threading.CancellationToken;
            public static add_deepLinkActivated ($value: System.Action$1<string>) : void
            public static remove_deepLinkActivated ($value: System.Action$1<string>) : void
            public static add_focusChanged ($value: System.Action$1<boolean>) : void
            public static remove_focusChanged ($value: System.Action$1<boolean>) : void
            public static add_logMessageReceived ($value: UnityEngine.Application.LogCallback) : void
            public static remove_logMessageReceived ($value: UnityEngine.Application.LogCallback) : void
            public static add_logMessageReceivedThreaded ($value: UnityEngine.Application.LogCallback) : void
            public static remove_logMessageReceivedThreaded ($value: UnityEngine.Application.LogCallback) : void
            public static add_lowMemory ($value: UnityEngine.Application.LowMemoryCallback) : void
            public static remove_lowMemory ($value: UnityEngine.Application.LowMemoryCallback) : void
            public static add_memoryUsageChanged ($value: UnityEngine.Application.MemoryUsageChangedCallback) : void
            public static remove_memoryUsageChanged ($value: UnityEngine.Application.MemoryUsageChangedCallback) : void
            public static add_onBeforeRender ($value: UnityEngine.Events.UnityAction) : void
            public static remove_onBeforeRender ($value: UnityEngine.Events.UnityAction) : void
            public static add_quitting ($value: System.Action) : void
            public static remove_quitting ($value: System.Action) : void
            public static add_wantsToQuit ($value: System.Func$1<boolean>) : void
            public static remove_wantsToQuit ($value: System.Func$1<boolean>) : void
            public static add_unloading ($value: System.Action) : void
            public static remove_unloading ($value: System.Action) : void
            /** This has the same functionality as Application.CanStreamedLevelBeLoaded. At the moment, the Device Simulator doesn't support simulation of this method.
            */
            public static CanStreamedLevelBeLoaded ($levelIndex: number) : boolean
            /** This has the same functionality as Application.CanStreamedLevelBeLoaded. At the moment, the Device Simulator doesn't support simulation of this method.
            */
            public static CanStreamedLevelBeLoaded ($levelName: string) : boolean
            /** This has the same functionality as Application.GetStackTraceLogType. At the moment, the Device Simulator doesn't support simulation of this method.
            */
            public static GetStackTraceLogType ($logType: UnityEngine.LogType) : UnityEngine.StackTraceLogType
            /** This has the same functionality as Application.HasProLicense. At the moment, the Device Simulator doesn't support simulation of this method.
            */
            public static HasProLicense () : boolean
            /** This has the same functionality as Application.HasUserAuthorization. At the moment, the Device Simulator doesn't support simulation of this method.
            */
            public static HasUserAuthorization ($mode: UnityEngine.UserAuthorization) : boolean
            /** This has the same functionality as Application.IsPlaying. At the moment, the Device Simulator doesn't support simulation of this method.
            */
            public static IsPlaying ($obj: UnityEngine.Object) : boolean
            /** This has the same functionality as Application.OpenURL. At the moment, the Device Simulator doesn't support simulation of this method.
            */
            public static OpenURL ($url: string) : void
            /** This has the same functionality as Application.Quit. At the moment, the Device Simulator doesn't support simulation of this method.
            */
            public static Quit () : void
            /** This has the same functionality as Application.Quit. At the moment, the Device Simulator doesn't support simulation of this method.
            */
            public static Quit ($exitCode: number) : void
            public static RequestAdvertisingIdentifierAsync ($delegateMethod: UnityEngine.Application.AdvertisingIdentifierCallback) : boolean
            /** This has the same functionality as Application.RequestUserAuthorization. At the moment, the Device Simulator doesn't support simulation of this method.
            */
            public static RequestUserAuthorization ($mode: UnityEngine.UserAuthorization) : UnityEngine.AsyncOperation
            /** This has the same functionality as Application.SetStackTraceLogType. At the moment, the Device Simulator doesn't support simulation of this method.
            */
            public static SetStackTraceLogType ($logType: UnityEngine.LogType, $stackTraceType: UnityEngine.StackTraceLogType) : void
            /** This has the same functionality as Application.Unload. At the moment, the Device Simulator doesn't support simulation of this method.
            */
            public static Unload () : void
        }
        /** Access platform-specific display information.
        */
        class Screen extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** This has the same functionality as Screen.autorotateToLandscapeLeft and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get autorotateToLandscapeLeft(): boolean;
            public static set autorotateToLandscapeLeft(value: boolean);
            /** This has the same functionality as Screen.autorotateToLandscapeRight and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get autorotateToLandscapeRight(): boolean;
            public static set autorotateToLandscapeRight(value: boolean);
            /** This has the same functionality as Screen.autorotateToPortrait and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get autorotateToPortrait(): boolean;
            public static set autorotateToPortrait(value: boolean);
            /** This has the same functionality as Screen.autorotateToPortraitUpsideDown and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get autorotateToPortraitUpsideDown(): boolean;
            public static set autorotateToPortraitUpsideDown(value: boolean);
            /** This has the same functionality as Screen.currentResolution and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get currentResolution(): UnityEngine.Resolution;
            /** This has the same functionality as Screen.cutouts and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get cutouts(): System.Array$1<UnityEngine.Rect>;
            /** This has the same functionality as Screen.dpi and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get dpi(): number;
            /** This has the same functionality as Screen.fullScreen and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get fullScreen(): boolean;
            public static set fullScreen(value: boolean);
            /** This has the same functionality as Screen.fullScreenMode and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get fullScreenMode(): UnityEngine.FullScreenMode;
            public static set fullScreenMode(value: UnityEngine.FullScreenMode);
            /** This has the same functionality as Screen.height and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get height(): number;
            /** This has the same functionality as Screen.width and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get width(): number;
            /** This has the same functionality as Screen.orientation and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get orientation(): UnityEngine.ScreenOrientation;
            public static set orientation(value: UnityEngine.ScreenOrientation);
            /** This has the same functionality as Screen.resolutions and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get resolutions(): System.Array$1<UnityEngine.Resolution>;
            /** This has the same functionality as Screen.safeArea and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get safeArea(): UnityEngine.Rect;
            /** This has the same functionality as Screen.sleepTimeout. At the moment, the Device Simulator doesn't support simulation of this property.
            */
            public static get sleepTimeout(): number;
            public static set sleepTimeout(value: number);
            /** This has the same functionality as Screen.brightness. At the moment, the Device Simulator doesn't support simulation of this property.
            */
            public static get brightness(): number;
            public static set brightness(value: number);
            /** The Device Simulator doesn't simulate this property.
            */
            public static get mainWindowPosition(): UnityEngine.Vector2Int;
            /** The Device Simulator doesn't simulate this property.
            */
            public static get mainWindowDisplayInfo(): UnityEngine.DisplayInfo;
            /** This has the same functionality as Screen.msaaSamples and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get msaaSamples(): number;
            /** This has the same functionality as Screen.SetResolution and also mimics platform-specific behavior in the Unity Editor.
            */
            public static SetResolution ($width: number, $height: number, $fullscreenMode: UnityEngine.FullScreenMode, $preferredRefreshRate: UnityEngine.RefreshRate) : void
            /** This has the same functionality as Screen.SetResolution and also mimics platform-specific behavior in the Unity Editor.
            */
            public static SetResolution ($width: number, $height: number, $fullscreenMode: UnityEngine.FullScreenMode) : void
            /** This has the same functionality as Screen.SetResolution and also mimics platform-specific behavior in the Unity Editor.
            */
            public static SetResolution ($width: number, $height: number, $fullscreen: boolean) : void
            public static GetDisplayLayout ($displayLayout: System.Collections.Generic.List$1<UnityEngine.DisplayInfo>) : void
            /** The Device Simulator doesn't simulate this method.
            * @param $display The target display where the window should move to.
            * @param $position The position the window moves to. Relative to the top left corner of the specified display in pixels.
            * @returns Returns AsyncOperation that represents moving the window. 
            */
            public static MoveMainWindowTo ($display: $Ref<UnityEngine.DisplayInfo>, $position: UnityEngine.Vector2Int) : UnityEngine.AsyncOperation
            /** This has the same functionality as Screen.SetMSAASamples and also mimics platform-specific behavior in the Unity Editor.
            */
            public static SetMSAASamples ($numSamples: number) : void
        }
        /** Access platform-specific system and hardware information.
        */
        class SystemInfo extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** This has the same functionality as SystemInfo.unsupportedIdentifier.
            */
            public static unsupportedIdentifier : string
            /** This has the same functionality as SystemInfo.batteryLevel and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get batteryLevel(): number;
            /** This has the same functionality as SystemInfo.batteryStatus and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get batteryStatus(): UnityEngine.BatteryStatus;
            /** This has the same functionality as SystemInfo.operatingSystem and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get operatingSystem(): string;
            /** This has the same functionality as SystemInfo.operatingSystemFamily and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get operatingSystemFamily(): UnityEngine.OperatingSystemFamily;
            /** This has the same functionality as SystemInfo.processorType and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get processorType(): string;
            /** This has the same functionality as SystemInfo.processorFrequency and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get processorFrequency(): number;
            /** This has the same functionality as SystemInfo.processorCount and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get processorCount(): number;
            /** This has the same functionality as SystemInfo.systemMemorySize and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get systemMemorySize(): number;
            /** This has the same functionality as SystemInfo.deviceUniqueIdentifier and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get deviceUniqueIdentifier(): string;
            /** This has the same functionality as SystemInfo.deviceName and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get deviceName(): string;
            /** This has the same functionality as SystemInfo.deviceModel and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get deviceModel(): string;
            /** This has the same functionality as SystemInfo.supportsAccelerometer and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get supportsAccelerometer(): boolean;
            /** This has the same functionality as SystemInfo.supportsGyroscope and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get supportsGyroscope(): boolean;
            /** This has the same functionality as SystemInfo.supportsLocationService and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get supportsLocationService(): boolean;
            /** This has the same functionality as SystemInfo.supportsVibration and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get supportsVibration(): boolean;
            /** This has the same functionality as SystemInfo.supportsAudio and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get supportsAudio(): boolean;
            /** This has the same functionality as SystemInfo.deviceType and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get deviceType(): UnityEngine.DeviceType;
            /** This has the same functionality as SystemInfo.graphicsMemorySize and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get graphicsMemorySize(): number;
            /** This has the same functionality as SystemInfo.graphicsDeviceName and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get graphicsDeviceName(): string;
            /** This has the same functionality as SystemInfo.graphicsDeviceVendor and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get graphicsDeviceVendor(): string;
            /** This has the same functionality as SystemInfo.graphicsDeviceID and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get graphicsDeviceID(): number;
            /** This has the same functionality as SystemInfo.graphicsDeviceVendorID and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get graphicsDeviceVendorID(): number;
            /** This has the same functionality as SystemInfo.graphicsDeviceType and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get graphicsDeviceType(): UnityEngine.Rendering.GraphicsDeviceType;
            /** This has the same functionality as SystemInfo.graphicsUVStartsAtTop and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get graphicsUVStartsAtTop(): boolean;
            /** This has the same functionality as SystemInfo.graphicsDeviceVersion and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get graphicsDeviceVersion(): string;
            /** This has the same functionality as SystemInfo.graphicsShaderLevel and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get graphicsShaderLevel(): number;
            /** This has the same functionality as SystemInfo.graphicsMultiThreaded and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get graphicsMultiThreaded(): boolean;
            /** This has the same functionality as SystemInfo.renderingThreadingMode and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get renderingThreadingMode(): UnityEngine.Rendering.RenderingThreadingMode;
            /** This has the same functionality as SystemInfo.foveatedRenderingCaps and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get foveatedRenderingCaps(): UnityEngine.Rendering.FoveatedRenderingCaps;
            /** This has the same functionality as SystemInfo.hasHiddenSurfaceRemovalOnGPU and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get hasHiddenSurfaceRemovalOnGPU(): boolean;
            /** This has the same functionality as SystemInfo.hasDynamicUniformArrayIndexingInFragmentShaders and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get hasDynamicUniformArrayIndexingInFragmentShaders(): boolean;
            /** This has the same functionality as SystemInfo.supportsShadows and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get supportsShadows(): boolean;
            /** This has the same functionality as SystemInfo.supportsRawShadowDepthSampling and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get supportsRawShadowDepthSampling(): boolean;
            /** This has the same functionality as SystemInfo.supportsMotionVectors and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get supportsMotionVectors(): boolean;
            /** This has the same functionality as SystemInfo.supports3DTextures and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get supports3DTextures(): boolean;
            /** This has the same functionality as SystemInfo.supportsCompressed3DTextures and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get supportsCompressed3DTextures(): boolean;
            /** This has the same functionality as SystemInfo.supports2DArrayTextures and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get supports2DArrayTextures(): boolean;
            /** This has the same functionality as SystemInfo.supports3DRenderTextures and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get supports3DRenderTextures(): boolean;
            /** This has the same functionality as SystemInfo.supportsCubemapArrayTextures and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get supportsCubemapArrayTextures(): boolean;
            /** This has the same functionality as SystemInfo.supportsAnisotropicFilter and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get supportsAnisotropicFilter(): boolean;
            /** This has the same functionality as SystemInfo.copyTextureSupport and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get copyTextureSupport(): UnityEngine.Rendering.CopyTextureSupport;
            /** This has the same functionality as SystemInfo.supportsComputeShaders and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get supportsComputeShaders(): boolean;
            /** This has the same functionality as SystemInfo.supportsGeometryShaders and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get supportsGeometryShaders(): boolean;
            /** This has the same functionality as SystemInfo.supportsTessellationShaders and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get supportsTessellationShaders(): boolean;
            /** This has the same functionality as SystemInfo.supportsRenderTargetArrayIndexFromVertexShader and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get supportsRenderTargetArrayIndexFromVertexShader(): boolean;
            /** This has the same functionality as SystemInfo.supportsInstancing and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get supportsInstancing(): boolean;
            /** This has the same functionality as SystemInfo.supportsHardwareQuadTopology and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get supportsHardwareQuadTopology(): boolean;
            /** This has the same functionality as SystemInfo.supports32bitsIndexBuffer and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get supports32bitsIndexBuffer(): boolean;
            /** This has the same functionality as SystemInfo.supportsSparseTextures and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get supportsSparseTextures(): boolean;
            /** This has the same functionality as SystemInfo.supportedRenderTargetCount and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get supportedRenderTargetCount(): number;
            /** This has the same functionality as SystemInfo.supportsSeparatedRenderTargetsBlend and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get supportsSeparatedRenderTargetsBlend(): boolean;
            /** This has the same functionality as SystemInfo.supportedRandomWriteTargetCount and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get supportedRandomWriteTargetCount(): number;
            /** This has the same functionality as SystemInfo.supportsMultisampledTextures and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get supportsMultisampledTextures(): number;
            /** This has the same functionality as SystemInfo.supportsMultisampled2DArrayTextures and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get supportsMultisampled2DArrayTextures(): boolean;
            /** This has the same functionality as SystemInfo.supportsMultisampleAutoResolve and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get supportsMultisampleAutoResolve(): boolean;
            /** This has the same functionality as SystemInfo.supportsTextureWrapMirrorOnce and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get supportsTextureWrapMirrorOnce(): number;
            /** This has the same functionality as SystemInfo.usesReversedZBuffer and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get usesReversedZBuffer(): boolean;
            /** This has the same functionality as SystemInfo.npotSupport and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get npotSupport(): UnityEngine.NPOTSupport;
            /** This has the same functionality as SystemInfo.maxTextureSize and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get maxTextureSize(): number;
            /** This has the same functionality as SystemInfo.maxTexture3DSize and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get maxTexture3DSize(): number;
            /** This has the same functionality as SystemInfo.maxTextureArraySlices and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get maxTextureArraySlices(): number;
            /** This has the same functionality as SystemInfo.maxCubemapSize and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get maxCubemapSize(): number;
            /** This has the same functionality as SystemInfo.maxAnisotropyLevel and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get maxAnisotropyLevel(): number;
            /** This has the same functionality as SystemInfo.maxComputeBufferInputsVertex and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get maxComputeBufferInputsVertex(): number;
            /** This has the same functionality as SystemInfo.maxComputeBufferInputsFragment and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get maxComputeBufferInputsFragment(): number;
            /** This has the same functionality as SystemInfo.maxComputeBufferInputsGeometry and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get maxComputeBufferInputsGeometry(): number;
            /** This has the same functionality as SystemInfo.maxComputeBufferInputsDomain and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get maxComputeBufferInputsDomain(): number;
            /** This has the same functionality as SystemInfo.maxComputeBufferInputsHull and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get maxComputeBufferInputsHull(): number;
            /** This has the same functionality as SystemInfo.maxComputeBufferInputsCompute and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get maxComputeBufferInputsCompute(): number;
            /** This has the same functionality as SystemInfo.maxComputeWorkGroupSize and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get maxComputeWorkGroupSize(): number;
            /** This has the same functionality as SystemInfo.maxComputeWorkGroupSizeX and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get maxComputeWorkGroupSizeX(): number;
            /** This has the same functionality as SystemInfo.maxComputeWorkGroupSizeY and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get maxComputeWorkGroupSizeY(): number;
            /** This has the same functionality as SystemInfo.maxComputeWorkGroupSizeZ and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get maxComputeWorkGroupSizeZ(): number;
            /** This has the same functionality as SystemInfo.computeSubGroupSize and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get computeSubGroupSize(): number;
            /** This has the same functionality as SystemInfo.supportsAsyncCompute and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get supportsAsyncCompute(): boolean;
            /** This has the same functionality as SystemInfo.supportsGpuRecorder and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get supportsGpuRecorder(): boolean;
            /** This has the same functionality as SystemInfo.supportsGraphicsFence and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get supportsGraphicsFence(): boolean;
            /** This has the same functionality as SystemInfo.supportsAsyncGPUReadback and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get supportsAsyncGPUReadback(): boolean;
            /** This has the same functionality as SystemInfo.supportsRayTracingShaders and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get supportsRayTracingShaders(): boolean;
            /** This has the same functionality as SystemInfo.supportsRayTracing and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get supportsRayTracing(): boolean;
            /** This property has the same functionality as SystemInfo.supportsInlineRayTracing and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get supportsInlineRayTracing(): boolean;
            /** This has the same functionality as SystemInfo.supportsSetConstantBuffer and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get supportsSetConstantBuffer(): boolean;
            /** This has the same functionality as SystemInfo.constantBufferOffsetAlignment and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get constantBufferOffsetAlignment(): number;
            /** This property mimics platform-specific behavior caused by SystemInfo.maxConstantBufferSize. Use this property for platform-specific testing in the Unity Editor.
            */
            public static get maxConstantBufferSize(): number;
            /** The maximum size of a graphics buffer (GraphicsBuffer, ComputeBuffer, vertex/index buffer, etc.) in bytes (Read Only).
            */
            public static get maxGraphicsBufferSize(): bigint;
            /** This has the same functionality as SystemInfo.hasMipMaxLevel and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get hasMipMaxLevel(): boolean;
            /** This has the same functionality as SystemInfo.supportsMipStreaming and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get supportsMipStreaming(): boolean;
            /** This has the same functionality as SystemInfo.usesLoadStoreActions and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get usesLoadStoreActions(): boolean;
            /** This has the same functionality as SystemInfo.hdrDisplaySupportFlags and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get hdrDisplaySupportFlags(): UnityEngine.HDRDisplaySupportFlags;
            /** This has the same functionality as SystemInfo.supportsConservativeRaster and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get supportsConservativeRaster(): boolean;
            /** This has the same functionality as SystemInfo.supportsMultiview and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get supportsMultiview(): boolean;
            /** This property has the same functionality as SystemInfo.supportsStoreAndResolveAction and also shows platform-specific behavior in the Unity Editor.
            */
            public static get supportsStoreAndResolveAction(): boolean;
            /** This property has the same functionality as SystemInfo.supportsMultisampleResolveDepth and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get supportsMultisampleResolveDepth(): boolean;
            /** This property has the same functionality as SystemInfo.supportsMultisampleResolveStencil and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get supportsMultisampleResolveStencil(): boolean;
            /** This property has the same functionality as SystemInfo.supportsIndirectArgumentsBuffer and also mimics platform-specific behavior in the Unity Editor.
            */
            public static get supportsIndirectArgumentsBuffer(): boolean;
            /** This has the same functionality as SystemInfo.SupportsRenderTextureFormat and also mimics platform-specific behavior in the Unity Editor.
            */
            public static SupportsRenderTextureFormat ($format: UnityEngine.RenderTextureFormat) : boolean
            /** This has the same functionality as SystemInfo.SupportsBlendingOnRenderTextureFormat and also mimics platform-specific behavior in the Unity Editor.
            */
            public static SupportsBlendingOnRenderTextureFormat ($format: UnityEngine.RenderTextureFormat) : boolean
            /** This has the same functionality as SystemInfo.SupportsTextureFormat and also mimics platform-specific behavior in the Unity Editor.
            */
            public static SupportsTextureFormat ($format: UnityEngine.TextureFormat) : boolean
            /** This has the same functionality as SystemInfo.SupportsVertexAttributeFormat and also mimics platform-specific behavior in the Unity Editor.
            */
            public static SupportsVertexAttributeFormat ($format: UnityEngine.Rendering.VertexAttributeFormat, $dimension: number) : boolean
            /** This has the same functionality as SystemInfo.IsFormatSupported and also mimics platform-specific behavior in the Unity Editor.
            */
            public static IsFormatSupported ($format: UnityEngine.Experimental.Rendering.GraphicsFormat, $usage: UnityEngine.Experimental.Rendering.GraphicsFormatUsage) : boolean
            /** This has the same functionality as SystemInfo.GetCompatibleFormat and also mimics platform-specific behavior in the Unity Editor.
            */
            public static GetCompatibleFormat ($format: UnityEngine.Experimental.Rendering.GraphicsFormat, $usage: UnityEngine.Experimental.Rendering.GraphicsFormatUsage) : UnityEngine.Experimental.Rendering.GraphicsFormat
            /** This has the same functionality as SystemInfo.GetGraphicsFormat and also mimics platform-specific behavior in the Unity Editor.
            */
            public static GetGraphicsFormat ($format: UnityEngine.Experimental.Rendering.DefaultFormat) : UnityEngine.Experimental.Rendering.GraphicsFormat
            /** This has the same functionality as SystemInfo.GetRenderTextureSupportedMSAASampleCount and also mimics platform-specific behavior in the Unity Editor.
            */
            public static GetRenderTextureSupportedMSAASampleCount ($desc: UnityEngine.RenderTextureDescriptor) : number
            /** This has the same functionality as SystemInfo.SupportsRandomWriteOnRenderTextureFormat. At the moment, the Device Simulator doesn't support simulation of this method.
            */
            public static SupportsRandomWriteOnRenderTextureFormat ($format: UnityEngine.RenderTextureFormat) : boolean
        }
    }
    namespace UnityEngine.DedicatedServer {
        /** DedicatedServer.Arguments provides accessors for common CLI options
        */
        class Arguments extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Port is the port on which the server will listen for connections.
            */
            public static get Port(): number | null;
            public static set Port(value: number | null);
            /** TargetFramerate is the rate at which the server process frames.
            */
            public static get TargetFramerate(): number | null;
            public static set TargetFramerate(value: number | null);
            /** LogLevel defines the loglevel.
            */
            public static get LogLevel(): number | null;
            public static set LogLevel(value: number | null);
            /** LogPath is the path the logfile(s).
            */
            public static get LogPath(): string;
            public static set LogPath(value: string);
            /** QueryPort is the port on which the server will listen for status requests.
            */
            public static get QueryPort(): number | null;
            public static set QueryPort(value: number | null);
            /** QueryType is the query protocl the server will handle for status requests.
            */
            public static get QueryType(): string;
            public static set QueryType(value: string);
            /** ErrorPolicy defines how errors in arguments are handled.
            */
            public static get ErrorPolicy(): UnityEngine.DedicatedServer.Arguments.ArgumentErrorPolicy;
            public static set ErrorPolicy(value: UnityEngine.DedicatedServer.Arguments.ArgumentErrorPolicy);
        }
    }
    namespace UnityEngine.DedicatedServer.Arguments {
        enum ArgumentErrorPolicy
        { Ignore = 0, Warn = 1, Fatal = 2 }
    }
    namespace UnityEngine.TestTools {
        /** Allows you to exclude an Assembly, Class, Constructor, Method or Struct from TestTools.Coverage.
        */
        class ExcludeFromCoverageAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Describes a covered sequence point used by TestTools.Coverage. For an example of typical usage, see TestTools.Coverage.GetSequencePointsFor.
        */
        class CoveredSequencePoint extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The method covered by the sequence point.
            */
            public method : System.Reflection.MethodBase
            /** The offset in bytes from the start of the method to the first Intermediate Language instruction of this sequence point.
            */
            public ilOffset : number
            /** The number of times the sequence point has been visited.
            */
            public hitCount : number
            /** The name of the file that contains the sequence point.
            */
            public filename : string
            /** The line number of the file that contains the sequence point.
            */
            public line : number
            /** The column number of the line of the file that contains the sequence point.
            */
            public column : number
        }
        /** Describes the summary of the code coverage for the specified method used by TestTools.Coverage. For an example of typical usage, see TestTools.Coverage.GetStatsFor.
        */
        class CoveredMethodStats extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The covered method.
            */
            public method : System.Reflection.MethodBase
            /** The total number of sequence points in the method.
            */
            public totalSequencePoints : number
            /** The total number of uncovered sequence points in the method.
            */
            public uncoveredSequencePoints : number
        }
        /** Describes the interface for the code coverage data exposed by mono.
        */
        class Coverage extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Enables or disables code coverage. Note that Code Coverage can affect the performance.
            * @returns Returns true if code coverage is enabled; otherwise, returns false. 
            */
            public static get enabled(): boolean;
            public static set enabled(value: boolean);
            /** Returns the coverage sequence points for the method you specify. See CoveredSequencePoint for more information about the coverage data this method returns.
            * @param $method The method to get the sequence points for.
            * @returns Array of sequence points. 
            */
            public static GetSequencePointsFor ($method: System.Reflection.MethodBase) : System.Array$1<UnityEngine.TestTools.CoveredSequencePoint>
            /** Returns the coverage summary for the specified method. See CoveredMethodStats for more information about the coverage statistics returned by this method.
            * @param $method The method to get coverage statistics for.
            * @returns Coverage summary. 
            */
            public static GetStatsFor ($method: System.Reflection.MethodBase) : UnityEngine.TestTools.CoveredMethodStats
            /** Returns an array of coverage summaries for the specified array of methods.
            * @param $methods The array of methods.
            * @returns Array of coverage summaries. 
            */
            public static GetStatsFor ($methods: System.Array$1<System.Reflection.MethodBase>) : System.Array$1<UnityEngine.TestTools.CoveredMethodStats>
            /** Returns an array of coverage summaries for the specified type.
            * @param $type The type.
            * @returns Array of coverage summaries. 
            */
            public static GetStatsFor ($type: System.Type) : System.Array$1<UnityEngine.TestTools.CoveredMethodStats>
            /** Returns the coverage summary for all methods that have been called since either the Unity process was started or Coverage.ResetAll() has been called.
            * @returns Array of coverage summaries. 
            */
            public static GetStatsForAllCoveredMethods () : System.Array$1<UnityEngine.TestTools.CoveredMethodStats>
            /** Resets the coverage data for the specified method.
            * @param $method The method.
            */
            public static ResetFor ($method: System.Reflection.MethodBase) : void
            /** Resets all coverage data.
            */
            public static ResetAll () : void
        }
    }
    namespace UnityEngine.Experimental.GlobalIllumination {
        /** The light type.
        */
        enum LightType
        { Directional = 0, Point = 1, Spot = 2, Rectangle = 3, Disc = 4, SpotPyramidShape = 5, SpotBoxShape = 6 }
        /** The lightmode. A light can be real-time, mixed, baked or unknown. Unknown lights will be ignored by the baking backends.
        */
        enum LightMode
        { Realtime = 0, Mixed = 1, Baked = 2, Unknown = 3 }
        /** Available falloff models for baking.
        */
        enum FalloffType
        { InverseSquared = 0, InverseSquaredNoRangeAttenuation = 1, Linear = 2, Legacy = 3, Undefined = 4 }
        /** Sets the method to use to compute the angular attenuation of spot lights.
        */
        enum AngularFalloffType
        { LUT = 0, AnalyticAndInnerAngle = 1 }
        /** Contains normalized linear color values for red, green, blue in the range of 0 to 1, and an additional intensity value.
        */
        class LinearColor extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The red color value in the range of 0.0 to 1.0.
            */
            public get red(): number;
            public set red(value: number);
            /** The green color value in the range of 0.0 to 1.0.
            */
            public get green(): number;
            public set green(value: number);
            /** The blue color value in the range of 0.0 to 1.0.
            */
            public get blue(): number;
            public set blue(value: number);
            /** The intensity value used to scale the red, green and blue values.
            */
            public get intensity(): number;
            public set intensity(value: number);
            /** Converts a Light's color value to a normalized linear color value, automatically handling gamma conversion if necessary.
            * @param $color Light color.
            * @param $intensity Light intensity.
            * @returns Returns the normalized linear color value. 
            */
            public static Convert ($color: UnityEngine.Color, $intensity: number) : UnityEngine.Experimental.GlobalIllumination.LinearColor
            /** Returns a black color.
            * @returns Returns a black color. 
            */
            public static Black () : UnityEngine.Experimental.GlobalIllumination.LinearColor
        }
        /** A helper structure used to initialize a LightDataGI structure as a directional light.
        */
        class DirectionalLight extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The light's instanceID.
            */
            public instanceID : number
            /** True if the light casts shadows, otherwise False.
            */
            public shadow : boolean
            /** The lightmode.
            */
            public mode : UnityEngine.Experimental.GlobalIllumination.LightMode
            /** The light's position. Only relevant for cookie placement.
            */
            public position : UnityEngine.Vector3
            /** The light's orientation. Only relevant for cookie placement.
            */
            public orientation : UnityEngine.Quaternion
            /** The direct light color.
            */
            public color : UnityEngine.Experimental.GlobalIllumination.LinearColor
            /** The indirect light color.
            */
            public indirectColor : UnityEngine.Experimental.GlobalIllumination.LinearColor
            /** The penumbra width for soft shadows in radians.
            */
            public penumbraWidthRadian : number
        }
        /** A helper structure used to initialize a LightDataGI structure as a point light.
        */
        class PointLight extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The light's instanceID.
            */
            public instanceID : number
            /** True if the light casts shadows, otherwise False.
            */
            public shadow : boolean
            /** The lightmode.
            */
            public mode : UnityEngine.Experimental.GlobalIllumination.LightMode
            /** The light's position.
            */
            public position : UnityEngine.Vector3
            /** The light's orientation.
            */
            public orientation : UnityEngine.Quaternion
            /** The direct light color.
            */
            public color : UnityEngine.Experimental.GlobalIllumination.LinearColor
            /** The indirect light color.
            */
            public indirectColor : UnityEngine.Experimental.GlobalIllumination.LinearColor
            /** The light's range.
            */
            public range : number
            /** The light's sphere radius, influencing soft shadows.
            */
            public sphereRadius : number
            /** The falloff model to use for baking the point light.
            */
            public falloff : UnityEngine.Experimental.GlobalIllumination.FalloffType
        }
        /** A helper structure used to initialize a LightDataGI structure as a spot light.
        */
        class SpotLight extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The light's instanceID.
            */
            public instanceID : number
            /** True if the light casts shadows, otherwise False.
            */
            public shadow : boolean
            /** The lightmode.
            */
            public mode : UnityEngine.Experimental.GlobalIllumination.LightMode
            /** The light's position.
            */
            public position : UnityEngine.Vector3
            /** The light's orientation.
            */
            public orientation : UnityEngine.Quaternion
            /** The direct light color.
            */
            public color : UnityEngine.Experimental.GlobalIllumination.LinearColor
            /** The indirect light color.
            */
            public indirectColor : UnityEngine.Experimental.GlobalIllumination.LinearColor
            /** The light's range.
            */
            public range : number
            /** The light's sphere radius, influencing soft shadows.
            */
            public sphereRadius : number
            /** The outer angle for the spot light.
            */
            public coneAngle : number
            /** The inner angle for the spot light.
            */
            public innerConeAngle : number
            /** The falloff model to use for baking the spot light.
            */
            public falloff : UnityEngine.Experimental.GlobalIllumination.FalloffType
            /** The angular falloff model to use for baking the spot light.
            */
            public angularFalloff : UnityEngine.Experimental.GlobalIllumination.AngularFalloffType
        }
        /** A helper structure used to initialize a LightDataGI structure as a rectangle light.
        */
        class RectangleLight extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The light's instanceID.
            */
            public instanceID : number
            /** True if the light casts shadows, otherwise False.
            */
            public shadow : boolean
            /** The lightmode.
            */
            public mode : UnityEngine.Experimental.GlobalIllumination.LightMode
            /** The light's position.
            */
            public position : UnityEngine.Vector3
            /** The light's orientation.
            */
            public orientation : UnityEngine.Quaternion
            /** The direct light color.
            */
            public color : UnityEngine.Experimental.GlobalIllumination.LinearColor
            /** The indirect light color.
            */
            public indirectColor : UnityEngine.Experimental.GlobalIllumination.LinearColor
            /** The light's range.
            */
            public range : number
            /** The width of the rectangle light.
            */
            public width : number
            /** The height of the rectangle light.
            */
            public height : number
            /** The falloff model to use for baking the rectangular light.
            */
            public falloff : UnityEngine.Experimental.GlobalIllumination.FalloffType
        }
        /** A helper structure used to initialize a LightDataGI structure as a disc light.
        */
        class DiscLight extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The light's instanceID.
            */
            public instanceID : number
            /** True if the light casts shadows, otherwise False.
            */
            public shadow : boolean
            /** The lightmode.
            */
            public mode : UnityEngine.Experimental.GlobalIllumination.LightMode
            /** The light's position.
            */
            public position : UnityEngine.Vector3
            /** The light's orientation.
            */
            public orientation : UnityEngine.Quaternion
            /** The direct light color.
            */
            public color : UnityEngine.Experimental.GlobalIllumination.LinearColor
            /** The indirect light color.
            */
            public indirectColor : UnityEngine.Experimental.GlobalIllumination.LinearColor
            /** The light's range.
            */
            public range : number
            /** The radius of the disc light.
            */
            public radius : number
            /** The falloff model to use for baking the disc light.
            */
            public falloff : UnityEngine.Experimental.GlobalIllumination.FalloffType
        }
        /** Use this Struct to help initialize a LightDataGI structure as a box-shaped spot light.
        */
        class SpotLightBoxShape extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The light's instanceID.
            */
            public instanceID : number
            /** Specifies whether the light casts shadows or not. This is true if the light does cast shadows and false otherwise.
            */
            public shadow : boolean
            /** The lightmode.
            */
            public mode : UnityEngine.Experimental.GlobalIllumination.LightMode
            /** The light's position.
            */
            public position : UnityEngine.Vector3
            /** The light's orientation.
            */
            public orientation : UnityEngine.Quaternion
            /** The direct light color.
            */
            public color : UnityEngine.Experimental.GlobalIllumination.LinearColor
            /** The indirect light color.
            */
            public indirectColor : UnityEngine.Experimental.GlobalIllumination.LinearColor
            /** The light's range.
            */
            public range : number
            /** The width of the box light.
            */
            public width : number
            /** The height of the box light.
            */
            public height : number
        }
        /** Use this Struct to help initialize a LightDataGI structure as a pyramid-shaped spot light.
        */
        class SpotLightPyramidShape extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The light's instanceID.
            */
            public instanceID : number
            /** Specifies whether the light casts shadows or not. This is true if the light does cast shadows and false otherwise.
            */
            public shadow : boolean
            /** The lightmode.
            */
            public mode : UnityEngine.Experimental.GlobalIllumination.LightMode
            /** The light's position.
            */
            public position : UnityEngine.Vector3
            /** The light's orientation.
            */
            public orientation : UnityEngine.Quaternion
            /** The direct light color.
            */
            public color : UnityEngine.Experimental.GlobalIllumination.LinearColor
            /** The indirect light color.
            */
            public indirectColor : UnityEngine.Experimental.GlobalIllumination.LinearColor
            /** The light's range.
            */
            public range : number
            /** The opening angle of the shorter side of the pyramid light.
            */
            public angle : number
            /** The aspect ratio for the pyramid shape. Values larger than 1 extend the width and values between 0 and 1 extend the height.
            */
            public aspectRatio : number
            /** The falloff model to use for baking the pyramid light.
            */
            public falloff : UnityEngine.Experimental.GlobalIllumination.FalloffType
        }
        /** A helper structure used to initialize a LightDataGI structure with cookie information.
        */
        class Cookie extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The cookie texture's instance id projected by the light.
            */
            public instanceID : number
            /** The uniform scale factor for downscaling cookies during lightmapping. Can be used as an optimization when full resolution cookies are not needed for indirect lighting.
            */
            public scale : number
            /** The scale factors controlling how the directional light's cookie is projected into the scene. This parameter should be set to 1 for all other light types.
            */
            public sizes : UnityEngine.Vector2
            /** Returns a default initialized cookie helper struct.
            */
            public static Defaults () : UnityEngine.Experimental.GlobalIllumination.Cookie
        }
        /** The interop structure to pass light information to the light baking backends. There are helper structures for Directional, Point, Spot and Rectangle lights to correctly initialize this structure.
        */
        class LightDataGI extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The light's instanceID.
            */
            public instanceID : number
            /** The cookie texture's instance id projected by the light.
            */
            public cookieID : number
            /** The uniform scale factor for downscaling cookies during lightmapping. Can be used as an optimization when full resolution cookies are not needed for indirect lighting.
            */
            public cookieScale : number
            /** The color of the light.
            */
            public color : UnityEngine.Experimental.GlobalIllumination.LinearColor
            /** The indirect color of the light.
            */
            public indirectColor : UnityEngine.Experimental.GlobalIllumination.LinearColor
            /** The orientation of the light.
            */
            public orientation : UnityEngine.Quaternion
            /** The position of the light.
            */
            public position : UnityEngine.Vector3
            /** The range of the light. Unused for directional lights.
            */
            public range : number
            /** The cone angle for spot lights.
            */
            public coneAngle : number
            /** The inner cone angle for spot lights.
            */
            public innerConeAngle : number
            /** The light's sphere radius for point and spot lights, or the width for rectangle lights.
            */
            public shape0 : number
            /** The height for rectangle lights.
            */
            public shape1 : number
            /** The type of the light.
            */
            public type : UnityEngine.Experimental.GlobalIllumination.LightType
            /** The lightmap mode for the light.
            */
            public mode : UnityEngine.Experimental.GlobalIllumination.LightMode
            /** Set to 1 for shadow casting lights, 0 otherwise.
            */
            public shadow : number
            /** The falloff model to use for baking point and spot lights.
            */
            public falloff : UnityEngine.Experimental.GlobalIllumination.FalloffType
            public Init ($light: $Ref<UnityEngine.Experimental.GlobalIllumination.DirectionalLight>, $cookie: $Ref<UnityEngine.Experimental.GlobalIllumination.Cookie>) : void
            public Init ($light: $Ref<UnityEngine.Experimental.GlobalIllumination.PointLight>, $cookie: $Ref<UnityEngine.Experimental.GlobalIllumination.Cookie>) : void
            public Init ($light: $Ref<UnityEngine.Experimental.GlobalIllumination.SpotLight>, $cookie: $Ref<UnityEngine.Experimental.GlobalIllumination.Cookie>) : void
            public Init ($light: $Ref<UnityEngine.Experimental.GlobalIllumination.RectangleLight>, $cookie: $Ref<UnityEngine.Experimental.GlobalIllumination.Cookie>) : void
            public Init ($light: $Ref<UnityEngine.Experimental.GlobalIllumination.DiscLight>, $cookie: $Ref<UnityEngine.Experimental.GlobalIllumination.Cookie>) : void
            public Init ($light: $Ref<UnityEngine.Experimental.GlobalIllumination.SpotLightBoxShape>, $cookie: $Ref<UnityEngine.Experimental.GlobalIllumination.Cookie>) : void
            public Init ($light: $Ref<UnityEngine.Experimental.GlobalIllumination.SpotLightPyramidShape>, $cookie: $Ref<UnityEngine.Experimental.GlobalIllumination.Cookie>) : void
            /** Initialize the struct with the parameters from the given light type.
            */
            public Init ($light: $Ref<UnityEngine.Experimental.GlobalIllumination.DirectionalLight>) : void
            /** Initialize the struct with the parameters from the given light type.
            */
            public Init ($light: $Ref<UnityEngine.Experimental.GlobalIllumination.PointLight>) : void
            /** Initialize the struct with the parameters from the given light type.
            */
            public Init ($light: $Ref<UnityEngine.Experimental.GlobalIllumination.SpotLight>) : void
            /** Initialize the struct with the parameters from the given light type.
            */
            public Init ($light: $Ref<UnityEngine.Experimental.GlobalIllumination.RectangleLight>) : void
            public Init ($light: $Ref<UnityEngine.Experimental.GlobalIllumination.DiscLight>) : void
            /** Initialize the struct with the parameters from the given light type.
            */
            public Init ($light: $Ref<UnityEngine.Experimental.GlobalIllumination.SpotLightBoxShape>) : void
            /** Initialize the struct with the parameters from the given light type.
            */
            public Init ($light: $Ref<UnityEngine.Experimental.GlobalIllumination.SpotLightPyramidShape>) : void
            /** Initialize a light so that the baking backends ignore it.
            */
            public InitNoBake ($lightInstanceID: number) : void
        }
        /** Utility class for converting Unity Lights to light types recognized by the baking backends.
        */
        class LightmapperUtils extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Extracts informations from Lights.
            * @param $baketype The lights baketype.
            * @returns Returns the light's light mode. 
            */
            public static Extract ($baketype: UnityEngine.LightmapBakeType) : UnityEngine.Experimental.GlobalIllumination.LightMode
            /** Extracts the indirect color from a light.
            */
            public static ExtractIndirect ($l: UnityEngine.Light) : UnityEngine.Experimental.GlobalIllumination.LinearColor
            /** Extracts the inner cone angle of spot lights.
            */
            public static ExtractInnerCone ($l: UnityEngine.Light) : number
            /** Extract type specific information from Lights.
            * @param $l The input light.
            * @param $dir Extracts directional light information.
            * @param $point Extracts point light information.
            * @param $spot Extracts spot light information.
            * @param $rect Extracts rectangle light information.
            */
            public static Extract ($l: UnityEngine.Light, $dir: $Ref<UnityEngine.Experimental.GlobalIllumination.DirectionalLight>) : void
            /** Extract type specific information from Lights.
            * @param $l The input light.
            * @param $dir Extracts directional light information.
            * @param $point Extracts point light information.
            * @param $spot Extracts spot light information.
            * @param $rect Extracts rectangle light information.
            */
            public static Extract ($l: UnityEngine.Light, $point: $Ref<UnityEngine.Experimental.GlobalIllumination.PointLight>) : void
            /** Extract type specific information from Lights.
            * @param $l The input light.
            * @param $dir Extracts directional light information.
            * @param $point Extracts point light information.
            * @param $spot Extracts spot light information.
            * @param $rect Extracts rectangle light information.
            */
            public static Extract ($l: UnityEngine.Light, $spot: $Ref<UnityEngine.Experimental.GlobalIllumination.SpotLight>) : void
            /** Extract type specific information from Lights.
            * @param $l The input light.
            * @param $dir Extracts directional light information.
            * @param $point Extracts point light information.
            * @param $spot Extracts spot light information.
            * @param $rect Extracts rectangle light information.
            */
            public static Extract ($l: UnityEngine.Light, $rect: $Ref<UnityEngine.Experimental.GlobalIllumination.RectangleLight>) : void
            public static Extract ($l: UnityEngine.Light, $disc: $Ref<UnityEngine.Experimental.GlobalIllumination.DiscLight>) : void
            public static Extract ($l: UnityEngine.Light, $cookie: $Ref<UnityEngine.Experimental.GlobalIllumination.Cookie>) : void
        }
        /** Interface to the light baking backends.
        */
        class Lightmapping extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static SetDelegate ($del: UnityEngine.Experimental.GlobalIllumination.Lightmapping.RequestLightsDelegate) : void
            /** Get the currently set conversion delegate.
            * @returns Returns the currently set conversion delegate. 
            */
            public static GetDelegate () : UnityEngine.Experimental.GlobalIllumination.Lightmapping.RequestLightsDelegate
            /** Resets the light conversion delegate to Unity's default conversion function.
            */
            public static ResetDelegate () : void
        }
        /** Experimental render settings features.
        */
        class RenderSettings extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** If enabled, ambient trilight will be sampled using the old radiance sampling method.
            */
            public static get useRadianceAmbientProbe(): boolean;
            public static set useRadianceAmbientProbe(value: boolean);
            public constructor ()
        }
    }
    namespace UnityEngine.Experimental.GlobalIllumination.Lightmapping {
        interface RequestLightsDelegate
        { 
        (requests: System.Array$1<UnityEngine.Light>, lightsOutput: Unity.Collections.NativeArray$1<UnityEngine.Experimental.GlobalIllumination.LightDataGI>) : void; 
        Invoke?: (requests: System.Array$1<UnityEngine.Light>, lightsOutput: Unity.Collections.NativeArray$1<UnityEngine.Experimental.GlobalIllumination.LightDataGI>) => void;
        }
        var RequestLightsDelegate: { new (func: (requests: System.Array$1<UnityEngine.Light>, lightsOutput: Unity.Collections.NativeArray$1<UnityEngine.Experimental.GlobalIllumination.LightDataGI>) => void): RequestLightsDelegate; }
    }
    namespace UnityEngine.Experimental.Playables {
        /** An implementation of IPlayable that produces a Camera texture.
        */
        class CameraPlayable extends System.ValueType implements UnityEngine.Playables.IPlayable, System.IEquatable$1<UnityEngine.Experimental.Playables.CameraPlayable>
        {
            protected [__keep_incompatibility]: never;
            /** Creates a CameraPlayable in the PlayableGraph.
            * @param $graph The PlayableGraph object that will own the CameraPlayable.
            * @param $camera Camera used to produce a texture in the PlayableGraph.
            * @returns A CameraPlayable linked to the PlayableGraph. 
            */
            public static Create ($graph: UnityEngine.Playables.PlayableGraph, $camera: UnityEngine.Camera) : UnityEngine.Experimental.Playables.CameraPlayable
            public GetHandle () : UnityEngine.Playables.PlayableHandle
            public static op_Implicit ($playable: UnityEngine.Experimental.Playables.CameraPlayable) : UnityEngine.Playables.Playable
            public static op_Explicit ($playable: UnityEngine.Playables.Playable) : UnityEngine.Experimental.Playables.CameraPlayable
            public Equals ($other: UnityEngine.Experimental.Playables.CameraPlayable) : boolean
            public GetCamera () : UnityEngine.Camera
            public SetCamera ($value: UnityEngine.Camera) : void
        }
        /** An implementation of IPlayable that allows application of a Material shader to one or many texture inputs to produce a texture output.
        */
        class MaterialEffectPlayable extends System.ValueType implements UnityEngine.Playables.IPlayable, System.IEquatable$1<UnityEngine.Experimental.Playables.MaterialEffectPlayable>
        {
            protected [__keep_incompatibility]: never;
            public static Create ($graph: UnityEngine.Playables.PlayableGraph, $material: UnityEngine.Material, $pass?: number) : UnityEngine.Experimental.Playables.MaterialEffectPlayable
            public GetHandle () : UnityEngine.Playables.PlayableHandle
            public static op_Implicit ($playable: UnityEngine.Experimental.Playables.MaterialEffectPlayable) : UnityEngine.Playables.Playable
            public static op_Explicit ($playable: UnityEngine.Playables.Playable) : UnityEngine.Experimental.Playables.MaterialEffectPlayable
            public Equals ($other: UnityEngine.Experimental.Playables.MaterialEffectPlayable) : boolean
            public GetMaterial () : UnityEngine.Material
            public SetMaterial ($value: UnityEngine.Material) : void
            public GetPass () : number
            public SetPass ($value: number) : void
        }
        /** An implementation of IPlayable that allows mixing two textures.
        */
        class TextureMixerPlayable extends System.ValueType implements UnityEngine.Playables.IPlayable, System.IEquatable$1<UnityEngine.Experimental.Playables.TextureMixerPlayable>
        {
            protected [__keep_incompatibility]: never;
            /** Creates a TextureMixerPlayable in the PlayableGraph.
            * @param $graph The PlayableGraph object that will own the TextureMixerPlayable.
            * @returns A TextureMixerPlayable linked to the PlayableGraph. 
            */
            public static Create ($graph: UnityEngine.Playables.PlayableGraph) : UnityEngine.Experimental.Playables.TextureMixerPlayable
            public GetHandle () : UnityEngine.Playables.PlayableHandle
            public static op_Implicit ($playable: UnityEngine.Experimental.Playables.TextureMixerPlayable) : UnityEngine.Playables.Playable
            public static op_Explicit ($playable: UnityEngine.Playables.Playable) : UnityEngine.Experimental.Playables.TextureMixerPlayable
            public Equals ($other: UnityEngine.Experimental.Playables.TextureMixerPlayable) : boolean
        }
        /** A PlayableBinding that contains information representing a TexturePlayableOutput.
        */
        class TexturePlayableBinding extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Creates a PlayableBinding that contains information representing a TexturePlayableOutput.
            * @param $key A reference to a UnityEngine.Object that acts as a key for this binding.
            * @param $name The name of the TexturePlayableOutput.
            * @returns Returns a PlayableBinding that contains information that is used to create a TexturePlayableOutput. 
            */
            public static Create ($name: string, $key: UnityEngine.Object) : UnityEngine.Playables.PlayableBinding
        }
        /** An IPlayableOutput implementation that will be used to manipulate textures.
        */
        class TexturePlayableOutput extends System.ValueType implements UnityEngine.Playables.IPlayableOutput
        {
            protected [__keep_incompatibility]: never;
            /** Returns an invalid TexturePlayableOutput.
            */
            public static get Null(): UnityEngine.Experimental.Playables.TexturePlayableOutput;
            public static Create ($graph: UnityEngine.Playables.PlayableGraph, $name: string, $target: UnityEngine.RenderTexture) : UnityEngine.Experimental.Playables.TexturePlayableOutput
            public GetHandle () : UnityEngine.Playables.PlayableOutputHandle
            public static op_Implicit ($output: UnityEngine.Experimental.Playables.TexturePlayableOutput) : UnityEngine.Playables.PlayableOutput
            public static op_Explicit ($output: UnityEngine.Playables.PlayableOutput) : UnityEngine.Experimental.Playables.TexturePlayableOutput
            public GetTarget () : UnityEngine.RenderTexture
            public SetTarget ($value: UnityEngine.RenderTexture) : void
        }
    }
    namespace UnityEngine.Assertions {
        /** The Assert class contains assertion methods for setting invariants in the code.
        */
        class Assert extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Asserts that the condition is true.
            * @param $message The string used to describe the Assert.
            * @param $condition true or false.
            */
            public static IsTrue ($condition: boolean) : void
            /** Asserts that the condition is true.
            * @param $message The string used to describe the Assert.
            * @param $condition true or false.
            */
            public static IsTrue ($condition: boolean, $message: string) : void
            /** Return true when the condition is false.  Otherwise return false.
            * @param $condition true or false.
            * @param $message The string used to describe the result of the Assert.
            */
            public static IsFalse ($condition: boolean) : void
            /** Return true when the condition is false.  Otherwise return false.
            * @param $condition true or false.
            * @param $message The string used to describe the result of the Assert.
            */
            public static IsFalse ($condition: boolean, $message: string) : void
            /** Assert the values are approximately equal.
            * @param $tolerance Tolerance of approximation.
            * @param $expected The assumed Assert value.
            * @param $actual The exact Assert value.
            * @param $message The string used to describe the Assert.
            */
            public static AreApproximatelyEqual ($expected: number, $actual: number) : void
            /** Assert the values are approximately equal.
            * @param $tolerance Tolerance of approximation.
            * @param $expected The assumed Assert value.
            * @param $actual The exact Assert value.
            * @param $message The string used to describe the Assert.
            */
            public static AreApproximatelyEqual ($expected: number, $actual: number, $message: string) : void
            /** Assert the values are approximately equal.
            * @param $tolerance Tolerance of approximation.
            * @param $expected The assumed Assert value.
            * @param $actual The exact Assert value.
            * @param $message The string used to describe the Assert.
            */
            public static AreApproximatelyEqual ($expected: number, $actual: number, $tolerance: number) : void
            /** Assert the values are approximately equal.
            * @param $tolerance Tolerance of approximation.
            * @param $expected The assumed Assert value.
            * @param $actual The exact Assert value.
            * @param $message The string used to describe the Assert.
            */
            public static AreApproximatelyEqual ($expected: number, $actual: number, $tolerance: number, $message: string) : void
            /** Asserts that the values are approximately not equal.
            * @param $tolerance Tolerance of approximation.
            * @param $expected The assumed Assert value.
            * @param $actual The exact Assert value.
            * @param $message The string used to describe the Assert.
            */
            public static AreNotApproximatelyEqual ($expected: number, $actual: number) : void
            /** Asserts that the values are approximately not equal.
            * @param $tolerance Tolerance of approximation.
            * @param $expected The assumed Assert value.
            * @param $actual The exact Assert value.
            * @param $message The string used to describe the Assert.
            */
            public static AreNotApproximatelyEqual ($expected: number, $actual: number, $message: string) : void
            /** Asserts that the values are approximately not equal.
            * @param $tolerance Tolerance of approximation.
            * @param $expected The assumed Assert value.
            * @param $actual The exact Assert value.
            * @param $message The string used to describe the Assert.
            */
            public static AreNotApproximatelyEqual ($expected: number, $actual: number, $tolerance: number) : void
            /** Asserts that the values are approximately not equal.
            * @param $tolerance Tolerance of approximation.
            * @param $expected The assumed Assert value.
            * @param $actual The exact Assert value.
            * @param $message The string used to describe the Assert.
            */
            public static AreNotApproximatelyEqual ($expected: number, $actual: number, $tolerance: number, $message: string) : void
            /** Assert that the values are equal.
            * @param $expected The assumed Assert value.
            * @param $actual The exact Assert value.
            * @param $message The string used to describe the Assert.
            * @param $comparer Method to compare expected and actual arguments have the same value.
            */
            public static AreEqual ($expected: UnityEngine.Object, $actual: UnityEngine.Object, $message: string) : void
            /** Assert that the values are not equal.
            * @param $expected The assumed Assert value.
            * @param $actual The exact Assert value.
            * @param $message The string used to describe the Assert.
            * @param $comparer Method to compare expected and actual arguments have the same value.
            */
            public static AreNotEqual ($expected: UnityEngine.Object, $actual: UnityEngine.Object, $message: string) : void
            /** Assert the value is null.
            * @param $value The Object or type being checked for.
            * @param $message The string used to describe the Assert.
            */
            public static IsNull ($value: UnityEngine.Object, $message: string) : void
            /** Assert that the value is not null.
            * @param $value The Object or type being checked for.
            * @param $message The string used to describe the Assert.
            */
            public static IsNotNull ($value: UnityEngine.Object, $message: string) : void
            /** Assert that the values are equal.
            * @param $expected The assumed Assert value.
            * @param $actual The exact Assert value.
            * @param $message The string used to describe the Assert.
            * @param $comparer Method to compare expected and actual arguments have the same value.
            */
            public static AreEqual ($expected: number, $actual: number) : void
            /** Assert that the values are equal.
            * @param $expected The assumed Assert value.
            * @param $actual The exact Assert value.
            * @param $message The string used to describe the Assert.
            * @param $comparer Method to compare expected and actual arguments have the same value.
            */
            public static AreEqual ($expected: number, $actual: number, $message: string) : void
            /** Assert that the values are not equal.
            * @param $expected The assumed Assert value.
            * @param $actual The exact Assert value.
            * @param $message The string used to describe the Assert.
            * @param $comparer Method to compare expected and actual arguments have the same value.
            */
            public static AreNotEqual ($expected: number, $actual: number) : void
            /** Assert that the values are not equal.
            * @param $expected The assumed Assert value.
            * @param $actual The exact Assert value.
            * @param $message The string used to describe the Assert.
            * @param $comparer Method to compare expected and actual arguments have the same value.
            */
            public static AreNotEqual ($expected: number, $actual: number, $message: string) : void
            /** Assert that the values are equal.
            * @param $expected The assumed Assert value.
            * @param $actual The exact Assert value.
            * @param $message The string used to describe the Assert.
            * @param $comparer Method to compare expected and actual arguments have the same value.
            */
            public static AreEqual ($expected: bigint, $actual: bigint) : void
            /** Assert that the values are equal.
            * @param $expected The assumed Assert value.
            * @param $actual The exact Assert value.
            * @param $message The string used to describe the Assert.
            * @param $comparer Method to compare expected and actual arguments have the same value.
            */
            public static AreEqual ($expected: bigint, $actual: bigint, $message: string) : void
            /** Assert that the values are not equal.
            * @param $expected The assumed Assert value.
            * @param $actual The exact Assert value.
            * @param $message The string used to describe the Assert.
            * @param $comparer Method to compare expected and actual arguments have the same value.
            */
            public static AreNotEqual ($expected: bigint, $actual: bigint) : void
            /** Assert that the values are not equal.
            * @param $expected The assumed Assert value.
            * @param $actual The exact Assert value.
            * @param $message The string used to describe the Assert.
            * @param $comparer Method to compare expected and actual arguments have the same value.
            */
            public static AreNotEqual ($expected: bigint, $actual: bigint, $message: string) : void
        }
        /** An exception that is thrown when an assertion fails.
        */
        class AssertionException extends System.Exception implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public get Message(): string;
            public constructor ($message: string, $userMessage: string)
        }
    }
    namespace UnityEngine.Assertions.Must {
        /** An extension class that serves as a wrapper for the Assert class.
        */
        class MustExtensions extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace UnityEngine.Apple {
        /** Destination of Frame Capture
        This is a wrapper for MTLCaptureDestination.
        */
        enum FrameCaptureDestination
        { DevTools = 1, GPUTraceDocument = 2 }
        /** Interface to control XCode Frame Capture.
        */
        class FrameCapture extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Is Capture destination supported.
            */
            public static IsDestinationSupported ($dest: UnityEngine.Apple.FrameCaptureDestination) : boolean
            /** Begin Capture in XCode frame debugger.
            */
            public static BeginCaptureToXcode () : void
            /** Begin Capture to the specified file.
            */
            public static BeginCaptureToFile ($path: string) : void
            /** End Capture.
            */
            public static EndCapture () : void
            /** Begin capture to Xcode at the beginning of the next frame, and end it at the end of the next frame.
            */
            public static CaptureNextFrameToXcode () : void
            /** Begin capture to the specified file at the beginning of the next frame, and end it at the end of the next frame.
            */
            public static CaptureNextFrameToFile ($path: string) : void
        }
    }
    namespace UnityEngine.Apple.TV {
        class Remote extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get allowExitToHome(): boolean;
            public static set allowExitToHome(value: boolean);
            public static get allowRemoteRotation(): boolean;
            public static set allowRemoteRotation(value: boolean);
            public static get reportAbsoluteDpadValues(): boolean;
            public static set reportAbsoluteDpadValues(value: boolean);
            public static get touchesEnabled(): boolean;
            public static set touchesEnabled(value: boolean);
            public constructor ()
        }
    }
    namespace UnityEngine.Apple.ReplayKit {
        /** ReplayKit is only available on certain iPhone, iPad and iPod Touch devices running iOS 9.0 or later.
        */
        class ReplayKit extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** A boolean that indicates whether the ReplayKit API is available (where True means available). (Read Only)
            */
            public static get APIAvailable(): boolean;
            /** A Boolean that indicates whether ReplayKit broadcasting API is available (true means available) (Read Only).
            Check the value of this property before making ReplayKit broadcasting API calls. On iOS versions prior to iOS 10, this property will have a value of false.
            */
            public static get broadcastingAPIAvailable(): boolean;
            /** A boolean value that indicates that a new recording is available for preview (where True means available). (Read Only)
            */
            public static get recordingAvailable(): boolean;
            /** A boolean that indicates whether ReplayKit is making a recording (where True means a recording is in progress). (Read Only)
            */
            public static get isRecording(): boolean;
            /** Boolean property that indicates whether a broadcast is currently in progress (Read Only).
            */
            public static get isBroadcasting(): boolean;
            /** Boolean property that indicates whether a broadcast is currently paused (Read Only).
            */
            public static get isBroadcastingPaused(): boolean;
            /** A boolean that indicates whether ReplayKit is currently displaying a preview controller. (Read Only)
            */
            public static get isPreviewControllerActive(): boolean;
            /** Camera enabled status. True, if camera enabled; false otherwise.
            */
            public static get cameraEnabled(): boolean;
            public static set cameraEnabled(value: boolean);
            /** Microphone enabled status. True, if microphone enabled; false otherwise.
            */
            public static get microphoneEnabled(): boolean;
            public static set microphoneEnabled(value: boolean);
            /** A string property that contains an URL used to redirect the user to an on-going or completed broadcast (Read Only).
            */
            public static get broadcastURL(): string;
            /** A string value of the last error incurred by the ReplayKit: Either 'Failed to get Screen Recorder' or 'No recording available'. (Read Only)
            */
            public static get lastError(): string;
            /** Start a new recording.
            * @param $enableMicrophone Enable or disable the microphone while making a recording. Enabling the microphone allows you to include user commentary while recording. The default value is false.
            * @param $enableCamera Enable or disable the camera while making a recording. Enabling camera allows you to include user camera footage while recording. The default value is false. To actually include camera footage in your recording, you also have to call ShowCameraPreviewAt as well to position the preview view.
            * @returns A boolean value of True if recording started successfully or False if an error occurred. 
            */
            public static StartRecording ($enableMicrophone: boolean, $enableCamera: boolean) : boolean
            public static StartRecording ($enableMicrophone: boolean) : boolean
            public static StartRecording () : boolean
            public static StartBroadcasting ($callback: UnityEngine.Apple.ReplayKit.ReplayKit.BroadcastStatusCallback, $enableMicrophone: boolean, $enableCamera: boolean) : void
            public static StartBroadcasting ($callback: UnityEngine.Apple.ReplayKit.ReplayKit.BroadcastStatusCallback, $enableMicrophone: boolean) : void
            public static StartBroadcasting ($callback: UnityEngine.Apple.ReplayKit.ReplayKit.BroadcastStatusCallback) : void
            /** Stop the current recording.
            * @returns A boolean value of True if recording stopped successfully or False if an error occurred. 
            */
            public static StopRecording () : boolean
            /** Stops current broadcast.
            Will terminate currently on-going broadcast. If no broadcast is in progress, does nothing.
            */
            public static StopBroadcasting () : void
            /** Pauses current broadcast.
            Will pause currently on-going broadcast. If no broadcast is in progress, does nothing.
            */
            public static PauseBroadcasting () : void
            /** Resumes current broadcast.
            Will resume currently on-going broadcast. If no broadcast is in progress, does nothing.
            */
            public static ResumeBroadcasting () : void
            /** Preview the current recording
            * @returns A boolean value of True if the video preview window opened successfully or False if an error occurred. 
            */
            public static Preview () : boolean
            /** Discard the current recording.
            * @returns A boolean value of True if the recording was discarded successfully or False if an error occurred. 
            */
            public static Discard () : boolean
            public static ShowCameraPreviewAt ($posX: number, $posY: number) : boolean
            /** Shows camera preview at coordinates posX and posY. The preview is width by height in size.
            */
            public static ShowCameraPreviewAt ($posX: number, $posY: number, $width: number, $height: number) : boolean
            /** Hide the camera preview view.
            */
            public static HideCameraPreview () : void
        }
    }
    namespace UnityEngine.Apple.ReplayKit.ReplayKit {
        interface BroadcastStatusCallback
        { 
        (hasStarted: boolean, errorMessage: string) : void; 
        Invoke?: (hasStarted: boolean, errorMessage: string) => void;
        }
        var BroadcastStatusCallback: { new (func: (hasStarted: boolean, errorMessage: string) => void): BroadcastStatusCallback; }
    }
    namespace UnityEngine.Analytics {
        enum SendEventOptions
        { kAppendNone = 0, kAppendBuildGuid = 1, kAppendBuildTarget = 2 }
        class AnalyticsEventBase extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public EventName () : string
            public EventVersion () : number
            public EventPrefix () : string
            public constructor ($eventName: string, $eventVersion: number, $sendEventOptions?: UnityEngine.Analytics.SendEventOptions, $eventPrefix?: string)
            public constructor ($e: UnityEngine.Analytics.AnalyticsEventBase)
            public constructor ()
        }
    }
}
